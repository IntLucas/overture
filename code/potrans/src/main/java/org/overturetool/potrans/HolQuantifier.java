//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2008-11-08 by the VDM++ to JAVA Code Generator
// (v8.1.1b - Fri 24-Oct-2008 08:59:25)
//
// Supported compilers: jdk 1.4/1.5/1.6
//

// ***** VDMTOOLS START Name=HeaderComment KEEP=NO
// ***** VDMTOOLS END Name=HeaderComment

// ***** VDMTOOLS START Name=package KEEP=NO
package org.overturetool.potrans;

// ***** VDMTOOLS END Name=package

// ***** VDMTOOLS START Name=imports KEEP=YES

import jp.co.csk.vdm.toolbox.VDM.*;
import java.util.*;
// ***** VDMTOOLS END Name=imports



public class HolQuantifier extends HolExpression {

// ***** VDMTOOLS START Name=vdmComp KEEP=NO
  static UTIL.VDMCompare vdmComp = new UTIL.VDMCompare();
// ***** VDMTOOLS END Name=vdmComp

// ***** VDMTOOLS START Name=type KEEP=NO
  private Object type = null;
// ***** VDMTOOLS END Name=type

// ***** VDMTOOLS START Name=parameters KEEP=NO
  private Vector parameters = null;
// ***** VDMTOOLS END Name=parameters

// ***** VDMTOOLS START Name=parameterTypes KEEP=NO
  private Vector parameterTypes = null;
// ***** VDMTOOLS END Name=parameterTypes

// ***** VDMTOOLS START Name=expression KEEP=NO
  private HolExpression expression = null;
// ***** VDMTOOLS END Name=expression


// ***** VDMTOOLS START Name=vdm_init_HolQuantifier KEEP=NO
  private void vdm_init_HolQuantifier () throws CGException {}
// ***** VDMTOOLS END Name=vdm_init_HolQuantifier


// ***** VDMTOOLS START Name=HolQuantifier KEEP=NO
  public HolQuantifier () throws CGException {
    vdm_init_HolQuantifier();
  }
// ***** VDMTOOLS END Name=HolQuantifier


// ***** VDMTOOLS START Name=HolQuantifier#4|Object|Vector|Vector|HolExpression KEEP=NO
  public HolQuantifier (final Object newType, final Vector newParameters, final Vector newTypes, final HolExpression newExpression) throws CGException {

    vdm_init_HolQuantifier();
    {

      type = UTIL.clone(newType);
      parameters = (Vector) UTIL.ConvertToList(UTIL.clone(newParameters));
      parameterTypes = (Vector) UTIL.ConvertToList(UTIL.clone(newTypes));
      expression = (HolExpression) UTIL.clone(newExpression);
    }
  }
// ***** VDMTOOLS END Name=HolQuantifier#4|Object|Vector|Vector|HolExpression


// ***** VDMTOOLS START Name=HolQuantifier#4|Object|Vector|Vector|Vector KEEP=NO
  public HolQuantifier (final Object newType, final Vector newParameters, final Vector newTypes, final Vector newExpressions) throws CGException {

    vdm_init_HolQuantifier();
    {

      type = UTIL.clone(newType);
      parameters = (Vector) UTIL.ConvertToList(UTIL.clone(newParameters));
      parameterTypes = (Vector) UTIL.ConvertToList(UTIL.clone(newTypes));
      expression = (HolExpression) UTIL.clone((HolExpression) mergeExpression(newExpressions));
    }
  }
// ***** VDMTOOLS END Name=HolQuantifier#4|Object|Vector|Vector|Vector


// ***** VDMTOOLS START Name=setTypeInformation#1|HolTypeDescription KEEP=NO
  public void setTypeInformation (final HolTypeDescription typeInfo) throws CGException {

    expression.setTypeInformation((HolTypeDescription) typeInfo);
    for (int ilb_7 = 1; ilb_7 <= new Integer(parameters.size()).intValue(); ilb_7++) {

      Integer i = new Integer(ilb_7);
      HolIdentifier obj_9 = null;
      if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
        obj_9 = (HolIdentifier) parameters.get(i.intValue() - 1);
      else 
        UTIL.RunTime("Run-Time Error:Illegal index");
      obj_9.setTypeInformation((HolTypeDescription) typeInfo);
    }
    if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) 
      for (int ilb_19 = 1; ilb_19 <= new Integer(parameterTypes.size()).intValue(); ilb_19++) {

        Integer i = new Integer(ilb_19);
        HolType obj_21 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
          obj_21 = (HolType) parameterTypes.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        obj_21.setTypeInformation((HolTypeDescription) typeInfo);
      }
  }
// ***** VDMTOOLS END Name=setTypeInformation#1|HolTypeDescription


// ***** VDMTOOLS START Name=requires KEEP=NO
  public HashSet requires () throws CGException {

    HashSet subProvides = new HashSet();
    HashSet result = new HashSet();
    for (int ilb_4 = 1; ilb_4 <= new Integer(parameters.size()).intValue(); ilb_4++) {

      Integer i = new Integer(ilb_4);
      String elem_6 = null;
      HolIdentifier obj_7 = null;
      if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
        obj_7 = (HolIdentifier) parameters.get(i.intValue() - 1);
      else 
        UTIL.RunTime("Run-Time Error:Illegal index");
      elem_6 = obj_7.print();
      subProvides.add(elem_6);
    }
    if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) 
      for (int ilb_16 = 1; ilb_16 <= new Integer(parameterTypes.size()).intValue(); ilb_16++) {

        Integer i = new Integer(ilb_16);
        HashSet rhs_17 = new HashSet();
        HashSet var2_19 = new HashSet();
        HolType obj_20 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
          obj_20 = (HolType) parameterTypes.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        var2_19 = obj_20.requires();
        rhs_17 = (HashSet) result.clone();
        rhs_17.addAll(var2_19);
        result = (HashSet) UTIL.clone(rhs_17);
      }
    HashSet rexpr_23 = new HashSet();
    HashSet var1_24 = new HashSet();
    HashSet var1_25 = new HashSet();
    var1_25 = expression.requires();
    var1_24 = (HashSet) var1_25.clone();
    var1_24.removeAll(subProvides);
    rexpr_23 = (HashSet) var1_24.clone();
    rexpr_23.addAll(result);
    return rexpr_23;
  }
// ***** VDMTOOLS END Name=requires


// ***** VDMTOOLS START Name=print KEEP=NO
  public String print () throws CGException {

    String result = null;
    String rhs_1 = null;
    if (new Boolean(UTIL.equals(type, new org.overturetool.potrans.quotes.universal())).booleanValue()) 
      rhs_1 = new String("! ");
    else 
      rhs_1 = new String("? ");
    result = UTIL.ConvertToString(UTIL.clone(rhs_1));
    for (int ilb_9 = 1; ilb_9 <= new Integer(parameters.size()).intValue(); ilb_9++) {

      Integer i = new Integer(ilb_9);
      {

        String rhs_10 = null;
        Vector unArg_11 = null;
        unArg_11 = new Vector();
        unArg_11.add(result);
        unArg_11.add(new String(" "));
        String e_seq_14 = null;
        HolIdentifier obj_15 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
          obj_15 = (HolIdentifier) parameters.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        e_seq_14 = obj_15.print();
        unArg_11.add(e_seq_14);
        String rdcseq_18 = new String();
        for (Iterator enm_21 = unArg_11.iterator(); enm_21.hasNext(); ) {

          String e_19 = UTIL.ConvertToString(enm_21.next());
          rdcseq_18 = rdcseq_18.concat(e_19);
        }
        rhs_10 = rdcseq_18;
        result = UTIL.ConvertToString(UTIL.clone(rhs_10));
        if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) {

          String rhs_25 = null;
          Vector unArg_26 = null;
          unArg_26 = new Vector();
          unArg_26.add(result);
          unArg_26.add(new String(":("));
          String e_seq_29 = null;
          HolType obj_30 = null;
          if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
            obj_30 = (HolType) parameterTypes.get(i.intValue() - 1);
          else 
            UTIL.RunTime("Run-Time Error:Illegal index");
          e_seq_29 = obj_30.print(new org.overturetool.potrans.quotes.plain());
          unArg_26.add(e_seq_29);
          unArg_26.add(new String(")"));
          String rdcseq_35 = new String();
          for (Iterator enm_38 = unArg_26.iterator(); enm_38.hasNext(); ) {

            String e_36 = UTIL.ConvertToString(enm_38.next());
            rdcseq_35 = rdcseq_35.concat(e_36);
          }
          rhs_25 = rdcseq_35;
          result = UTIL.ConvertToString(UTIL.clone(rhs_25));
        }
      }
    }
    String rexpr_39 = null;
    Vector unArg_40 = null;
    unArg_40 = new Vector();
    unArg_40.add(new String("("));
    unArg_40.add(result);
    unArg_40.add(new String("."));
    String e_seq_44 = null;
    e_seq_44 = expression.print();
    unArg_40.add(e_seq_44);
    unArg_40.add(new String(")"));
    String rdcseq_46 = new String();
    for (Iterator enm_49 = unArg_40.iterator(); enm_49.hasNext(); ) {

      String e_47 = UTIL.ConvertToString(enm_49.next());
      rdcseq_46 = rdcseq_46.concat(e_47);
    }
    rexpr_39 = rdcseq_46;
    return rexpr_39;
  }
// ***** VDMTOOLS END Name=print


// ***** VDMTOOLS START Name=mergeExpression#1|Vector KEEP=NO
  private HolExpression mergeExpression (final Vector exprs) throws CGException {

    Object varRes_2 = null;
    if (new Boolean(new Integer(exprs.size()).intValue() == new Integer(0).intValue()).booleanValue()) 
      varRes_2 = new HolIdentifier(new String("T"));
    else 
      if (new Boolean(new Integer(exprs.size()).intValue() == new Integer(1).intValue()).booleanValue()) 
        if ((1 <= new Integer(1).intValue()) && (new Integer(1).intValue() <= exprs.size())) 
          varRes_2 = exprs.get(new Integer(1).intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
      else {

        Vector arg_9 = null;
        arg_9 = new Vector();
        arg_9.add((HolExpression) exprs.get(0));
        arg_9.add((HolExpression) mergeExpression(new Vector(exprs.subList(1, exprs.size()))));
        varRes_2 = new HolApplication(new HolNativeIdentifier(new String("$/\\")), arg_9);
      }
    return (HolExpression) varRes_2;
  }
// ***** VDMTOOLS END Name=mergeExpression#1|Vector

}
;
