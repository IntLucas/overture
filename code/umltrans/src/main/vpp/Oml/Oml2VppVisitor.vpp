\section{Visitor for pretty-pinting ASTs}

\begin{vdm_al}
class Oml2VppVisitor is subclass of OmlVisitor
types
  String = seq of char;
values
  private nl : seq of char = "\n";
  

instance variables
  public result : seq of char := [];
  private lvl : nat := 0

operations
private printNodeField: IOmlNode ==> ()
printNodeField (pNode) == pNode.accept(self);

private printBoolField: bool ==> ()
printBoolField (pval) ==
  result := if pval then "true" else "false";
    
private printNatField: nat ==> ()
-- implement this operation by hand!
printNatField (pval) == result := StdLib`ToStringInt(pval);

private printRealField: real ==> ()
  -- implement this operation by hand!
printRealField (-) == error;
  
private printCharField: char ==> ()
printCharField (pval) ==
  result := "'"^ [pval]^"'";
  
private printField: IOmlNode`FieldValue ==> ()
printField (fld) ==
  if is_bool(fld) then printBoolField(fld)
  elseif is_char(fld) then printCharField(fld)
  elseif is_nat(fld) then printNatField(fld)
  elseif is_real(fld) then printRealField(fld)
  elseif isofclass(IOmlNode,fld) then printNodeField(fld)
  else printStringField(fld);
  
private printStringField: seq of char ==> ()
printStringField (str) == result := "\"" ^ str ^ "\"";
  
private printSeqofField: seq of IOmlNode`FieldValue ==> ()
printSeqofField (pval) ==
( dcl str : seq of char := "", cnt : nat := len pval;
   while cnt > 0 do
   ( 
     printField(pval(len pval - cnt + 1));
     str := str ^ result;
     if cnt > 1
     then str := str ^ ", ";
     cnt := cnt - 1 ); 
     result := str 
    );

public visitNode: IOmlNode ==> ()
visitNode (pNode) == pNode.accept(self);
  
public visitDocument: IOmlDocument ==> ()
visitDocument(pcmp) ==
( dcl str : seq of char := "--BEGIN FileName: " ^ pcmp.getFilename() ^ nl;
   
  if pcmp.hasSpecifications() then visitSpecifications(pcmp.getSpecifications());
  --if pcmp.hasExpression() then visitExpression(pcmp.getExpression());
  result := str ^ result ^ "--END FileName: " ^ pcmp.getFilename();
);
    
public visitSpecifications: IOmlSpecifications ==> ()
visitSpecifications(pcmp) ==
( dcl str : seq of char := nl;
  for node in pcmp.getClassList() do
  (
    printNodeField(node);
    str := str ^ nl ^ result ^nl;
  );
  result := str;
);
     
public visitClass: IOmlClass ==> ()
visitClass(pcmp) ==
( dcl str : seq of char := "class " ^ pcmp.getIdentifier();
     
  if pcmp.hasInheritanceClause()
  then printNodeField(pcmp.getInheritanceClause())
  else result :="";
  str := str ^ result ^nl;

  for db in pcmp.getClassBody() do
  (  
    printNodeField(db);
    str := str ^ nl ^ result;
  );
        
      --pushNL();
      --str := str ^getNL();
      --printStringField(pcmp.getIdentifier());
      --str := str ^result ^"," ^getNL();
      --printSeqofField(pcmp.getGenericTypes());
      --str := str ^result ^"," ^getNL();
      --if pcmp.hasInheritanceClause()
      --then printNodeField(pcmp.getInheritanceClause())
      --else result := "nil";
      --str := str ^result ^"," ^getNL();
      --printSeqofField(pcmp.getClassBody());
      --str := str ^result ^"," ^getNL();
      --printBoolField(pcmp.getSystemSpec());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getLine());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getColumn());
      --str := str ^result;
      --popNL();
      --str := str ^getNL() ^")";
      
  result := str ^ nl ^ "end " ^ pcmp.getIdentifier() 
);
    
public visitInheritanceClause: IOmlInheritanceClause ==> ()
visitInheritanceClause(pcmp) ==
( dcl str : seq of char := " is subclass of ",
  list : seq of String := pcmp.getIdentifierList(),
  length : nat := len list, 
  i : nat := 1;
  while i <= length do
  ( str := str ^ list(i);
    i := i+1;
    if i <= length then
    str := str ^ " ,";
  );
  result := str ^ nl;
);
    
public visitValueDefinitions: IOmlValueDefinitions ==> ()
visitValueDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "values" ^ nl;
   
  for db in pcmp.getValueList() do
  (  printNodeField(db);
    str := str ^ result ^nl;
  );
  if len pcmp.getValueList() =0 then 
    result := ""
  else 
    result := str; );
      
public visitValueDefinition: IOmlValueDefinition ==> ()
visitValueDefinition(pcmp) ==
( dcl str : seq of char;
  printNodeField(pcmp.getAccess());
  str := result;
  printNodeField(pcmp.getShape());
  str := str ^ result ^ ";" ^ nl;
  result := str 
);
      
public visitAccessDefinition: IOmlAccessDefinition ==> ()
visitAccessDefinition(pcmp) ==
( dcl str : seq of char := "";-- prefix ^pcmp.identity() ^"(";
      --pushNL();
      --str := str ^getNL();
      --printBoolField(pcmp.getAsyncAccess());
      --str := str ^result ^"," ^getNL();
  if pcmp.getStaticAccess() 
  then str := " static ";
      
  printNodeField(pcmp.getScope());
  str := str ^ result ^ " ";
  result := str 
);
      
public visitScope: IOmlScope ==> ()
visitScope(pNode) == 
( --dcl str : seq of char;-- := prefix ^pNode.identity() ^"(";
  cases pNode.getValue():
   (OmlScopeQuotes`IQPUBLIC) 	    	-> result := "public",
   (OmlScopeQuotes`IQPRIVATE),
   (OmlScopeQuotes`IQDEFAULT)  		-> result := "private",
   (OmlScopeQuotes`IQPROTECTED) 		-> result := "protected",
   others 	                            -> error
  end;
      --result := str 
);

public visitValueShape: IOmlValueShape ==> ()
visitValueShape(pcmp) ==
( dcl str : seq of char; -- := prefix ^pcmp.identity() ^"(";
  printNodeField(pcmp.getPattern());
  str := result ^ " ";
  if pcmp.hasType()
  then
  ( printNodeField(pcmp.getType());
    str := str ^ ":" ^ result ^ " ";
  )
  else result := "";
      
  printNodeField(pcmp.getExpression());
  str := str ^ "=" ^ result ^ " ";
  result := str );  
      
      

          

public visitPattern: IOmlPattern ==> ()
visitPattern(pNode) == pNode.accept(self);
  
public visitExpression: IOmlExpression ==> ()
visitExpression(pNode) == pNode.accept(self);
  
public visitBinaryExpression: IOmlBinaryExpression ==> ()
visitBinaryExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getLhsExpression());
    str := str ^result;
    printNodeField(pcmp.getOperator());
    str := str ^result;
    printNodeField(pcmp.getRhsExpression());
    str := str ^result ^ nl;
    result := str );

public visitUnaryExpression: IOmlUnaryExpression ==> ()
visitUnaryExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getOperator());
    str := str ^result;
    printNodeField(pcmp.getExpression());
    str := str ^result ^ nl;
    result := str );

public visitBinaryOperator: IOmlBinaryOperator ==> ()
visitBinaryOperator(pNode) == 
 result :=
 cases pNode.getValue():
  (OmlBinaryOperatorQuotes`IQMODIFY     )-> "++",
  (OmlBinaryOperatorQuotes`IQGE         )-> ">=",
  (OmlBinaryOperatorQuotes`IQLT         )-> "<",
  (OmlBinaryOperatorQuotes`IQPSUBSET    )-> "psubset",
  (OmlBinaryOperatorQuotes`IQMOD        )-> "mod",
  (OmlBinaryOperatorQuotes`IQMAPDOMRESBY)-> "<-:",
  (OmlBinaryOperatorQuotes`IQINTER      )-> "inter",
  (OmlBinaryOperatorQuotes`IQCOMP       )-> "comp",
  (OmlBinaryOperatorQuotes`IQMINUS      )-> "-",
  (OmlBinaryOperatorQuotes`IQREM        )-> "rem",
  (OmlBinaryOperatorQuotes`IQAND        )-> "and",
  (OmlBinaryOperatorQuotes`IQUNION      )-> "union",
  (OmlBinaryOperatorQuotes`IQINSET      )-> "in set",
  (OmlBinaryOperatorQuotes`IQEQUIV      )-> "<=>",
  (OmlBinaryOperatorQuotes`IQMAPRNGRESTO)-> ":>",
  (OmlBinaryOperatorQuotes`IQITERATE    )-> "**",
  (OmlBinaryOperatorQuotes`IQSUBSET     )-> "subset",
  (OmlBinaryOperatorQuotes`IQMAPRNGRESBY)-> ":->",
  (OmlBinaryOperatorQuotes`IQTUPSEL     )-> "#.",
  (OmlBinaryOperatorQuotes`IQNOTINSET   )-> "not in set",
  (OmlBinaryOperatorQuotes`IQMULTIPLY   )-> "*",
  (OmlBinaryOperatorQuotes`IQIMPLY      )-> "=>",
  (OmlBinaryOperatorQuotes`IQOR         )-> "or",
  (OmlBinaryOperatorQuotes`IQGT         )-> ">",
  (OmlBinaryOperatorQuotes`IQPLUS       )-> "+",
  (OmlBinaryOperatorQuotes`IQMUNION     )-> "munion",
  (OmlBinaryOperatorQuotes`IQMAPDOMRESTO)-> "<:",
  (OmlBinaryOperatorQuotes`IQEQ         )-> "=",
  (OmlBinaryOperatorQuotes`IQDIV        )-> "div",
  (OmlBinaryOperatorQuotes`IQDIFFERENCE )-> "-",
  (OmlBinaryOperatorQuotes`IQCONC       )-> "^",
  (OmlBinaryOperatorQuotes`IQLE         )-> "<=",
  (OmlBinaryOperatorQuotes`IQDIVIDE     )-> "\\",
  (OmlBinaryOperatorQuotes`IQNE         )-> "<>"
end;

public visitUnaryOperator: IOmlUnaryOperator ==> ()
visitUnaryOperator(pNode) == 
 result :=
 cases pNode.getValue():
    (OmlUnaryOperatorQuotes`IQABS    ) -> "abs",
    (OmlUnaryOperatorQuotes`IQINVERSE) -> "inverse",
    (OmlUnaryOperatorQuotes`IQHD     ) -> "hd",
    (OmlUnaryOperatorQuotes`IQELEMS  ) -> "elems",
    (OmlUnaryOperatorQuotes`IQINDS   ) -> "inds",
    (OmlUnaryOperatorQuotes`IQTL     ) -> "tl",
    (OmlUnaryOperatorQuotes`IQCARD   ) -> "card",
    (OmlUnaryOperatorQuotes`IQDUNION ) -> "dunion",
    (OmlUnaryOperatorQuotes`IQPOWER  ) -> "power",
    (OmlUnaryOperatorQuotes`IQLEN    ) -> "len",
    (OmlUnaryOperatorQuotes`IQPLUS   ) -> "+",
    (OmlUnaryOperatorQuotes`IQDOM    ) -> "dom",
    (OmlUnaryOperatorQuotes`IQDMERGE ) -> "merge",
    (OmlUnaryOperatorQuotes`IQDINTER ) -> "dinter",
    (OmlUnaryOperatorQuotes`IQNOT    ) -> "not",
    (OmlUnaryOperatorQuotes`IQMINUS  ) -> "-",
    (OmlUnaryOperatorQuotes`IQRNG    ) -> "rng",
    (OmlUnaryOperatorQuotes`IQFLOOR  ) -> "floor",
    (OmlUnaryOperatorQuotes`IQDCONC  ) -> "conc"
  end;


public visitSetEnumeration: IOmlSetEnumeration ==> ()
visitSetEnumeration(pcmp) ==
  ( dcl str : seq of char := "{";
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^"}";
    result := str );

public visitLetExpression: IOmlLetExpression ==> ()
visitLetExpression(pcmp) ==
  ( dcl str : seq of char := "let ";
    printSeqofField(pcmp.getDefinitionList());
    str := str ^result ^ nl ^ " in ";
    printNodeField(pcmp.getExpression());
    str := str ^result ^ nl;
    result := str );

public visitFieldSelect: IOmlFieldSelect ==> ()
visitFieldSelect(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getExpression());
    str := str ^result ^"."; 
    printNodeField(pcmp.getName());
    str := str ^result;
    result := str );

public visitApplyExpression: IOmlApplyExpression ==> ()
visitApplyExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getExpression());
    str := str ^result ^"("; 
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitTupleConstructor: IOmlTupleConstructor ==> ()
visitTupleConstructor(pcmp) ==
  ( dcl str : seq of char := "mk_(";
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitRecordConstructor: IOmlRecordConstructor ==> ()
visitRecordConstructor(pcmp) ==
  ( dcl str : seq of char := "mk_";
    printNodeField(pcmp.getName());
    str := str ^result ^"("; 
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitTokenExpression: IOmlTokenExpression ==> ()
visitTokenExpression(pcmp) ==
  ( dcl str : seq of char := "mk_token(";
    printNodeField(pcmp.getExpression());
    str := str ^result ^")";
    result := str );

public visitLiteral: IOmlLiteral ==> ()
visitLiteral(pNode) == pNode.accept(self);
  
public visitType: IOmlType ==> ()
visitType(pNode) == pNode.accept(self);
  
public visitPatternIdentifier: IOmlPatternIdentifier ==> ()
visitPatternIdentifier(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^" ";
  result := str );
      
public visitSymbolicLiteralExpression: IOmlSymbolicLiteralExpression ==> ()
visitSymbolicLiteralExpression(pcmp) ==
( --dcl str : seq of char := prefix ^pcmp.identity() ^"(";
  printNodeField(pcmp.getLiteral());
  -- := str ^result;
  --str := str ^")";
  --result := str 
);
      
public visitTextLiteral: IOmlTextLiteral ==> ()
visitTextLiteral(pcmp) ==
( dcl str : seq of char := pcmp.getVal();
  result := "\"" ^ str ^ "\"" );
      
public visitSeq0Type: IOmlSeq0Type ==> ()
visitSeq0Type(pcmp) ==
( dcl str : seq of char := "seq of ";
  printNodeField(pcmp.getType());
  str := str ^ result;
  result := str );
      
public visitCharType: IOmlCharType ==> ()
visitCharType(-) ==
( dcl str : seq of char := "char";
  result := str );
      
public visitInstanceVariableDefinitions: IOmlInstanceVariableDefinitions ==> ()
visitInstanceVariableDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "instance variables" ^ nl ^ nl;
    
  for db in pcmp.getVariablesList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;
  );
  if len pcmp.getVariablesList() =0 then 
    result := ""
  else 
    result := str  );

public visitInstanceVariable: IOmlInstanceVariable ==> ()
visitInstanceVariable(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^ result; 
  printNodeField(pcmp.getAssignmentDefinition());
  str := str ^ result ;
  result := str );
      
public visitAssignmentDefinition: IOmlAssignmentDefinition ==> ()
visitAssignmentDefinition(pcmp) ==
( dcl str : seq of char := "";
  str := str ^ pcmp.getIdentifier();
  printNodeField(pcmp.getType());
  str := str ^ " : " ^ result;
  if pcmp.hasExpression()
  then 
  (printNodeField(pcmp.getExpression());
   str := str ^" := ";
  )
  else result := "";
  str := str ^ result ^";";
  result := str );
      
public visitTypeName: IOmlTypeName ==> ()
visitTypeName(pcmp) ==
( --dcl str : seq of char := prefix ^pcmp.identity() ^"(";
  printNodeField(pcmp.getName());
);

public visitName: IOmlName ==> ()
visitName(pcmp) ==
( dcl str : seq of char := "";
  if pcmp.hasClassIdentifier()
  then str := str ^ pcmp.getClassIdentifier();
  str := str ^ pcmp.getIdentifier();
  result := str );
      
public visitIntType: IOmlIntType ==> ()
visitIntType(-) ==
( dcl str : seq of char := "int";
  result := str );
      
public visitNatType: IOmlNatType ==> ()
visitNatType(-) ==
( dcl str : seq of char := "nat";
  result := str );
      
public visitNat1Type: IOmlNat1Type ==> ()
visitNat1Type(-) ==
( dcl str : seq of char := "nat1";
  result := str );
  
public visitBoolType: IOmlBoolType ==> ()
visitBoolType(-) ==
( dcl str : seq of char := "bool";
  result := str );
      
public visitSeq1Type: IOmlSeq1Type ==> ()
visitSeq1Type(pcmp) ==
( dcl str : seq of char := "seq1 of ";
  printNodeField(pcmp.getType());
  str := str ^result;
  result := str );
      
public visitRealType: IOmlRealType ==> ()
visitRealType(-) ==
( dcl str : seq of char := "real";
  result := str );
      
public visitSetType: IOmlSetType ==> ()
visitSetType(pcmp) ==
( dcl str : seq of char := "set of ";
  printNodeField(pcmp.getType());
  str := str ^result;
  result := str );
      
public visitTypeDefinitions: IOmlTypeDefinitions ==> ()
visitTypeDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "types" ^ nl ^ nl;
    
  for db in pcmp.getTypeList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    result := str;
);
    
public visitTypeDefinition: IOmlTypeDefinition ==> ()
visitTypeDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result ^";";
  result := str );
      
public visitSimpleType: IOmlSimpleType ==> ()
visitSimpleType(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier();
  printNodeField(pcmp.getType());
  result := str ^ " = " ^ result);
  
 public visitEmptyType: IOmlEmptyType ==> ()
  visitEmptyType(-) ==
    ( dcl str : seq of char := "()";
      result := str );

public visitNewExpression: IOmlNewExpression ==> ()
visitNewExpression(pcmp) ==
( dcl str : seq of char := "new ";
  printNodeField(pcmp.getName());
  str := str ^result ^ "()";
      --printSeqofField(pcmp.getGenericTypes());
      --str := str ^result ^"," ^getNL();
      --printSeqofField(pcmp.getExpressionList());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getLine());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getColumn());
      --str := str ^result;
      --popNL();
      --str := str ^getNL() ^")";
  result := str );
      
public visitNumericLiteral: IOmlNumericLiteral ==> ()
visitNumericLiteral(pcmp) ==
( dcl str : seq of char := "";
  printNatField(pcmp.getVal());
  str := str ^result;
  result := str );
      
public visitQuoteLiteral: IOmlQuoteLiteral ==> ()
visitQuoteLiteral(pcmp) ==
 ( dcl str : seq of char := "<";
   printStringField(pcmp.getVal());
   str := str ^result ^">";
   result := str );

public visitOperationDefinitions: IOmlOperationDefinitions ==> ()
visitOperationDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "operations" ^ nl ^ nl;
    
  for db in pcmp.getOperationList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    
    if len pcmp.getOperationList()>0 then
    result := str
    else
    result :="";
);
    
public visitOperationDefinition: IOmlOperationDefinition ==> ()
visitOperationDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result;
  result := str );
      
public visitExplicitOperation: IOmlExplicitOperation ==> ()
visitExplicitOperation(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^ " : ";
  --printNodeField(pcmp.getType());
  printNodeField(pcmp.getType());
  str := str ^result;
  str := str ^ nl ^ pcmp.getIdentifier() ^ "(";
  if len pcmp.getParameterList() > 0
  then 
  (
    for db in pcmp.getParameterList() do
    ( printNodeField(db);
      str := str ^ result ^", ";);
      str := str(1,...,len str -2); 
  )  ;  
  str := str ^ ") == ";
    --  printSeqofField(pcmp.getParameterList());
    --  str := str ^result ^"," ^getNL();
      printNodeField(pcmp.getBody());
     str := str ^result ^";"^nl;
   
  result := str );
      
public visitOperationType: IOmlOperationType ==> ()
visitOperationType(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getDomType());
  str := str ^result ^ " ==> ";
  printNodeField(pcmp.getRngType());
  str := str ^result;
  result := str );
  
  public visitOperationBody: IOmlOperationBody ==> ()
  visitOperationBody(pcmp) ==
    ( dcl str : seq of char := "(";
      
      
      if pcmp.getNotYetSpecified()then
      ( result := "is not yet specified";
        return;
      )
      else
      (  if pcmp.hasStatement()
        then printNodeField(pcmp.getStatement())
        else result := "";
        str := str ^result;
      );
      if pcmp.getSubclassResponsibility() then
      (
         result := "sub class responsibility";
         return;
      );
     
      str := str ^")";
      result := str );
      
  public visitSkipStatement: IOmlSkipStatement ==> ()
  visitSkipStatement(-) ==
    ( dcl str : seq of char := "skip";
      result := str );
      
public visitParameter: IOmlParameter ==> ()
visitParameter(pcmp) ==
( dcl str : seq of char := "";
  for db in pcmp.getPatternList() do
  ( printNodeField(db);
    str := str ^ result ^", ";);
    str := str(1,...,len str -2);-- ", ";
  result := str );
      
public visitFunctionDefinitions: IOmlFunctionDefinitions ==> ()
visitFunctionDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "functions" ^ nl ^ nl;
    
  for db in pcmp.getFunctionList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    result := str;
);

public visitFunctionDefinition: IOmlFunctionDefinition ==> ()
visitFunctionDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result;
  result := str );
      
public visitExplicitFunction: IOmlExplicitFunction ==> ()
visitExplicitFunction(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^ " : ";
  if len pcmp.getTypeVariableList() > 0
  then
  (
    for db in pcmp.getTypeVariableList() do
    ( printNodeField(db);
      str := str ^ result ^"* ";);  
    str := str(1,...,len str -2);
    
  );
 -- str := str ^" -> ";    
  printNodeField(pcmp.getType());
  str := str ^result;
  str := str ^ nl ^ pcmp.getIdentifier() ^ "(";
  for db in pcmp.getParameterList() do
  ( printNodeField(db);
    str := str ^ result ^", ";);
  str := str(1,...,len str -2);
  str := str ^ ") == is not yet specified;";
    --  printSeqofField(pcmp.getParameterList());
    --  str := str ^result ^"," ^getNL();
    --  printNodeField(pcmp.getBody());
   --   str := str ^result ^"," ^getNL();
   
  result := str );
      
public visitPartialFunctionType: IOmlPartialFunctionType ==> ()
visitPartialFunctionType(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getDomType());
  str := str ^result ^ " -> ";
  printNodeField(pcmp.getRngType());
  str := str ^result;
  result := str );
      
public visitUnionType: IOmlUnionType ==> ()
visitUnionType(pcmp) ==
(
  dcl str : seq of char := "";
  pcmp.getLhsType().accept(self);
  str := str ^ result;
  pcmp.getRhsType().accept(self);
  str := str ^ " | " ^ result;
  
  result := str;
  
);
  
public visitProductType: IOmlProductType ==> ()
visitProductType(pcmp) ==
(
  dcl str : seq of char := "";
  pcmp.getLhsType().accept(self);
  str := str ^ result;
  pcmp.getRhsType().accept(self);
  str := str ^ " * " ^ result;
  
  result := str;
  
);
  
  
  
  
  
  
public visitTraceDefinitions: IOmlTraceDefinitions ==> ()
visitTraceDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "traces" ^ nl ^nl;
  for db in pcmp.getTraces() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
  result := str;
   
);
       
       
public visitNamedTrace: IOmlNamedTrace ==> ()
visitNamedTrace(pcmp) ==
( dcl str : seq of char := "  ";
  str := str ^pcmp.getName() ^" : ";
     
  printNodeField(pcmp.getDefs());
  str := str ^result ;
     
  result := str;
);
     
public visitTraceDefinition: IOmlTraceDefinition ==> ()
visitTraceDefinition(pNode) == pNode.accept(self);
  
public visitTraceDefinitionItem: IOmlTraceDefinitionItem ==> ()
visitTraceDefinitionItem(pcmp) ==
( dcl str : seq of char := "";
     
  printSeqofField(pcmp.getBind());
  str := str ^result;
  printNodeField(pcmp.getTest());
  str := str ^result;
  if pcmp.hasRegexpr()
  then printNodeField(pcmp.getRegexpr())
  else result := "";
  str := str ^result;
  result := str );
      
public visitTraceBinding: IOmlTraceBinding ==> ()
visitTraceBinding(pNode) == pNode.accept(self);
  
public visitTraceLetBinding: IOmlTraceLetBinding ==> ()
visitTraceLetBinding(pcmp) ==
( dcl str : seq of char := "";
  printSeqofField(pcmp.getDefinitionList());
  str := str ^result ;
     
  result := str );
         
public visitTraceBracketedDefinition: IOmlTraceBracketedDefinition ==> ()
visitTraceBracketedDefinition(pcmp) ==
( dcl str : seq of char := "(";
  printNodeField(pcmp.getDefinition());
  str := str ^result^")";
  result := str );
      
public visitTraceMethodApply: IOmlTraceMethodApply ==> ()
visitTraceMethodApply(pcmp) ==
( dcl str : seq of char := "";     
  str := str ^pcmp.getVariableName() ^".";
  str := str ^pcmp.getMethodName()^"(";
  printSeqofField(pcmp.getArgs());
  str := str ^result ^")";
  result := str );
      
public visitTraceCoreDefinition: IOmlTraceCoreDefinition ==> ()
visitTraceCoreDefinition(pNode) == pNode.accept(self);

public visitTraceRepeatPattern: IOmlTraceRepeatPattern ==> ()
visitTraceRepeatPattern(pNode) == pNode.accept(self);
  
public visitTraceZeroOrMore: IOmlTraceZeroOrMore ==> ()
visitTraceZeroOrMore(-) ==
( dcl str : seq of char := "*";
  result := str );
      
      
public visitTraceOneOrMore: IOmlTraceOneOrMore ==> ()
visitTraceOneOrMore(-) ==
( dcl str : seq of char := "+";
  result := str );
      
public visitTraceZeroOrOne: IOmlTraceZeroOrOne ==> ()
visitTraceZeroOrOne(-) ==
( dcl str : seq of char := "?";
  result := str );
      
public visitTraceRange: IOmlTraceRange ==> ()
visitTraceRange(pcmp) ==
( dcl str : seq of char := "{";
  printNodeField(pcmp.getLower());
  str := str ^result  ;
  if pcmp.hasUpper()
  then 
  (
    printNodeField(pcmp.getUpper());
    str := str ^"," ^result;
  );
  str := str ^"}";
  result := str );
  
  
public visitTraceChoiceDefinition: IOmlTraceChoiceDefinition ==> ()
visitTraceChoiceDefinition(pcmp) ==
( dcl str : seq of char := "", count : nat := 1;
  for db in pcmp.getDefs() do
  ( printNodeField(db);
    if len pcmp.getDefs() = count then str := str ^result
    else str := str^ result ^" | ";
    count := count + 1;
   );
    result := str;
);
       
       
public visitTraceSequenceDefinition: IOmlTraceSequenceDefinition ==> ()
visitTraceSequenceDefinition(pcmp) ==
( dcl str : seq of char := "", count : nat := 1;
  for db in pcmp.getDefs() do
  ( printNodeField(db);
    if len pcmp.getDefs() = count then str := str ^result
    else str := str^ result ^" ; ";
    count := count + 1;
   );
    result := str;
);
       
end Oml2VppVisitor
\end{vdm_al}

\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[Oml2VppVisitor]

\end{rtinfo}
