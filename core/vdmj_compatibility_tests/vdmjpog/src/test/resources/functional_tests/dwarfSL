-- TCErrors: WARNING:5000:32,3 WARNING:5000:170,3 PROOFOBLIGATION: fDEyNTo2IE5vQ29ycmVjdGlvbiwtLSBBZnRlciB0cmFjZSA6PSAodHJhY2UgXiBuZXd0cikKbGV0IG1rX0R3YXJmKHQsIHMpID0gRHdhcmYgaW4gKE1heE9uZUxhbXBDaGFuZ2UodCkgYW5kIChTdG9wVG9Ecml2ZU9yV2FybmluZyh0KSBhbmQgKFRvQW5kRnJvbURhcmsodCkgYW5kIEFsd2F5c0RlZmluZWRTdGF0ZShzKSkpKQosc3RhdGUgaW52YXJpYW50LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDEyNjo2IE5vQ29ycmVjdGlvbiwtLSBBZnRlciBsYW1wc3RhdGUgOj0gbmV3c2lnbmFscwpsZXQgbWtfRHdhcmYodCwgcykgPSBEd2FyZiBpbiAoTWF4T25lTGFtcENoYW5nZSh0KSBhbmQgKFN0b3BUb0RyaXZlT3JXYXJuaW5nKHQpIGFuZCAoVG9BbmRGcm9tRGFyayh0KSBhbmQgQWx3YXlzRGVmaW5lZFN0YXRlKHMpKSkpCixzdGF0ZSBpbnZhcmlhbnQsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDEyMjozIE5vQ29ycmVjdGlvbixpc18oUkVTVUxULCAoTWVzc2FnZSAqIEVycm9ycyAqIFRyYWNlKSkKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE0MDoxNSBNYXhPbmVMYW1wQ2hhbmdlLChmb3JhbGwgdDpUcmFjZSAmCiAgKGZvcmFsbCBpIGluIHNldCAoKGluZHMgdCkgXCB7MX0pICYKICAgIChpIC0gMSkgaW4gc2V0IGluZHMgdCkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE0MDoyNyBNYXhPbmVMYW1wQ2hhbmdlLChmb3JhbGwgdDpUcmFjZSAmCiAgKGZvcmFsbCBpIGluIHNldCAoKGluZHMgdCkgXCB7MX0pICYKICAgIGkgaW4gc2V0IGluZHMgdCkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE0MDo0OCBNYXhPbmVMYW1wQ2hhbmdlLChmb3JhbGwgdDpUcmFjZSAmCiAgKGZvcmFsbCBpIGluIHNldCAoKGluZHMgdCkgXCB7MX0pICYKICAgICgoKGNhcmQgKHQoKGkgLSAxKSkgXCB0KGkpKSkgPD0gMSkgPT4KICAgICAgaSBpbiBzZXQgaW5kcyB0KSkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE0MDo1NSBNYXhPbmVMYW1wQ2hhbmdlLChmb3JhbGwgdDpUcmFjZSAmCiAgKGZvcmFsbCBpIGluIHNldCAoKGluZHMgdCkgXCB7MX0pICYKICAgICgoKGNhcmQgKHQoKGkgLSAxKSkgXCB0KGkpKSkgPD0gMSkgPT4KICAgICAgKGkgLSAxKSBpbiBzZXQgaW5kcyB0KSkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE0NToyMyBTdG9wVG9Ecml2ZU9yV2FybmluZywoZm9yYWxsIHQ6VHJhY2UgJgogIChmb3JhbGwgaSwgaiBpbiBzZXQgKGluZHMgdCkgJgogICAgKChpIDwgaikgPT4KICAgICAgaSBpbiBzZXQgaW5kcyB0KSkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE0NjoxMyBTdG9wVG9Ecml2ZU9yV2FybmluZywoZm9yYWxsIHQ6VHJhY2UgJgogIChmb3JhbGwgaSwgaiBpbiBzZXQgKGluZHMgdCkgJgogICAgKChpIDwgaikgPT4KICAgICAgKCh0KGkpID0gc3RvcGxhbXBzKSA9PgogICAgICAgIGogaW4gc2V0IGluZHMgdCkpKSkKLHNlcXVlbmNlIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE0ODoxOSBTdG9wVG9Ecml2ZU9yV2FybmluZywoZm9yYWxsIHQ6VHJhY2UgJgogIChmb3JhbGwgaSwgaiBpbiBzZXQgKGluZHMgdCkgJgogICAgKChpIDwgaikgPT4KICAgICAgKCh0KGkpID0gc3RvcGxhbXBzKSA9PgogICAgICAgICgodChqKSBpbiBzZXQge2RyaXZlbGFtcHMsIHdhcm5pbmdsYW1wc30pID0+CiAgICAgICAgICAoZm9yYWxsIGsgaW4gc2V0IHsoaSArIDEpLCAuLi4gLChqIC0gMSl9ICYKICAgICAgICAgICAgayBpbiBzZXQgaW5kcyB0KSkpKSkpCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE1MDo1MCBTdG9wVG9Ecml2ZU9yV2FybmluZywoZm9yYWxsIHQ6VHJhY2UgJgogIChmb3JhbGwgaSwgaiBpbiBzZXQgKGluZHMgdCkgJgogICAgKGZvcmFsbCBrIGluIHNldCB7KGkgKyAxKSwgLi4uICwoaiAtIDEpfSAmCiAgICAgIGsgaW4gc2V0IGluZHMgdCkpKQosc2VxdWVuY2UgYXBwbHksbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE1MDo2OCBTdG9wVG9Ecml2ZU9yV2FybmluZywoZm9yYWxsIHQ6VHJhY2UgJgogIChmb3JhbGwgaSwgaiBpbiBzZXQgKGluZHMgdCkgJgogICAgKGZvcmFsbCBrIGluIHNldCB7KGkgKyAxKSwgLi4uICwoaiAtIDEpfSAmCiAgICAgICgoKGNhcmQgdChrKSkgPCAzKSA9PgogICAgICAgIGsgaW4gc2V0IGluZHMgdCkpKSkKLHNlcXVlbmNlIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1NDozMCBUb0FuZEZyb21EYXJrLChmb3JhbGwgdDpUcmFjZSAmCiAgKGZvcmFsbCBpIGluIHNldCAoaW5kcyB0KSAmCiAgICBpIGluIHNldCBpbmRzIHQpKQosc2VxdWVuY2UgYXBwbHksbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE1ODoxNSBUb09yRnJvbVN0b3AsKGZvcmFsbCB0OlRyYWNlLCBpOm5hdDEgJgogIChpIC0gMikgaW4gc2V0IGluZHMgdCkKLHNlcXVlbmNlIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1OToyMyBUb09yRnJvbVN0b3AsKGZvcmFsbCB0OlRyYWNlLCBpOm5hdDEgJgogICgoKGkgPiAyKSA9PiAodCgoaSAtIDIpKSA9IHN0b3BsYW1wcykpID0+CiAgICAoaSArIDIpIGluIHNldCBpbmRzIHQpKQosc2VxdWVuY2UgYXBwbHksbnVsbCxVbnByb3ZlZHw=


--dwarf.vdmsl

types

  LampId = <L1> | <L2> | <L3>;

values

  darklamps: set of LampId = {};

  stoplamps: set of LampId = {<L1>,<L2>};

  warninglamps: set of LampId = {<L1>,<L3>};

  drivelamps: set of LampId = {<L2>,<L3>};

types

  Signal = set of LampId;

  LogCom = <stop> | <dark> | <drive> | <warning>;

  Message = LogCom | <unknown> | <port_failure>;

  Errors = set of LampId;

operations

  Control: [LogCom] * set of LampId ==> Message * Errors * Trace
  Control(com,failures) ==
    let newstate = NormalTrans(com)
    in
      ErrorCorrection(com,newstate,failures) 
  pre AllowedCommand(com,lampstate);

functions

  AllowedCommand: [LogCom] * Signal +> bool
  AllowedCommand(com,signal) ==
    (com = <dark> => signal in set {stoplamps,darklamps}) and
    (com in set {<warning>,<drive>} => signal <> darklamps);

types

  Trace = seq of set of LampId

state Dwarf of
    trace : Trace
    lampstate : Signal
  inv mk_Dwarf(t,s) == 
          MaxOneLampChange(t) and 
          StopToDriveOrWarning(t) and
          ToAndFromDark(t) and
          AlwaysDefinedState(s) -- this may change when errors are 
                                -- taken into account
  init s == s = mk_Dwarf([stoplamps],stoplamps)
end

operations

  NormalTrans: [LogCom] ==> Dwarf
  NormalTrans(command) ==
    cases command:
      nil       -> return mk_Dwarf([],lampstate),
      <dark>    -> let t = if lampstate = stoplamps
                           then [{<L1>},darklamps]
                           else [] -- already in darksignals state
                   in
                     return mk_Dwarf(t,darklamps),
      <stop>    -> let t = if lampstate = darklamps
                           then [{<L1>},stoplamps]
                           elseif lampstate = warninglamps
                           then [{<L1>},stoplamps]
                           elseif lampstate = drivelamps
                           then [{<L2>},stoplamps]
                           else [] -- already in stoplamps state
                   in
                     return mk_Dwarf(t,stoplamps),
      <warning> -> let t = if lampstate = drivelamps
                           then [{<L3>},warninglamps]
                           elseif lampstate = stoplamps
                           then [{<L1>},warninglamps]
                           else [] -- already in warninglamps state
                   in
                     return mk_Dwarf(t,warninglamps),
      <drive>   -> let t = if lampstate = warninglamps
                           then [{<L3>},drivelamps]
                           elseif lampstate = stoplamps
                           then [{<L2>},drivelamps]
                           else [] -- already in drivelamps state
                   in
                     return mk_Dwarf(t,drivelamps)
    end
  pre AllowedCommand(command,lampstate);

  ErrorCorrection: [LogCom] * Dwarf * set of LampId ==> 
                   Message * Errors * Trace
  ErrorCorrection(com,dwarf,failures) ==
     if failures = {<L2>}
     then (cases com:
             nil       -> if <L2> in set lampstate
                          then let errdwarf = NormalTrans(<warning>)
                               in
                                 NoCorrection(com,errdwarf,failures)
                          else NoCorrection(com,dwarf,failures),
             <dark>    -> NoCorrection(com,dwarf,failures),
             <stop>    -> let errdwarf = NormalTrans(<warning>)
                          in
                            NoCorrection(com,errdwarf,failures),
             <warning> -> NoCorrection(com,dwarf,failures),
             <drive>   -> let errdwarf = NormalTrans(<warning>)
                          in
                            NoCorrection(com,errdwarf,failures)
           end;
          )
     else (-- other error sitiuations have not yet been coped with
           NoCorrection(com,dwarf,failures));

  NoCorrection: [LogCom] * Dwarf * set of LampId ==> 
                Message * Errors * Trace
  NoCorrection(com,mk_Dwarf(newtr,newsignals),failures) ==
    (trace := trace ^ newtr;
     lampstate := newsignals;
     let m = if failures <> {}
             then <port_failure>
             elseif com = nil
             then <unknown>
             else com
     in
       return mk_(m,{},newtr));

functions

  MaxOneLampChange: Trace +> bool
  MaxOneLampChange(t) ==
    forall i in set inds t \ {1} &
        card (t(i - 1) \  t(i)) <= 1 and card (t(i) \ t(i - 1)) <= 1;

  StopToDriveOrWarning: Trace +> bool
  StopToDriveOrWarning(t) ==
    forall i,j in set inds t & 
           (i < j and t(i) = stoplamps and 
            t(j) in set {drivelamps,warninglamps} and
            not exists k in set {i+1,...,j-1} &
                  t(k) in set {darklamps, warninglamps,drivelamps}) 
             =>
            forall k in set {i+1,...,j-1} & card t(k) < 3 and card t(k) > 0;

  ToAndFromDark: Trace +> bool
  ToAndFromDark(t) ==
    forall i in set inds t & t(i) = darklamps => ToOrFromStop(t,i); 

  ToOrFromStop: Trace * nat1 +> bool
  ToOrFromStop(t,i) ==
    (i > 2 => t(i - 2) = stoplamps) and 
    (i + 1 < len t => t(i + 2) = stoplamps);

  AlwaysDefinedState: Signal +> bool
  AlwaysDefinedState(sig) ==
    sig in set {darklamps, 
                stoplamps,
                warninglamps,
                drivelamps};
                
traces

  SeqTest: (let com : LogCom
            in
              NormalTrans(com)){5};