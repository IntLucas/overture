["MissileInputs \u003d MissileInputs","MissileInput \u003d MissileInput","MissileType \u003d MissileType","Angle \u003d Angle\n\tinv num \u003d\u003d (num \u003c\u003d 360)","Output \u003d Output","MagId \u003d MagId","OutputStep \u003d OutputStep","Response \u003d Response","AbsTime \u003d AbsTime","FlareType \u003d FlareType","Plan \u003d Plan","Delay \u003d Delay","responseDB:map (MissileType) to (Plan) \u003d {\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)], \u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)], \u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}","missilePriority:map (MissileType) to (nat) \u003d {\u003cMissileA\u003e |-\u003e 1, \u003cMissileB\u003e |-\u003e 2, \u003cMissileC\u003e |-\u003e 3, \u003cNone\u003e |-\u003e 0}","stepLength:nat \u003d 100","testval1:MissileInputs \u003d [mk_(\u003cMissileA\u003e, 88), mk_(\u003cMissileB\u003e, 70), mk_(\u003cMissileA\u003e, 222), mk_(\u003cMissileC\u003e, 44)]","testval2:MissileInputs \u003d [mk_(\u003cMissileC\u003e, 188), mk_(\u003cMissileB\u003e, 70), mk_(\u003cMissileA\u003e, 2), mk_(\u003cMissileC\u003e, 44)]","testval3:MissileInputs \u003d [mk_(\u003cMissileA\u003e, 288), mk_(\u003cMissileB\u003e, 170), mk_(\u003cMissileA\u003e, 222), mk_(\u003cMissileC\u003e, 44)]","private CounterMeasures: (MissileInputs -\u003e Output)\n\tCounterMeasures(missileInputs) \u003d\u003d\nCM(missileInputs, {|-\u003e}, {|-\u003e}, 0)","private CM: (MissileInputs * Output * map (MagId) to ([MissileType]) * nat -\u003e Output)\n\tCM(missileInputs, outputSoFar, lastMissile, curTime) \u003d\u003d\n(if (missileInputs \u003d [])\nthen outputSoFar\nelse let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (if ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))\nthen let newOutput:Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in CM((tl missileInputs), newOutput, (lastMissile ++ {magid |-\u003e curMis}), (curTime + stepLength))\nelse CM((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))","private CMLen: (MissileInputs * Output * map (MagId) to ([MissileType]) * nat -\u003e nat)\n\tCMLen(list, -, -, -) \u003d\u003d\n(len list)","private InterruptPlan: (nat * Output * Plan * MagId -\u003e Output)\n\tInterruptPlan(curTime, expOutput, plan, magid) \u003d\u003d\n({magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))} munion ({magid} \u003c-: expOutput))","private LeavePrefixUnchanged: (seq of (OutputStep) * nat -\u003e seq of (OutputStep))\n\tLeavePrefixUnchanged(output_l, curTime) \u003d\u003d\n[output_l(i) | i in set (inds output_l) \u0026 let mk_(-, t):OutputStep \u003d output_l(i) in (t \u003c\u003d curTime)]","private MakeOutputFromPlan: (nat * seq of (Response) -\u003e seq of (OutputStep))\n\tMakeOutputFromPlan(curTime, response) \u003d\u003d\nlet output:seq of (OutputStep) \u003d OutputAtTimeZero(response) in [let mk_(flare, t):OutputStep \u003d output(i) in mk_(flare, (t + curTime)) | i in set (inds output)]","private OutputAtTimeZero: (seq of (Response) -\u003e seq of (OutputStep))\n\tOutputAtTimeZero(response) \u003d\u003d\nlet absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(FlareType * nat) \u003d (hd absTimes) in ([mk_(firstFlare, 0)] ^ [let mk_(-, t):(FlareType * nat) \u003d absTimes((i - 1)), mk_(f, -):(FlareType * nat) \u003d absTimes(i) in mk_(f, t) | i in set {2, ... ,(len absTimes)}])","private RelativeToAbsoluteTimes: (seq of (Response) -\u003e seq of ((FlareType * nat)))\n\tRelativeToAbsoluteTimes(ts) \u003d\u003d\n(if (ts \u003d [])\nthen []\nelse let mk_(f, t):Response \u003d (hd ts), ns:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes((tl ts)) in ([mk_(f, t)] ^ [let mk_(nf, nt):(FlareType * nat) \u003d ns(i) in mk_(nf, (nt + t)) | i in set (inds ns)]))","private RespLen: (seq of (Response) -\u003e nat)\n\tRespLen(l) \u003d\u003d\n(len l)","private Angle2MagId: (Angle -\u003e MagId)\n\tAngle2MagId(angle) \u003d\u003d\n(if (angle \u003c 90)\nthen mk_token(\"Magazine 1\")\nelseif (angle \u003c 180)\nthen mk_token(\"Magazine 2\")\nelseif (angle \u003c 270)\nthen mk_token(\"Magazine 3\")\nelse mk_token(\"Magazine 4\"))"]