["class Config\npublic static  Range:nat \u003d 12\npublic static  TrafficDataLifeTime:nat \u003d 300000\npublic static  TrafficDataKeeptNumber:nat \u003d 5\npublic static  TrafficCongestionTrack:nat \u003d 5\npublic static  TrafficCongestionRange:nat \u003d 1\npublic static  TrafficCongestionThreshold:nat \u003d 2\nend Config\n","class Controller\nprivate  internalTrafficData:seq of (TrafficData) :\u003d []\nprivate  inv((len internalTrafficData) \u003c\u003d Config`TrafficDataKeeptNumber)\nprivate  externalTrafficData:seq of (TrafficData) :\u003d []\nprivate  inv((len externalTrafficData) \u003c\u003d Config`TrafficDataKeeptNumber)\nprivate  communicatedWith:seq of (nat) :\u003d []\nprivate  inv((len communicatedWith) \u003c\u003d Config`TrafficDataKeeptNumber)\nprivate  traffic:Traffic :\u003d (undefined)\nprivate  vemoVehicle:Vehicle :\u003d (undefined)\nprivate  canRun:bool :\u003d true\npublic  Controller(Vehicle) (Vehicle \u003d\u003d\u003e Controller)\n\tController(Vehicle)(vehicle) \u003d\u003d\n(\n\nvemoVehicle :\u003d vehicle;\ntraffic :\u003d new Traffic()\n)\npublic async  AddOncomingVehicle(VehicleData) (VehicleData \u003d\u003d\u003e ())\n\tAddOncomingVehicle(VehicleData)(vd) \u003d\u003d\n(\n\nif (not (traffic.ExistVehicleData)(vd))\nthen\nlet v:Vehicle \u003d new Vehicle(vd) in traffic.AddVehicle(v)\n)\npublic  AddTrafficData(nat, seq of (TrafficData)) (nat * seq of (TrafficData) \u003d\u003d\u003e ())\n\tAddTrafficData(nat, seq of (TrafficData))(vemoUnitID, data) \u003d\u003d\n(\n\nif (data \u003d [])\nthen\nreturn;\nif (vemoUnitID in set (elems communicatedWith))\nthen\nreturn;\nif ((len communicatedWith) \u003c Config`TrafficDataKeeptNumber)\nthen\ncommunicatedWith :\u003d (communicatedWith ^ [vemoUnitID])else\ncommunicatedWith :\u003d ((tl communicatedWith) ^ [vemoUnitID]);\nif ((len externalTrafficData) \u003c Config`TrafficDataKeeptNumber)\nthen\nexternalTrafficData :\u003d (externalTrafficData ^ data)else\nexternalTrafficData :\u003d ((tl externalTrafficData) ^ data);\nfor in \u0027Controller\u0027 (Controller.vdmrt) at line 93:6dADefPatternBind[d \u003d TrafficData]ADefPatternBind in data do\n(\n\nWorld`env.handleEvent((((\"Vehicle: \" ^ Printer`natToString(GetVehicleID())) ^ \" received \") ^ (d.ToString)()))\n);\nVeMoController`graphics.receivedMessage(GetVehicleID())\n)\nprivate  AddInternalTrafficData(TrafficData) (TrafficData \u003d\u003d\u003e ())\n\tAddInternalTrafficData(TrafficData)(data) \u003d\u003d\n(\n\nif ((len internalTrafficData) \u003c Config`TrafficDataKeeptNumber)\nthen\ninternalTrafficData :\u003d (internalTrafficData ^ [data])else\ninternalTrafficData :\u003d ((tl internalTrafficData) ^ [data])\n)\npublic  GetTrafficData() (() \u003d\u003d\u003e [seq of (TrafficData)])\n\tGetTrafficData()() \u003d\u003d\nreturn ([new TrafficData((internalTrafficData(i).GetMessage)(), (internalTrafficData(i).GetPosition)(), (internalTrafficData(i).GetDirection)()) | i in set (inds internalTrafficData)])\npublic  GetVehicleID() (() \u003d\u003d\u003e nat)\n\tGetVehicleID()() \u003d\u003d\nreturn ((vemoVehicle.GetID)())\npublic  GetPosition() (() \u003d\u003d\u003e [Position])\n\tGetPosition()() \u003d\u003d\nreturn ((vemoVehicle.GetPosition)())\npublic  GetDirection() (() \u003d\u003d\u003e [Direction])\n\tGetDirection()() \u003d\u003d\nreturn ((vemoVehicle.GetDirection)())\npublic  getVehicle() (() \u003d\u003d\u003e [Vehicle])\n\tgetVehicle()() \u003d\u003d\nreturn (vemoVehicle)\npublic  getVehicleDTO() (() \u003d\u003d\u003e [VehicleData])\n\tgetVehicleDTO()() \u003d\u003d\nvemoVehicle.getDTO()\npublic  EnvironmentReady() (() \u003d\u003d\u003e ())\n\tEnvironmentReady()() \u003d\u003d\nif (canRun \u003d false)\nthen\ncanRun :\u003d true\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nvemoVehicle.Move();\nfor all td in set (elems internalTrafficData) do\n(\n\nif (td.Expired)()\nthen\n(\n\ninternalTrafficData :\u003d [internalTrafficData(i) | i in set (inds internalTrafficData) \u0026 (internalTrafficData(i) \u003c\u003e td)]\n)\n);\nif ((vemoVehicle.getLowGrip)() \u003d true)\nthen\n(\n\nif (((vemoVehicle.GetSpeed)() \u003d 0) \u003d\u003e (not (exists data in set (elems internalTrafficData) \u0026 (Position`Compare((data.GetPosition)(), GetPosition()) and (((data.GetPosition)() \u003c\u003e GetPosition()) and ((data.GetMessage)() \u003d \u003cLowGrip\u003e))))))\nthen\nlet lowGripMsg:TrafficData \u003d new TrafficData(\u003cLowGrip\u003e, (GetPosition().deepCopy)(), GetDirection()) in AddInternalTrafficData(lowGripMsg)\n);\nif ((vemoVehicle.TurnIndicator)() \u003d \u003cLEFT\u003e)\nthen\n(\n\nif (((vemoVehicle.GetSpeed)() \u003d 0) \u003d\u003e (not (exists data in set (elems internalTrafficData) \u0026 (Position`Compare((data.GetPosition)(), GetPosition()) and ((data.GetMessage)() \u003d \u003cLeftTurn\u003e)))))\nthen\nlet turnMsg:TrafficData \u003d new TrafficData(\u003cLeftTurn\u003e, (GetPosition().deepCopy)(), GetDirection()) in AddInternalTrafficData(turnMsg)\n);\nif ((traffic.Congestion)() \u003d true)\nthen\n(\n\nif (((vemoVehicle.GetSpeed)() \u003d 0) \u003d\u003e (not (exists data in set (elems internalTrafficData) \u0026 (Position`Compare((data.GetPosition)(), GetPosition()) and ((data.GetMessage)() \u003d \u003cCongestion\u003e)))))\nthen\n(\n\nlet congMsg:TrafficData \u003d new TrafficData(\u003cCongestion\u003e, (GetPosition().deepCopy)(), GetDirection()) in (\n\nAddInternalTrafficData(congMsg)\n)\n)\n)\n)\npublic async  run() (() \u003d\u003d\u003e ())\n\trun()() \u003d\u003d\nstart (self)\nprotected  thread while true do duration (500) (\n\nStep();\ncanRun :\u003d false\n)\nprivate  per Step \u003d\u003e canRun\nprivate  mutex(AddInternalTrafficData, GetTrafficData)\nprivate  mutex(AddInternalTrafficData)\nprivate  mutex(Step)\nend Controller\n","class Environment\nprivate  vemoCtrl:VeMoController :\u003d (undefined)\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (char) :\u003d []\nprivate  busy:bool :\u003d true\nprivate static  inline \u003d inline\nprivate static  InputTP \u003d InputTP\npublic  Environment(seq of (char)) (seq of (char) \u003d\u003d\u003e Environment)\n\tEnvironment(seq of (char))(filename) \u003d\u003d\n(\n\nPrinter`OutWithTS(((\"Environment created: \" ^ \"Some aren\u0027t used to an environment\") ^ \" where excellence is expected\"));\nlet mk_(-, input) \u003d ((io.freadval))[InputTP](filename) in (\n\ninlines :\u003d input\n)\n)\npublic  Events() (() \u003d\u003d\u003e ())\n\tEvents()() \u003d\u003d\n(\n\nif (inlines \u003c\u003e [])\nthen\n(\ndone:bool :\u003d false\neventOccurred:bool :\u003d false\ncurtime:Time :\u003d time\n\nwhile (not done) do (\n\nlet event \u003d (hd inlines) in cases event :\n  mk_VechicleRun(-, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS((\"Environment: Start Vehicle event \" ^ Printer`natToString((event.ID))));\nlet ctrl:Controller \u003d (vemoCtrl.getController)((event.ID)) in (\n\nctrl.run()\n);\neventOccurred :\u003d true\n)\n)  mk_TrafficLightRun(-, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS((\"Environment: \" ^ \" Start TrafficLight event\"));\nlet light:TrafficLight \u003d (vemoCtrl.getTrafficLight)((event.ID)) in start (light);\neventOccurred :\u003d true\n)\n)  mk_VehicleUpdateSpeed(-, -, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS(((((\"Environment: SpeedUpdate event: \" ^ \"For vehicle: \") ^ Printer`natToString((event.ID))) ^ \" New Speed: \") ^ Printer`natToString((event.speed))));\nlet c:Controller \u003d (vemoCtrl.getController)((event.ID)) in c.getVehicle().SetSpeed((event.speed));\neventOccurred :\u003d true\n)\n)  mk_VehicleUpdatePosition(-, -, -, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nlet pos:Position \u003d new Position((event.posX), (event.posY)) in let c:Controller \u003d (vemoCtrl.getController)((event.ID)) in (\n\nc.getVehicle().SetPosition(pos);\nPrinter`OutWithTS((((\"Environment: PositionUpdate event: \n\t\t\t\t\t\t\t\t\tFor vehicle: \" ^ Printer`natToString((event.ID))) ^ \" New position:\") ^ (pos.toString)()))\n);\neventOccurred :\u003d true\n)\n)  mk_VehicleLowGrip(-, -, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS(((\"Environment: LowGrip event: \" ^ \"For vehicle: \") ^ Printer`natToString((event.ID))));\nlet c:Controller \u003d (vemoCtrl.getController)((event.ID)) in c.getVehicle().setLowGrip((event.lowGrip));\neventOccurred :\u003d true\n)\n)  mk_VehicleTurnIndication(-, -, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS(((((\"Environment: TurnIndication event: \" ^ \"For vehicle: \") ^ Printer`natToString((event.ID))) ^ \" New indicator: \") ^ Vehicle`IndicatorToString((event.turn))));\nlet c:Controller \u003d (vemoCtrl.getController)((event.ID)) in c.getVehicle().setTurnIndicator((event.turn));\neventOccurred :\u003d true\n)\n)  mk_VehicleUpdateDirection(-, -, -) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS(((((\"Environment: DirectionUpdate event: \" ^ \"For vehicle: \") ^ Printer`natToString((event.ID))) ^ \" New Direction: \") ^ Types`DirectionToString((event.direction))));\nlet c:Controller \u003d (vemoCtrl.getController)((event.ID)) in c.getVehicle().SetDirection((event.direction));\neventOccurred :\u003d true\n)\n)  mk_WasteTime(-) -\u003e (\n\nif ((event.t) \u003c\u003d curtime)\nthen\n(\n\nPrinter`OutWithTS(\"Environment: Wasting time\");\neventOccurred :\u003d true\n)\n)  others -\u003e Printer`OutWithTS(\"Environment: No match found\") end;\nif eventOccurred\nthen\n(\n\ninlines :\u003d (tl inlines);\ndone :\u003d ((len inlines) \u003d 0)\n)else\ndone :\u003d true;\neventOccurred :\u003d false\n)\n)else\nbusy :\u003d false\n)\npublic  handleEvent(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\thandleEvent(seq of (char))(s) \u003d\u003d\n(\n\nPrinter`OutWithTS((\"#Environment Handled System Event: \" ^ s));\noutlines :\u003d ((((outlines ^ Printer`natToString(time)) ^ \": \") ^ s) ^ \"\n\")\n)\npublic  report() (() \u003d\u003d\u003e ())\n\treport()() \u003d\u003d\n(\n\nPrinter`OutAlways((\"\n\nHowever beautiful the strategy,\" ^ \"you should occasionally look at the results.\"));\nPrinter`OutAlways(\"**RESULT***\");\nPrinter`OutAlways(\"***********\");\nPrinter`OutAlways(outlines);\nPrinter`OutAlways(\"\n***********\");\nPrinter`OutAlways(\"***********\")\n)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  goEnvironment() (() \u003d\u003d\u003e ())\n\tgoEnvironment()() \u003d\u003d\nskip\npublic  setVeMoCtrl(VeMoController) (VeMoController \u003d\u003d\u003e ())\n\tsetVeMoCtrl(VeMoController)(vemoController) \u003d\u003d\nvemoCtrl :\u003d vemoController\npublic  run() (() \u003d\u003d\u003e ())\n\trun()() \u003d\u003d\n(\n\nstart (vemoCtrl);\nstart (self)\n)\nprotected  thread (\n\nwhile busy do (\n\nEvents();\nvemoCtrl.EnvironmentReady()\n);\nPrinter`OutAlways(\"No more events;\")\n)\nprivate  per isFinished \u003d\u003e (not busy)\nprivate  per Events \u003d\u003e (#fin[Events] \u003d #fin[goEnvironment])\nprivate  mutex(handleEvent)\nend Environment\n","class Position\nprivate  x:int :\u003d (undefined)\nprivate  y:int :\u003d (undefined)\npublic  Position(int, int) (int * int \u003d\u003d\u003e Position)\n\tPosition(int, int)(x_, y_) \u003d\u003d\n(\n\nx :\u003d x_;\ny :\u003d y_\n)\npublic  X() (() \u003d\u003d\u003e int)\n\tX()() \u003d\u003d\n(\n\nreturn (x)\n)\npublic  Y() (() \u003d\u003d\u003e int)\n\tY()() \u003d\u003d\n(\n\nreturn (y)\n)\npublic  setX(int) (int \u003d\u003d\u003e ())\n\tsetX(int)(newX) \u003d\u003d\n(\n\nx :\u003d newX\n)\npublic  setY(int) (int \u003d\u003d\u003e ())\n\tsetY(int)(newY) \u003d\u003d\n(\n\ny :\u003d newY\n)\npublic  toString() (() \u003d\u003d\u003e seq of (char))\n\ttoString()() \u003d\u003d\n(\n\nreturn ((((\"position X: \" ^ (VDMUtil`val2seq_of_char)[int](x)) ^ \" Y: \") ^ (VDMUtil`val2seq_of_char)[int](y)))\n)\npublic  inRange(Position, int) (Position * int \u003d\u003d\u003e bool)\n\tinRange(Position, int)(p, range) \u003d\u003d\n(\n\nlet xd:int \u003d (x - (p.X)()), yd:int \u003d (y - (p.Y)()) in (\n\nlet d:real \u003d MATH`sqrt(((xd * xd) + (yd * yd))) in (\n\nreturn ((d \u003c\u003d range))\n)\n)\n)\npublic  deepCopy() (() \u003d\u003d\u003e Position)\n\tdeepCopy()() \u003d\u003d\n(\n\nlet newPos:Position \u003d new Position(x, y) in return (newPos)\n)\npublic static  public static Compare: (Position * Position -\u003e bool)\n\tCompare(a, b) \u003d\u003d\n(((a.X)() \u003d (b.X)()) and ((a.Y)() \u003d (b.Y)()))\nend Position\n","class Printer\nprivate static  echo:bool :\u003d true\npublic static  Echo(bool) (bool \u003d\u003d\u003e ())\n\tEcho(bool)(v) \u003d\u003d\necho :\u003d v\npublic static  OutAlways(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tOutAlways(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((pstr ^ \"\n\")) in skip\npublic static  OutWithTS(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tOutWithTS(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((((Printer`natToString(time) ^ \": \") ^ pstr) ^ \"\n\")) in skip\npublic static  natToString(nat) (nat \u003d\u003d\u003e seq of (char))\n\tnatToString(nat)(n) \u003d\u003d\n(\n\nreturn ((VDMUtil`val2seq_of_char)[nat](n))\n)\npublic static  intToString(int) (int \u003d\u003d\u003e seq of (char))\n\tintToString(int)(i) \u003d\u003d\n(\n\nreturn ((VDMUtil`val2seq_of_char)[int](i))\n)\nprivate  mutex(OutWithTS)\nend Printer\n","class Test\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(-) \u003d\u003d\nis subclass responsibility\nend Test\n","class TestCase is subclass of [Test]\nprivate  name:seq of (char) :\u003d (undefined)\npublic  TestCase(seq of (char)) (seq of (char) \u003d\u003d\u003e TestCase)\n\tTestCase(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\npublic  GetName() (() \u003d\u003d\u003e seq of (char))\n\tGetName()() \u003d\u003d\nreturn (name)\nprotected  AssertTrue(bool) (bool \u003d\u003d\u003e ())\n\tAssertTrue(bool)(pb) \u003d\u003d\nif (not pb)\nthen\nexit (\u003cFAILURE\u003e)\nprotected  AssertFalse(bool) (bool \u003d\u003d\u003e ())\n\tAssertFalse(bool)(pb) \u003d\u003d\nif pb\nthen\nexit (\u003cFAILURE\u003e)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(ptr) \u003d\u003d\ntrap in \u0027TestCase\u0027 (TestCase.vdmrt) at line 24:10\u003cFAILURE\u003eADefPatternBind[]ADefPatternBind with ptr.AddFailure(self) in (\n\nSetUp();\nRunTest();\nTearDown()\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nis subclass responsibility\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nis subclass responsibility\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nis subclass responsibility\nend TestCase\n","class TestController is subclass of [TestCase]\nprivate  pos:Position :\u003d (undefined)\npublic  TestController(seq of (char)) (seq of (char) \u003d\u003d\u003e TestController)\n\tTestController(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\npos :\u003d new Position(1, 1)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\nvec:Vehicle :\u003d new Vehicle(2, pos, 1, \u003cNORTH\u003e)\nctrl:Controller :\u003d new Controller(vec)\nvec2:Vehicle :\u003d new Vehicle(3, (pos.deepCopy)(), 1, \u003cNORTH\u003e)\nctrl2:Controller :\u003d new Controller(vec2)\nvec3:Vehicle :\u003d new Vehicle(4, (pos.deepCopy)(), 1, \u003cNORTH\u003e)\nctrl3:Controller :\u003d new Controller(vec3)\n\nAssertTrue(((ctrl.getVehicle)() \u003d vec));\nAssertTrue(((ctrl.GetDirection)() \u003d \u003cNORTH\u003e));\nAssertTrue(((ctrl.GetVehicleID)() \u003d 2));\nAssertTrue((((ctrl.GetPosition)().X)() \u003d (pos.X)()));\nAssertTrue((((ctrl.GetPosition)().Y)() \u003d (pos.Y)()));\nvec.setLowGrip(true);\nvec.setTurnIndicator(\u003cLEFT\u003e);\nctrl.Step();\nlet vs:[seq of (TrafficData)] \u003d (ctrl.GetTrafficData)() in (\n\nlet v:TrafficData \u003d vs(1) in (\n\nAssertTrue((((v.GetPosition)().X)() \u003d 1));\nAssertTrue((((v.GetPosition)().Y)() \u003d 2));\nAssertTrue(((v.GetMessage)() \u003d \u003cLowGrip\u003e));\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e))\n);\nlet v:TrafficData \u003d vs(2) in (\n\nAssertTrue((((v.GetPosition)().X)() \u003d 1));\nAssertTrue((((v.GetPosition)().Y)() \u003d 2));\nAssertTrue(((v.GetMessage)() \u003d \u003cLeftTurn\u003e));\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e))\n)\n);\nvec.SetSpeed(0);\nvec.setTurnIndicator(\u003cLEFT\u003e);\nctrl.Step();\nlet vs:[seq of (TrafficData)] \u003d (ctrl.GetTrafficData)() in (\n\nlet v:TrafficData \u003d vs(1) in (\n\nAssertTrue((((v.GetPosition)().X)() \u003d 1));\nAssertTrue((((v.GetPosition)().Y)() \u003d 2));\nAssertTrue(((v.GetMessage)() \u003d \u003cLowGrip\u003e));\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e))\n);\nlet v:TrafficData \u003d vs(2) in (\n\nAssertTrue((((v.GetPosition)().X)() \u003d 1));\nAssertTrue((((v.GetPosition)().Y)() \u003d 2));\nAssertTrue(((v.GetMessage)() \u003d \u003cLeftTurn\u003e));\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e))\n)\n);\nctrl.AddOncomingVehicle((ctrl2.getVehicleDTO)());\nctrl.AddOncomingVehicle((ctrl3.getVehicleDTO)());\nctrl.Step();\nlet vs:[seq of (TrafficData)] \u003d (ctrl.GetTrafficData)() in let v:TrafficData \u003d vs(3) in (\n\nAssertTrue(((v.GetMessage)() \u003d \u003cCongestion\u003e))\n);\nctrl.AddTrafficData(21, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(22, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(23, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(24, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(25, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(26, [new TrafficData(\u003cLeftTurn\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(31, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(32, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(33, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(34, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(31, [new TrafficData(\u003cLeftTurn\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(35, [new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)]);\nctrl.AddTrafficData(31, [new TrafficData(\u003cLeftTurn\u003e, pos, \u003cNORTH\u003e)])\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend TestController\n","class TestPosition is subclass of [TestCase]\npublic  TestPosition(seq of (char)) (seq of (char) \u003d\u003d\u003e TestPosition)\n\tTestPosition(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\npos:Position :\u003d new Position(2, 1)\n\nAssertTrue(((pos.X)() \u003d 2));\nAssertTrue(((pos.Y)() \u003d 1));\npos.setX(10);\nAssertTrue(((pos.X)() \u003d 10));\npos.setY(4);\nAssertTrue(((pos.Y)() \u003d 4));\nAssertTrue(((pos.toString)() \u003d \"position X: 10 Y: 4\"));\ntestInRange();\ntestDeepCopy();\ntestCompare()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\npublic  testInRange() (() \u003d\u003d\u003e ())\n\ttestInRange()() \u003d\u003d\n(\np:Position :\u003d new Position(0, 0)\np2:Position :\u003d new Position(1, 0)\n\nAssertTrue((p.inRange)(p2, 1));\nAssertFalse((p.inRange)(p2, 0));\np2.setY(4);\np2.setX(4);\nAssertTrue((p.inRange)(p2, 5))\n)\npublic  testDeepCopy() (() \u003d\u003d\u003e ())\n\ttestDeepCopy()() \u003d\u003d\n(\np:Position :\u003d new Position(5, 3)\np2:Position :\u003d (p.deepCopy)()\n\nAssertFalse((p \u003d p2));\nAssertTrue(((p.X)() \u003d (p2.X)()));\nAssertTrue(((p.Y)() \u003d (p2.Y)()));\np.setX(10);\nAssertTrue(((p.X)() \u003c\u003e (p2.X)()))\n)\npublic  testCompare() (() \u003d\u003d\u003e ())\n\ttestCompare()() \u003d\u003d\n(\np:Position :\u003d new Position(5, 3)\np2:Position :\u003d (p.deepCopy)()\n\nAssertTrue(Position`Compare(p, p2));\nAssertTrue(Position`Compare(p2, p));\np.setX(10);\nAssertFalse(Position`Compare(p, p2))\n)\nend TestPosition\n","class TestResult\nprivate  failures:seq of (TestCase) :\u003d []\npublic  AddFailure(TestCase) (TestCase \u003d\u003d\u003e ())\n\tAddFailure(TestCase)(ptst) \u003d\u003d\nfailures :\u003d (failures ^ [ptst])\npublic  Print(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrint(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((pstr ^ \"\n\")) in skip\npublic  Show() (() \u003d\u003d\u003e ())\n\tShow()() \u003d\u003d\nif (failures \u003d [])\nthen\nPrint(\"No failures detected\")else\nfor in \u0027TestResult\u0027 (TestResult.vdmrt) at line 22:11failureADefPatternBind[failure \u003d TestCase]ADefPatternBind in failures do\nPrint(((failure.GetName)() ^ \" failed\"))\nend TestResult\n","class TestSuite is subclass of [Test]\nprivate  tests:seq of (Test) :\u003d []\npublic static  TestKinds \u003d TestKinds\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\nntr:TestResult :\u003d new TestResult()\n\nRun(ntr);\nntr.Show()\n)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(result) \u003d\u003d\nfor in \u0027TestSuite\u0027 (TestSuite.vdmrt) at line 23:9testADefPatternBind[test \u003d Test]ADefPatternBind in tests do\ntest.Run(result)\npublic  AddTest(TestKinds) (TestKinds \u003d\u003d\u003e ())\n\tAddTest(TestKinds)(test) \u003d\u003d\ntests :\u003d (tests ^ [test])\nend TestSuite\n","class TestTraffic is subclass of [TestCase]\nprivate  pos:Position :\u003d (undefined)\npublic  TestTraffic(seq of (char)) (seq of (char) \u003d\u003d\u003e TestTraffic)\n\tTestTraffic(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\npos :\u003d new Position(1, 1)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntraf:Traffic :\u003d new Traffic()\nvec:Vehicle :\u003d new Vehicle(2, pos, 1, \u003cNORTH\u003e)\nvec2:Vehicle :\u003d new Vehicle(3, pos, 1, \u003cNORTH\u003e)\nvec3:Vehicle :\u003d new Vehicle(4, pos, 1, \u003cNORTH\u003e)\nvec4:Vehicle :\u003d new Vehicle(5, pos, 1, \u003cNORTH\u003e)\nvec5:Vehicle :\u003d new Vehicle(6, pos, 1, \u003cNORTH\u003e)\nvec6:Vehicle :\u003d new Vehicle(7, pos, 1, \u003cNORTH\u003e)\n\nAssertFalse((traf.ExistVehicle)(vec));\ntraf.AddVehicle(vec);\nAssertTrue((traf.ExistVehicle)(vec));\ntraf.AddVehicle(vec2);\nlet vs:seq of (Vehicle) \u003d (traf.GetVehicles)() in (\n\nAssertTrue(((len vs) \u003d 2));\nAssertTrue((vs(1) \u003d vec))\n);\ntraf.AddVehicle(vec3);\ntraf.AddVehicle(vec4);\ntraf.AddVehicle(vec5);\nlet vs:seq of (Vehicle) \u003d (traf.GetVehicles)() in AssertTrue(((len vs) \u003d 5));\ntraf.AddVehicle(vec6);\nlet vs:seq of (Vehicle) \u003d (traf.GetVehicles)() in AssertTrue(((len vs) \u003d 5));\ntestCongestion()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\npublic  testCongestion() (() \u003d\u003d\u003e ())\n\ttestCongestion()() \u003d\u003d\n(\npos2:Position :\u003d new Position(1, 2)\npos3:Position :\u003d new Position(1, 3)\npos4:Position :\u003d new Position(1, 5)\ntraf:Traffic :\u003d new Traffic()\nvec:Vehicle :\u003d new Vehicle(2, pos, 1, \u003cNORTH\u003e)\nvec2:Vehicle :\u003d new Vehicle(3, pos2, 1, \u003cNORTH\u003e)\nvec3:Vehicle :\u003d new Vehicle(4, pos3, 1, \u003cNORTH\u003e)\nvec4:Vehicle :\u003d new Vehicle(5, pos4, 1, \u003cSOUTH\u003e)\ntraf:Traffic :\u003d new Traffic()\n\nlet vs:seq1 of (Vehicle) \u003d [vec, vec2, vec3, vec4] in (\n\nfor in \u0027TestTraffic\u0027 (TestTraffic.vdmrt) at line 93:7vADefPatternBind[v \u003d Vehicle]ADefPatternBind in vs do\n(\n\ntraf.AddVehicle(v)\n);\nAssertTrue((traf.Congestion)())\n)\n)\nend TestTraffic\n","class TestTrafficData is subclass of [TestCase]\nprivate  pos:Position :\u003d (undefined)\npublic  TestTrafficData(seq of (char)) (seq of (char) \u003d\u003d\u003e TestTrafficData)\n\tTestTrafficData(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\npos :\u003d new Position(5, 1)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntd:TrafficData :\u003d new TrafficData(\u003cCongestion\u003e, pos, \u003cNORTH\u003e)\ntd2:TrafficData :\u003d new TrafficData(\u003cLeftTurn\u003e, pos, \u003cWEST\u003e)\ntd3:TrafficData :\u003d new TrafficData(\u003cRedLight\u003e, pos, \u003cEAST\u003e)\n\nAssertTrue((((td.GetPosition)().X)() \u003d 5));\nAssertTrue((((td.GetPosition)().Y)() \u003d 1));\nAssertTrue(((td.GetDirection)() \u003d \u003cNORTH\u003e));\nAssertTrue(((td.GetMessage)() \u003d \u003cCongestion\u003e));\nAssertTrue((TrafficData`MessageTypeToString((td.GetMessage)()) \u003d \"Congestion \"));\nAssertTrue((((td2.GetPosition)().X)() \u003d 5));\nAssertTrue((((td2.GetPosition)().Y)() \u003d 1));\nAssertTrue(((td2.GetDirection)() \u003d \u003cWEST\u003e));\nAssertTrue(((td2.GetMessage)() \u003d \u003cLeftTurn\u003e));\nAssertTrue((TrafficData`MessageTypeToString((td2.GetMessage)()) \u003d \"Left Turn\"));\nAssertTrue((((td3.GetPosition)().X)() \u003d 5));\nAssertTrue((((td3.GetPosition)().Y)() \u003d 1));\nAssertTrue(((td3.GetDirection)() \u003d \u003cEAST\u003e));\nAssertTrue(((td3.GetMessage)() \u003d \u003cRedLight\u003e));\nAssertTrue((TrafficData`MessageTypeToString((td3.GetMessage)()) \u003d \"Red Light\"));\ntestExpired()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\npublic  testExpired() (() \u003d\u003d\u003e ())\n\ttestExpired()() \u003d\u003d\n(\ntd:TrafficData :\u003d new TrafficData(\u003cLowGrip\u003e, pos, \u003cNORTH\u003e)\n\nAssertFalse((td.Expired)());\nduration (15000) AssertFalse((td.Expired)());\nduration (15000) AssertTrue((td.Expired)())\n)\nend TestTrafficData\n","class TestTrafficLight is subclass of [TestCase]\nprivate  pos:Position :\u003d (undefined)\npublic  TestTrafficLight(seq of (char)) (seq of (char) \u003d\u003d\u003e TestTrafficLight)\n\tTestTrafficLight(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\npos :\u003d new Position(5, 1)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntrfLgt:TrafficLight :\u003d new TrafficLight(1, pos, 5)\n\nAssertTrue(((trfLgt.GetID)() \u003d 1));\nAssertTrue((((trfLgt.GetPosition)().X)() \u003d 5));\nAssertTrue((((trfLgt.GetPosition)().Y)() \u003d 1));\nAssertTrue(((trfLgt.GreenLightPath)() \u003d \u003cNORTH\u003e));\ntestGreenLightPath();\ntestCrossDirection()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\npublic  testGreenLightPath() (() \u003d\u003d\u003e ())\n\ttestGreenLightPath()() \u003d\u003d\n(\ntrfLgt:TrafficLight :\u003d new TrafficLight(1, pos, 2)\n\nstart (trfLgt);\nAssertTrue(((trfLgt.GreenLightPath)() \u003d \u003cNORTH\u003e))\n)\npublic  testCrossDirection() (() \u003d\u003d\u003e ())\n\ttestCrossDirection()() \u003d\u003d\n(\n\nAssertTrue((TrafficLight`CrossDirection(\u003cNORTH\u003e) \u003d \u003cEAST\u003e));\nAssertTrue((TrafficLight`CrossDirection(\u003cSOUTH\u003e) \u003d \u003cWEST\u003e));\nAssertTrue((TrafficLight`CrossDirection(\u003cEAST\u003e) \u003d \u003cNORTH\u003e));\nAssertTrue((TrafficLight`CrossDirection(\u003cWEST\u003e) \u003d \u003cSOUTH\u003e))\n)\nend TestTrafficLight\n","class TestVeMoComplete\npublic  Execute() (() \u003d\u003d\u003e ())\n\tExecute()() \u003d\u003d\n(\nw:World :\u003d new World()\nts:TestSuite :\u003d new TestSuite()\n\nts.AddTest(new TestVehicle(\"TestVehicle\"));\nts.AddTest(new TestPosition(\"TestPosition\"));\nts.AddTest(new TestTrafficLight(\"TestTrafficLight\"));\nts.AddTest(new TestTrafficData(\"TestTrafficData\"));\nts.AddTest(new TestTraffic(\"TestTraffic\"));\nts.AddTest(new TestController(\"TestController\"));\nts.AddTest(new TestVeMoController(\"TestVeMoController\"));\nts.Run()\n)\nend TestVeMoComplete\n","class TestVeMoController is subclass of [TestCase]\nprivate  pos:Position :\u003d (undefined)\npublic  TestVeMoController(seq of (char)) (seq of (char) \u003d\u003d\u003e TestVeMoController)\n\tTestVeMoController(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\npos :\u003d new Position(1, 1)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\n\nPrinter`OutAlways(\"Testing VeMoController\");\nstart (self);\nself.IsFinished()\n)\nprivate  runner() (() \u003d\u003d\u003e ())\n\trunner()() \u003d\u003d\n(\nvec:Vehicle :\u003d new Vehicle(2, pos, 1, \u003cNORTH\u003e)\nvec2:Vehicle :\u003d new Vehicle(3, new Position(1, 3), 1, \u003cSOUTH\u003e)\nctrl:Controller :\u003d new Controller(vec)\nctrl2:Controller :\u003d new Controller(vec2)\nvec3:Vehicle :\u003d new Vehicle(4, new Position(1, 3), 1, \u003cEAST\u003e)\nvemoCtrl:VeMoController :\u003d new VeMoController()\ntrfLight:TrafficLight :\u003d new TrafficLight(11, new Position(1, 3), 5)\n\nvec.setLowGrip(true);\nvemoCtrl.addController(ctrl);\nvemoCtrl.addController(ctrl2);\nAssertTrue(((vemoCtrl.getController)(2) \u003d ctrl));\nstart (vemoCtrl);\nvemoCtrl.CalculateInRange();\nlet vs:[seq of (TrafficData)] \u003d (ctrl.GetTrafficData)() in (\n\nskip;\nlet v:TrafficData \u003d vs(1) in (\n\nAssertTrue((((v.GetPosition)().X)() \u003d 1));\nAssertTrue((((v.GetPosition)().Y)() \u003d 2));\nAssertTrue(((v.GetMessage)() \u003d \u003cLowGrip\u003e));\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e))\n)\n);\nAssertTrue((VeMoController`OppositeDirection((vec3.GetDirection)()) \u003d \u003cWEST\u003e));\nvec3.SetDirection(\u003cWEST\u003e);\nAssertTrue((VeMoController`OppositeDirection((vec3.GetDirection)()) \u003d \u003cEAST\u003e));\nvemoCtrl.addTrafficLight(trfLight);\nlet t:TrafficLight \u003d (vemoCtrl.getTrafficLight)(11) in (\n\nAssertTrue(((t.GetID)() \u003d 11));\nAssertTrue(Position`Compare((t.GetPosition)(), new Position(1, 3)))\n)\n)\nprivate  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nprotected  thread (\n\nrunner()\n)\nprivate  per IsFinished \u003d\u003e (#fin[runner] \u003e 0)\nend TestVeMoController\n","class TestVehicle is subclass of [TestCase]\nprivate  dir:Direction :\u003d (undefined)\nprivate  pos:Position :\u003d (undefined)\npublic  TestVehicle(seq of (char)) (seq of (char) \u003d\u003d\u003e TestVehicle)\n\tTestVehicle(seq of (char))(s) \u003d\u003d\n(\n\nTestCase(s)\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\n(\n\ndir :\u003d \u003cEAST\u003e;\npos :\u003d new Position(5, 1)\n)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\nvec:Vehicle :\u003d new Vehicle(2, pos, 1, dir)\nvec2:Vehicle :\u003d new Vehicle(3, pos, 1, dir)\n\nAssertTrue((vec \u003c\u003e vec2));\nAssertTrue(((vec.GetID)() \u003d 2));\nAssertTrue(((vec2.GetID)() \u003d 3));\ntestGetDirection();\ntestSetDirection();\ntestGetSpeed();\ntestSetSpeed();\ntestgetLowGrip();\ntestsetLowGrip();\ntestTurnIndicator();\ntestsetTurnIndicator();\ntestGetPosition();\ntestSetPosition();\ntestStep()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nprotected  initData() (() \u003d\u003d\u003e Vehicle)\n\tinitData()() \u003d\u003d\nreturn (new Vehicle(1, pos, 1, dir))\nprotected  testGetDirection() (() \u003d\u003d\u003e ())\n\ttestGetDirection()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nAssertTrue(((v.GetDirection)() \u003d \u003cEAST\u003e))\n)\nprotected  testSetDirection() (() \u003d\u003d\u003e ())\n\ttestSetDirection()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nv.SetDirection(\u003cWEST\u003e);\nAssertTrue(((v.GetDirection)() \u003d \u003cWEST\u003e))\n)\nprotected  testGetSpeed() (() \u003d\u003d\u003e ())\n\ttestGetSpeed()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nAssertTrue(((v.GetSpeed)() \u003d 1))\n)\nprotected  testSetSpeed() (() \u003d\u003d\u003e ())\n\ttestSetSpeed()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nv.SetSpeed(10);\nAssertTrue(((v.GetSpeed)() \u003d 10))\n)\nprotected  testgetLowGrip() (() \u003d\u003d\u003e ())\n\ttestgetLowGrip()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nAssertFalse((v.getLowGrip)())\n)\nprotected  testsetLowGrip() (() \u003d\u003d\u003e ())\n\ttestsetLowGrip()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nv.setLowGrip(true);\nAssertTrue((v.getLowGrip)());\nv.setLowGrip(false);\nAssertFalse((v.getLowGrip)())\n)\nprotected  testTurnIndicator() (() \u003d\u003d\u003e ())\n\ttestTurnIndicator()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nAssertTrue(((v.TurnIndicator)() \u003d \u003cNONE\u003e));\nAssertTrue((Vehicle`IndicatorToString(\u003cLEFT\u003e) \u003d \"LEFT\"));\nAssertTrue((Vehicle`IndicatorToString(\u003cRIGHT\u003e) \u003d \"RIGHT\"));\nAssertTrue((Vehicle`IndicatorToString(\u003cNONE\u003e) \u003d \"NONE\"))\n)\nprotected  testsetTurnIndicator() (() \u003d\u003d\u003e ())\n\ttestsetTurnIndicator()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nv.setTurnIndicator(\u003cLEFT\u003e);\nAssertTrue(((v.TurnIndicator)() \u003d \u003cLEFT\u003e))\n)\nprotected  testGetPosition() (() \u003d\u003d\u003e ())\n\ttestGetPosition()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 5));\nAssertTrue(((p.Y)() \u003d 1))\n)\n)\nprotected  testSetPosition() (() \u003d\u003d\u003e ())\n\ttestSetPosition()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nlet newP:Position \u003d new Position(10, 1) in v.SetPosition(newP);\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 10));\nAssertTrue(((p.Y)() \u003d 1))\n)\n)\nprotected  testStep() (() \u003d\u003d\u003e ())\n\ttestStep()() \u003d\u003d\n(\nv:Vehicle :\u003d initData()\n\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 5));\nAssertTrue(((p.Y)() \u003d 1))\n);\nv.Move();\nAssertTrue(((v.GetDirection)() \u003d \u003cEAST\u003e));\nAssertTrue((Types`DirectionToString((v.GetDirection)()) \u003d \"EAST\"));\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 6));\nAssertTrue(((p.Y)() \u003d 1))\n);\nv.Move();\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 7));\nAssertTrue(((p.Y)() \u003d 1))\n);\nv.SetDirection(\u003cNORTH\u003e);\nAssertTrue(((v.GetDirection)() \u003d \u003cNORTH\u003e));\nAssertTrue((Types`DirectionToString((v.GetDirection)()) \u003d \"NORTH\"));\nv.Move();\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 7));\nAssertTrue(((p.Y)() \u003d 2))\n);\nv.SetDirection(\u003cWEST\u003e);\nAssertTrue(((v.GetDirection)() \u003d \u003cWEST\u003e));\nAssertTrue((Types`DirectionToString((v.GetDirection)()) \u003d \"WEST\"));\nv.Move();\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 6));\nAssertTrue(((p.Y)() \u003d 2))\n);\nv.SetDirection(\u003cSOUTH\u003e);\nAssertTrue(((v.GetDirection)() \u003d \u003cSOUTH\u003e));\nAssertTrue((Types`DirectionToString((v.GetDirection)()) \u003d \"SOUTH\"));\nv.Move();\nlet p:Position \u003d (v.GetPosition)() in (\n\nAssertTrue(((p.X)() \u003d 6));\nAssertTrue(((p.Y)() \u003d 1))\n)\n)\nend TestVehicle\n","class Traffic\nprivate  vehicles:seq of (Vehicle) :\u003d []\nprivate  inv((len vehicles) \u003c\u003d 5)\npublic  AddVehicle(Vehicle) (Vehicle \u003d\u003d\u003e ())\n\tAddVehicle(Vehicle)(vehicle) \u003d\u003d\n(\n\nif ((len vehicles) \u003c Config`TrafficCongestionTrack)\nthen\nvehicles :\u003d (vehicles ^ [vehicle])else\nvehicles :\u003d ((tl vehicles) ^ [vehicle])\n)\n\tpre (vehicle not in set (elems vehicles))\npublic  ExistVehicle(Vehicle) (Vehicle \u003d\u003d\u003e bool)\n\tExistVehicle(Vehicle)(v) \u003d\u003d\n(\n\nreturn (({vec | vec in set (elems vehicles) \u0026 ((v.GetID)() \u003d (vec.GetID)())} \u003c\u003e {}))\n)\npublic  ExistVehicleData(VehicleData) (VehicleData \u003d\u003d\u003e bool)\n\tExistVehicleData(VehicleData)(v) \u003d\u003d\n(\n\nreturn (({vec | vec in set (elems vehicles) \u0026 ((v.GetID)() \u003d (vec.GetID)())} \u003c\u003e {}))\n)\npublic  GetVehicles() (() \u003d\u003d\u003e seq of (Vehicle))\n\tGetVehicles()() \u003d\u003d\nreturn (vehicles)\npublic  Congestion() (() \u003d\u003d\u003e bool)\n\tCongestion()() \u003d\u003d\n(\ninrange:set of (Vehicle) :\u003d {}\n\nfor in \u0027Traffic\u0027 (Traffic.vdmrt) at line 67:6vADefPatternBind[v \u003d Vehicle]ADefPatternBind in vehicles do\n(\n\nlet vs:set of (Vehicle) \u003d FindInRangeWithSameDirection(v, vehicles) in inrange :\u003d (inrange union vs)\n);\nif ((card inrange) \u003d 0)\nthen\nreturn (false);\nlet avgspeed:nat \u003d AverageSpeed(inrange) in (\n\nreturn ((avgspeed \u003c Config`TrafficCongestionThreshold))\n)\n)\nprivate  AverageSpeed(set of (Vehicle)) (set of (Vehicle) \u003d\u003d\u003e nat)\n\tAverageSpeed(set of (Vehicle))(vs) \u003d\u003d\n(\nsumSpeed:nat :\u003d 0\n\nfor all v in set vs do\nsumSpeed :\u003d (sumSpeed + (v.GetSpeed)());\nreturn ((sumSpeed / (card vs)))\n)\n\tpre ((card vs) \u003c\u003e 0)\npublic  public InRange: (Vehicle * Vehicle -\u003e bool)\n\tInRange(v1, v2) \u003d\u003d\nlet pos1:Position \u003d (v1.GetPosition)(), pos2:Position \u003d (v2.GetPosition)() in (pos1.inRange)(pos2, Config`TrafficCongestionRange)\npublic  public FindInRangeWithSameDirection: (Vehicle * seq of (Vehicle) -\u003e set of (Vehicle))\n\tFindInRangeWithSameDirection(v, vs) \u003d\u003d\nlet dir:Direction \u003d (v.GetDirection)() in {ir | ir in set (elems vs) \u0026 ((v \u003c\u003e ir) and ((dir \u003d (ir.GetDirection)()) and (InRange(v, ir) \u003d true)))}\nprivate  mutex(Congestion, AddVehicle)\nprivate  mutex(ExistVehicle, AddVehicle)\nprivate  mutex(GetVehicles, AddVehicle)\nprivate  mutex(AddVehicle)\nend Traffic\n","class TrafficData\nprivate  dir:Direction :\u003d (undefined)\nprivate  pos:Position :\u003d (undefined)\nprivate  message:MessageType :\u003d (undefined)\nprivate  timeToLive:nat :\u003d (undefined)\npublic static  MessageType \u003d MessageType\npublic  TrafficData(MessageType, Position, Direction) (MessageType * Position * Direction \u003d\u003d\u003e TrafficData)\n\tTrafficData(MessageType, Position, Direction)(m, p, d) \u003d\u003d\n(\n\npos :\u003d p;\nmessage :\u003d m;\ndir :\u003d d;\ntimeToLive :\u003d (time + Config`TrafficDataLifeTime)\n)\npublic  GetPosition() (() \u003d\u003d\u003e Position)\n\tGetPosition()() \u003d\u003d\nreturn (pos)\npublic  GetMessage() (() \u003d\u003d\u003e MessageType)\n\tGetMessage()() \u003d\u003d\nreturn (message)\npublic  GetDirection() (() \u003d\u003d\u003e Direction)\n\tGetDirection()() \u003d\u003d\nreturn (dir)\npublic  Expired() (() \u003d\u003d\u003e bool)\n\tExpired()() \u003d\u003d\nreturn ((time \u003e\u003d timeToLive))\npublic  ToString() (() \u003d\u003d\u003e seq of (char))\n\tToString()() \u003d\u003d\nreturn ((((((((\"traffic data reporting \" ^ MessageTypeToString(message)) ^ \" moved \") ^ Types`DirectionToString(dir)) ^ \" at \") ^ (pos.toString)()) ^ \" with lifetime \") ^ Printer`intToString((timeToLive - time))))\npublic static  public static MessageTypeToString: (MessageType -\u003e seq of (char))\n\tMessageTypeToString(m) \u003d\u003d\n(cases m :\n\u003cLowGrip\u003e -\u003e \"Low Grip\",\n\u003cCongestion\u003e -\u003e \"Congestion \",\n\u003cLeftTurn\u003e -\u003e \"Left Turn\",\n\u003cRedLight\u003e -\u003e \"Red Light\"\n end)\nend TrafficData\n","class TrafficLight\nprivate  pos:Position :\u003d (undefined)\nprivate  greenLightTime:nat1 :\u003d (undefined)\nprivate  greenDir:Direction :\u003d (undefined)\nprivate  id:nat :\u003d (undefined)\npublic  TrafficLight(nat, Position, nat1) (nat * Position * nat1 \u003d\u003d\u003e TrafficLight)\n\tTrafficLight(nat, Position, nat1)(identifier, p, t) \u003d\u003d\n(\n\npos :\u003d p;\ngreenLightTime :\u003d t;\nid :\u003d identifier;\ngreenDir :\u003d \u003cNORTH\u003e\n)\npublic  AddTrafficData(TrafficData) (TrafficData \u003d\u003d\u003e ())\n\tAddTrafficData(TrafficData)(data) \u003d\u003d\nis not yet specified\npublic  GetTrafficData() (() \u003d\u003d\u003e set of (TrafficData))\n\tGetTrafficData()() \u003d\u003d\nis not yet specified\npublic  GetPosition() (() \u003d\u003d\u003e Position)\n\tGetPosition()() \u003d\u003d\nreturn (pos)\npublic  GreenLightPath() (() \u003d\u003d\u003e Direction)\n\tGreenLightPath()() \u003d\u003d\nreturn (greenDir)\npublic  GetID() (() \u003d\u003d\u003e nat)\n\tGetID()() \u003d\u003d\nreturn (id)\nprivate  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif ((time mod greenLightTime) \u003d 0)\nthen\n(\n\ngreenDir :\u003d CrossDirection(greenDir)\n)\n)\npublic static  public static CrossDirection: (Direction -\u003e Direction)\n\tCrossDirection(d) \u003d\u003d\n(cases d :\n\u003cNORTH\u003e -\u003e \u003cEAST\u003e,\n\u003cSOUTH\u003e -\u003e \u003cWEST\u003e,\n\u003cEAST\u003e -\u003e \u003cNORTH\u003e,\n\u003cWEST\u003e -\u003e \u003cSOUTH\u003e\n end)\nprotected  thread periodic(1.0E9, 10, 9.0E8, 0)(Step())\nprivate  mutex(GreenLightPath)\nprivate  mutex(Step, GreenLightPath)\nend TrafficLight\n","class Types\npublic static  Time \u003d Time\npublic static  Direction \u003d Direction\npublic static  Event \u003d Event\npublic static  VechicleRun \u003d VechicleRun\npublic static  TrafficLightRun \u003d TrafficLightRun\npublic static  VehicleUpdateSpeed \u003d VehicleUpdateSpeed\npublic static  VehicleUpdatePosition \u003d VehicleUpdatePosition\npublic static  VehicleUpdateDirection \u003d VehicleUpdateDirection\npublic static  VehicleLowGrip \u003d VehicleLowGrip\npublic static  VehicleTurnIndication \u003d VehicleTurnIndication\npublic static  WasteTime \u003d WasteTime\npublic static  public static DirectionToString: (Direction -\u003e seq of (char))\n\tDirectionToString(d) \u003d\u003d\n(cases d :\n\u003cNORTH\u003e -\u003e \"NORTH\",\n\u003cSOUTH\u003e -\u003e \"SOUTH\",\n\u003cEAST\u003e -\u003e \"EAST\",\n\u003cWEST\u003e -\u003e \"WEST\"\n end)\npublic static  public static DirectionToGraphics: (Direction -\u003e nat)\n\tDirectionToGraphics(d) \u003d\u003d\n(cases d :\n\u003cNORTH\u003e -\u003e 1,\n\u003cSOUTH\u003e -\u003e 5,\n\u003cEAST\u003e -\u003e 3,\n\u003cWEST\u003e -\u003e 7\n end)\nend Types\n","system VeMo\npublic  cpu0:CPU :\u003d new CPU(\u003cFP\u003e, 1000000.0)\npublic  cpu1:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\npublic  cpu2:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\npublic  cpu9:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\npublic  bus1:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu0, cpu1, cpu2, cpu9})\nprivate static  e:Environment :\u003d World`env\npublic static  ctrl1:Controller :\u003d new Controller(new Vehicle(1, new Position(17, -20), 1, \u003cNORTH\u003e))\npublic static  ctrl2:Controller :\u003d new Controller(new Vehicle(2, new Position(-4, 25), 3, \u003cSOUTH\u003e))\npublic static  ctrl9:Controller :\u003d new Controller(new Vehicle(9, new Position(23, 20), 1, \u003cSOUTH\u003e))\npublic static  tl1:TrafficLight :\u003d new TrafficLight(20, new Position(1, 1), 100)\npublic static  vemoCtrl:VeMoController :\u003d new VeMoController()\npublic  VeMo() (() \u003d\u003d\u003e VeMo)\n\tVeMo()() \u003d\u003d\n(\n\ncpu1.deploy(ctrl1);\ncpu2.deploy(ctrl2);\ncpu9.deploy(ctrl9)\n)\nend VeMo\n","class VeMoController\npublic  ctrlUnits:inmap (nat) to (Controller) :\u003d {|-\u003e}\npublic  lights:inmap (nat) to (TrafficLight) :\u003d {|-\u003e}\nprivate  inv(((dom ctrlUnits) inter (dom lights)) \u003d {})\nprivate  inv(forall id in set (dom ctrlUnits) \u0026 ((ctrlUnits(id).GetVehicleID)() \u003d id))\nprivate  inv(forall id in set (dom lights) \u0026 ((lights(id).GetID)() \u003d id))\npublic static  graphics:gui_Graphics :\u003d new gui_Graphics()\nprivate static  env:Environment :\u003d World`env\npublic  VeMoController() (() \u003d\u003d\u003e VeMoController)\n\tVeMoController()() \u003d\u003d\n(\n\ngraphics.init()\n)\npublic  addController(Controller) (Controller \u003d\u003d\u003e ())\n\taddController(Controller)(ctrl) \u003d\u003d\n(\n\nctrlUnits :\u003d (ctrlUnits munion {(ctrl.GetVehicleID)() |-\u003e ctrl});\nlet vecID:nat \u003d (ctrl.GetVehicleID)() in (\n\ngraphics.addVehicle(vecID);\nlet pos:[Position] \u003d (ctrl.GetPosition)() in graphics.updatePosition(vecID, (pos.X)(), (pos.Y)());\nlet dir:[Direction] \u003d (ctrl.GetDirection)() in graphics.updateDirection(vecID, Types`DirectionToGraphics(dir));\nfor all unit in set (rng ctrlUnits) do\ngraphics.connectVehicles((unit.GetVehicleID)(), vecID)\n)\n)\n\tpre ((ctrl.GetVehicleID)() not in set ((dom ctrlUnits) union (dom lights)))\npublic  addTrafficLight(TrafficLight) (TrafficLight \u003d\u003d\u003e ())\n\taddTrafficLight(TrafficLight)(light) \u003d\u003d\n(\n\nlights :\u003d (lights munion {(light.GetID)() |-\u003e light})\n)\n\tpre (((light.GetID)() not in set (dom lights)) and ((light.GetID)() not in set (dom ctrlUnits)))\npublic  getController(nat) (nat \u003d\u003d\u003e Controller)\n\tgetController(nat)(id) \u003d\u003d\n(\n\nreturn (ctrlUnits(id))\n)\n\tpre (id in set (dom ctrlUnits))\npublic  getTrafficLight(nat) (nat \u003d\u003d\u003e TrafficLight)\n\tgetTrafficLight(nat)(id) \u003d\u003d\n(\n\nreturn (lights(id))\n)\n\tpre (id in set (dom lights))\npublic  EnvironmentReady() (() \u003d\u003d\u003e ())\n\tEnvironmentReady()() \u003d\u003d\nskip\npublic  CalculateInRange() (() \u003d\u003d\u003e ())\n\tCalculateInRange()() \u003d\u003d\n(\n\nlet units:set of (Controller) \u003d (rng ctrlUnits) in for all unit in set units do\n(\n\nlet pos:[Position] \u003d (unit.GetPosition)() in graphics.updatePosition((unit.GetVehicleID)(), (pos.X)(), (pos.Y)());\nlet dir:[Direction] \u003d (unit.GetDirection)() in graphics.updateDirection((unit.GetVehicleID)(), Types`DirectionToGraphics(dir));\nlet inrange:set of (Controller) \u003d FindInRangeWithOppositeDirection(unit, units) in (\n\nif ((card inrange) \u003e 0)\nthen\nfor all oncomingVehicle in set inrange do\n(\n\nunit.AddTrafficData((oncomingVehicle.GetVehicleID)(), (oncomingVehicle.GetTrafficData)());\nlet vehicleDTO:[VehicleData] \u003d (unit.getVehicleDTO)() in oncomingVehicle.AddOncomingVehicle(vehicleDTO)\n)\n)\n);\ngraphics.sleep();\nfor all u in set (rng ctrlUnits) do\nu.EnvironmentReady()\n)\npublic static  public static OppositeDirection: (Direction -\u003e Direction)\n\tOppositeDirection(d) \u003d\u003d\n(cases d :\n\u003cNORTH\u003e -\u003e \u003cSOUTH\u003e,\n\u003cSOUTH\u003e -\u003e \u003cNORTH\u003e,\n\u003cEAST\u003e -\u003e \u003cWEST\u003e,\n\u003cWEST\u003e -\u003e \u003cEAST\u003e\n end)\npublic  public FindInRange: (Controller * set of (Controller) -\u003e set of (Controller))\n\tFindInRange(v, vs) \u003d\u003d\nlet inrange:set of (Controller) \u003d {ir | ir in set vs \u0026 ((v \u003c\u003e ir) and (InRange(v, ir) \u003d true))} in inrange\npublic  public InRange: (Controller * Controller -\u003e bool)\n\tInRange(u1, u2) \u003d\u003d\nlet pos1:[Position] \u003d (u1.GetPosition)(), pos2:[Position] \u003d (u2.GetPosition)() in (pos1.inRange)(pos2, Config`Range)\npublic  public FindInRangeWithOppositeDirection: (Controller * set of (Controller) -\u003e set of (Controller))\n\tFindInRangeWithOppositeDirection(u, us) \u003d\u003d\nlet dir:Direction \u003d OppositeDirection((u.GetDirection)()) in let inrange:set of (Controller) \u003d {ir | ir in set FindInRange(u, us) \u0026 (dir \u003d (ir.GetDirection)())} in inrange\nprotected  thread (\n\nwhile true do (\n\nCalculateInRange();\nenv.goEnvironment()\n)\n)\nprivate  per CalculateInRange \u003d\u003e (#fin[EnvironmentReady] \u003e #fin[CalculateInRange])\nprivate  mutex(CalculateInRange, addController, getController)\nprivate  mutex(addController)\nprivate  mutex(getController)\nprivate  mutex(CalculateInRange)\nend VeMoController\n","class Vehicle\nprivate  dir:Direction :\u003d (undefined)\nprivate  speed:nat :\u003d (undefined)\nprivate  lowgrip:bool :\u003d (undefined)\nprivate  turnIndicator:Indicator :\u003d \u003cNONE\u003e\nprivate  pos:Position :\u003d (undefined)\nprivate  id:nat :\u003d (undefined)\npublic static  Indicator \u003d Indicator\npublic  Vehicle(nat, Position, nat, Direction) (nat * Position * nat * Direction \u003d\u003d\u003e Vehicle)\n\tVehicle(nat, Position, nat, Direction)(identifier, p, s, d) \u003d\u003d\n(\n\npos :\u003d p;\nspeed :\u003d s;\ndir :\u003d d;\nid :\u003d identifier;\nlowgrip :\u003d false\n)\npublic  Vehicle(VehicleData) (VehicleData \u003d\u003d\u003e Vehicle)\n\tVehicle(VehicleData)(vdDTO) \u003d\u003d\n(\n\npos :\u003d (vdDTO.GetPosition)();\nspeed :\u003d (vdDTO.GetSpeed)();\ndir :\u003d (vdDTO.GetDirection)();\nid :\u003d (vdDTO.GetID)();\nlowgrip :\u003d (vdDTO.getLowGrip)()\n)\npublic  GetDirection() (() \u003d\u003d\u003e Direction)\n\tGetDirection()() \u003d\u003d\nreturn (dir)\npublic async  SetDirection(Direction) (Direction \u003d\u003d\u003e ())\n\tSetDirection(Direction)(d) \u003d\u003d\n(\n\ndir :\u003d d\n)\npublic  GetSpeed() (() \u003d\u003d\u003e nat)\n\tGetSpeed()() \u003d\u003d\nreturn (speed)\npublic async  SetSpeed(nat) (nat \u003d\u003d\u003e ())\n\tSetSpeed(nat)(s) \u003d\u003d\nspeed :\u003d s\npublic  getLowGrip() (() \u003d\u003d\u003e bool)\n\tgetLowGrip()() \u003d\u003d\n(\n\nreturn (lowgrip)\n)\npublic async  setLowGrip(bool) (bool \u003d\u003d\u003e ())\n\tsetLowGrip(bool)(lg) \u003d\u003d\n(\n\nlowgrip :\u003d lg\n)\npublic  TurnIndicator() (() \u003d\u003d\u003e Indicator)\n\tTurnIndicator()() \u003d\u003d\nreturn (turnIndicator)\npublic async  setTurnIndicator(Indicator) (Indicator \u003d\u003d\u003e ())\n\tsetTurnIndicator(Indicator)(indicator) \u003d\u003d\n(\n\nturnIndicator :\u003d indicator\n)\npublic  GetPosition() (() \u003d\u003d\u003e Position)\n\tGetPosition()() \u003d\u003d\nreturn (pos)\npublic async  SetPosition(Position) (Position \u003d\u003d\u003e ())\n\tSetPosition(Position)(p) \u003d\u003d\npos :\u003d p\npublic  GetID() (() \u003d\u003d\u003e nat)\n\tGetID()() \u003d\u003d\nreturn (id)\npublic  Move() (() \u003d\u003d\u003e ())\n\tMove()() \u003d\u003d\n(\n\ncases dir :\n  \u003cNORTH\u003e -\u003e pos.setY(((pos.Y)() + speed))  \u003cSOUTH\u003e -\u003e pos.setY(((pos.Y)() - speed))  \u003cEAST\u003e -\u003e pos.setX(((pos.X)() + speed))  \u003cWEST\u003e -\u003e pos.setX(((pos.X)() - speed)) end;\nPrinter`OutWithTS((((((((\"Vehicle \" ^ Printer`natToString(id)) ^ \" moved \") ^ Types`DirectionToString(dir)) ^ \" to  \") ^ (pos.toString)()) ^ \" with speed \") ^ Printer`natToString(speed)))\n)\npublic  getDTO() (() \u003d\u003d\u003e VehicleData)\n\tgetDTO()() \u003d\u003d\n(\n\nlet vd:VehicleData \u003d new VehicleData(id, (pos.deepCopy)(), speed, dir, lowgrip) in return (vd)\n)\npublic static  public static IndicatorToString: (Indicator -\u003e seq of (char))\n\tIndicatorToString(i) \u003d\u003d\n(cases i :\n\u003cLEFT\u003e -\u003e \"LEFT\",\n\u003cRIGHT\u003e -\u003e \"RIGHT\",\n\u003cNONE\u003e -\u003e \"NONE\"\n end)\nprivate  mutex(Move)\nprivate  mutex(Move, SetPosition, GetPosition)\nprivate  mutex(SetPosition)\nprivate  mutex(SetDirection)\nprivate  mutex(GetDirection, SetDirection)\nprivate  mutex(SetSpeed)\nprivate  mutex(GetSpeed, SetSpeed)\nprivate  mutex(setLowGrip)\nprivate  mutex(getLowGrip, setLowGrip)\nprivate  mutex(setTurnIndicator)\nprivate  mutex(TurnIndicator, setTurnIndicator)\nend Vehicle\n","class VehicleData\nprivate  dir:Direction :\u003d (undefined)\nprivate  speed:nat :\u003d (undefined)\nprivate  lowgrip:bool :\u003d (undefined)\nprivate  turnIndicator:Indicator :\u003d \u003cNONE\u003e\nprivate  pos:Position :\u003d (undefined)\nprivate  id:nat :\u003d (undefined)\npublic static  Indicator \u003d Indicator\npublic  VehicleData(nat, Position, nat, Direction, bool) (nat * Position * nat * Direction * bool \u003d\u003d\u003e VehicleData)\n\tVehicleData(nat, Position, nat, Direction, bool)(identifier, p, s, d, grip) \u003d\u003d\n(\n\npos :\u003d p;\nspeed :\u003d s;\ndir :\u003d d;\nid :\u003d identifier;\nlowgrip :\u003d grip\n)\npublic  GetDirection() (() \u003d\u003d\u003e Direction)\n\tGetDirection()() \u003d\u003d\nreturn (dir)\npublic  GetSpeed() (() \u003d\u003d\u003e nat)\n\tGetSpeed()() \u003d\u003d\nreturn (speed)\npublic  getLowGrip() (() \u003d\u003d\u003e bool)\n\tgetLowGrip()() \u003d\u003d\n(\n\nreturn (lowgrip)\n)\npublic  TurnIndicator() (() \u003d\u003d\u003e Indicator)\n\tTurnIndicator()() \u003d\u003d\nreturn (turnIndicator)\npublic  GetPosition() (() \u003d\u003d\u003e Position)\n\tGetPosition()() \u003d\u003d\nreturn ((pos.deepCopy)())\npublic  GetID() (() \u003d\u003d\u003e nat)\n\tGetID()() \u003d\u003d\nreturn (id)\nend VehicleData\n","class World\npublic static  env:[Environment] :\u003d new Environment(\"inputvalues.txt\")\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nPrinter`OutAlways(\"Creating World\");\nVeMo`vemoCtrl.addController(VeMo`ctrl1);\nVeMo`vemoCtrl.addController(VeMo`ctrl2);\nVeMo`vemoCtrl.addController(VeMo`ctrl9);\nenv.setVeMoCtrl(VeMo`vemoCtrl);\nPrinter`OutAlways((\"World created: \" ^ \" Maybe this world is another planet\u0027s hell.\"));\nPrinter`OutAlways(\"------------------------------------------\n\")\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nenv.run();\nenv.isFinished();\nduration (1000) env.report();\nPrinter`OutWithTS(\"End of this world\")\n)\npublic static  Verbose(bool) (bool \u003d\u003d\u003e ())\n\tVerbose(bool)(v) \u003d\u003d\nPrinter`Echo(v)\nend World\n","class gui_Graphics\npublic  init() (() \u003d\u003d\u003e ())\n\tinit()() \u003d\u003d\nis not yet specified\npublic  sleep() (() \u003d\u003d\u003e ())\n\tsleep()() \u003d\u003d\nis not yet specified\npublic  addVehicle(int) (int \u003d\u003d\u003e ())\n\taddVehicle(int)(vecID) \u003d\u003d\nis not yet specified\npublic  connectVehicles(int, int) (int * int \u003d\u003d\u003e ())\n\tconnectVehicles(int, int)(vecID, vecID2) \u003d\u003d\nis not yet specified\npublic  disconnectVehicles(int, int) (int * int \u003d\u003d\u003e ())\n\tdisconnectVehicles(int, int)(vecID, vecID2) \u003d\u003d\nis not yet specified\npublic  updatePosition(int, int, int) (int * int * int \u003d\u003d\u003e ())\n\tupdatePosition(int, int, int)(vecID, x, y) \u003d\u003d\nis not yet specified\npublic  updateDirection(int, int) (int * int \u003d\u003d\u003e ())\n\tupdateDirection(int, int)(vecID, dir) \u003d\u003d\nis not yet specified\npublic  receivedMessage(int) (int \u003d\u003d\u003e ())\n\treceivedMessage(int)(vecID) \u003d\u003d\nis not yet specified\nend gui_Graphics\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n","class VDMUtil\npublic static  public static set2seq[(T)]: (set of (@T) +\u003e seq of (@T))\n\tset2seq(x) \u003d\u003d\nis not yet specified\npublic static  public static get_file_pos: (() +\u003e [(seq of (char) * nat * nat * seq of (char) * seq of (char))])\n\tget_file_pos() \u003d\u003d\nis not yet specified\npublic static  public static val2seq_of_char[(T)]: (@T +\u003e seq of (char))\n\tval2seq_of_char(x) \u003d\u003d\nis not yet specified\npublic static  public static seq_of_char2val[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tseq_of_char2val(s) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic static  public static classname[(T)]: (@T -\u003e [seq1 of (char)])\n\tclassname(s) \u003d\u003d\nis not yet specified\nend VDMUtil\n"]