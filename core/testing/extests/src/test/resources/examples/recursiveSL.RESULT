["max:nat \u003d 10","N \u003d N\n\tinv n \u003d\u003d (n \u003c max)","NPoint \u003d NPoint","NSeg \u003d NSeg\n\tinv mk_NSeg(ps) \u003d\u003d ((card ps) \u003d 2)","private SelPoints: (NSeg +\u003e (NPoint * NPoint))\n\tSelPoints(mk_NSeg(pts)) \u003d\u003d\nlet p in set pts in let q in set (pts \\ {p}) in mk_(p, q)","private Points: (NSeg +\u003e set of (NPoint))\n\tPoints(s) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in {mk_NPoint(x, y) | x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 let p:NPoint \u003d mk_NPoint(x, y) in (RatEq(Slope(p, p1), Slope(p2, p)) or ((p \u003d p1) or (p \u003d p2)))}","Rat \u003d Rat","private Slope: (NPoint * NPoint +\u003e Rat)\n\tSlope(mk_NPoint(x1, y1), mk_NPoint(x2, y2)) \u003d\u003d\nmk_((y2 - y1), (x2 - x1))","private RatEq: (Rat * Rat +\u003e bool)\n\tRatEq(mk_(x1, y1), mk_(x2, y2)) \u003d\u003d\n((x1 * y2) \u003d (x2 * y1))","private DiffX: (NPoint * NPoint +\u003e set of (N))\n\tDiffX(mk_NPoint(x1, -), mk_NPoint(x2, -)) \u003d\u003d\n(if (x1 \u003c x2)\nthen {x1, ... ,x2}\nelse {x2, ... ,x1})","private DiffY: (NPoint * NPoint +\u003e set of (N))\n\tDiffY(mk_NPoint(-, y1), mk_NPoint(-, y2)) \u003d\u003d\n(if (y1 \u003c y2)\nthen {y1, ... ,y2}\nelse {y2, ... ,y1})","private On: (NPoint * NSeg +\u003e bool)\n\tOn(p, s) \u003d\u003d\n(p in set Points(s))","private In: (NPoint * NSeg +\u003e bool)\n\tIn(p, s) \u003d\u003d\n(On(p, s) and (p not in set (s.pts)))","private Meet: (NSeg * NSeg +\u003e bool)\n\tMeet(mk_NSeg(pts1), mk_NSeg(pts2)) \u003d\u003d\n((card (pts1 inter pts2)) \u003d 1)","private Parallel: (NSeg * NSeg +\u003e bool)\n\tParallel(s, t) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s), mk_(p3, p4):(NPoint * NPoint) \u003d SelPoints(t) in (Slope(p1, p2) \u003d Slope(p3, p4))","private Overlap: (NSeg * NSeg +\u003e bool)\n\tOverlap(s1, s2) \u003d\u003d\n((card (Points(s1) inter Points(s2))) \u003e 1)","private Aligned: (NSeg * NSeg +\u003e bool)\n\tAligned(s1, s2) \u003d\u003d\n(Coliner(s1, s2) and (not Overlap(s1, s2)))","private Intersect: (NSeg * NSeg +\u003e bool)\n\tIntersect(s, t) \u003d\u003d\nlet mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d2:int \u003d ((b2 * a11) - (b1 * a21)), d:int \u003d ((a11 * a22) - (a12 * a21)) in ((d \u003c\u003e 0) and let l:real \u003d (d1 / d), m:real \u003d (d2 / d) in ((0 \u003c l) and ((l \u003c 1) and ((0 \u003c m) and (m \u003c 1)))))","private Coliner: (NSeg * NSeg +\u003e bool)\n\tColiner(s, t) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s), mk_(p3, p4):(NPoint * NPoint) \u003d SelPoints(t) in (RatEq(Slope(p1, p2), Slope(p3, p4)) and (RatEq(Slope(p1, p3), Slope(p1, p4)) or RatEq(Slope(p3, p1), Slope(p1, p4))))","private Disjoint: (NSeg * NSeg +\u003e bool)\n\tDisjoint(s1, s2) \u003d\u003d\n((s1 \u003c\u003e s2) and ((not Meet(s1, s2)) and (not Intersect(s1, s2))))","private Intersection: (NSeg * NSeg -\u003e NPoint)\n\tIntersection(s, t) \u003d\u003d\nlet mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d:int \u003d ((a11 * a22) - (a12 * a21)) in (if (d \u003c\u003e 0)\nthen let x0:int \u003d ((x11 * d) + (d1 * (x12 - x11))), y0:int \u003d ((y11 * d) + (d1 * (y12 - y11))) in mk_NPoint(RoundToN((abs x0), (abs d)), RoundToN((abs y0), (abs d)))\nelse (undefined))\n\tpre Intersect(s, t)","private RoundToN: (nat * nat +\u003e nat)\n\tRoundToN(a, b) \u003d\u003d\nlet mk_(z, aa):((int * int) | (nat * nat)) \u003d (if (a \u003e\u003d b)\nthen mk_((a div b), (a mod b))\nelse mk_(0, a)) in (if ((aa \u003d 0) or ((2 * aa) \u003c\u003d b))\nthen z\nelse (z + 1))","Realm \u003d Realm\n\tinv mk_Realm(ps, ss) \u003d\u003d ((forall mk_NSeg(pts) in set ss \u0026 (pts subset ps)) and ((forall s in set ss, p in set ps \u0026 (not In(p, s))) and (forall s1, s2 in set ss \u0026 ((s1 \u003c\u003e s2) \u003d\u003e ((not Intersect(s1, s2)) and (not Overlap(s1, s2)))))))","private InsertNPoint: (Realm * NPoint +\u003e Realm)\n\tInsertNPoint(mk_Realm(ps, ss), p) \u003d\u003d\n(if (p in set ps)\nthen mk_Realm(ps, ss)\nelseif (forall s in set ss \u0026 (p not in set E(s)))\nthen mk_Realm((ps union {p}), ss)\nelse let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 (p in set E(s))} in let ss1:set of (NSeg) \u003d (dunion {{mk_NSeg({p1, p}), mk_NSeg({p, p2})} | mk_NSeg({p1, p2}) in set s_env \u0026 (p not in set {p1, p2})}) in mk_Realm((ps union {p}), ((ss union ss1) \\ s_env)))\n\tpre (not (exists s in set ss \u0026 In(p, s)))","private InsertNSegment: (Realm * NSeg +\u003e Realm)\n\tInsertNSegment(mk_Realm(ps, ss), s) \u003d\u003d\n(if (s in set ss)\nthen mk_Realm(ps, ss)\nelseif ((forall p in set ps \u0026 (p not in set (E(s) \\ EndPoints(ss)))) and (forall t in set ss \u0026 ((not Intersect(s, t)) and (not Overlap(s, t)))))\nthen mk_Realm(ps, (ss union {s}))\nelse let p_env:set of (NPoint) \u003d ({p | p in set (ps inter E(s))} \\ EndPoints(ss)), s_inter:set of (NSeg) \u003d {t | t in set ss \u0026 Intersect(s, t)} in let ss1:set of (NSeg) \u003d ChopNPoints(p_env, {s}) in let mk_(new_ps, new_ss):(set of (NPoint) * set of (NSeg)) \u003d ChopNSegs(ss, s_inter, ss1, {}) in mk_Realm((ps union new_ps), new_ss))\n\tpre ((s.pts) subset ps)","private ChopNPoints: (set of (NPoint) * set of (NSeg) +\u003e set of (NSeg))\n\tChopNPoints(ps, ss) \u003d\u003d\n(if (ps \u003d {})\nthen ss\nelse let p in set ps in let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))} in let s in set s_env in let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in ChopNPoints((ps \\ {p}), ((ss \\ {s}) union {mk_NSeg({p1, p}), mk_NSeg({p2, p})})))\n\tpre (forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))))","private ChopNSegs: (set of (NSeg) * set of (NSeg) * set of (NSeg) * set of (NPoint) +\u003e (set of (NPoint) * set of (NSeg)))\n\tChopNSegs(ss, s_inter, newss, ps) \u003d\u003d\n(if (s_inter \u003d {})\nthen mk_(ps, (ss union newss))\nelse let t in set s_inter in let {s}:set of (NSeg) \u003d {s | s in set newss \u0026 Intersect(s, t)} in let p:NPoint \u003d Intersection(t, s) in let chop_s:set of (NSeg) \u003d {mk_NSeg({p, sp}) | sp in set (s.pts) \u0026 (p \u003c\u003e sp)}, chop_t:set of (NSeg) \u003d {mk_NSeg({p, tp}) | tp in set (t.pts) \u0026 (p \u003c\u003e tp)} in ChopNSegs(((ss \\ {t}) union chop_t), (s_inter \\ {t}), ((newss \\ {s}) union chop_s), (ps union {p})))","private E: (NSeg +\u003e set of (NPoint))\n\tE(s) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in {mk_NPoint(x, y) | x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 (((0 \u003c y) and ((y \u003c (max - 1)) and Intersect(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}), s))) or ((0 \u003c x) and ((x \u003c (max - 1)) and Intersect(mk_NSeg({mk_NPoint((x - 1), y), mk_NPoint((x + 1), y)}), s))))}","private EndPoints: (set of (NSeg) -\u003e set of (NPoint))\n\tEndPoints(ss) \u003d\u003d\n(dunion {pts | mk_NSeg(pts) in set ss})","private CycleCheck: (set of (NSeg) +\u003e bool)\n\tCycleCheck(ss) \u003d\u003d\n(exists sl in set AllLists(ss) \u0026 (forall i in set (inds sl) \u0026 (Meet(sl(i), sl((if (i \u003d (len sl))\nthen 1\nelse (i + 1)))) and (forall j in set ((inds sl) \\ {(if (i \u003d 1)\nthen (len sl)\nelse (i - 1)), i, (if (i \u003d (len sl))\nthen 1\nelse (i + 1))}) \u0026 (not Meet(sl(i), sl(j)))))))","private AllLists: (set of (NSeg) +\u003e set of (seq of (NSeg)))\n\tAllLists(ss) \u003d\u003d\n(cases ss :\n{} -\u003e {[]},\n{s} -\u003e {[s]}\nothers (dunion {{([s] ^ l) | l in set AllLists((ss \\ {s}))} | s in set ss})\n end)","Cycle \u003d Cycle\n\tinv ss \u003d\u003d CycleCheck(ss)","private OnCycle: (NPoint * Cycle +\u003e bool)\n\tOnCycle(p, c) \u003d\u003d\n(exists s in set c \u0026 On(p, s))","private InsideCycle: (NPoint * Cycle +\u003e bool)\n\tInsideCycle(p, c) \u003d\u003d\n((not OnCycle(p, c)) and IsOdd(((card SR(p, c)) + (card SI(p, c)))))","private OutsideCycle: (NPoint * Cycle +\u003e bool)\n\tOutsideCycle(p, c) \u003d\u003d\n(not (OnCycle(p, c) or InsideCycle(p, c)))","private SR: (NPoint * Cycle +\u003e set of (NSeg))\n\tSR(p, ss) \u003d\u003d\n{s | s in set ss \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in ((((p.y) \u003c (max - 1)) and ((not On(p1, SP(p))) and On(p2, SP(p)))) or (((p.y) \u003c (max - 1)) and ((not On(p2, SP(p))) and On(p1, SP(p)))))}\n\tpre CycleCheck(ss)","private SI: (NPoint * Cycle +\u003e set of (NSeg))\n\tSI(p, ss) \u003d\u003d\n{s | s in set ss \u0026 (((p.y) \u003c (max - 1)) and Intersect(s, SP(p)))}","private SP: (NPoint +\u003e NSeg)\n\tSP(mk_NPoint(x, y)) \u003d\u003d\nmk_NSeg({mk_NPoint(x, y), mk_NPoint(x, (max - 1))})\n\tpre (y \u003c (max - 1))","private IsOdd: (nat +\u003e bool)\n\tIsOdd(n) \u003d\u003d\n((n mod 2) \u003c\u003e 0)","private Partition: ((NPoint * set of (NSeg) -\u003e bool) * Cycle +\u003e set of (NPoint))\n\tPartition(pred, ss) \u003d\u003d\n{mk_NPoint(x, y) | x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 pred(mk_NPoint(x, y), ss)}","private P: (Cycle +\u003e set of (NPoint))\n\tP(ss) \u003d\u003d\n(Partition(OnCycle, ss) union Partition(InsideCycle, ss))","private AreaInside: (Cycle * Cycle +\u003e bool)\n\tAreaInside(c1, c2) \u003d\u003d\n(P(c1) subset P(c2))","private EdgeInside: (Cycle * Cycle +\u003e bool)\n\tEdgeInside(c1, c2) \u003d\u003d\n(AreaInside(c1, c2) and ((c1 inter c2) \u003d {}))","private VertexInside: (Cycle * Cycle +\u003e bool)\n\tVertexInside(c1, c2) \u003d\u003d\n(EdgeInside(c1, c2) and ((Partition(OnCycle, c1) inter Partition(OnCycle, c2)) \u003d {}))","private AreaDisjoint: (Cycle * Cycle +\u003e bool)\n\tAreaDisjoint(c1, c2) \u003d\u003d\n(((Partition(InsideCycle, c1) inter P(c2)) \u003d {}) and ((Partition(InsideCycle, c2) inter P(c1)) \u003d {}))","private EdgeDisjoint: (Cycle * Cycle +\u003e bool)\n\tEdgeDisjoint(c1, c2) \u003d\u003d\n(AreaDisjoint(c1, c2) and ((c1 inter c2) \u003d {}))","private VertexDisjoint: (Cycle * Cycle +\u003e bool)\n\tVertexDisjoint(c1, c2) \u003d\u003d\n((P(c1) inter P(c2)) \u003d {})","private AdjacentCycles: (Cycle * Cycle +\u003e bool)\n\tAdjacentCycles(c1, c2) \u003d\u003d\n(AreaDisjoint(c1, c2) and ((c1 inter c2) \u003c\u003e {}))","private MeetCycles: (Cycle * Cycle +\u003e bool)\n\tMeetCycles(c1, c2) \u003d\u003d\n(EdgeDisjoint(c1, c2) and ((Partition(OnCycle, c1) inter Partition(OnCycle, c2)) \u003c\u003e {}))","private SAreaInside: (NSeg * Cycle +\u003e bool)\n\tSAreaInside(s, c) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (PAreaInside(p1, c) and PAreaInside(p2, c))","private SEdgeInside: (NSeg * Cycle +\u003e bool)\n\tSEdgeInside(s, c) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in ((PAreaInside(p1, c) and PVertexInside(p2, c)) or (PAreaInside(p2, c) and PVertexInside(p1, c)))","private SVertexInside: (NSeg * Cycle +\u003e bool)\n\tSVertexInside(s, c) \u003d\u003d\nlet mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (PVertexInside(p1, c) and PVertexInside(p2, c))","private PAreaInside: (NPoint * Cycle +\u003e bool)\n\tPAreaInside(p, c) \u003d\u003d\n(p in set P(c))","private PVertexInside: (NPoint * Cycle +\u003e bool)\n\tPVertexInside(p, c) \u003d\u003d\n(p in set Partition(InsideCycle, c))","Face \u003d Face\n\tinv mk_Face(c, hs) \u003d\u003d ((forall h in set hs \u0026 EdgeInside(h, c)) and ((forall h1, h2 in set hs \u0026 ((h1 \u003c\u003e h2) \u003d\u003e EdgeDisjoint(h1, h2))) and (forall ss in set (power (c union (dunion hs))) \u0026 (CycleCheck(ss) \u003d\u003e (ss in set (hs union {c}))))))","private PAreaInsideF: (NPoint * Face +\u003e bool)\n\tPAreaInsideF(p, mk_Face(c, hs)) \u003d\u003d\n(PAreaInside(p, c) and (forall h in set hs \u0026 (not PVertexInside(p, h))))","private SAreaInsideF: (NSeg * Face +\u003e bool)\n\tSAreaInsideF(s, mk_Face(c, hs)) \u003d\u003d\n(SAreaInside(s, c) and (forall h in set hs \u0026 (not SEdgeInside(s, h))))","private FAreaInside: (Face * Face +\u003e bool)\n\tFAreaInside(mk_Face(c1, hs1), mk_Face(c2, hs2)) \u003d\u003d\n(AreaInside(c1, c2) and (forall h2 in set hs2 \u0026 (AreaDisjoint(h2, c1) or (exists h1 in set hs1 \u0026 AreaInside(h2, h1)))))","private FAreaDisjoint: (Face * Face +\u003e bool)\n\tFAreaDisjoint(mk_Face(c1, hs1), mk_Face(c2, hs2)) \u003d\u003d\n(AreaDisjoint(c1, c2) or ((exists h2 in set hs2 \u0026 AreaInside(c1, h2)) or (exists h1 in set hs1 \u0026 AreaInside(c2, h1))))","private FEdgeDisjoint: (Face * Face +\u003e bool)\n\tFEdgeDisjoint(mk_Face(c1, hs1), mk_Face(c2, hs2)) \u003d\u003d\n(EdgeDisjoint(c1, c2) or ((exists h2 in set hs2 \u0026 EdgeInside(c1, h2)) or (exists h1 in set hs1 \u0026 EdgeInside(c2, h1))))","p1:NPoint \u003d mk_REALM`NPoint(1, 1)","p2:NPoint \u003d mk_REALM`NPoint(5, 3)","p3:NPoint \u003d mk_REALM`NPoint(1, 9)","p4:NPoint \u003d mk_REALM`NPoint(2, 3)","p5:NPoint \u003d mk_REALM`NPoint(9, 5)","p6:NPoint \u003d mk_REALM`NPoint(6, 9)","p7:NPoint \u003d mk_REALM`NPoint(4, 5)","p8:NPoint \u003d mk_REALM`NPoint(4, 6)","p9:NPoint \u003d mk_REALM`NPoint(1, 6)","p10:NPoint \u003d mk_REALM`NPoint(5, 0)","p11:NPoint \u003d mk_REALM`NPoint(5, 1)","p12:NPoint \u003d mk_REALM`NPoint(6, 0)","p13:NPoint \u003d mk_REALM`NPoint(6, 1)","s1:NSeg \u003d mk_REALM`NSeg({p1, p2})","s2:NSeg \u003d mk_REALM`NSeg({p1, p3})","s3:NSeg \u003d mk_REALM`NSeg({p2, p4})","s4:NSeg \u003d mk_REALM`NSeg({p4, p3})","s5:NSeg \u003d mk_REALM`NSeg({p3, p2})","s6:NSeg \u003d mk_REALM`NSeg({p5, p4})","s7:NSeg \u003d mk_REALM`NSeg({p6, p1})","s8:NSeg \u003d mk_REALM`NSeg({p5, p3})","s9:NSeg \u003d mk_REALM`NSeg({p5, p7})","s10:NSeg \u003d mk_REALM`NSeg({p9, p3})","s11:NSeg \u003d mk_REALM`NSeg({p10, p8})","s12:NSeg \u003d mk_REALM`NSeg({p1, p5})","s13:NSeg \u003d mk_REALM`NSeg({p10, p13})","s14:NSeg \u003d mk_REALM`NSeg({p11, p12})","r1:Realm \u003d mk_REALM`Realm({p1, p2}, {s1})","r2:Realm \u003d mk_REALM`Realm({p5, p4}, {s6})","r3:Realm \u003d mk_REALM`Realm({p5, p4, p3}, {s6, s8})","r4:Realm \u003d mk_REALM`Realm({p1, p3, p4, p5, p6, p7, p8}, {s6, s8})","r5:Realm \u003d mk_REALM`Realm({p10, p13}, {s13})"]