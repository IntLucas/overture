["class AutomatedStockBroker is subclass of [GLOBAL]\nprivate  stocks:seq of (StockRecord) :\u003d (undefined)\nprivate  stockWatchers:map (StockIdentifier) to (StockWatcher) :\u003d (undefined)\nprivate  actionLog:seq of (ActionEvent) :\u003d []\nprivate  balance:int :\u003d (undefined)\nprivate  inv(balance \u003e\u003d 0)\nprivate  inv(forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))\nprivate  invlet stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))\nprivate  invMaxOneOfEachActionTypePerTime(actionLog)\npublic  AutomatedStockBroker(nat) (nat \u003d\u003d\u003e AutomatedStockBroker)\n\tAutomatedStockBroker(nat)(startCash) \u003d\u003d\n(\n\nbalance :\u003d startCash;\nstocks :\u003d [];\nstockWatchers :\u003d {|-\u003e}\n)\npublic  AddStock(StockRecord, nat1) (StockRecord * nat1 \u003d\u003d\u003e ())\n\tAddStock(StockRecord, nat1)(sRecord, priority) \u003d\u003d\n(\n\nstocks :\u003d (((stocks(1, ... ,(priority - 1))) ^ [sRecord]) ^ (stocks((priority + 1), ... ,(len stocks))));\nif World`simulate\nthen\nstockWatchers((sRecord.Name)) :\u003d new StockWatcher(sRecord)else\nstockWatchers((sRecord.Name)) :\u003d new StockWatcher(sRecord, testValues((sRecord.Name)))\n)\n\tpre ((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)})\n\tpost (((sRecord.Name) in set (dom stockWatchers)) and (sRecord \u003d stocks(priority)))\npublic  GetActionLog() (() \u003d\u003d\u003e seq of (ActionEvent))\n\tGetActionLog()() \u003d\u003d\nreturn (actionLog)\npublic  GetStocksWithActiveActionTrigger(StockState) (StockState \u003d\u003d\u003e seq of (StockRecord))\n\tGetStocksWithActiveActionTrigger(StockState)(ss) \u003d\u003d\nreturn ([stocks(s) | s in set (inds stocks) \u0026 (((stockWatchers((stocks(s).Name)).GetTriggeredAction)() \u003c\u003e nil) and ((stocks(s).State) \u003d ss))])\n\tpost let res:seq of (StockRecord) \u003d RESULT in (forall i in set (inds res) \u0026 ((res(i).State) \u003d ss))\nprivate  FindValidBuy(seq of (StockRecord), nat) (seq of (StockRecord) * nat \u003d\u003d\u003e [StockRecord])\n\tFindValidBuy(seq of (StockRecord), nat)(potBuys, time) \u003d\u003d\nreturn (let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (if ((len affordableStocks) \u003e 0)\nthen let x in set (inds affordableStocks) be st (forall y in set (inds affordableStocks) \u0026 ((stockWatchers((affordableStocks(x).Name)).GetStockValue)(time) \u003e\u003d (stockWatchers((affordableStocks(y).Name)).GetStockValue)(time))) in affordableStocks(x)\nelse nil))\nprivate  FindValidSell(seq of (StockRecord), nat) (seq of (StockRecord) * nat \u003d\u003d\u003e StockRecord)\n\tFindValidSell(seq of (StockRecord), nat)(potSells, time) \u003d\u003d\nreturn (let x in set (inds potSells) be st (forall y in set (inds potSells) \u0026 (((stockWatchers((potSells(x).Name)).GetStockValue)(time) - (potSells(x).Cost)) \u003e\u003d ((stockWatchers((potSells(y).Name)).GetStockValue)(time) - (potSells(y).Cost)))) in potSells(x))\n\tpre ((len potSells) \u003e 0)\n\tpost IsGTAll(((stockWatchers((RESULT.Name)).GetStockValue)(time) - (RESULT.Cost)), {((stockWatchers((x.Name)).GetStockValue)(time) - (x.Cost)) | x in set (elems potSells)})\nprivate  PerformBuy(StockRecord, nat) (StockRecord * nat \u003d\u003d\u003e ())\n\tPerformBuy(StockRecord, nat)(potAction, time) \u003d\u003d\nlet sw:StockWatcher \u003d stockWatchers((potAction.Name)), value:StockValue \u003d (sw.GetStockValue)(time) in (\n\nactionLog :\u003d ([mk_ActionEvent(\u003cBuy\u003e, time, (potAction.Name), value)] ^ actionLog);\nbalance :\u003d (balance - value);\nlet i in set (inds stocks) be st ((stocks(i).Name) \u003d (potAction.Name)) in (\n\nstocks(i) :\u003d mu(potAction, State |-\u003e \u003cBought\u003e, Cost |-\u003e value);\nsw.updateStockRecord(stocks(i))\n)\n)\n\tpre (((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e))\n\tpost (balance \u003e\u003d 0)\nprivate  PerformSell(StockRecord, nat) (StockRecord * nat \u003d\u003d\u003e ())\n\tPerformSell(StockRecord, nat)(potAction, time) \u003d\u003d\nlet sw:StockWatcher \u003d stockWatchers((potAction.Name)), value:StockValue \u003d (sw.GetStockValue)(time) in (\n\nactionLog :\u003d ([mk_ActionEvent(\u003cSell\u003e, time, (potAction.Name), value)] ^ actionLog);\nbalance :\u003d (balance + value);\nlet i in set (inds stocks) be st ((stocks(i).Name) \u003d (potAction.Name)) in (\n\nstocks(i) :\u003d mu(potAction, State |-\u003e \u003cPotentialBuy\u003e, Cost |-\u003e 0);\nsw.updateStockRecord(stocks(i))\n)\n)\n\tpre (((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e))\n\tpost (balance \u003e\u003d 0)\nprivate  ObserveAllStocks(nat) (nat \u003d\u003d\u003e ())\n\tObserveAllStocks(nat)(time) \u003d\u003d\nfor all i in set (inds stocks) do\nlet stock:StockRecord \u003d stocks(i), csw:StockWatcher \u003d stockWatchers((stock.Name)) in csw.ObserveStock(time)\npublic  Step(nat) (nat \u003d\u003d\u003e ())\n\tStep(nat)(time) \u003d\u003d\n(\n\nObserveAllStocks(time);\nlet potBuys:seq of (StockRecord) \u003d GetStocksWithActiveActionTrigger(\u003cPotentialBuy\u003e), potSells:seq of (StockRecord) \u003d GetStocksWithActiveActionTrigger(\u003cBought\u003e), validBuy:[StockRecord] \u003d FindValidBuy(potBuys, time) in (\n\nif ((len potSells) \u003e 0)\nthen\n(\n\nPerformSell(FindValidSell(potSells, time), time)\n)else\nskip;\nIO`print(\"\npot sels : \");\nIO`print(potSells);\nif (validBuy \u003c\u003e nil)\nthen\n(\n\nPerformBuy(validBuy, time)\n)else\nskip;\nIO`print(\"\npot buys : \");\nIO`print(potBuys)\n);\nIO`print(\"\n\");\nIO`print(\"Finished step : \");\nIO`print(time);\nIO`print(\" with actionLog : \");\nIO`print(actionLog);\nIO`print(\" and Balance : \");\nIO`print(balance);\nIO`print(\"\n\")\n)\n\tpost MaxOneOfEachActionTypePerTime(actionLog)\nprivate  private IsGTAll: (int * set of (int) -\u003e bool)\n\tIsGTAll(sv, ssv) \u003d\u003d\n(forall i in set ssv \u0026 (sv \u003e\u003d i))\nprivate  private CanAfford: (StockRecord * nat -\u003e bool)\n\tCanAfford(sr, balance) \u003d\u003d\n((sr.Cost) \u003c\u003d balance)\nprivate  private MaxOneOfEachActionTypePerTime: (seq of (ActionEvent) -\u003e bool)\n\tMaxOneOfEachActionTypePerTime(actionLog) \u003d\u003d\n(forall x, y in set (inds actionLog) \u0026 (((x \u003c\u003e y) and ((actionLog(x).Time) \u003d (actionLog(y).Time))) \u003d\u003e ((actionLog(x).Type) \u003c\u003e (actionLog(y).Type))))\nend AutomatedStockBroker\n","class GLOBAL\npublic static  String \u003d String\npublic static  EventType \u003d EventType\npublic static  StockState \u003d StockState\npublic static  Event \u003d Event\npublic static  Region \u003d Region\n\tinv mk_Region(p1, p2) \u003d\u003d (p1 \u003e\u003d p2)\npublic static  StockValue \u003d StockValue\npublic static  StockIdentifier \u003d StockIdentifier\npublic static  ActionType \u003d ActionType\npublic static  ActionTrigger \u003d ActionTrigger\npublic static  StockRecord \u003d StockRecord\n\tinv mk_StockRecord(p1, p2, p3, p4, p5) \u003d\u003d (((p2(\u003cPotentialBuy\u003e).Action) \u003d \u003cBuy\u003e) and ((p2(\u003cBought\u003e).Action) \u003d \u003cSell\u003e))\npublic static  ActionEvent \u003d ActionEvent\npublic static  testValues:map (StockIdentifier) to (seq of (Event)) \u003d {mk_token(\"test\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cLowerLimit\u003e, 5, 8), mk_Event(\u003cUpperLimit\u003e, 4, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 13), mk_Event(\u003cUpperLimit\u003e, 1, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)], mk_token(\"test12\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cLowerLimit\u003e, 5, 8), mk_Event(\u003cUpperLimit\u003e, 4, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 16), mk_Event(\u003cUpperLimit\u003e, 1, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)], mk_token(\"test2\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cUpperLimit\u003e, 5, 8), mk_Event(\u003cLowerLimit\u003e, 4, 8), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 6), mk_Event(\u003cLowerLimit\u003e, 1, 8), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)]}\nend GLOBAL\n","class Stock is subclass of [GLOBAL]\npublic static  RateOfChange \u003d RateOfChange\nprivate  name:StockIdentifier :\u003d (undefined)\nprivate  valueHistory:seq of (StockValue) :\u003d (undefined)\nprivate  currentRateOfChange:[RateOfChange] :\u003d (undefined)\npublic  Stock(StockIdentifier, StockValue) (StockIdentifier * StockValue \u003d\u003d\u003e Stock)\n\tStock(StockIdentifier, StockValue)(n, startValue) \u003d\u003d\n(\n\nvalueHistory :\u003d [];\nvalueHistory :\u003d ([startValue] ^ valueHistory);\nname :\u003d n;\ncurrentRateOfChange :\u003d nil\n)\npublic  UpdateStock() (() \u003d\u003d\u003e ())\n\tUpdateStock()() \u003d\u003d\n(\n\ncurrentRateOfChange :\u003d (cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end);\ncases currentRateOfChange :\n  \u003cpositive\u003e -\u003e valueHistory :\u003d ([((hd valueHistory) + 1)] ^ valueHistory)  \u003cnegative\u003e -\u003e valueHistory :\u003d ([((hd valueHistory) - 1)] ^ valueHistory)  \u003cconstant\u003e -\u003e valueHistory :\u003d ([(hd valueHistory)] ^ valueHistory) end\n)\n\tpre ((len valueHistory) \u003e\u003d 1)\n\tpost (((currentRateOfChange \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) and (((currentRateOfChange \u003d \u003cnegative\u003e) \u003d\u003e (valueHistory(1) \u003c valueHistory(2))) and (((currentRateOfChange \u003d \u003cconstant\u003e) \u003d\u003e (valueHistory(1) \u003d valueHistory(2))) and ((hd valueHistory) \u003e\u003d 0))))\npublic  GetName() (() \u003d\u003d\u003e StockIdentifier)\n\tGetName()() \u003d\u003d\nreturn (name)\npublic  GetCurrentValue() (() \u003d\u003d\u003e StockValue)\n\tGetCurrentValue()() \u003d\u003d\nreturn ((hd valueHistory))\npublic  GetValueHistory() (() \u003d\u003d\u003e seq of (StockValue))\n\tGetValueHistory()() \u003d\u003d\n(\n\nreturn (valueHistory)\n)\nprivate  private InitialRateOfChange: (StockValue -\u003e RateOfChange)\n\tInitialRateOfChange(sv) \u003d\u003d\nlet r:int \u003d (MATH`rand(21) mod 3) in (if (sv \u003e 0)\nthen (cases r :\n0 -\u003e \u003cpositive\u003e,\n1 -\u003e \u003cnegative\u003e,\n2 -\u003e \u003cconstant\u003e\n end)\nelse (cases r :\n0 -\u003e \u003cpositive\u003e,\n1 -\u003e \u003cpositive\u003e,\n2 -\u003e \u003cconstant\u003e\n end))\nprivate  private NextRateOfChange: (RateOfChange * StockValue -\u003e RateOfChange)\n\tNextRateOfChange(roc, sv) \u003d\u003d\nlet r:int \u003d MATH`rand(10), other:seq of (RateOfChange) \u003d MakelistFromSet({x | x:RateOfChange \u0026 ((x \u003c\u003e roc) and ((x \u003d \u003cnegative\u003e) \u003d\u003e (sv \u003e 0)))}) in (if ((r \u003e\u003d 0) and ((r \u003c\u003d 7) and ((roc \u003d \u003cnegative\u003e) \u003d\u003e (sv \u003e 0))))\nthen roc\nelse other(((MATH`rand(20) mod (len other)) + 1)))\nprivate  private MakelistFromSet: (set of (RateOfChange) -\u003e seq of (RateOfChange))\n\tMakelistFromSet(roc) \u003d\u003d\n(if ((card roc) \u003e 0)\nthen let r in set roc in ([r] ^ MakelistFromSet((roc \\ {r})))\nelse [])\nend Stock\n","class StockMarket is subclass of [GLOBAL]\nprivate  stocks:map (StockIdentifier) to (Stock) :\u003d {|-\u003e}\npublic  UpdateStocks() (() \u003d\u003d\u003e ())\n\tUpdateStocks()() \u003d\u003d\nfor all stock in set (rng stocks) do\nstock.UpdateStock()\npublic  AddStock(Stock) (Stock \u003d\u003d\u003e ())\n\tAddStock(Stock)(stock) \u003d\u003d\nstocks :\u003d ({(stock.GetName)() |-\u003e stock} munion stocks)\n\tpre ((stock.GetName)() not in set (dom stocks))\n\tpost ((stock.GetName)() in set (dom stocks))\npublic  RemoveStock(Stock) (Stock \u003d\u003d\u003e ())\n\tRemoveStock(Stock)(stock) \u003d\u003d\nstocks :\u003d ({(stock.GetName)()} \u003c-: stocks)\n\tpre ((stock.GetName)() in set (dom stocks))\n\tpost ((stock.GetName)() not in set (dom stocks))\npublic  GetStock(StockIdentifier) (StockIdentifier \u003d\u003d\u003e Stock)\n\tGetStock(StockIdentifier)(name) \u003d\u003d\nreturn (stocks(name))\n\tpre (name in set (dom stocks))\npublic  GetStockNames() (() \u003d\u003d\u003e set of (StockIdentifier))\n\tGetStockNames()() \u003d\u003d\nreturn ((dom stocks))\nend StockMarket\n","class StockWatcher is subclass of [GLOBAL]\nprivate  eventHistory:seq of (Event) :\u003d (undefined)\nprivate  stockRecord:StockRecord :\u003d (undefined)\nprivate  sm:[StockMarket] :\u003d (undefined)\nprivate  currentlyTriggeredAction:[ActionType] :\u003d (undefined)\nprivate  inv(((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))\npublic  StockWatcher(StockRecord, seq of (Event)) (StockRecord * seq of (Event) \u003d\u003d\u003e StockWatcher)\n\tStockWatcher(StockRecord, seq of (Event))(sr, predefinedEvents) \u003d\u003d\n(\n\neventHistory :\u003d predefinedEvents;\nsm :\u003d nil;\nstockRecord :\u003d sr;\ncurrentlyTriggeredAction :\u003d nil\n)\n\tpre let val:nat \u003d (predefinedEvents((len predefinedEvents)).Value) in IsInRegion(val, (sr.NoActionReg))\npublic  StockWatcher(StockRecord) (StockRecord \u003d\u003d\u003e StockWatcher)\n\tStockWatcher(StockRecord)(sr) \u003d\u003d\n(\n\nsm :\u003d World`stockMarket;\nstockRecord :\u003d sr;\neventHistory :\u003d [mk_Event(\u003cEntersNoActionRegion\u003e, 0, ((sm.GetStock)((stockRecord.Name)).GetCurrentValue)())];\ncurrentlyTriggeredAction :\u003d nil\n)\n\tpre (((sr.Name) in set (World`stockMarket.GetStockNames)()) and let val:StockValue \u003d ((World`stockMarket.GetStock)((sr.Name)).GetCurrentValue)() in IsInRegion(val, (sr.NoActionReg)))\nprivate  UpdateEvents(nat) (nat \u003d\u003d\u003e ())\n\tUpdateEvents(nat)(time) \u003d\u003d\nlet stock:Stock \u003d (sm.GetStock)((stockRecord.Name)) in let stockHistory:seq of (StockValue) \u003d (stock.GetValueHistory)(), reg:Region \u003d (stockRecord.NoActionReg), l:StockValue \u003d (reg.LowerValue), u:StockValue \u003d (reg.UpperValue), cv:StockValue \u003d (stock.GetCurrentValue)() in (\n\nif (IsInRegion((hd stockHistory), reg) and (not IsInRegion(stockHistory(2), reg)))\nthen\neventHistory :\u003d ([mk_Event(\u003cEntersNoActionRegion\u003e, time, cv)] ^ eventHistory)elseif ((not IsInRegion((hd stockHistory), reg)) and IsInRegion(stockHistory(2), reg))\nthen\neventHistory :\u003d ([mk_Event(\u003cLeavesNoActionRegion\u003e, time, cv)] ^ eventHistory);\nif (((hd stockHistory) \u003d u) and (stockHistory(2) \u003c\u003e u))\nthen\neventHistory :\u003d ([mk_Event(\u003cUpperLimit\u003e, time, cv)] ^ eventHistory)elseif (((hd stockHistory) \u003d l) and (stockHistory(2) \u003c\u003e l))\nthen\neventHistory :\u003d ([mk_Event(\u003cLowerLimit\u003e, time, cv)] ^ eventHistory)elseif ((not IsInRegion((hd stockHistory), reg)) and IsPeak(stockHistory))\nthen\neventHistory :\u003d ([mk_Event(\u003cPeak\u003e, time, cv)] ^ eventHistory)elseif ((not IsInRegion((hd stockHistory), reg)) and IsValley(stockHistory))\nthen\neventHistory :\u003d ([mk_Event(\u003cValley\u003e, time, cv)] ^ eventHistory);\nIO`print(eventHistory)\n)\n\tpre let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2)\n\tpost (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))\nprivate  UpdateAction(nat) (nat \u003d\u003d\u003e ())\n\tUpdateAction(nat)(tim) \u003d\u003d\nlet actionTrigger:ActionTrigger \u003d (stockRecord.Triggers)((stockRecord.State)) in currentlyTriggeredAction :\u003d (if (IsActionTriggeredAtTime(tim, actionTrigger, eventHistory) and (not IsInRegion(GetStockValue(tim), (stockRecord.NoActionReg))))\nthen (actionTrigger.Action)\nelse nil)\npublic  ObserveStock(nat) (nat \u003d\u003d\u003e ())\n\tObserveStock(nat)(time) \u003d\u003d\n(\n\nif World`simulate\nthen\n(\n\nUpdateEvents(time)\n)else\nskip;\nUpdateAction(time)\n)\n\tpost NoActiveTriggerInNoActionRegion(GetStockValue(time), (stockRecord.NoActionReg), currentlyTriggeredAction)\npublic  updateStockRecord(StockRecord) (StockRecord \u003d\u003d\u003e ())\n\tupdateStockRecord(StockRecord)(sr) \u003d\u003d\nstockRecord :\u003d sr\npublic  GetStockValue(nat) (nat \u003d\u003d\u003e StockValue)\n\tGetStockValue(nat)(time) \u003d\u003d\nif World`simulate\nthen\nreturn ((eventHistory(1).Value))else\nreturn ((eventHistory(((len eventHistory) - time)).Value))\n\tpre ((len eventHistory) \u003e 0)\npublic  GetTriggeredAction() (() \u003d\u003d\u003e [ActionType])\n\tGetTriggeredAction()() \u003d\u003d\nreturn (currentlyTriggeredAction)\nprivate  private NoActiveTriggerInNoActionRegion: (StockValue * Region * [ActionType] -\u003e bool)\n\tNoActiveTriggerInNoActionRegion(sv, reg, at) \u003d\u003d\n(IsInRegion(sv, reg) \u003d\u003e (at \u003d nil))\nprivate  private IsInRegion: (StockValue * Region -\u003e bool)\n\tIsInRegion(sv, reg) \u003d\u003d\nlet u:StockValue \u003d (reg.UpperValue), l:StockValue \u003d (reg.LowerValue) in ((sv \u003e\u003d l) and (sv \u003c\u003d u))\nprivate  private IsPeak: (seq of (StockValue) -\u003e bool)\n\tIsPeak(svs) \u003d\u003d\nlet current:StockValue \u003d (hd svs) in let indicesOneAbove:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current + 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (exists i in set indicesOneAbove \u0026 (forall v in set {2, ... ,i} \u0026 (((current + 1) \u003d svs(v)) and (svs((i + 1)) \u003d current))))\nprivate  private IsValley: (seq of (StockValue) -\u003e bool)\n\tIsValley(svs) \u003d\u003d\nlet current:StockValue \u003d (hd svs) in let indicesOneBelow:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current - 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (exists i in set indicesOneBelow \u0026 (forall v in set {2, ... ,i} \u0026 (((current - 1) \u003d svs(v)) and (svs((i + 1)) \u003d current))))\nprivate  private FindLowestIndexFromTime: (nat * seq of (Event) -\u003e nat1)\n\tFindLowestIndexFromTime(time, events) \u003d\u003d\nlet pastEvents:set of (nat1) \u003d {x | x in set (inds events) \u0026 ((events(x).TimeStamp) \u003c\u003d time)} in let i, j in set pastEvents be st ((i \u003c\u003e j) \u003d\u003e ((events(i).TimeStamp) \u003c\u003d (events(j).TimeStamp))) in i\npublic  public IsActionTriggeredAtTime: (nat * ActionTrigger * seq of (Event) -\u003e bool)\n\tIsActionTriggeredAtTime(time, action, eventHistory) \u003d\u003d\nlet tgr:seq of (EventType) \u003d (action.Trigger) in let index:nat1 \u003d FindLowestIndexFromTime(time, eventHistory), s:seq of (Event) \u003d (eventHistory(index, ... ,((index + (len tgr)) - 1))) in ((forall i in set (inds s) \u0026 ((s(i).Type) \u003d tgr(i))) and (((s(1).TimeStamp) \u003d time) and ((len s) \u003d (len tgr))))\nend StockWatcher\n","class World is subclass of [GLOBAL]\nprivate static  simTime:nat \u003d 100\nprivate static  actionsLimit:nat \u003d 4\nprivate static  startCash:nat \u003d 100\npublic static  simulate:bool \u003d false\npublic static  timerRef:Timer :\u003d new Timer()\npublic static  stockMarket:StockMarket :\u003d new StockMarket()\nprivate  asb:AutomatedStockBroker :\u003d new AutomatedStockBroker(startCash)\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn (((not ((len (asb.GetActionLog)()) \u003c actionsLimit)) or (not ((timerRef.GetTime)() \u003c\u003d simTime))))\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nstockMarket.AddStock(new Stock(mk_token(\"test\"), 10));\nstockMarket.AddStock(new Stock(mk_token(\"test12\"), 10));\nstockMarket.AddStock(new Stock(mk_token(\"test2\"), 10));\n(\nr1:StockRecord :\u003d mk_StockRecord(mk_token(\"test\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 10, \u003cBought\u003e)\nr2:StockRecord :\u003d mk_StockRecord(mk_token(\"test12\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 10, \u003cBought\u003e)\nr3:StockRecord :\u003d mk_StockRecord(mk_token(\"test2\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 0, \u003cPotentialBuy\u003e)\n\nasb.AddStock(r1, 1);\nasb.AddStock(r2, 2);\nasb.AddStock(r3, 3);\nwhile (not isFinished()) do (\n\nIO`print(\"step : \");\nIO`print((timerRef.GetTime)());\nIO`print(\"\n\");\nstockMarket.UpdateStocks();\nasb.Step((timerRef.GetTime)());\ntimerRef.StepTime()\n)\n)\n)\npublic  public FindSmallestSeqLen: (map (String) to (seq of (Event)) -\u003e nat)\n\tFindSmallestSeqLen(m) \u003d\u003d\nlet x, y in set {(len m(x)) | x in set (dom m)} be st ((x \u003c\u003e y) \u003d\u003e (x \u003c\u003d y)) in x\nend World\n","class Timer\nprivate  currentTime:nat :\u003d 1\nprivate static  stepLength:nat \u003d 1\npublic  StepTime() (() \u003d\u003d\u003e ())\n\tStepTime()() \u003d\u003d\ncurrentTime :\u003d (currentTime + stepLength)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nend Timer\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n"]