["HAInputs \u003d HAInputs","HAInput \u003d HAInput","Change \u003d Change","TargetTemp \u003d TargetTemp\n\tinv num \u003d\u003d (num \u003c\u003d 100)","CurrentTemp \u003d CurrentTemp\n\tinv num \u003d\u003d (num \u003c\u003d 100)","TargetHumid \u003d TargetHumid\n\tinv num \u003d\u003d (num \u003c\u003d 100)","CurrentHumid \u003d CurrentHumid\n\tinv num \u003d\u003d (num \u003c\u003d 100)","HAOut \u003d HAOut","OutStep \u003d OutStep","AbsTime \u003d AbsTime","EnvManipulation \u003d EnvManipulation","TempChangeDuration:nat \u003d 2","HumidChangeDuration:nat \u003d 4","StepLength:nat \u003d 1","private HomeAutomation: (HAInputs -\u003e HAOut)\n\tHomeAutomation(haInputs) \u003d\u003d\nHA(haInputs, [], 0)","private HA: (HAInputs * HAOut * nat -\u003e HAOut)\n\tHA(haInputs, outputSoFar, curTime) \u003d\u003d\n(if (haInputs \u003d [])\nthen outputSoFar\nelse let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid):HAInput \u003d (hd haInputs), rest:HAInputs \u003d (tl haInputs), nextTime:nat \u003d (curTime + StepLength) in (if (outputSoFar \u003c\u003e [])\nthen let mk_(-, timeOfLastInput):OutStep \u003d outputSoFar((len outputSoFar)) in (if ((curTime \u003c\u003d timeOfLastInput) and change)\nthen let interruptedOutput:seq of (OutStep) \u003d InterruptOutput(outputSoFar, curTime), newOutput:seq of (OutStep) \u003d CounterOutput(interruptedOutput, curTime) in HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, newOutput), nextTime)\nelse ChangeHA(haInputs, outputSoFar, curTime))\nelse ChangeHA(haInputs, outputSoFar, curTime)))","private ChangeHA: (HAInputs * HAOut * AbsTime -\u003e HAOut)\n\tChangeHA(haInputs, outputSoFar, curTime) \u003d\u003d\nlet mk_(change, targetTemp, currentTemp, targetHumid, currentHumid):HAInput \u003d (hd haInputs), rest:HAInputs \u003d (tl haInputs), nextTime:nat \u003d (curTime + StepLength) in (if change\nthen HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, outputSoFar), nextTime)\nelse HA(rest, outputSoFar, nextTime))","private AddOutput: (nat * nat * nat * nat * nat * seq of (OutStep) -\u003e seq of (OutStep))\n\tAddOutput(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) \u003d\u003d\n(if (targetHumid \u003c\u003e curHumid)\nthen HumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar)\nelseif (targetTemp \u003c\u003e curTemp)\nthen TempChanged(targetTemp, curTemp, curTime, outputSoFar)\nelse outputSoFar)","private TempChanged: (nat * nat * nat * seq of (OutStep) -\u003e seq of (OutStep))\n\tTempChanged(targetTemp, curTemp, curTime, outputSoFar) \u003d\u003d\nlet nextTime:nat \u003d (curTime + ((abs (curTemp - targetTemp)) * TempChangeDuration)), action:(\u003cDecTemp\u003e | \u003cIncTemp\u003e) \u003d (if (curTemp \u003e targetTemp)\nthen \u003cDecTemp\u003e\nelse \u003cIncTemp\u003e) in ((outputSoFar ^ [mk_(action, curTime)]) ^ [mk_(\u003cLeaveTemp\u003e, nextTime)])","private HumidChanged: (nat * nat * nat * nat * nat * seq of (OutStep) -\u003e seq of (OutStep))\n\tHumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) \u003d\u003d\nlet tempChanged:real \u003d (((curHumid - targetHumid) * HumidChangeDuration) / TempChangeDuration), action:(\u003cDecTemp\u003e | \u003cIncTemp\u003e) \u003d (if ((curTemp - tempChanged) \u003e targetTemp)\nthen \u003cDecTemp\u003e\nelse \u003cIncTemp\u003e), timeChange:int \u003d (curTime + ((curHumid - targetHumid) * HumidChangeDuration)) in ((outputSoFar ^ [mk_(\u003cOpenWindow\u003e, curTime)]) ^ (if ((curTemp - tempChanged) \u003c\u003e targetTemp)\nthen [mk_(\u003cCloseWindow\u003e, timeChange), mk_(action, timeChange), mk_(\u003cLeaveTemp\u003e, (timeChange + (((abs (curTemp - targetTemp)) - tempChanged) * TempChangeDuration)))]\nelse [mk_(\u003cCloseWindow\u003e, timeChange)]))","private InterruptOutput: (seq of (OutStep) * nat -\u003e seq of (OutStep))\n\tInterruptOutput(output, curTime) \u003d\u003d\n[output(i) | i in set (inds output) \u0026 let mk_(-, t):OutStep \u003d output(i) in (t \u003c\u003d curTime)]","private CounterOutput: (seq of (OutStep) * nat -\u003e seq of (OutStep))\n\tCounterOutput(output, curTime) \u003d\u003d\nlet mk_(lastOutput, -):OutStep \u003d output((len output)) in (if (lastOutput \u003d \u003cOpenWindow\u003e)\nthen (output ^ [mk_(\u003cCloseWindow\u003e, curTime)])\nelseif ((lastOutput \u003d \u003cIncTemp\u003e) or (lastOutput \u003d \u003cDecTemp\u003e))\nthen (output ^ [mk_(\u003cLeaveTemp\u003e, curTime)])\nelse output)"]