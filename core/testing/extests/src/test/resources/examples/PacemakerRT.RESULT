["class AirSpace is subclass of [GLOBAL]\nprivate  airspace:map (FOId) to (FO) :\u003d {|-\u003e}\nprivate  inv(forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)())))\npublic  addFO(FO) (FO \u003d\u003d\u003e ())\n\taddFO(FO)(fo) \u003d\u003d\n(\n\nairspace :\u003d (airspace munion {(fo.getId)() |-\u003e fo});\nMSAW`atc.UpdatesPresent()\n)\n\tpre ((fo.getId)() not in set (dom airspace))\npublic  removeFO(FOId) (FOId \u003d\u003d\u003e ())\n\tremoveFO(FOId)(id) \u003d\u003d\n(\n\nairspace :\u003d ({id} \u003c-: airspace);\nMSAW`atc.UpdatesPresent()\n)\npublic  getFO(FOId) (FOId \u003d\u003d\u003e FO)\n\tgetFO(FOId)(id) \u003d\u003d\nreturn (airspace(id))\n\tpre (id in set (dom airspace))\npublic  getAirspace() (() \u003d\u003d\u003e set of (FO))\n\tgetAirspace()() \u003d\u003d\nreturn ((rng airspace))\npublic  updateFO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e ())\n\tupdateFO(FOId, Coordinates, Altitude)(id, coord, alt) \u003d\u003d\n(\n\nif (id in set (dom airspace))\nthen\nlet fo:FO \u003d airspace(id) in (\n\nfo.setCoordinates(coord);\nfo.setAltitude(alt)\n)else\n(\n\nlet newfo:FO \u003d new FO(id, coord, alt) in airspace :\u003d (airspace munion {id |-\u003e newfo})\n);\nMSAW`atc.UpdatesPresent()\n)\nend AirSpace\n","class FO is subclass of [GLOBAL]\nprivate  id:FOId :\u003d (undefined)\nprivate  coord:Coordinates :\u003d (undefined)\nprivate  alt:Altitude :\u003d (undefined)\npublic  FO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e FO)\n\tFO(FOId, Coordinates, Altitude)(idpar, coordpar, altpar) \u003d\u003d\n(\n\nid :\u003d idpar;\ncoord :\u003d coordpar;\nalt :\u003d altpar\n)\npublic  getId() (() \u003d\u003d\u003e FOId)\n\tgetId()() \u003d\u003d\nreturn (id)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (coord)\npublic  setCoordinates(Coordinates) (Coordinates \u003d\u003d\u003e ())\n\tsetCoordinates(Coordinates)(coordpar) \u003d\u003d\ncoord :\u003d coordpar\npublic  getAltitude() (() \u003d\u003d\u003e Altitude)\n\tgetAltitude()() \u003d\u003d\nreturn (alt)\npublic  setAltitude(Altitude) (Altitude \u003d\u003d\u003e ())\n\tsetAltitude(Altitude)(altpar) \u003d\u003d\nalt :\u003d altpar\npublic  getPosition() (() \u003d\u003d\u003e Position)\n\tgetPosition()() \u003d\u003d\nreturn (mk_Position(coord, alt))\nend FO\n","class GLOBAL\npublic static  Altitude \u003d Altitude\npublic static  FOId \u003d FOId\npublic static  RadarId \u003d RadarId\npublic static  Coordinates \u003d Coordinates\npublic static  Time \u003d Time\npublic static  String \u003d String\npublic static  ObstacleType \u003d ObstacleType\npublic static  FOWarning \u003d FOWarning\npublic static  RadarWarning \u003d RadarWarning\npublic static  MinimumSafetyAltitude \u003d MinimumSafetyAltitude\npublic static  Position \u003d Position\npublic static  History \u003d History\npublic static  Vector \u003d Vector\nprotected  protected isPointInRange: (Coordinates * nat1 * Coordinates -\u003e bool)\n\tisPointInRange(center, range, point) \u003d\u003d\n(((((center.X) - (point.X)) ** 2) + (((center.Y) - (point.Y)) ** 2)) \u003c\u003d (range ** 2))\nprotected  protected vectorSum: (Vector * Vector -\u003e Vector)\n\tvectorSum(v1, v2) \u003d\u003d\nmk_Vector(((v1.X) + (v2.X)), ((v1.Y) + (v2.Y)))\nprotected  protected vectorDiv: (Vector * int -\u003e Vector)\n\tvectorDiv(v, n) \u003d\u003d\nmk_Vector(((v.X) / n), ((v.Y) / n))\n\tpre (n \u003c\u003e 0)\nprotected  protected addVectorToPoint: (Vector * Position -\u003e Coordinates)\n\taddVectorToPoint(v, p) \u003d\u003d\nmk_Coordinates((((p.coord).X) + (v.X)), (((p.coord).Y) + (v.Y)))\nprotected  protected vectorLength: (Vector -\u003e real)\n\tvectorLength(v) \u003d\u003d\nMATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))\nprotected  protected unitVector: (Vector -\u003e Vector)\n\tunitVector(v) \u003d\u003d\nlet l:real \u003d vectorLength(v) in mk_Vector(((v.X) / l), ((v.Y) / l))\nprotected  protected dotProduct: (Vector * Vector -\u003e real)\n\tdotProduct(v1, v2) \u003d\u003d\n(((v1.X) * (v2.X)) + ((v1.Y) * (v2.Y)))\nprotected  protected angleBetweenVectors: (Vector * Vector -\u003e real)\n\tangleBetweenVectors(v1, v2) \u003d\u003d\nlet uv1:Vector \u003d unitVector(v1), uv2:Vector \u003d unitVector(v2), dvs:real \u003d dotProduct(uv1, uv2), angle:real \u003d MATH`acos(dvs) in radians2degree(angle)\nprotected  protected radians2degree: (real -\u003e real)\n\tradians2degree(r) \u003d\u003d\n(r * (180 / MATH`pi))\nprotected  protected atan2: (real * real -\u003e real)\n\tatan2(y, x) \u003d\u003d\n(2 * MATH`atan((y / (MATH`sqrt(((x ** 2) + (y ** 2))) + x))))\n\tpre (not ((x \u003d 0) and (y \u003d 0)))\nprotected  protected signedVectorAngle: (Vector * Vector -\u003e real)\n\tsignedVectorAngle(v1, v2) \u003d\u003d\n(atan2((v2.Y), (v2.X)) - atan2((v1.Y), (v1.X)))\nprotected  protected vectorAngle: (Vector -\u003e (real * real))\n\tvectorAngle(v) \u003d\u003d\nmk_(radians2degree(MATH`acos(((v.X) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))), radians2degree(MATH`asin(((v.Y) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))))\nprotected  protected vectorRotate: (Vector * real -\u003e Vector)\n\tvectorRotate(v, a) \u003d\u003d\nlet x\u0027:real \u003d ((MATH`cos(a) * (v.X)) - (MATH`sin(a) * (v.Y))), y\u0027:real \u003d ((MATH`cos(a) * (v.Y)) + (MATH`sin(a) * (v.X))) in mk_Vector(round(x\u0027), round(y\u0027))\nprotected  protected round: (real -\u003e real)\n\tround(r) \u003d\u003d\nlet fr:int \u003d (floor r), dif:real \u003d (abs (r - fr)) in (if (dif \u003c (10 ** -10))\nthen fr\nelse r)\npublic  test(real, real, real, real) (real * real * real * real \u003d\u003d\u003e (Vector * Vector * real * real * Vector * real * real))\n\ttest(real, real, real, real)(x1, y1, x2, y2) \u003d\u003d\nlet v1:Vector \u003d mk_Vector(x1, y1), v2:Vector \u003d mk_Vector(x2, y2) in return (mk_(unitVector(v1), unitVector(v2), dotProduct(unitVector(v1), unitVector(v2)), atan2(1.0E-6, 0.0), vectorRotate(v2, signedVectorAngle(v1, v2)), radians2degree(signedVectorAngle(v1, v2)), angleBetweenVectors(v1, v2)))\nend GLOBAL\n","system MSAW\nprivate  cpu1:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\nprivate  cpu2:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\nprivate  cpu3:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\nprivate  bus1:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu1, cpu2, cpu3})\npublic static  atc:AirTrafficController :\u003d new AirTrafficController()\npublic static  radar1:Radar :\u003d new Radar(6, 11, 20)\npublic static  radar2:Radar :\u003d new Radar(30, 30, 5)\npublic static  airspace:AirSpace :\u003d new AirSpace()\npublic static  militaryZone:Obstacle :\u003d new Obstacle(\u003cNotAllowed\u003e, mk_GLOBAL`Coordinates(25, 0), 5, 5, \u003cMilitary_Area\u003e)\npublic  MSAW() (() \u003d\u003d\u003e MSAW)\n\tMSAW()() \u003d\u003d\n(\n\ncpu1.deploy(atc);\ncpu2.deploy(radar1);\ncpu3.deploy(radar2)\n)\nend MSAW\n","class Radar is subclass of [GLOBAL]\nprivate  busy:bool :\u003d true\nprivate  location:Coordinates :\u003d (undefined)\nprivate  range:nat1 :\u003d (undefined)\nprivate  detected:map (FOId) to (FO) :\u003d (undefined)\nprivate  priority:seq of (FO) :\u003d []\nprivate  inv(forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid))\npublic  Radar(int, int, nat1) (int * int * nat1 \u003d\u003d\u003e Radar)\n\tRadar(int, int, nat1)(x, y, r) \u003d\u003d\n(\n\nlocation :\u003d mk_Coordinates(x, y);\nrange :\u003d r;\ndetected :\u003d {|-\u003e}\n)\npublic  Scan(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tScan(AirSpace)(as) \u003d\u003d\n(\n\ndetected :\u003d {(x.getId)() |-\u003e x | x in set (as.getAirspace)() \u0026 InRange(x)};\nUpdatePriorityList()\n)\nprivate  InRange(FO) (FO \u003d\u003d\u003e bool)\n\tInRange(FO)(fo) \u003d\u003d\nlet foLocation:Coordinates \u003d (fo.getCoordinates)() in return (isPointInRange(location, range, foLocation))\npublic  getDetected() (() \u003d\u003d\u003e set of (FO))\n\tgetDetected()() \u003d\u003d\nreturn ((rng detected))\npublic  getDetectedMap() (() \u003d\u003d\u003e map (FOId) to (FO))\n\tgetDetectedMap()() \u003d\u003d\nreturn (detected)\npublic  saturatedRadar() (() \u003d\u003d\u003e bool)\n\tsaturatedRadar()() \u003d\u003d\nreturn (((card (dom detected)) \u003e (range / 4)))\npublic  getSaturatingFOs() (() \u003d\u003d\u003e set of (FOId))\n\tgetSaturatingFOs()() \u003d\u003d\nreturn ({(priority(i).getId)() | i in set (inds priority) \u0026 (i \u003e (floor (range / 4)))})\npublic  getLocation() (() \u003d\u003d\u003e Coordinates)\n\tgetLocation()() \u003d\u003d\nreturn (location)\npublic  getRange() (() \u003d\u003d\u003e nat1)\n\tgetRange()() \u003d\u003d\nreturn (range)\nprivate  UpdatePriorityList() (() \u003d\u003d\u003e ())\n\tUpdatePriorityList()() \u003d\u003d\nlet notDetect:set of (FO) \u003d ((elems priority) \\ (rng detected)), newlyDet:map (FOId) to (FO) \u003d (detected :-\u003e (elems priority)) in (\n\nremoveNotDetected(notDetect);\naddNewlyDetected(newlyDet)\n)\nprivate  removeNotDetected(set of (FO)) (set of (FO) \u003d\u003d\u003e ())\n\tremoveNotDetected(set of (FO))(fos) \u003d\u003d\npriority :\u003d [priority(i) | i in set (inds priority) \u0026 (priority(i) in set fos)]\nprivate  addNewlyDetected(map (FOId) to (FO)) (map (FOId) to (FO) \u003d\u003d\u003e ())\n\taddNewlyDetected(map (FOId) to (FO))(newlyDetect) \u003d\u003d\npriority :\u003d (priority ^ set2seqFO((rng newlyDetect)))\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\nprivate  private set2seqFO: (set of (FO) -\u003e seq of (FO))\n\tset2seqFO(fos) \u003d\u003d\n(if (fos \u003d {})\nthen []\nelse let fo in set fos in ([fo] ^ set2seqFO((fos \\ {fo}))))\nprivate  private set2seqFOm: (set of (FO) -\u003e nat)\n\tset2seqFOm(fos) \u003d\u003d\n(card fos)\nprivate  detectFOs() (() \u003d\u003d\u003e ())\n\tdetectFOs()() \u003d\u003d\nlet as:AirSpace \u003d MSAW`airspace in detected :\u003d {(x.getId)() |-\u003e x | x in set (as.getAirspace)() \u0026 InRange(x)}\nprivate  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nbusy :\u003d true;\ndetectFOs();\nUpdatePriorityList();\nbusy :\u003d false\n)\nprotected  thread periodic(2.0E9, 0, 0, 0)(Step())\nprivate  mutex(UpdatePriorityList)\nprivate  mutex(removeNotDetected, addNewlyDetected)\nprivate  per isFinished \u003d\u003e (not busy)\nend Radar\n","class AirTrafficController is subclass of [GLOBAL]\nprivate  busy:bool :\u003d false\nprivate  radars:set of (Radar) :\u003d {}\nprivate  obstacles:set of (Obstacle) :\u003d {}\nprivate  history:map (FOId) to (seq of (Position)) :\u003d {|-\u003e}\nprivate  OverviewAllRadars() (() \u003d\u003d\u003e map (FOId) to (FO))\n\tOverviewAllRadars()() \u003d\u003d\nreturn ((merge {(r.getDetectedMap)() | r in set radars}))\nprivate  getDirectionVectors(FOId) (FOId \u003d\u003d\u003e seq of (Vector))\n\tgetDirectionVectors(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), p1:Position \u003d hist(3), p2:Position \u003d hist(2), p3:Position \u003d hist(1) in return ([mk_Vector((((p1.coord).X) - ((p2.coord).X)), (((p1.coord).Y) - ((p2.coord).Y))), mk_Vector((((p2.coord).X) - ((p3.coord).X)), (((p2.coord).Y) - ((p3.coord).Y)))])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  getAltitudeHistory(FOId) (FOId \u003d\u003d\u003e seq of (nat))\n\tgetAltitudeHistory(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), lastHist:seq of (Position) \u003d (hist(1, ... ,2)) in return ([(lastHist(i).altitude) | i in set (inds lastHist)])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  updateHistory() (() \u003d\u003d\u003e ())\n\tupdateHistory()() \u003d\u003d\n(\n\ncleanUpHistory();\nfor all r in set radars do\n(\n\nfor all fo in set (r.getDetected)() do\nregisterHistory(fo)\n)\n)\nprivate  registerHistory(FO) (FO \u003d\u003d\u003e ())\n\tregisterHistory(FO)(fo) \u003d\u003d\n(\n\nlet id:FOId \u003d (fo.getId)() in if (id in set (dom history))\nthen\nhistory :\u003d (history ++ {id |-\u003e addHistory(history(id), (fo.getCoordinates)(), (fo.getAltitude)())})else\nhistory :\u003d (history munion {id |-\u003e addHistory([], (fo.getCoordinates)(), (fo.getAltitude)())})\n)\nprivate  cleanUpHistory() (() \u003d\u003d\u003e ())\n\tcleanUpHistory()() \u003d\u003d\n(\n\nlet alldetected:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}), allids:set of (FOId) \u003d {(fo.getId)() | fo in set alldetected} in history :\u003d (allids \u003c: history)\n)\nprivate  private addHistory: (History * Coordinates * Altitude -\u003e History)\n\taddHistory(hist, coord, alt) \u003d\u003d\n(if ((len hist) \u003e 0)\nthen let lastValue:Position \u003d last(hist) in (if (lastValue \u003d mk_Position(coord, alt))\nthen hist\nelse (if ((len hist) \u003c 3)\nthen (hist ^ [mk_Position(coord, alt)])\nelse ((tl hist) ^ [mk_Position(coord, alt)])))\nelse (hist ^ [mk_Position(coord, alt)]))\nprivate  private last: (History -\u003e Position)\n\tlast(hist) \u003d\u003d\nhist((len hist))\n\tpre ((len hist) \u003e 0)\npublic  addRadar(Radar) (Radar \u003d\u003d\u003e ())\n\taddRadar(Radar)(r) \u003d\u003d\nradars :\u003d ({r} union radars)\npublic  addObstacle(Obstacle) (Obstacle \u003d\u003d\u003e ())\n\taddObstacle(Obstacle)(ob) \u003d\u003d\nobstacles :\u003d ({ob} union obstacles)\npublic  findThreats() (() \u003d\u003d\u003e ())\n\tfindThreats()() \u003d\u003d\nlet allFOs:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}) in (\n\nfor all fo in set allFOs do\nfor all ob in set obstacles do\nif (not isFOSafe(ob, (fo.getPosition)()))\nthen\nwriteObjectWarning(ob, fo)else\nif (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nthen\nwillFObeSafe(ob, fo);\nfor all r in set radars do\nif (r.saturatedRadar)()\nthen\nwriteRadarWarning(r)\n)\npublic  UpdatesPresent() (() \u003d\u003d\u003e ())\n\tUpdatesPresent()() \u003d\u003d\nbusy :\u003d true\npublic  public detectedByTwoRadars: (set of (Radar) -\u003e set of (FO))\n\tdetectedByTwoRadars(radars) \u003d\u003d\n(dunion {((a.getDetected)() inter (b.getDetected)()) | a, b in set radars \u0026 (a \u003c\u003e b)})\npublic  public detectedByAllRadars: (set of (Radar) -\u003e set of (FO))\n\tdetectedByAllRadars(radars) \u003d\u003d\n(dinter {(r.getDetected)() | r in set radars})\nprivate  private isFOSafe: (Obstacle * Position -\u003e bool)\n\tisFOSafe(obs, pos) \u003d\u003d\nlet obsloc:Coordinates \u003d (obs.getCoordinates)(), secureRange:nat1 \u003d (obs.getSecureRange)(), foloc:Coordinates \u003d (pos.coord) in (isPointInRange(obsloc, secureRange, foloc) \u003d\u003e isFOatSafeAltitude((obs.getMSA)(), pos))\nprivate  private isFOatSafeAltitude: (MinimumSafetyAltitude * Position -\u003e bool)\n\tisFOatSafeAltitude(msa, pos) \u003d\u003d\n((msa \u003c\u003e \u003cNotAllowed\u003e) and (msa \u003c (pos.altitude)))\nprivate  willFObeSafe(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twillFObeSafe(Obstacle, FO)(obs, fo) \u003d\u003d\nlet pred:[set of (Position)] \u003d isPredictPossible(fo) in for all p in set pred do\nif (not isFOSafe(obs, p))\nthen\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:\u003cEstimationWarning\u003e \u003d \u003cEstimationWarning\u003e, msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d time in (\n\nWorld`env.handleFOWarningEvent(id, cs, alt, type, msa, t);\nreturn\n)\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  writeObjectWarning(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twriteObjectWarning(Obstacle, FO)(obs, fo) \u003d\u003d\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:ObstacleType \u003d (obs.getType)(), msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d time in World`env.handleFOWarningEvent(id, cs, alt, type, msa, t)\nprivate  writeRadarWarning(Radar) (Radar \u003d\u003d\u003e ())\n\twriteRadarWarning(Radar)(r) \u003d\u003d\nlet coord:Coordinates \u003d (r.getLocation)(), range:nat1 \u003d (r.getRange)(), radWarn:\u003cSaturated\u003e \u003d \u003cSaturated\u003e, num:nat \u003d (card (r.getDetected)()), t:nat \u003d time in World`env.handleRadarWarningEvent(coord, range, radWarn, num, t)\nprivate  isPredictPossible(FO) (FO \u003d\u003d\u003e [set of (Position)])\n\tisPredictPossible(FO)(fo) \u003d\u003d\nlet hist:seq of (Position) \u003d history((fo.getId)()) in if ((len hist) \u003c 3)\nthen\nreturn (nil)else\nreturn (predictPosition(fo))\n\tpre ((fo.getId)() in set (dom history))\nprivate  predictPosition(FO) (FO \u003d\u003d\u003e set of (Position))\n\tpredictPosition(FO)(fo) \u003d\u003d\nlet foid:FOId \u003d (fo.getId)(), vs:seq of (Vector) \u003d getDirectionVectors(foid), estVec:Vector \u003d vectorRotate(vs(1), signedVectorAngle(vs(2), vs(1))), estAlt:nat \u003d predictAltitude(getAltitudeHistory(foid)), estCoo:Coordinates \u003d addVectorToPoint(estVec, history(foid)(3)), estPos:Position \u003d mk_Position(estCoo, estAlt) in return (calculateNeighborhood(estPos))\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  private calculateNeighborhood: (Position -\u003e set of (Position))\n\tcalculateNeighborhood(pos) \u003d\u003d\n{pos, mk_Position(addVectorToPoint(mk_Vector(2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(-2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, 2), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, -2), pos), (pos.altitude))}\nprivate  private predictAltitude: (seq of (nat) -\u003e nat)\n\tpredictAltitude(alts) \u003d\u003d\n(alts(1) + (alts(1) - alts(2)))\n\tpre ((len alts) \u003d 2)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nfor all r in set radars do\nr.isFinished()\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nbusy :\u003d true;\nupdateHistory();\nfindThreats();\nbusy :\u003d false\n)\nprotected  thread periodic(1.6E9, 0, 0, 0)(Step())\nprivate  per isFinished \u003d\u003e (not busy)\nend AirTrafficController\n","class Environment is subclass of [GLOBAL]\nprivate static  InputTP \u003d InputTP\nprivate static  inline \u003d inline\nprivate static  FOOut \u003d FOOut\nprivate static  RadarOut \u003d RadarOut\nprivate static  outline \u003d outline\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (outline) :\u003d []\nprivate  airspace:[AirSpace] :\u003d nil\nprivate  busy:bool :\u003d true\nprivate  updating:bool :\u003d false\nprivate  simtime:Time :\u003d (undefined)\npublic  Environment(String) (String \u003d\u003d\u003e Environment)\n\tEnvironment(String)(fname) \u003d\u003d\nlet mk_(-, mk_(timeval, input)) \u003d ((io.freadval))[InputTP](fname) in (\n\ninlines :\u003d input;\nsimtime :\u003d timeval\n)\npublic  setAirSpace(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tsetAirSpace(AirSpace)(as) \u003d\u003d\nairspace :\u003d as\npublic  handleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time) (FOId * Coordinates * Altitude * FOWarning * MinimumSafetyAltitude * Time \u003d\u003d\u003e ())\n\thandleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time)(id, coord, alt, warn, msa, t) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(id, coord, alt, warn, msa, t)])\npublic  handleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time) (Coordinates * nat1 * RadarWarning * nat * Time \u003d\u003d\u003e ())\n\thandleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time)(coord, range, radWarn, num, pt) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(coord, range, radWarn, num, pt)])\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (outline)](outlines) in skip\nprivate  updateFOs() (() \u003d\u003d\u003e ())\n\tupdateFOs()() \u003d\u003d\n(\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d time\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(id, x, y, altitude, pt) \u003d (hd inlines) in if (pt \u003c\u003d curtime)\nthen\n(\n\nairspace.updateFO(id, mk_Coordinates(x, y), altitude);\ninlines :\u003d (tl inlines);\nupdating :\u003d true;\ndone :\u003d ((len inlines) \u003d 0)\n)else\ndone :\u003d true\n)else\nbusy :\u003d false\n)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\nprivate  mutex(updateFOs)\nprivate  mutex(handleFOWarningEvent, updateFOs, handleRadarWarningEvent)\nprivate  mutex(handleFOWarningEvent)\nprivate  per isFinished \u003d\u003e (not busy)\nprivate  mutex(handleRadarWarningEvent)\nprivate  mutex(handleRadarWarningEvent, handleFOWarningEvent)\nprotected  thread periodic(1.0E9, 10, 30, 0)(updateFOs())\nend Environment\n","class Obstacle is subclass of [GLOBAL]\nprivate  MSA:MinimumSafetyAltitude :\u003d (undefined)\nprivate  location:Coordinates :\u003d (undefined)\nprivate  radius:nat1 :\u003d (undefined)\nprivate  securityRadius:nat :\u003d (undefined)\nprivate  type:ObstacleType :\u003d (undefined)\npublic  Obstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType) (MinimumSafetyAltitude * Coordinates * nat * nat * ObstacleType \u003d\u003d\u003e Obstacle)\n\tObstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType)(msa, loc, ra, secRa, tp) \u003d\u003d\n(\n\nMSA :\u003d msa;\nlocation :\u003d loc;\nradius :\u003d ra;\nsecurityRadius :\u003d secRa;\ntype :\u003d tp\n)\npublic  getType() (() \u003d\u003d\u003e ObstacleType)\n\tgetType()() \u003d\u003d\nreturn (type)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (location)\npublic  getSecureRange() (() \u003d\u003d\u003e nat1)\n\tgetSecureRange()() \u003d\u003d\nreturn ((radius + securityRadius))\npublic  getMSA() (() \u003d\u003d\u003e MinimumSafetyAltitude)\n\tgetMSA()() \u003d\u003d\nreturn (MSA)\nend Obstacle\n","class World\npublic static  env:[Environment] :\u003d nil\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Environment(\"scenario.txt\");\nenv.setAirSpace(MSAW`airspace);\nMSAW`atc.addObstacle(MSAW`militaryZone);\nMSAW`atc.addRadar(MSAW`radar1);\nMSAW`atc.addRadar(MSAW`radar2)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nstart (env);\nstart (MSAW`atc);\nstart (MSAW`radar1);\nstart (MSAW`radar2);\nenv.isFinished();\nMSAW`atc.isFinished();\nenv.showResult()\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n"]