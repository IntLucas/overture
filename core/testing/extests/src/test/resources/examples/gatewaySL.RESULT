["PhysicalFile \u003d PhysicalFile","HeaderEntity \u003d HeaderEntity","Scope \u003d Scope","Record \u003d Record","SuperRecord \u003d SuperRecord","SimpleRecord \u003d SimpleRecord","Parameter \u003d Parameter","StringParameter \u003d StringParameter","RealParameter \u003d RealParameter","IntegerParameter \u003d IntegerParameter","EntityInstanceName \u003d EntityInstanceName","EnumerationParameter \u003d EnumerationParameter","BinaryParameter \u003d BinaryParameter","ListParameter \u003d ListParameter","TypedParameter \u003d TypedParameter","OmittedParameter \u003d OmittedParameter","UnknownParameter \u003d UnknownParameter","CheckReferences (Parameter \u003d\u003d\u003e set of (nat))\n\tCheckReferences(parm) \u003d\u003d\ncases parm :\n  mk_EntityInstanceName(id) -\u003e return ({id})  mk_ListParameter(parms) -\u003e (\nres:set of (nat) :\u003d {}\n\nfor in \u0027Database\u0027 (express.vdmsl) at line 97:15subparmADefPatternBind[subparm \u003d Parameter]ADefPatternBind in parms do\nres :\u003d (res union CheckReferences(subparm));\nreturn (res)\n)  others -\u003e return ({}) end","FindAllReferencesToEntity (nat \u003d\u003d\u003e set of (nat))\n\tFindAllReferencesToEntity(eid) \u003d\u003d\nlet eins:set of (nat) \u003d ((dom (in_model.datasec)) \\ {eid}) in (\nres:set of (nat) :\u003d {}\n\nfor all ein in set eins do\nlet mk_(-, mk_SimpleRecord(-, parms)):([Scope] * Record) \u003d (in_model.datasec)(ein) in if (eid in set CheckReferences(mk_ListParameter(parms)))\nthen\nres :\u003d (res union {ein});\nreturn (res)\n)","FindAllInstances (seq of (char) \u003d\u003d\u003e set of (nat))\n\tFindAllInstances(nm) \u003d\u003d\nlet eins:set of (nat) \u003d (dom (in_model.datasec)) in (\nres:set of (nat) :\u003d {}\n\nfor all ein in set eins do\nlet mk_(-, rec):([Scope] * Record) \u003d (in_model.datasec)(ein) in if IsA(rec, nm)\nthen\nres :\u003d (res union {ein});\nreturn (res)\n)","LookUpEntityInstance (nat \u003d\u003d\u003e [Record])\n\tLookUpEntityInstance(ein) \u003d\u003d\nlet eins:set of (nat) \u003d (dom (in_model.datasec)) in if (ein in set eins)\nthen\nlet mk_(-, rec):([Scope] * Record) \u003d (in_model.datasec)(ein) in return (rec)else\nreturn (nil)","TransformRmVertex (nat \u003d\u003d\u003e nat)\n\tTransformRmVertex(rmv_id) \u003d\u003d\nlet mk_SimpleRecord(-, parms):[Record] \u003d LookUpEntityInstance(rmv_id) in let mk_EntityInstanceName(cpnt_id):Parameter \u003d parms(5) in return (cpnt_id)","TransformRmEdge (nat \u003d\u003d\u003e set of ((nat * nat)))\n\tTransformRmEdge(rme_id) \u003d\u003d\nlet mk_SimpleRecord(-, parms):[Record] \u003d LookUpEntityInstance(rme_id) in let mk_ListParameter(rmees):Parameter \u003d parms(3) in (\nres:set of ((nat * nat)) :\u003d {}\n\nfor in \u0027Database\u0027 (express.vdmsl) at line 156:11rmeeADefPatternBind[rmee \u003d Parameter]ADefPatternBind in rmees do\nlet mk_EntityInstanceName(rmee_id):Parameter \u003d rmee in let {rmee_ref}:set of (nat) \u003d (FindAllReferencesToEntity(rmee_id) \\ {rme_id}) in res :\u003d (res union {mk_(rme_id, TransformRmVertex(rmee_ref))});\nreturn (res)\n)","TransformRmLoop (nat \u003d\u003d\u003e seq of (nat))\n\tTransformRmLoop(rml_id) \u003d\u003d\nlet mk_SimpleRecord(-, parms):[Record] \u003d LookUpEntityInstance(rml_id) in let mk_ListParameter(rmess):Parameter \u003d parms(2) in (\nres:set of ((nat * nat)) :\u003d {}\n\nfor in \u0027Database\u0027 (express.vdmsl) at line 170:19rmesADefPatternBind[rmes \u003d Parameter]ADefPatternBind in rmess do\nlet mk_EntityInstanceName(rmes_id):Parameter \u003d rmes in let rme_ref:set of (nat) \u003d (FindAllReferencesToEntity(rmes_id) \\ {rml_id}) in for all rme_id in set rme_ref do\nres :\u003d (res union TransformRmEdge(rme_id));\nreturn (SortPoints(res))\n)","Transform (() \u003d\u003d\u003e set of (seq of (nat)))\n\tTransform() \u003d\u003d\nlet rmls:set of (nat) \u003d FindAllInstances(\"RM_LOOP\") in (\nres:set of (seq of (nat)) :\u003d {}\n\nfor all rml in set rmls do\nres :\u003d (res union {TransformRmLoop(rml)});\nreturn (res)\n)","Create (set of (seq of (nat)) \u003d\u003d\u003e ())\n\tCreate(AbstrMod) \u003d\u003d\n(\nds:map (nat) to (([Scope] * Record)) :\u003d {|-\u003e}\nLookUpTable:map (nat) to (nat) :\u003d {|-\u003e}\npolylist:seq of (EntityInstanceName) :\u003d []\n\nfor all ent in set Collect(AbstrMod) do\n(\n\nlast_id :\u003d (last_id + 1);\nLookUpTable :\u003d (LookUpTable munion {ent |-\u003e last_id});\nlet mk_SimpleRecord(-, parms):[Record] \u003d LookUpEntityInstance(ent) in ds :\u003d (ds munion {last_id |-\u003e mk_(nil, mk_SimpleRecord(\"VERTEX\", [parms(3)]))})\n);\nfor all poly in set AbstrMod do\n(\n\nlast_id :\u003d (last_id + 1);\nds :\u003d (ds munion {last_id |-\u003e mk_(nil, mk_SimpleRecord(\"POLYLINE\", [mk_ListParameter(MapInToOut(poly, LookUpTable))]))});\npolylist :\u003d (polylist ^ [mk_EntityInstanceName(last_id)])\n);\nds :\u003d (ds munion {(last_id + 1) |-\u003e mk_(nil, mk_SimpleRecord(\"DRAWING\", [mk_ListParameter(polylist)]))});\nout_model :\u003d mk_PhysicalFile({\"FILE_NAME\" |-\u003e [mk_UnknownParameter()], \"FILE_DESCRIPTION\" |-\u003e [mk_UnknownParameter()], \"FILE_SCHEMA\" |-\u003e [mk_UnknownParameter()]}, ds)\n)","DoMapping (PhysicalFile \u003d\u003d\u003e PhysicalFile)\n\tDoMapping(pf) \u003d\u003d\n(\n\nin_model :\u003d pf;\nCreate(Transform());\nreturn (out_model)\n)","private MapInToOut: (seq of (nat) * map (nat) to (nat) -\u003e seq of (EntityInstanceName))\n\tMapInToOut(ins, lut) \u003d\u003d\n(if (ins \u003d [])\nthen []\nelse ([mk_EntityInstanceName(lut((hd ins)))] ^ MapInToOut((tl ins), lut)))","private LenPar1: (seq of (nat) * map (nat) to (nat) -\u003e nat)\n\tLenPar1(list, -) \u003d\u003d\n(len list)","private Collect: (set of (seq of (nat)) -\u003e set of (nat))\n\tCollect(theSet) \u003d\u003d\n(cases theSet :\n{} -\u003e {}\nothers let e in set theSet in ((elems e) union Collect((theSet \\ {e})))\n end)","private SetCard: (set of (seq of (nat)) -\u003e nat)\n\tSetCard(s) \u003d\u003d\n(card s)","private IsA: (Record * seq of (char) -\u003e bool)\n\tIsA(rec, nm) \u003d\u003d\n(if is_(rec, SimpleRecord)\nthen let mk_SimpleRecord(name, -):SimpleRecord \u003d rec in (nm \u003d name)\nelse false)","private SortInnerLeft: (set of ((nat * nat)) * nat -\u003e seq of (nat))\n\tSortInnerLeft(theSet, goal) \u003d\u003d\n(cases theSet :\n{} -\u003e []\nothers let mk_(a, b) in set theSet be st (a \u003d goal) in SortInnerRight((theSet \\ {mk_(a, b)}), b)\n end)","private SortInnerRight: (set of ((nat * nat)) * nat -\u003e seq of (nat))\n\tSortInnerRight(theSet, goal) \u003d\u003d\n(cases theSet :\n{} -\u003e []\nothers let mk_(a, b) in set theSet be st (b \u003d goal) in ([b] ^ SortInnerLeft((theSet \\ {mk_(a, b)}), a))\n end)","private SortPoints: (set of ((nat * nat)) -\u003e seq of (nat))\n\tSortPoints(theSet) \u003d\u003d\nlet mk_(a, b) in set theSet in SortInnerRight((theSet \\ {mk_(a, b)}), b)","state Kernelof\n[in_model : PhysicalFile, out_model : PhysicalFile, last_id : nat]\n\tinit k \u003d\u003d (k \u003d mk_Kernel(mk_PhysicalFile({|-\u003e}, {|-\u003e}), mk_PhysicalFile({|-\u003e}, {|-\u003e}), 0))"]