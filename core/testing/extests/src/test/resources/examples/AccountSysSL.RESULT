["TrackC \u003d TrackC\n\tinv tc \u003d\u003d (((card (dom (tc.joints))) \u003e 1) and (((dom (tc.atc)) \u003d {\u003cADIR\u003e, \u003cBDIR\u003e}) and (TD_Used_for_NonInsulated_TrackC((tc.td), (tc.atbt), (rng (tc.joints))) and ((((tc.atc)(\u003cADIR\u003e).used) and ((tc.atc)(\u003cBDIR\u003e).used)) \u003d\u003e (((tc.atc)(\u003cADIR\u003e).carrier) \u003c\u003e ((tc.atc)(\u003cBDIR\u003e).carrier))))))","Joint_id \u003d Joint_id","Joint \u003d Joint","Insulation \u003d Insulation","Remark \u003d Remark\n\tinv rm \u003d\u003d ((dom (rm.atc_terminal)) \u003d {\u003cADIR\u003e, \u003cBDIR\u003e})","Direction \u003d Direction","ATC \u003d ATC","TD \u003d TD","ATBT \u003d ATBT","private TD_Used_for_NonInsulated_TrackC: (TD * ATBT * set of (Joint) -\u003e bool)\n\tTD_Used_for_NonInsulated_TrackC(td, atbt, joints) \u003d\u003d\n(((atbt \u003d \u003cNULL\u003e) \u003c\u003d\u003e (not (td.used))) and ((exists j in set joints \u0026 (not (j.insulated))) \u003d\u003e (td.used)))","TrackC_id \u003d TrackC_id","TrackC_map \u003d TrackC_map\n\tinv tcs \u003d\u003d (forall tid in set (dom tcs) \u0026 (forall jid in set (dom (tcs(tid).joints)) \u0026 (Only_One_Next_TrackC(tcs, tid, jid) and (forall tid2 in set (dom tcs) \u0026 ((tid \u003c\u003e tid2) \u003d\u003e Joint_and_Next_TrackC(tcs(tid), tcs(tid2), jid))))))","private Only_One_Next_TrackC: (map (TrackC_id) to (TrackC) * TrackC_id * Joint_id -\u003e bool)\n\tOnly_One_Next_TrackC(tcs, tcid, jid) \u003d\u003d\n((card {tid | tid in set (dom tcs) \u0026 ((tid \u003c\u003e tcid) and (jid in set (dom (tcs(tid).joints))))}) \u003c 2)","private Joint_and_Next_TrackC: (TrackC * TrackC * Joint_id -\u003e bool)\n\tJoint_and_Next_TrackC(tc1, tc2, jid) \u003d\u003d\n(((jid in set (dom (tc1.joints))) and (jid in set (dom (tc2.joints)))) \u003d\u003e (((tc1.joints)(jid) \u003d (tc2.joints)(jid)) and ((not (((tc1.joints)(jid).remark).line_terminal)) and Is_wf_adjacent_signal(tc1, jid, tc2, jid, false))))","private Is_wf_adjacent_signal: (TrackC * Joint_id * TrackC * Joint_id * bool -\u003e bool)\n\tIs_wf_adjacent_signal(tc1, jid1, tc2, jid2, dir_chng) \u003d\u003d\n((jid1 in set (dom (tc1.joints))) and ((jid2 in set (dom (tc2.joints))) and (Remark_Compatible(((tc1.joints)(jid1).remark), ((tc2.joints)(jid2).remark), dir_chng) and (ATC_Terminal_and_ATC_Used((tc1.atc)(\u003cADIR\u003e), (tc2.atc)(\u003cBDIR\u003e), ((tc1.joints)(jid1).remark), (tc2.atc)(\u003cADIR\u003e), (tc2.atc)(\u003cBDIR\u003e), ((tc2.joints)(jid2).remark), dir_chng) and Adjacent_TD_Carrier_Differ((tc1.td), (tc1.atbt), (tc2.td), (tc2.atbt), (((tc1.joints)(jid1).insulated) and ((tc2.joints)(jid2).insulated)))))))","private Remark_Compatible: (Remark * Remark * bool -\u003e bool)\n\tRemark_Compatible(rm1, rm2, dir_chng) \u003d\u003d\n(((not dir_chng) \u003d\u003e ((rm1.atc_terminal) \u003d (rm2.atc_terminal))) and (dir_chng \u003d\u003e (((rm1.atc_terminal)(\u003cADIR\u003e) \u003d (rm2.atc_terminal)(\u003cBDIR\u003e)) and ((rm1.atc_terminal)(\u003cBDIR\u003e) \u003d (rm2.atc_terminal)(\u003cADIR\u003e)))))","private ATC_Terminal_and_ATC_Used: (ATC * ATC * Remark * ATC * ATC * Remark * bool -\u003e bool)\n\tATC_Terminal_and_ATC_Used(atcA1, atcB1, rm1, atcA2, atcB2, rm2, dir_chng) \u003d\u003d\n(((not dir_chng) \u003d\u003e ((((atcA1.used) \u003c\u003e (atcA2.used)) \u003d (rm1.atc_terminal)(\u003cADIR\u003e)) and (((atcB1.used) \u003c\u003e (atcB2.used)) \u003d (rm1.atc_terminal)(\u003cBDIR\u003e)))) and (dir_chng \u003d\u003e ((((atcA1.used) \u003c\u003e (atcB2.used)) \u003d (rm1.atc_terminal)(\u003cADIR\u003e)) and (((atcB1.used) \u003c\u003e (atcA2.used)) \u003d (rm1.atc_terminal)(\u003cBDIR\u003e)))))\n\tpre Remark_Compatible(rm1, rm2, dir_chng)","private Adjacent_TD_Carrier_Differ: (TD * ATBT * TD * ATBT * Insulation -\u003e bool)\n\tAdjacent_TD_Carrier_Differ(td1, atbt1, td2, atbt2, insulated) \u003d\u003d\n(insulated or (((td1.carrier) \u003c\u003e (td2.carrier)) and ((atbt1 \u003c\u003e atbt2) or ((atbt1 \u003d \u003cAT\u003e) and (atbt2 \u003d \u003cAT\u003e)))))","Path \u003d Path\n\tinv p \u003d\u003d (((p.start) \u003c\u003e (p.endp)) and (((dom (p.used)) \u003d {\u003cADIR\u003e, \u003cBDIR\u003e}) and ((exists dr in set (dom (p.used)) \u0026 (p.used)(dr)) and (forall c1, c2 in set (p.condition) \u0026 Condition_not_Conflict(c1, c2)))))","Condition \u003d Condition\n\tinv con \u003d\u003d ((con.start) \u003c (con.endp))","Cond_Kind \u003d Cond_Kind","private Condition_not_Conflict: (Condition * Condition -\u003e bool)\n\tCondition_not_Conflict(c1, c2) \u003d\u003d\n(((c1 \u003c\u003e c2) and (((c1.kind) \u003d (c2.kind)) and ((c1.kind) \u003c\u003e \u003cLIMIT\u003e))) \u003d\u003e (not Overlap(c1, c2)))","private Overlap: (Condition * Condition -\u003e bool)\n\tOverlap(c1, c2) \u003d\u003d\n((((c1.start) \u003c (c2.start)) and ((c2.start) \u003c (c1.endp))) or ((((c2.start) \u003c (c1.start)) and ((c1.start) \u003c (c2.endp))) or ((c1.start) \u003d (c2.start))))","Path_id \u003d Path_id","Path_map \u003d Path_map\n\tinv ps \u003d\u003d (forall pid1, pid2 in set (dom ps) \u0026 ((pid1 \u003c\u003e pid2) \u003d\u003e (Not_Same_Path(ps(pid1), ps(pid2)) and Not_Start_and_End(ps(pid1), ps(pid2)))))","private Not_Same_Path: (Path * Path -\u003e bool)\n\tNot_Same_Path(p1, p2) \u003d\u003d\n((not (((p1.start) \u003d (p2.start)) and ((p1.endp) \u003d (p2.endp)))) and (not (((p1.start) \u003d (p2.endp)) and ((p1.endp) \u003d (p2.start)))))","private Not_Start_and_End: (Path * Path -\u003e bool)\n\tNot_Start_and_End(p1, p2) \u003d\u003d\n(((p1.tc) \u003d (p2.tc)) \u003d\u003e ((not ((p1.start) \u003d (p2.endp))) and (not ((p2.start) \u003d (p1.endp)))))","Route \u003d Route","Route_map \u003d Route_map","Route_id \u003d Route_id","Area \u003d Area\n\tinv mk_Area(trackcs, paths, routes, -, -) \u003d\u003d ((forall p in set (rng paths) \u0026 (Path_within_TrackC(trackcs, p) and Direction_Correct(trackcs, p))) and (forall r in set (rng routes) \u0026 (Path_Exists(paths, (r.paths), (r.dr)) and (Exists_ATC_for_Route(trackcs, paths, r) and (Route_not_Circular(paths, r) and Path_Connected(paths, (r.paths), (r.dr)))))))","Area_Kind \u003d Area_Kind","MaxSpeed \u003d MaxSpeed","private Path_within_TrackC: (TrackC_map * Path -\u003e bool)\n\tPath_within_TrackC(trackcs, p) \u003d\u003d\n(((p.tc) in set (dom trackcs)) and (((p.start) in set (dom (trackcs((p.tc)).joints))) and ((p.endp) in set (dom (trackcs((p.tc)).joints)))))","private Direction_Correct: (TrackC_map * Path -\u003e bool)\n\tDirection_Correct(trackcs, p) \u003d\u003d\nlet pstart:nat \u003d ((trackcs((p.tc)).joints)((p.start)).position), pend:nat \u003d ((trackcs((p.tc)).joints)((p.endp)).position) in ((pstart \u003c pend) and (((p.length) \u003d (pend - pstart)) and (forall c in set (p.condition) \u0026 ((pstart \u003c\u003d (c.start)) and ((c.endp) \u003c\u003d pend)))))\n\tpre Path_within_TrackC(trackcs, p)","private Path_Exists: (Path_map * seq of (Path_id) * Direction -\u003e bool)\n\tPath_Exists(paths, route, dr) \u003d\u003d\n(forall pid in set (elems route) \u0026 ((pid in set (dom paths)) and (paths(pid).used)(dr)))","private Exists_ATC_for_Route: (TrackC_map * Path_map * Route -\u003e bool)\n\tExists_ATC_for_Route(trackcs, paths, r) \u003d\u003d\n(forall pid in set (elems (r.paths)) \u0026 (((paths(pid).tc) in set (dom trackcs)) and ((trackcs((paths(pid).tc)).atc)((r.dr)).used)))\n\tpre Path_Exists(paths, (r.paths), (r.dr))","private Route_not_Circular: (Path_map * Route -\u003e bool)\n\tRoute_not_Circular(paths, r) \u003d\u003d\n(forall i, j in set (inds (r.paths)) \u0026 ((i \u003c\u003e j) \u003d\u003e ((paths((r.paths)(i)).tc) \u003c\u003e (paths((r.paths)(j)).tc))))\n\tpre Path_Exists(paths, (r.paths), (r.dr))","private Path_Connected: (Path_map * seq of (Path_id) * Direction -\u003e bool)\n\tPath_Connected(paths, route, dr) \u003d\u003d\n(forall i in set (inds route) \u0026 (((i + 1) in set (inds route)) \u003d\u003e (((dr \u003d \u003cADIR\u003e) \u003d\u003e ((paths(route(i)).endp) \u003d (paths(route((i + 1))).start))) and ((dr \u003d \u003cBDIR\u003e) \u003d\u003e ((paths(route(i)).start) \u003d (paths(route((i + 1))).endp))))))\n\tpre Path_Exists(paths, route, dr)","private Add_TrackC: (Area * TrackC_id * TrackC -\u003e Area)\n\tAdd_TrackC(ar, tcid, tc) \u003d\u003d\nmu(ar, trackcs |-\u003e ((ar.trackcs) ++ {tcid |-\u003e tc}))\n\tpre ((tcid not in set (dom (ar.trackcs))) and (forall jid in set (dom (tc.joints)) \u0026 (Only_One_Next_TrackC((ar.trackcs), tcid, jid) and (forall tcid1 in set (dom (ar.trackcs)) \u0026 Joint_and_Next_TrackC(tc, (ar.trackcs)(tcid1), jid)))))\n\tpost ((tcid in set (dom (RESULT.trackcs))) and (((RESULT.trackcs) \u003d ((ar.trackcs) ++ {tcid |-\u003e tc})) and (((RESULT.trackcs)(tcid) \u003d tc) and (((RESULT.paths) \u003d (ar.paths)) and ((RESULT.routes) \u003d (ar.routes))))))","private Del_TrackC: (Area * TrackC_id -\u003e Area)\n\tDel_TrackC(ar, tcid) \u003d\u003d\nmu(ar, trackcs |-\u003e ({tcid} \u003c-: (ar.trackcs)))\n\tpre ((tcid in set (dom (ar.trackcs))) and (forall p in set (rng (ar.paths)) \u0026 ((p.tc) \u003c\u003e tcid)))\n\tpost ((tcid not in set (dom (RESULT.trackcs))) and (((RESULT.trackcs) \u003d ({tcid} \u003c-: (ar.trackcs))) and (((RESULT.paths) \u003d (ar.paths)) and ((RESULT.routes) \u003d (ar.routes)))))","private Add_Joint: (Area * TrackC_id * Joint_id * Joint -\u003e Area)\n\tAdd_Joint(ar, tid, jid, joint) \u003d\u003d\nlet tc:TrackC \u003d (ar.trackcs)(tid) in mu(ar, trackcs |-\u003e ((ar.trackcs) ++ {tid |-\u003e mu(tc, joints |-\u003e ((tc.joints) ++ {jid |-\u003e joint}))}))\n\tpre ((tid in set (dom (ar.trackcs))) and let tc:TrackC \u003d (ar.trackcs)(tid) in ((jid not in set (dom (tc.joints))) and (TD_Used_for_NonInsulated_TrackC((tc.td), (tc.atbt), ((rng (tc.joints)) union {joint})) and (Only_One_Next_TrackC((ar.trackcs), tid, jid) and (forall tid1 in set (dom (ar.trackcs)) \u0026 ((tid1 \u003c\u003e tid) \u003d\u003e Joint_and_Next_TrackC((ar.trackcs)(tid1), mu(tc, joints |-\u003e ((tc.joints) ++ {jid |-\u003e joint})), jid)))))))\n\tpost ((tid in set (dom (RESULT.trackcs))) and ((jid in set (dom ((RESULT.trackcs)(tid).joints))) and (((dom (RESULT.trackcs)) \u003d (dom (ar.trackcs))) and ((({tid} \u003c-: (RESULT.trackcs)) \u003d ({tid} \u003c-: (ar.trackcs))) and (((RESULT.trackcs)(tid) \u003d mu((ar.trackcs)(tid), joints |-\u003e (((ar.trackcs)(tid).joints) ++ {jid |-\u003e joint}))) and ((((RESULT.trackcs)(tid).joints)(jid) \u003d joint) and ((((RESULT.trackcs)(tid).atc) \u003d ((ar.trackcs)(tid).atc)) and ((((RESULT.trackcs)(tid).td) \u003d ((ar.trackcs)(tid).td)) and ((((RESULT.trackcs)(tid).atbt) \u003d ((ar.trackcs)(tid).atbt)) and (((RESULT.paths) \u003d (ar.paths)) and ((RESULT.routes) \u003d (ar.routes))))))))))))","private Del_Joint: (Area * TrackC_id * Joint_id -\u003e Area)\n\tDel_Joint(ar, tcid, jid) \u003d\u003d\nlet tc:TrackC \u003d (ar.trackcs)(tcid) in mu(ar, trackcs |-\u003e ((ar.trackcs) ++ {tcid |-\u003e mu(tc, joints |-\u003e ({jid} \u003c-: (tc.joints)))}))\n\tpre ((tcid in set (dom (ar.trackcs))) and ((jid in set (dom ((ar.trackcs)(tcid).joints))) and (((card (dom ((ar.trackcs)(tcid).joints))) \u003e 2) and (forall path in set (rng (ar.paths)) \u0026 (((path.tc) \u003c\u003e tcid) or ((jid \u003c\u003e (path.start)) and (jid \u003c\u003e (path.endp))))))))\n\tpost ((tcid in set (dom (RESULT.trackcs))) and (((dom (RESULT.trackcs)) \u003d (dom (ar.trackcs))) and ((({tcid} \u003c-: (RESULT.trackcs)) \u003d ({tcid} \u003c-: (ar.trackcs))) and ((jid not in set (dom ((RESULT.trackcs)(tcid).joints))) and (((RESULT.trackcs)(tcid) \u003d mu((ar.trackcs)(tcid), joints |-\u003e ({jid} \u003c-: ((ar.trackcs)(tcid).joints)))) and ((((RESULT.trackcs)(tcid).atc) \u003d ((ar.trackcs)(tcid).atc)) and ((((RESULT.trackcs)(tcid).td) \u003d ((ar.trackcs)(tcid).td)) and ((((RESULT.trackcs)(tcid).atbt) \u003d ((ar.trackcs)(tcid).atbt)) and ((((RESULT.trackcs)(tcid).joints) \u003d ({jid} \u003c-: ((ar.trackcs)(tcid).joints))) and (((RESULT.paths) \u003d (ar.paths)) and ((RESULT.routes) \u003d (ar.routes))))))))))))","private Add_Path: (Area * Path_id * Path -\u003e Area)\n\tAdd_Path(ar, pid, path) \u003d\u003d\nmu(ar, paths |-\u003e ((ar.paths) ++ {pid |-\u003e path}))\n\tpre ((pid not in set (dom (ar.paths))) and (Path_within_TrackC((ar.trackcs), path) and (Direction_Correct((ar.trackcs), path) and (forall p in set (rng (ar.paths)) \u0026 (Not_Same_Path(p, path) and Not_Start_and_End(p, path))))))\n\tpost ((pid in set (dom (RESULT.paths))) and (((RESULT.paths) \u003d ((ar.paths) ++ {pid |-\u003e path})) and (((RESULT.paths)(pid) \u003d path) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.routes) \u003d (ar.routes))))))","private Del_Path: (Area * Path_id -\u003e Area)\n\tDel_Path(ar, pid) \u003d\u003d\nmu(ar, paths |-\u003e ({pid} \u003c-: (ar.paths)))\n\tpre ((pid in set (dom (ar.paths))) and (forall r in set (rng (ar.routes)) \u0026 (pid not in set (elems (r.paths)))))\n\tpost ((pid not in set (dom (RESULT.paths))) and (((RESULT.paths) \u003d ({pid} \u003c-: (ar.paths))) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.routes) \u003d (ar.routes)))))","private Add_Route: (Area * Route_id * Route -\u003e Area)\n\tAdd_Route(ar, rid, r) \u003d\u003d\nmu(ar, routes |-\u003e ((ar.routes) ++ {rid |-\u003e r}))\n\tpre ((rid not in set (dom (ar.routes))) and (Path_Exists((ar.paths), (r.paths), (r.dr)) and (Exists_ATC_for_Route((ar.trackcs), (ar.paths), r) and (Route_not_Circular((ar.paths), r) and Path_Connected((ar.paths), (r.paths), (r.dr))))))\n\tpost ((rid in set (dom (RESULT.routes))) and (((RESULT.routes) \u003d ((ar.routes) ++ {rid |-\u003e r})) and (((RESULT.routes)(rid) \u003d r) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.paths) \u003d (ar.paths))))))","private Del_Route: (Area * Route_id -\u003e Area)\n\tDel_Route(ar, rid) \u003d\u003d\nmu(ar, routes |-\u003e ({rid} \u003c-: (ar.routes)))\n\tpre (rid in set (dom (ar.routes)))\n\tpost ((rid not in set (dom (RESULT.routes))) and (((RESULT.routes) \u003d ({rid} \u003c-: (ar.routes))) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.paths) \u003d (ar.paths)))))","private Add_Condition: (Area * Path_id * Condition -\u003e Area)\n\tAdd_Condition(ar, pid, con) \u003d\u003d\nlet p:Path \u003d mu((ar.paths)(pid), condition |-\u003e (((ar.paths)(pid).condition) union {con})) in mu(ar, paths |-\u003e ((ar.paths) ++ {pid |-\u003e p}))\n\tpre ((pid in set (dom (ar.paths))) and let p:Path \u003d (ar.paths)(pid) in (((((ar.trackcs)((p.tc)).joints)((p.start)).position) \u003c\u003d (con.start)) and (((con.endp) \u003c\u003d (((ar.trackcs)((p.tc)).joints)((p.endp)).position)) and (forall c in set (p.condition) \u0026 Condition_not_Conflict(c, con)))))\n\tpost ((pid in set (dom (RESULT.paths))) and (((dom (RESULT.paths)) \u003d (dom (ar.paths))) and ((({pid} \u003c-: (RESULT.paths)) \u003d ({pid} \u003c-: (ar.paths))) and (((RESULT.paths)(pid) \u003d mu((ar.paths)(pid), condition |-\u003e (((ar.paths)(pid).condition) union {con}))) and ((((RESULT.paths)(pid).start) \u003d ((ar.paths)(pid).start)) and ((((RESULT.paths)(pid).endp) \u003d ((ar.paths)(pid).endp)) and ((((RESULT.paths)(pid).tc) \u003d ((ar.paths)(pid).tc)) and ((((RESULT.paths)(pid).length) \u003d ((ar.paths)(pid).length)) and ((((RESULT.paths)(pid).condition) \u003d (((ar.paths)(pid).condition) union {con})) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.routes) \u003d (ar.routes))))))))))))","private Del_Condition: (Area * Path_id * Cond_Kind * nat * nat -\u003e Area)\n\tDel_Condition(ar, pid, kind, start, endp) \u003d\u003d\nlet p:Path \u003d mu((ar.paths)(pid), condition |-\u003e {l | l in set ((ar.paths)(pid).condition) \u0026 (not (((l.kind) \u003d kind) and (((l.start) \u003d start) and ((l.endp) \u003d endp))))}) in mu(ar, paths |-\u003e ((ar.paths) ++ {pid |-\u003e p}))\n\tpre ((pid in set (dom (ar.paths))) and (exists c in set ((ar.paths)(pid).condition) \u0026 (((c.kind) \u003d kind) and (((c.start) \u003d start) and ((c.endp) \u003d endp)))))\n\tpost ((pid in set (dom (RESULT.paths))) and (((dom (RESULT.paths)) \u003d (dom (ar.paths))) and ((({pid} \u003c-: (RESULT.paths)) \u003d ({pid} \u003c-: (ar.paths))) and (((RESULT.paths)(pid) \u003d mu((ar.paths)(pid), condition |-\u003e {l | l in set ((ar.paths)(pid).condition) \u0026 (not (((l.kind) \u003d kind) and (((l.start) \u003d start) and ((l.endp) \u003d endp))))})) and ((((RESULT.paths)(pid).start) \u003d ((ar.paths)(pid).start)) and ((((RESULT.paths)(pid).endp) \u003d ((ar.paths)(pid).endp)) and ((((RESULT.paths)(pid).tc) \u003d ((ar.paths)(pid).tc)) and ((((RESULT.paths)(pid).length) \u003d ((ar.paths)(pid).length)) and (((RESULT.trackcs) \u003d (ar.trackcs)) and ((RESULT.routes) \u003d (ar.routes)))))))))))","Line \u003d Line\n\tinv mk_Line(areas, connect) \u003d\u003d (forall c in set (dom connect) \u0026 ((forall n in set c \u0026 Area_Joint_Exists(areas, n)) and (forall n1, n2 in set c \u0026 ((n1 \u003c\u003e n2) \u003d\u003e (Direction_for_Area_Joint((areas((n1.aid)).paths), (n1.no), (areas((n2.aid)).paths), (n2.no), (connect(c).chng_direction)) and let tc1:TrackC \u003d (areas((n1.aid)).trackcs)((n1.tcid)), tc2:TrackC \u003d (areas((n2.aid)).trackcs)((n2.tcid)) in (Joint_Compatible((tc1.joints)((n1.no)), (tc2.joints)((n2.no)), connect(c)) and Is_wf_adjacent_signal(tc1, (n1.no), tc2, (n2.no), (connect(c).chng_direction))))))))","Area_map \u003d Area_map","Area_id \u003d Area_id","Area_Joint \u003d Area_Joint","Connect \u003d Connect\n\tinv con \u003d\u003d (((card con) \u003d 2) and (forall a1, a2 in set con \u0026 ((a1 \u003c\u003e a2) \u003d\u003e ((a1.aid) \u003c\u003e (a2.aid)))))","Connect_map \u003d Connect_map\n\tinv con \u003d\u003d (forall a1, a2 in set (dom con) \u0026 ((a1 \u003c\u003e a2) \u003d\u003e ((a1 inter a2) \u003d {})))","Remark_Connect \u003d Remark_Connect","private Area_Joint_Exists: (Area_map * Area_Joint -\u003e bool)\n\tArea_Joint_Exists(areas, n) \u003d\u003d\n(((n.aid) in set (dom areas)) and (((n.tcid) in set (dom (areas((n.aid)).trackcs))) and (((n.no) in set (dom ((areas((n.aid)).trackcs)((n.tcid)).joints))) and ((not ((((areas((n.aid)).trackcs)((n.tcid)).joints)((n.no)).remark).line_terminal)) and (forall tcid in set (dom (areas((n.aid)).trackcs)) \u0026 (((n.tcid) \u003c\u003e tcid) \u003d\u003e ((n.no) not in set (dom ((areas((n.aid)).trackcs)(tcid).joints)))))))))","private Direction_for_Area_Joint: (Path_map * Joint_id * Path_map * Joint_id * bool -\u003e bool)\n\tDirection_for_Area_Joint(pm1, n1, pm2, n2, chng_dir) \u003d\u003d\n(forall p1 in set (rng pm1), p2 in set (rng pm2) \u0026 (((((p1.start) \u003d n1) and ((p2.start) \u003d n2)) \u003d\u003e chng_dir) and (((((p1.endp) \u003d n1) and ((p2.endp) \u003d n2)) \u003d\u003e chng_dir) and (((((p1.start) \u003d n1) and ((p2.endp) \u003d n2)) \u003d\u003e (not chng_dir)) and ((((p1.endp) \u003d n1) and ((p2.start) \u003d n2)) \u003d\u003e (not chng_dir))))))","private Joint_Compatible: (Joint * Joint * Remark_Connect -\u003e bool)\n\tJoint_Compatible(j1, j2, rm) \u003d\u003d\n(((j1.insulated) \u003d (j2.insulated)) and ((((j1.position) \u003c\u003e (j2.position)) \u003d (rm.chng_distance)) and Remark_Compatible((j1.remark), (j2.remark), (rm.chng_direction))))","private Add_Area: (Line * Area_id * Area_Kind * MaxSpeed -\u003e Line)\n\tAdd_Area(ln, aid, kind, max) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e mk_Area({|-\u003e}, {|-\u003e}, {|-\u003e}, kind, max)}))\n\tpre (aid not in set (dom (ln.areas)))\n\tpost ((aid in set (dom (RESULT.areas))) and ((RESULT.connect) \u003d (ln.connect)))","private Change_Area: (Line * Area_id * Area -\u003e Line)\n\tChange_Area(ln, aid, area) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e area}))\n\tpre ((aid in set (dom (ln.areas))) and inv_Line(mk_Line(((ln.areas) ++ {aid |-\u003e area}), (ln.connect))))\n\tpost (((RESULT.areas)(aid) \u003d area) and ((RESULT.connect) \u003d (ln.connect)))","private Del_Area: (Line * Area_id -\u003e Line)\n\tDel_Area(ln, aid) \u003d\u003d\nmu(ln, areas |-\u003e ({aid} \u003c-: (ln.areas)))\n\tpre ((aid in set (dom (ln.areas))) and (forall c in set (dom (ln.connect)) \u0026 (forall aj in set c \u0026 ((aj.aid) \u003c\u003e aid))))\n\tpost ((aid not in set (dom (RESULT.areas))) and ((RESULT.connect) \u003d (ln.connect)))","private Add_Connect: (Line * Connect * Remark_Connect -\u003e Line)\n\tAdd_Connect(ln, con, r) \u003d\u003d\nmu(ln, connect |-\u003e ((ln.connect) ++ {con |-\u003e r}))\n\tpre ((forall c in set (dom (ln.connect)) \u0026 ((c inter con) \u003d {})) and ((forall n in set con \u0026 Area_Joint_Exists((ln.areas), n)) and (forall n1, n2 in set con \u0026 ((n1 \u003c\u003e n2) \u003d\u003e (Direction_for_Area_Joint(((ln.areas)((n1.aid)).paths), (n1.no), ((ln.areas)((n2.aid)).paths), (n2.no), (r.chng_direction)) and let tc1:TrackC \u003d ((ln.areas)((n1.aid)).trackcs)((n1.tcid)), tc2:TrackC \u003d ((ln.areas)((n2.aid)).trackcs)((n2.tcid)) in (Joint_Compatible((tc1.joints)((n1.no)), (tc2.joints)((n2.no)), r) and Is_wf_adjacent_signal(tc1, (n1.no), tc2, (n2.no), (r.chng_direction))))))))\n\tpost ((con in set (dom (RESULT.connect))) and (((RESULT.connect) \u003d ((ln.connect) ++ {con |-\u003e r})) and (((RESULT.connect)(con) \u003d r) and ((RESULT.areas) \u003d (ln.areas)))))","private Del_Connect: (Line * Area_Joint -\u003e Line)\n\tDel_Connect(ln, n) \u003d\u003d\nmu(ln, connect |-\u003e {c |-\u003e (ln.connect)(c) | c in set (dom (ln.connect)) \u0026 (n not in set c)})\n\tpre (exists c in set (dom (ln.connect)) \u0026 (n in set c))\n\tpost (forall c in set (dom (RESULT.connect)) \u0026 ((n not in set c) and ((RESULT.areas) \u003d (ln.areas))))","private Line_Add_TrackC: (Line * Area_id * TrackC_id * TrackC -\u003e Line)\n\tLine_Add_TrackC(ln, aid, tcid, tc) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Add_TrackC((ln.areas)(aid), tcid, tc)}))\n\tpre ((aid in set (dom (ln.areas))) and (pre_Add_TrackC((ln.areas)(aid), tcid, tc) and (forall jid in set (dom (tc.joints)) \u0026 (forall c in set (dom (ln.connect)) \u0026 (forall n in set c \u0026 (((n.aid) \u003d aid) \u003d\u003e ((n.no) \u003c\u003e jid)))))))\n\tpost ((aid in set (dom (RESULT.areas))) and (((dom (ln.areas)) \u003d (dom (RESULT.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((tcid in set (dom ((RESULT.areas)(aid).trackcs))) and ((((RESULT.areas)(aid).trackcs) \u003d (((ln.areas)(aid).trackcs) ++ {tcid |-\u003e tc})) and ((((RESULT.areas)(aid).trackcs)(tcid) \u003d tc) and ((RESULT.connect) \u003d (ln.connect))))))))","private Line_Del_TrackC: (Line * Area_id * TrackC_id -\u003e Line)\n\tLine_Del_TrackC(ln, aid, tcid) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Del_TrackC((ln.areas)(aid), tcid)}))\n\tpre ((aid in set (dom (ln.areas))) and (pre_Del_TrackC((ln.areas)(aid), tcid) and (forall c in set (dom (ln.connect)) \u0026 (forall aj in set c \u0026 (((aj.aid) \u003d aid) \u003d\u003e ((aj.tcid) \u003c\u003e tcid))))))\n\tpost ((aid in set (dom (RESULT.areas))) and (((dom (ln.areas)) \u003d (dom (RESULT.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((((RESULT.areas)(aid).trackcs) \u003d ({tcid} \u003c-: ((ln.areas)(aid).trackcs))) and ((tcid not in set (dom ((RESULT.areas)(aid).trackcs))) and ((RESULT.connect) \u003d (ln.connect)))))))","private Line_Add_Joint: (Line * Area_id * TrackC_id * Joint_id * Joint -\u003e Line)\n\tLine_Add_Joint(ln, aid, tcid, jid, j) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Add_Joint((ln.areas)(aid), tcid, jid, j)}))\n\tpre ((aid in set (dom (ln.areas))) and (pre_Add_Joint((ln.areas)(aid), tcid, jid, j) and (forall c in set (dom (ln.connect)) \u0026 (forall n in set c \u0026 (((n.aid) \u003d aid) \u003d\u003e ((n.no) \u003c\u003e jid))))))\n\tpost ((aid in set (dom (RESULT.areas))) and ((tcid in set (dom ((RESULT.areas)(aid).trackcs))) and ((jid in set (dom (((RESULT.areas)(aid).trackcs)(tcid).joints))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and (((dom ((RESULT.areas)(aid).trackcs)) \u003d (dom ((ln.areas)(aid).trackcs))) and ((({tcid} \u003c-: ((RESULT.areas)(aid).trackcs)) \u003d ({tcid} \u003c-: ((ln.areas)(aid).trackcs))) and (((((RESULT.areas)(aid).trackcs)(tcid).joints) \u003d ((((ln.areas)(aid).trackcs)(tcid).joints) ++ {jid |-\u003e j})) and (((((RESULT.areas)(aid).trackcs)(tcid).joints)(jid) \u003d j) and ((RESULT.connect) \u003d (ln.connect)))))))))))","private Line_Del_Joint: (Line * Area_id * TrackC_id * Joint_id -\u003e Line)\n\tLine_Del_Joint(ln, aid, tcid, jid) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Del_Joint((ln.areas)(aid), tcid, jid)}))\n\tpre ((aid in set (dom (ln.areas))) and (pre_Del_Joint((ln.areas)(aid), tcid, jid) and (forall c in set (dom (ln.connect)) \u0026 (forall aj in set c \u0026 ((((aj.aid) \u003d aid) and ((aj.tcid) \u003d tcid)) \u003d\u003e ((aj.no) \u003c\u003e jid))))))\n\tpost ((aid in set (dom (RESULT.areas))) and ((tcid in set (dom ((RESULT.areas)(aid).trackcs))) and ((jid not in set (dom (((RESULT.areas)(aid).trackcs)(tcid).joints))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and (((dom ((RESULT.areas)(aid).trackcs)) \u003d (dom ((ln.areas)(aid).trackcs))) and ((({tcid} \u003c-: ((RESULT.areas)(aid).trackcs)) \u003d ({tcid} \u003c-: ((ln.areas)(aid).trackcs))) and (((((RESULT.areas)(aid).trackcs)(tcid).joints) \u003d ({jid} \u003c-: (((ln.areas)(aid).trackcs)(tcid).joints))) and ((RESULT.connect) \u003d (ln.connect))))))))))","private Line_Add_Path: (Line * Area_id * Path_id * Path -\u003e Line)\n\tLine_Add_Path(ln, aid, pid, p) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Add_Path((ln.areas)(aid), pid, p)}))\n\tpre ((aid in set (dom (ln.areas))) and (pre_Add_Path((ln.areas)(aid), pid, p) and (forall c in set (dom (ln.connect)) \u0026 (forall n1, n2 in set c \u0026 (((n1 \u003c\u003e n2) and ((n1.aid) \u003d aid)) \u003d\u003e Direction_for_Area_Joint({pid |-\u003e p}, (n1.no), ((ln.areas)((n2.aid)).paths), (n2.no), ((ln.connect)(c).chng_direction)))))))\n\tpost ((aid in set (dom (RESULT.areas))) and ((pid in set (dom ((RESULT.areas)(aid).paths))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((((RESULT.areas)(aid).paths) \u003d (((ln.areas)(aid).paths) ++ {pid |-\u003e p})) and ((((RESULT.areas)(aid).paths)(pid) \u003d p) and ((RESULT.connect) \u003d (ln.connect))))))))","private Line_Del_Path: (Line * Area_id * Path_id -\u003e Line)\n\tLine_Del_Path(ln, aid, pid) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Del_Path((ln.areas)(aid), pid)}))\n\tpre ((aid in set (dom (ln.areas))) and pre_Del_Path((ln.areas)(aid), pid))\n\tpost ((aid in set (dom (RESULT.areas))) and ((pid not in set (dom ((RESULT.areas)(aid).paths))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((((RESULT.areas)(aid).paths) \u003d ({pid} \u003c-: ((ln.areas)(aid).paths))) and ((RESULT.connect) \u003d (ln.connect)))))))","private Line_Add_Route: (Line * Area_id * Route_id * Route -\u003e Line)\n\tLine_Add_Route(ln, aid, rid, r) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Add_Route((ln.areas)(aid), rid, r)}))\n\tpre ((aid in set (dom (ln.areas))) and pre_Add_Route((ln.areas)(aid), rid, r))\n\tpost ((aid in set (dom (RESULT.areas))) and ((rid in set (dom ((RESULT.areas)(aid).routes))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((((RESULT.areas)(aid).routes) \u003d (((ln.areas)(aid).routes) ++ {rid |-\u003e r})) and ((((RESULT.areas)(aid).routes)(rid) \u003d r) and ((RESULT.connect) \u003d (ln.connect))))))))","private Line_Del_Route: (Line * Area_id * Route_id -\u003e Line)\n\tLine_Del_Route(ln, aid, rid) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Del_Route((ln.areas)(aid), rid)}))\n\tpre ((aid in set (dom (ln.areas))) and pre_Del_Route((ln.areas)(aid), rid))\n\tpost ((aid in set (dom (RESULT.areas))) and (((dom (RESULT.areas)) \u003d (dom (ln.areas))) and ((({aid} \u003c-: (RESULT.areas)) \u003d ({aid} \u003c-: (ln.areas))) and ((rid not in set (dom ((RESULT.areas)(aid).routes))) and ((((RESULT.areas)(aid).routes) \u003d ({rid} \u003c-: ((ln.areas)(aid).routes))) and ((RESULT.connect) \u003d (ln.connect)))))))","private Line_Add_Condition: (Line * Area_id * Path_id * Condition -\u003e Line)\n\tLine_Add_Condition(ln, aid, pid, con) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Add_Condition((ln.areas)(aid), pid, con)}))\n\tpre ((aid in set (dom (ln.areas))) and pre_Add_Condition((ln.areas)(aid), pid, con))","private Line_Del_Condition: (Line * Area_id * Path_id * Cond_Kind * nat * nat -\u003e Line)\n\tLine_Del_Condition(ln, aid, pid, kind, start, endp) \u003d\u003d\nmu(ln, areas |-\u003e ((ln.areas) ++ {aid |-\u003e Del_Condition((ln.areas)(aid), pid, kind, start, endp)}))\n\tpre ((aid in set (dom (ln.areas))) and pre_Del_Condition((ln.areas)(aid), pid, kind, start, endp))","private Is_wf_Line_DB: (Line -\u003e bool)\n\tIs_wf_Line_DB(ln) \u003d\u003d\n((forall aid in set (dom (ln.areas)) \u0026 let ar:Area \u003d (ln.areas)(aid) in (Joint_Completed((ar.trackcs), aid, (ln.connect)) and (Path_Exists_for_Joint((ar.trackcs), (ar.paths)) and (Path_Exists_for_TrackC((ar.trackcs), (ar.paths)) and (Route_Exists_for_Path(ar) and (Path_Exists_before_Start(ar, aid, (ln.connect)) and (Path_Exists_after_End(ar, aid, (ln.connect)) and (Route_Exists_to_Terminal(ar, aid, (ln.connect)) and (((ar.kind) \u003d \u003cPLAIN\u003e) \u003d\u003e Is_Plain_Area(ar, aid, (ln.connect))))))))))) and (Following_Path_Exists_at_Connect(ln) and (Preceding_Path_Exists_at_Connect(ln) and One_Side_Unique_Path_at_Connection(ln))))","private Joint_Completed: (TrackC_map * Area_id * Connect_map -\u003e bool)\n\tJoint_Completed(trackcs, aid, connect) \u003d\u003d\n(forall tid in set (dom trackcs) \u0026 let tc:TrackC \u003d trackcs(tid) in (forall jid in set (dom (tc.joints)) \u0026 ((not (exists tcid in set (dom trackcs) \u0026 ((tcid \u003c\u003e tid) and (jid in set (dom (trackcs(tcid).joints)))))) \u003d\u003e ((mk_Area_Joint(aid, tid, jid) in set (dunion (dom connect))) or (((tc.joints)(jid).remark).line_terminal)))))","private Path_Exists_for_Joint: (TrackC_map * Path_map -\u003e bool)\n\tPath_Exists_for_Joint(trackcs, paths) \u003d\u003d\n(forall tid in set (dom trackcs) \u0026 (forall jid in set (dom (trackcs(tid).joints)) \u0026 (exists p in set (rng paths) \u0026 (((p.tc) \u003d tid) and (((p.start) \u003d jid) or ((p.endp) \u003d jid))))))","private Path_Exists_for_TrackC: (TrackC_map * Path_map -\u003e bool)\n\tPath_Exists_for_TrackC(trackcs, paths) \u003d\u003d\n(forall tid in set (dom trackcs) \u0026 (forall dr in set (dom (trackcs(tid).atc)) \u0026 (((trackcs(tid).atc)(dr).used) \u003d\u003e (exists p in set (rng paths) \u0026 (((p.tc) \u003d tid) and (p.used)(dr))))))","private Route_Exists_for_Path: (Area -\u003e bool)\n\tRoute_Exists_for_Path(ar) \u003d\u003d\n(forall pid in set (dom (ar.paths)) \u0026 (forall dr in set (dom ((ar.paths)(pid).used)) \u0026 (((ar.paths)(pid).used)(dr) \u003d\u003e ((((ar.trackcs)(((ar.paths)(pid).tc)).atc)(dr).used) \u003d\u003e (exists r in set (rng (ar.routes)) \u0026 (((r.dr) \u003d dr) and (pid in set (elems (r.paths)))))))))","private Path_Exists_before_Start: (Area * Area_id * Connect_map -\u003e bool)\n\tPath_Exists_before_Start(ar, aid, connect) \u003d\u003d\n(forall pid in set (dom (ar.paths)) \u0026 let p:Path \u003d (ar.paths)(pid) in (forall dr in set (dom (p.used)) \u0026 ((p.used)(dr) \u003d\u003e ((mk_Area_Joint(aid, (p.tc), (p.start)) in set (dunion (dom connect))) or (((((ar.trackcs)((p.tc)).joints)((p.start)).remark).line_terminal) or (((((ar.trackcs)((p.tc)).joints)((p.start)).remark).atc_terminal)(dr) or (exists pid1 in set (dom (ar.paths)) \u0026 let p1:Path \u003d (ar.paths)(pid1) in (((p1.tc) \u003c\u003e (p.tc)) and ((p1.used)(dr) and ((p1.endp) \u003d (p.start)))))))))))","private Path_Exists_after_End: (Area * Area_id * Connect_map -\u003e bool)\n\tPath_Exists_after_End(ar, aid, connect) \u003d\u003d\n(forall pid in set (dom (ar.paths)) \u0026 let p:Path \u003d (ar.paths)(pid) in (forall dr in set (dom (p.used)) \u0026 ((p.used)(dr) \u003d\u003e ((mk_Area_Joint(aid, (p.tc), (p.endp)) in set (dunion (dom connect))) or (((((ar.trackcs)((p.tc)).joints)((p.endp)).remark).line_terminal) or (((((ar.trackcs)((p.tc)).joints)((p.endp)).remark).atc_terminal)(dr) or (exists pid1 in set (dom (ar.paths)) \u0026 let p1:Path \u003d (ar.paths)(pid1) in (((p1.tc) \u003c\u003e (p.tc)) and ((p1.used)(dr) and ((p1.start) \u003d (p.endp)))))))))))","private StartJoint: (Path * Direction -\u003e Joint_id)\n\tStartJoint(path, dr) \u003d\u003d\n(if (dr \u003d \u003cADIR\u003e)\nthen (path.start)\nelse (path.endp))\n\tpost (((dr \u003d \u003cADIR\u003e) \u003d\u003e (RESULT \u003d (path.start))) and ((dr \u003d \u003cBDIR\u003e) \u003d\u003e (RESULT \u003d (path.endp))))","private EndJoint: (Path * Direction -\u003e Joint_id)\n\tEndJoint(path, dr) \u003d\u003d\n(if (dr \u003d \u003cADIR\u003e)\nthen (path.endp)\nelse (path.start))\n\tpost (((dr \u003d \u003cADIR\u003e) \u003d\u003e (RESULT \u003d (path.endp))) and ((dr \u003d \u003cBDIR\u003e) \u003d\u003e (RESULT \u003d (path.start))))","private Route_Exists_to_Terminal: (Area * Area_id * Connect_map -\u003e bool)\n\tRoute_Exists_to_Terminal(ar, aid, connect) \u003d\u003d\n(forall rid in set (dom (ar.routes)) \u0026 let r:Route \u003d (ar.routes)(rid) in let pid:Path_id \u003d (r.paths)((len (r.paths))) in let jid:Joint_id \u003d EndJoint((ar.paths)(pid), (r.dr)), tcid:TrackC_id \u003d ((ar.paths)(pid).tc) in ((mk_Area_Joint(aid, tcid, jid) in set (dunion (dom connect))) or (((((ar.trackcs)(tcid).joints)(jid).remark).line_terminal) or (((((ar.trackcs)(tcid).joints)(jid).remark).atc_terminal)((r.dr)) or (Following_Route_Exists((ar.routes), rid) or Following_Path_Unique((ar.paths), pid, (r.dr)))))))","private Following_Route_Exists: (Route_map * Route_id -\u003e bool)\n\tFollowing_Route_Exists(routes, rid) \u003d\u003d\n(exists rid1 in set (dom routes) \u0026 let r:Route \u003d routes(rid), r1:Route \u003d routes(rid1) in (((r1.dr) \u003d (r.dr)) and (exists i in set (inds (r1.paths)) \u0026 (((r1.paths)(i) \u003d (r.paths)((len (r.paths)))) and (i \u003c (len (r1.paths)))))))\n\tpre (rid in set (dom routes))","private Following_Path_Unique: (Path_map * Path_id * Direction -\u003e bool)\n\tFollowing_Path_Unique(paths, pid, dr) \u003d\u003d\n(exists1 pid1 in set (dom paths) \u0026 (((paths(pid1).tc) \u003c\u003e (paths(pid).tc)) and ((paths(pid1).used)(dr) and (EndJoint(paths(pid), dr) \u003d StartJoint(paths(pid1), dr)))))\n\tpre (pid in set (dom paths))","private Is_Plain_Area: (Area * Area_id * Connect_map -\u003e bool)\n\tIs_Plain_Area(ar, aid, connect) \u003d\u003d\n((forall tcid in set (dom (ar.trackcs)) \u0026 (forall dr in set (dom ((ar.trackcs)(tcid).atc)) \u0026 ((((ar.trackcs)(tcid).atc)(dr).used) \u003d\u003e (exists1 rid in set (dom (ar.routes)) \u0026 ((((ar.routes)(rid).dr) \u003d dr) and (exists pid in set (elems ((ar.routes)(rid).paths)) \u0026 (((ar.paths)(pid).tc) \u003d tcid))))))) and (forall r in set (rng (ar.routes)) \u0026 let p:Path \u003d (ar.paths)((r.paths)((len (r.paths)))) in let jid:Joint_id \u003d EndJoint(p, (r.dr)) in ((mk_Area_Joint(aid, (p.tc), jid) in set (dunion (dom connect))) or (((((ar.trackcs)((p.tc)).joints)(jid).remark).line_terminal) or ((((ar.trackcs)((p.tc)).joints)(jid).remark).atc_terminal)((r.dr))))))","private One_Side_Unique_Path_at_Connection: (Line -\u003e bool)\n\tOne_Side_Unique_Path_at_Connection(ln) \u003d\u003d\n(forall con in set (dom (ln.connect)) \u0026 (forall n1, n2 in set con \u0026 ((n1 \u003c\u003e n2) \u003d\u003e (forall dr in set {\u003cADIR\u003e, \u003cBDIR\u003e} \u0026 (((card {p | p in set (rng ((ln.areas)((n1.aid)).paths)) \u0026 ((p.used)(dr) and (EndJoint(p, dr) \u003d (n1.no)))}) \u003e 1) \u003d\u003e ((((((ln.areas)((n1.aid)).trackcs)((n1.tcid)).joints)((n1.no)).remark).atc_terminal)(dr) or let dr2:(\u003cADIR\u003e | \u003cBDIR\u003e) \u003d (if (not ((ln.connect)(con).chng_direction))\nthen dr\nelse (if (dr \u003d \u003cADIR\u003e)\nthen \u003cBDIR\u003e\nelse \u003cADIR\u003e)) in ((card {p | p in set (rng ((ln.areas)((n2.aid)).paths)) \u0026 ((p.used)(dr2) and (StartJoint(p, dr2) \u003d (n2.no)))}) \u003d 1)))))))","private Following_Path_Exists_at_Connect: (Line -\u003e bool)\n\tFollowing_Path_Exists_at_Connect(ln) \u003d\u003d\n(forall con in set (dom (ln.connect)) \u0026 (forall n1, n2 in set con \u0026 ((n1 \u003c\u003e n2) \u003d\u003e (forall dr in set {\u003cADIR\u003e, \u003cBDIR\u003e} \u0026 ((exists p in set (rng ((ln.areas)((n1.aid)).paths)) \u0026 ((p.used)(dr) and (EndJoint(p, dr) \u003d (n1.no)))) \u003d\u003e ((((((ln.areas)((n1.aid)).trackcs)((n1.tcid)).joints)((n1.no)).remark).atc_terminal)(dr) or (exists p2 in set (rng ((ln.areas)((n2.aid)).paths)) \u0026 let dr2:(\u003cADIR\u003e | \u003cBDIR\u003e) \u003d (if (not ((ln.connect)(con).chng_direction))\nthen dr\nelse (if (dr \u003d \u003cADIR\u003e)\nthen \u003cBDIR\u003e\nelse \u003cADIR\u003e)) in ((p2.used)(dr2) and (StartJoint(p2, dr2) \u003d (n2.no))))))))))","private Preceding_Path_Exists_at_Connect: (Line -\u003e bool)\n\tPreceding_Path_Exists_at_Connect(ln) \u003d\u003d\n(forall con in set (dom (ln.connect)) \u0026 (forall n1, n2 in set con \u0026 ((n1 \u003c\u003e n2) \u003d\u003e (forall dr in set {\u003cADIR\u003e, \u003cBDIR\u003e} \u0026 ((exists p in set (rng ((ln.areas)((n1.aid)).paths)) \u0026 ((p.used)(dr) and (StartJoint(p, dr) \u003d (n1.no)))) \u003d\u003e ((((((ln.areas)((n1.aid)).trackcs)((n1.tcid)).joints)((n1.no)).remark).atc_terminal)(dr) or (exists p2 in set (rng ((ln.areas)((n2.aid)).paths)) \u0026 let dr2:(\u003cADIR\u003e | \u003cBDIR\u003e) \u003d (if (not ((ln.connect)(con).chng_direction))\nthen dr\nelseif (dr \u003d \u003cADIR\u003e)\nthen \u003cBDIR\u003e\nelse \u003cADIR\u003e) in ((p2.used)(dr2) and (EndJoint(p2, dr2) \u003d (n2.no))))))))))"]