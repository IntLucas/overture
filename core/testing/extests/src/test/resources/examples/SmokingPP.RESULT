["class AllT\npublic  run() (() \u003d\u003d\u003e bool)\n\trun()() \u003d\u003d\nlet ResultOfTest:seq1 of (bool) \u003d [(new TermT().run)(), (new TimeT().run)(), (new MapT().run)(), (new HashtableT().run)(), (new FHashtableT().run)(), (new DoubleListQueueT().run)(), (new QueueT().run)(), (new ＵｎｉｑｕｅＮｕｍｂｅｒＴ().run)(), (new RealT().run)(), (new SetT().run)(), (new SequenceT().run)(), (new StringT().run)(), (new IntegerT().run)(), (new NumberT().run)(), (new CalendarT().run)(), (new SBCalendarT().run)(), (new DateT().run)(), (new FunctionT().run)()], Message:seq1 of (char) \u003d \"Result of all test cases.\" in if (forall i in set (inds ResultOfTest) \u0026 ResultOfTest(i))\nthen\nreturn ((new TestLogger().succeededInAllTestcases)(Message))else\nreturn ((new TestLogger().notSucceededInAllTestcases)(Message))\nend AllT\n","class CalendarDefinition\npublic static  homedir:seq1 of (char) \u003d \".\"\npublic static  NameOfDayOfTheWeek \u003d NameOfDayOfTheWeek\npublic static  NumberOfDayOfTheWeek \u003d NumberOfDayOfTheWeek\n\tinv d \u003d\u003d (d \u003c\u003d 6)\nend CalendarDefinition\n","class Calendar is subclass of [CalendarDefinition]\nprivate static  daysDifferenceOfModifiedJulianDate:real \u003d 2400000.5\nprivate static  namesOfDayOfTheWeek:seq1 of ((\u003cFri\u003e | \u003cMon\u003e | \u003cSat\u003e | \u003cSun\u003e | \u003cThu\u003e | \u003cTue\u003e | \u003cWed\u003e)) \u003d [\u003cSun\u003e, \u003cMon\u003e, \u003cTue\u003e, \u003cWed\u003e, \u003cThu\u003e, \u003cFri\u003e, \u003cSat\u003e]\nprivate static  daysInYear:real \u003d 365.25\nprotected static  monthsInYear:nat1 \u003d 12\nprivate static  correctedMonths:nat1 \u003d 14\nprivate static  daysInWeek:nat1 \u003d 7\nprivate static  averageDaysInMonth:real \u003d 30.6001\nprivate static  yearInCentury:nat1 \u003d 100\nprivate static  calculationCoefficientOfDate:real \u003d 122.1\nprivate static  calculationCoefficientOfYear:nat1 \u003d 4800\nprivate static  centuryCalculationCoefficient:real \u003d 32044.9\nprivate static  theDayBeforeGregorioCalendarStarted:nat1 \u003d 2299160.0\nprivate static  theFirstDayOfGregorioCalendar:real \u003d 1582.78\nprivate static  io:IO \u003d new IO()\nprotected  differenceWithGMT:real :\u003d 0\nprotected  iToday:[Date] :\u003d nil\nprotected  Year2Holidays:map (int) to (set of (Date)) :\u003d {|-\u003e}\npublic  public LT: (Date * Date -\u003e bool)\n\tLT(date1, date2) \u003d\u003d\n((date1.getModifiedJulianDate)() \u003c (date2.getModifiedJulianDate)())\npublic  public GT: (Date * Date -\u003e bool)\n\tGT(date1, date2) \u003d\u003d\n((date1.getModifiedJulianDate)() \u003e (date2.getModifiedJulianDate)())\npublic  public LE: (Date * Date -\u003e bool)\n\tLE(date1, date2) \u003d\u003d\n(not GT(date1, date2))\npublic  public GE: (Date * Date -\u003e bool)\n\tGE(date1, date2) \u003d\u003d\n(not LT(date1, date2))\npublic  public EQ: (Date * Date -\u003e bool)\n\tEQ(date1, date2) \u003d\u003d\n((date1.getModifiedJulianDate)() \u003d (date2.getModifiedJulianDate)())\npublic  public min: (Date -\u003e (Date -\u003e Date))\n\tmin(date1)(date2) \u003d\u003d\n(if (date1.LT)(date2)\nthen date1\nelse date2)\npublic  public max: (Date -\u003e (Date -\u003e Date))\n\tmax(date1)(date2) \u003d\u003d\n(if (date1.GT)(date2)\nthen date1\nelse date2)\npublic  public isDateString: (seq of (char) -\u003e bool)\n\tisDateString(yyyymmdd) \u003d\u003d\n(if (getDateFromString(yyyymmdd) \u003d false)\nthen false\nelse true)\npublic  public isLeapYear: (int -\u003e bool)\n\tisLeapYear(year) \u003d\u003d\n(((year mod 400) \u003d 0) or (((year mod yearInCentury) \u003c\u003e 0) and ((year mod 4) \u003d 0)))\npublic  public getNumberOfDayOfTheWeek: (Date -\u003e NumberOfDayOfTheWeek)\n\tgetNumberOfDayOfTheWeek(date) \u003d\u003d\nlet modifiedJulianDate:int \u003d (floor (date.getModifiedJulianDate)()) in ((modifiedJulianDate - 4) mod daysInWeek)\npublic  public getYyyymmdd: (Date -\u003e (int * int * int))\n\tgetYyyymmdd(date) \u003d\u003d\nmk_(Year(date), Month(date), day(date))\npublic  public getNameOfDayOfTheWeek: (Date -\u003e NameOfDayOfTheWeek)\n\tgetNameOfDayOfTheWeek(date) \u003d\u003d\nnamesOfDayOfTheWeek((getNumberOfDayOfTheWeek(date) + 1))\npublic  public getNumberOfDayOfTheWeekFromName: (NameOfDayOfTheWeek -\u003e NumberOfDayOfTheWeek)\n\tgetNumberOfDayOfTheWeekFromName(nameOfDayOfTheWeek) \u003d\u003d\n((Sequence`Index)[NameOfDayOfTheWeek](nameOfDayOfTheWeek)(namesOfDayOfTheWeek) - 1)\npublic  public firstDayOfTheWeekInMonth: (int * int * NameOfDayOfTheWeek -\u003e Date)\n\tfirstDayOfTheWeekInMonth(year, month, nameOfDayOfTheWeek) \u003d\u003d\nlet numberOfDayOfTheWeek:NumberOfDayOfTheWeek \u003d getNumberOfDayOfTheWeekFromName(nameOfDayOfTheWeek), firstDayOfMonth:Date \u003d getFirstDayOfMonth(year, month), diff:int \u003d (numberOfDayOfTheWeek - getNumberOfDayOfTheWeek(firstDayOfMonth)) in (cases true :\n((diff \u003d 0)) -\u003e firstDayOfMonth,\n((diff \u003e 0)) -\u003e (firstDayOfMonth.plus)(diff),\n((diff \u003c 0)) -\u003e (firstDayOfMonth.plus)(((daysInWeek + diff) mod daysInWeek))\n end)\npublic  public lastDayOfTheWeekInMonth: (int * int * NameOfDayOfTheWeek -\u003e Date)\n\tlastDayOfTheWeekInMonth(year, month, nameOfDayOfTheWeek) \u003d\u003d\n(firstDayOfTheWeekInMonth(year, (month + 1), nameOfDayOfTheWeek).minus)(daysInWeek)\npublic  public getNthDayOfTheWeek: (int * int * int * NameOfDayOfTheWeek -\u003e (Date | bool))\n\tgetNthDayOfTheWeek(aYear, aMonth, n, nameOfDayOfTheWeek) \u003d\u003d\nlet firstDayOfMonth:Date \u003d firstDayOfTheWeekInMonth(aYear, aMonth, nameOfDayOfTheWeek), r:Date \u003d (firstDayOfMonth.plus)((daysInWeek * (n - 1))) in (cases Month(r) :\n(aMonth) -\u003e r\nothers false\n end)\npublic  public getFirstDayOfMonth: (int * int -\u003e Date)\n\tgetFirstDayOfMonth(year, month) \u003d\u003d\ngetRegularDate(year, month, 1)\npublic  public getLastDayOfMonth: (int * int -\u003e Date)\n\tgetLastDayOfMonth(year, month) \u003d\u003d\n(getRegularDate(year, (month + 1), 1).minus)(1)\npublic  public isSunday: (Date -\u003e bool)\n\tisSunday(date) \u003d\u003d\n(getNumberOfDayOfTheWeek(date) \u003d 0)\npublic  public isSaturday: (Date -\u003e bool)\n\tisSaturday(date) \u003d\u003d\n(getNumberOfDayOfTheWeek(date) \u003d 6)\npublic  public isWeekday: (Date -\u003e bool)\n\tisWeekday(date) \u003d\u003d\n(getNumberOfDayOfTheWeek(date) in set {1, ... ,5})\npublic  public isNotDayOff: (Date -\u003e bool)\n\tisNotDayOff(date) \u003d\u003d\n(not isSundayOrDayoff(date))\npublic  public isWeekday: (NameOfDayOfTheWeek -\u003e bool)\n\tisWeekday(nameOfDayOfTheWeek) \u003d\u003d\n(nameOfDayOfTheWeek not in set {\u003cSat\u003e, \u003cSun\u003e})\npublic  public getNumberOfTheDayOfWeek: (Date * Date * NameOfDayOfTheWeek -\u003e int)\n\tgetNumberOfTheDayOfWeek(date1, date2, nameOfDayOfTheWeek) \u003d\u003d\nlet numberOfDayOfTheWeek:NumberOfDayOfTheWeek \u003d getNumberOfDayOfTheWeekFromName(nameOfDayOfTheWeek), startDate:Date \u003d min(date1)(date2), endDate:Date \u003d max(date1)(date2), numOfDays:int \u003d (diffOfDates(endDate, startDate) + 1), quotient:int \u003d (numOfDays div daysInWeek), remainder:int \u003d (numOfDays mod daysInWeek), delta:nat \u003d (if ((subtractDayOfTheWeek(numberOfDayOfTheWeek, getNumberOfDayOfTheWeek(startDate)) + 1) \u003c\u003d remainder)\nthen 1\nelse 0) in (quotient + delta)\nprivate  private subtractDayOfTheWeek: (int * int -\u003e int)\n\tsubtractDayOfTheWeek(x, y) \u003d\u003d\n(if (x \u003e\u003d y)\nthen (x - y)\nelse ((x - y) + daysInWeek))\npublic  public Year: (Date -\u003e int)\n\tYear(date) \u003d\u003d\n(if (monthAux(date) \u003c correctedMonths)\nthen (yearAux(date) - calculationCoefficientOfYear)\nelse ((yearAux(date) - calculationCoefficientOfYear) + 1))\npublic  public Month: (Date -\u003e int)\n\tMonth(date) \u003d\u003d\n(if (monthAux(date) \u003c correctedMonths)\nthen (monthAux(date) - 1)\nelse (monthAux(date) - 13))\npublic  public day: (Date -\u003e int)\n\tday(date) \u003d\u003d\ndaysFromTheBeginningOfTheMonth(date)\npublic  public daysFromNewYear: (Date -\u003e int)\n\tdaysFromNewYear(date) \u003d\u003d\nlet firstDateOfYear:Date \u003d getDateFrom_yyyy_mm_dd(Year(date), 1, 0) in diffOfDates(date, firstDateOfYear)\nprivate  private daysFromTheBeginningOfTheMonth: (Date -\u003e int)\n\tdaysFromTheBeginningOfTheMonth(date) \u003d\u003d\n(floor daysFromTheBeginningOfTheMonthAsReal(date))\nprivate  private daysFromTheBeginningOfTheMonthAsReal: (Date -\u003e real)\n\tdaysFromTheBeginningOfTheMonthAsReal(date) \u003d\u003d\n(((yyyymmddModifyAux(date) + calculationCoefficientOfDate) - (floor (daysInYear * yearAux(date)))) - (floor (averageDaysInMonth * monthAux(date))))\nprivate  private monthAux: (Date -\u003e int)\n\tmonthAux(date) \u003d\u003d\n(floor (((yyyymmddModifyAux(date) + calculationCoefficientOfDate) - (floor (daysInYear * yearAux(date)))) / averageDaysInMonth))\nprivate  private yyyymmddModifyAux: (Date -\u003e real)\n\tyyyymmddModifyAux(date) \u003d\u003d\nlet julianDate:real \u003d mjd2Jd((date.getModifiedJulianDate)()), century:int \u003d (floor ((julianDate + centuryCalculationCoefficient) / 36524.25)) in (if (julianDate \u003e theDayBeforeGregorioCalendarStarted)\nthen ((((julianDate + centuryCalculationCoefficient) + century) - (century div 4)) + 0.5)\nelse ((julianDate + 32082.9) + 0.5))\nprivate  private yearAux: (Date -\u003e int)\n\tyearAux(date) \u003d\u003d\n(floor (yyyymmddModifyAux(date) / daysInYear))\npublic  public getVernalEquinoxOnGMT: (int -\u003e Date)\n\tgetVernalEquinoxOnGMT(year) \u003d\u003d\nlet y:real \u003d (year / 1000.0) in modifiedJulianDate2Date(julianDate2ModifiedJulianDate(((1721139.2855 + (365.2421376 * year)) + ((y * y) * (0.067919 - (0.0027879 * y))))))\npublic  public getSummerSolsticeOnGMT: (int -\u003e Date)\n\tgetSummerSolsticeOnGMT(year) \u003d\u003d\nlet y:real \u003d (year / 1000.0) in modifiedJulianDate2Date(julianDate2ModifiedJulianDate(((1721233.2486 + (365.2417284 * year)) - ((y * y) * (0.053018 - (0.009332 * y))))))\npublic  public getAutumnalEquinoxOnGMT: (int -\u003e Date)\n\tgetAutumnalEquinoxOnGMT(year) \u003d\u003d\nlet y:real \u003d (year / 1000.0) in modifiedJulianDate2Date(julianDate2ModifiedJulianDate(((1721325.6978 + (365.2425055 * year)) - ((y * y) * (0.126689 - (0.0019401 * y))))))\npublic  public getWinterSolsticeOnGMT: (int -\u003e Date)\n\tgetWinterSolsticeOnGMT(year) \u003d\u003d\nlet y:real \u003d (year / 1000.0) in modifiedJulianDate2Date(julianDate2ModifiedJulianDate(((1721414.392 + (365.2428898 * year)) - ((y * y) * (0.010965 - (0.0084855 * y))))))\npublic  public getVernalEquinox: (int -\u003e Date)\n\tgetVernalEquinox(year) \u003d\u003d\ngetDateInStandardTime(getVernalEquinoxOnGMT(year))\npublic  public getSummerSolstice: (int -\u003e Date)\n\tgetSummerSolstice(year) \u003d\u003d\ngetDateInStandardTime(getSummerSolsticeOnGMT(year))\npublic  public getAutumnalEquinox: (int -\u003e Date)\n\tgetAutumnalEquinox(year) \u003d\u003d\ngetDateInStandardTime(getAutumnalEquinoxOnGMT(year))\npublic  public getWinterSolstice: (int -\u003e Date)\n\tgetWinterSolstice(year) \u003d\u003d\ngetDateInStandardTime(getWinterSolsticeOnGMT(year))\npublic  public dateAdding: (Date * int -\u003e Date)\n\tdateAdding(date, addNumOfDays) \u003d\u003d\n(date.plus)(addNumOfDays)\npublic  public diffOfDates: (Date * Date -\u003e int)\n\tdiffOfDates(date1, date2) \u003d\u003d\n(floor ((date1.getModifiedJulianDate)() - (date2.getModifiedJulianDate)()))\npublic  public dateSubtracting: (Date * int -\u003e Date)\n\tdateSubtracting(date, subtractNumOfDays) \u003d\u003d\n(date.minus)(subtractNumOfDays)\npublic  public mjd2Jd: (real -\u003e real)\n\tmjd2Jd(modifiedJulianDate) \u003d\u003d\n(modifiedJulianDate + daysDifferenceOfModifiedJulianDate)\npublic  public julianDate2ModifiedJulianDate: (real -\u003e real)\n\tjulianDate2ModifiedJulianDate(julianDate) \u003d\u003d\n(julianDate - daysDifferenceOfModifiedJulianDate)\npublic  public getRegularDate: (int * int * int -\u003e Date)\n\tgetRegularDate(candidateYear, candidateOfMonth, candidateDate) \u003d\u003d\nlet mk_(year, month):(int * int) \u003d getRegularMonth(candidateYear, candidateOfMonth) in getDateFrom_yyyy_mm_dd(year, month, candidateDate)\npublic  public getRegularMonth: (int * int -\u003e (int * int))\n\tgetRegularMonth(candidateYear, candidateOfMonth) \u003d\u003d\nlet year:int \u003d (if (candidateOfMonth \u003c\u003d 0)\nthen (candidateYear + ((candidateOfMonth - 12) div monthsInYear))\nelse (candidateYear + ((candidateOfMonth - 1) div monthsInYear))), candidateOfMonth2:int \u003d (candidateOfMonth mod monthsInYear), month:int \u003d (if (candidateOfMonth2 \u003d 0)\nthen 12\nelse candidateOfMonth2) in mk_(year, month)\npublic  public date2Year: (int * int * int -\u003e real)\n\tdate2Year(year, month, day) \u003d\u003d\n((year + ((month - 1) / monthsInYear)) + ((day - 1.0) / daysInYear))\npublic  public date2Str: (Date +\u003e seq of (char))\n\tdate2Str(date) \u003d\u003d\n(date.date2Str)()\npublic  public convertDateFromString: (seq of (char) +\u003e [Date])\n\tconvertDateFromString(dateStr) \u003d\u003d\nlet date:(Date | bool) \u003d getDateFromString(dateStr) in (if (date \u003d false)\nthen nil\nelse date)\npublic  public getSetOfDayOffBetweenDates: (Date * Date -\u003e set of (Date))\n\tgetSetOfDayOffBetweenDates(date1, date2) \u003d\u003d\nlet Date1:Date \u003d min(date1)(date2), Date2:Date \u003d max(date1)(date2), setOfYear:set of (int) \u003d {Year(Date1), ... ,Year(Date2)}, setOfDayOff:set of (Date) \u003d (dunion {getSetOfDayOff(year) | year in set setOfYear}) in {dayOff | dayOff in set setOfDayOff \u0026 ((date1.LE)(dayOff) and (dayOff.LE)(date2))}\npublic  public getDayOffsExceptSunday: (Date * Date -\u003e int)\n\tgetDayOffsExceptSunday(date1, date2) \u003d\u003d\n(card getSetOfDayOffBetweenDates(date1, date2))\npublic  public getTheNumberOfDayOff: (Date * Date -\u003e int)\n\tgetTheNumberOfDayOff(date1, date2) \u003d\u003d\nlet Date1:Date \u003d min(date1)(date2), Date2:Date \u003d max(date1)(date2), numberOfSunday:int \u003d getNumberOfTheDayOfWeek(Date1, Date2, \u003cSun\u003e) in (numberOfSunday + (card getSetOfNotSundayDayOff(Date1, Date2)))\npublic  public getTheNumberOfDayOffExceptStartDate: (Date * Date -\u003e int)\n\tgetTheNumberOfDayOffExceptStartDate(date1, date2) \u003d\u003d\nlet Date1:Date \u003d min(date1)(date2), Date2:Date \u003d max(date1)(date2) in getTheNumberOfDayOff((Date1.plus)(1), Date2)\nprivate  private getSetOfNotSundayDayOff: (Date * Date -\u003e set of (Date))\n\tgetSetOfNotSundayDayOff(date1, date2) \u003d\u003d\nlet setOfDayOff:set of (Date) \u003d getSetOfDayOffBetweenDates(date1, date2) in {dayOff | dayOff in set setOfDayOff \u0026 (not isSunday(dayOff))}\npublic  public getDayOffsAndSunday: (Date * Date -\u003e set of (Date))\n\tgetDayOffsAndSunday(date1, date2) \u003d\u003d\nlet setOfDayOff:set of (Date) \u003d getSetOfDayOffBetweenDates(date1, date2) in {dayOff | dayOff in set setOfDayOff \u0026 isSunday(dayOff)}\npublic  public getFutureWeekday: (Date -\u003e Date)\n\tgetFutureWeekday(date) \u003d\u003d\n(cases (isSundayOrDayoff(date) or isSaturday(date)) :\n(true) -\u003e getFutureWeekday((date.plus)(1))\nothers date\n end)\npublic  public getPastWeekday: (Date -\u003e Date)\n\tgetPastWeekday(date) \u003d\u003d\n(cases (isSundayOrDayoff(date) or isSaturday(date)) :\n(true) -\u003e getPastWeekday((date.minus)(1))\nothers date\n end)\nprivate  private getPastWeekdaymeasure: (Date +\u003e nat)\n\tgetPastWeekdaymeasure(d) \u003d\u003d\n(d.getModifiedJulianDate)()\npublic  public addWeekday: (Date * int -\u003e Date)\n\taddWeekday(date, addNumOfDays) \u003d\u003d\naddWeekdayAux(getFutureWeekday(date), addNumOfDays)\npublic  public addWeekdayAux: (Date * int -\u003e Date)\n\taddWeekdayAux(date, addNumOfDays) \u003d\u003d\n(cases (isSundayOrDayoff(date) or isSaturday(date)) :\n(true) -\u003e addWeekdayAux((date.plus)(1), addNumOfDays)\nothers (if (addNumOfDays \u003c\u003d 0)\nthen date\nelse addWeekdayAux((date.plus)(1), (addNumOfDays - 1)))\n end)\npublic  public subtractWeekday: (Date * int -\u003e Date)\n\tsubtractWeekday(date, subtractNumOfDays) \u003d\u003d\nsubtractWeekdayAux(getPastWeekday(date), subtractNumOfDays)\npublic  public subtractWeekdayAux: (Date * int -\u003e Date)\n\tsubtractWeekdayAux(date, subtractNumOfDays) \u003d\u003d\n(cases (isSundayOrDayoff(date) or isSaturday(date)) :\n(true) -\u003e subtractWeekdayAux((date.minus)(1), subtractNumOfDays)\nothers (if (subtractNumOfDays \u003c\u003d 0)\nthen date\nelse subtractWeekdayAux((date.minus)(1), (subtractNumOfDays - 1)))\n end)\npublic  public isDayOff: (Date -\u003e bool)\n\tisDayOff(date) \u003d\u003d\nlet setOfDayOff:set of (real) \u003d {(d.getModifiedJulianDate)() | d in set getSetOfDayOff((date.Year)())} in ((date.getModifiedJulianDate)() in set setOfDayOff)\npublic  public isSundayOrDayoff: (Date -\u003e bool)\n\tisSundayOrDayoff(date) \u003d\u003d\n(isSunday(date) or isDayOff(date))\npublic  public isInDateSet: (Date * set of (Date) -\u003e bool)\n\tisInDateSet(date, aNationalHolidaySet) \u003d\u003d\nlet holidaySetByModifiedJulianDate:set of (int) \u003d {(floor (d.getModifiedJulianDate)()) | d in set aNationalHolidaySet} in ((date.getModifiedJulianDate)() in set holidaySetByModifiedJulianDate)\npublic  modifiedJulianDate2Date(real) (real \u003d\u003d\u003e Date)\n\tmodifiedJulianDate2Date(real)(modifiedJulianDate) \u003d\u003d\nreturn (new Date(self, modifiedJulianDate))\npublic  getDateFrom_yyyy_mm_dd(int, int, int) (int * int * int \u003d\u003d\u003e Date)\n\tgetDateFrom_yyyy_mm_dd(int, int, int)(year, month, day) \u003d\u003d\nlet [y, m]:seq1 of (int) \u003d (if (month \u003e (correctedMonths - monthsInYear))\nthen [(year + calculationCoefficientOfYear), (month + 1)]\nelse [((year + calculationCoefficientOfYear) - 1), ((month + correctedMonths) - 1)]), century:int \u003d (y div yearInCentury), centuryCoefficient:int \u003d (if (date2Year(year, month, day) \u003e theFirstDayOfGregorioCalendar)\nthen (((century div 4) - century) - 32167.0)\nelse -32205.0), haldDay:real \u003d 0.5 in return (modifiedJulianDate2Date(((((((floor (daysInYear * y)) + (floor (averageDaysInMonth * m))) + day) + centuryCoefficient) - haldDay) - daysDifferenceOfModifiedJulianDate)))\npublic  getDateFromString(seq of (char)) (seq of (char) \u003d\u003d\u003e (Date | bool))\n\tgetDateFromString(seq of (char))(yyyymmdd) \u003d\u003d\n(\n\nif (not String`isDigits(yyyymmdd))\nthen\nreturn (false);\nlet yyyymmddByInt:int \u003d String`asInteger(yyyymmdd), year:int \u003d (yyyymmddByInt div 10000), mmddByInt:int \u003d (yyyymmddByInt mod 10000), month:int \u003d (mmddByInt div 100), day:int \u003d (mmddByInt mod 100) in if ((getDateFrom_yyyy_mm_dd(year, month, day).date2Str)() \u003d yyyymmdd)\nthen\nreturn (getDateFrom_yyyy_mm_dd(year, month, day))else\nreturn (false)\n)\npublic  getDateInStandardTime(Date) (Date \u003d\u003d\u003e Date)\n\tgetDateInStandardTime(Date)(date) \u003d\u003d\nreturn (modifiedJulianDate2Date(((date.getModifiedJulianDate)() + ((date.calendar)().getDifferenceWithGMT)())))\npublic  getDayOfTheWeekInYear(int, NameOfDayOfTheWeek) (int * NameOfDayOfTheWeek \u003d\u003d\u003e set of (Date))\n\tgetDayOfTheWeekInYear(int, NameOfDayOfTheWeek)(year, dayOfWeek) \u003d\u003d\n(\naSetOfTheDayOfWeek:set of (Date) :\u003d {}\ndate:Date :\u003d (self.getNthDayOfTheWeek)(year, 1, 1, dayOfWeek)\n\nwhile (date.LE)((self.lastDayOfTheWeekInMonth)(year, 12, dayOfWeek)) do (\n\naSetOfTheDayOfWeek :\u003d (aSetOfTheDayOfWeek union {date});\ndate :\u003d (date.plus)(7)\n);\nreturn (aSetOfTheDayOfWeek)\n)\npublic  getDifferenceWithGMT() (() \u003d\u003d\u003e real)\n\tgetDifferenceWithGMT()() \u003d\u003d\nreturn (differenceWithGMT)\npublic  setDifferenceWithGMT(real) (real \u003d\u003d\u003e ())\n\tsetDifferenceWithGMT(real)(diff) \u003d\u003d\ndifferenceWithGMT :\u003d diff\npublic  setTheSetOfDayOffs(int) (int \u003d\u003d\u003e ())\n\tsetTheSetOfDayOffs(int)(-) \u003d\u003d\nis subclass responsibility\npublic  getSetOfDayOff(int) (int \u003d\u003d\u003e set of (Date))\n\tgetSetOfDayOff(int)(aYear) \u003d\u003d\n(\n\nif (not (aYear in set (dom Year2Holidays)))\nthen\nself.setTheSetOfDayOffs(aYear);\nreturn ((self.Year2Holidays)(aYear))\n)\npublic  readToday(seq of (char)) (seq of (char) \u003d\u003d\u003e [Date])\n\treadToday(seq of (char))(fname) \u003d\u003d\nlet mk_(r, mk_(y, m, d)):(bool * [(int * int * int)]) \u003d ((io.freadval))[(int * int * int)](fname) in if r\nthen\nreturn (getDateFrom_yyyy_mm_dd(y, m, d))else\nlet -:bool \u003d (io.echo)(\"Can\u0027t read today\u0027s data file.\") in return (nil)\npublic  today() (() \u003d\u003d\u003e Date)\n\ttoday()() \u003d\u003d\nif (iToday \u003d nil)\nthen\nreturn (readToday((homedir ^ \"/temp/Today.txt\")))else\nreturn (iToday)\npublic  readFromFiletoday(seq of (char)) (seq of (char) \u003d\u003d\u003e Date)\n\treadFromFiletoday(seq of (char))(fname) \u003d\u003d\nif (iToday \u003d nil)\nthen\nreturn (readToday(fname))else\nreturn (iToday)\npublic  setToday(Date) (Date \u003d\u003d\u003e ())\n\tsetToday(Date)(date) \u003d\u003d\niToday :\u003d date\nend Calendar\n","class CalendarT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new CalendarT12(), new CalendarT11(), new CalendarT10(), new CalendarT09(), new CalendarT07(), new CalendarT06(), new CalendarT05(), new CalendarT03(), new CalendarT02(), new CalendarT01(), new CalendarT04()]\nend CalendarT\n","class CalendarT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in (\n\njc.setToday((jc.getDateFrom_yyyy_mm_dd)(2001, 9, 12));\nreturn (((((jc.getDateFrom_yyyy_mm_dd)(2003, 3, 0).asString)() \u003d \"20030228\") and ((((jc.getDateFrom_yyyy_mm_dd)(2003, 2, 29).asString)() \u003d \"20030301\") and ((((jc.getDateFrom_yyyy_mm_dd)(2004, 3, 0).asString)() \u003d \"20040229\") and ((((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 30).asString)() \u003d \"20040301\") and ((((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 60).asString)() \u003d \"20040229\") and ((((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 61).asString)() \u003d \"20040301\") and ((((jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1).get_yyyy_mm_dd)() \u003d mk_(2001, 5, 1)) and (((jc.getYyyymmdd)((jc.today)()) \u003d mk_(2001, 9, 12)) and ((((jc.modifiedJulianDate2Date)((jc.julianDate2ModifiedJulianDate)(2299160)).get_yyyy_mm_dd)() \u003d mk_(1582, 10, 4)) and (((((jc.modifiedJulianDate2Date)((jc.julianDate2ModifiedJulianDate)(2299160)).plus)(1).get_yyyy_mm_dd)() \u003d mk_(1582, 10, 15)) and (((jc.date2Str)((jc.getDateFromString)(\"20010711\")) \u003d \"20010711\") and (((jc.convertDateFromString)(\"saharashin\") \u003d nil) and ((JapaneseCalendar`getJapaneseDateStr((jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1)) \u003d \"13 5 1\") and (((jc.getAutumnalEquinox)(2001).EQ)((jc.getDateFrom_yyyy_mm_dd)(2001, 9, 23)) \u003d true)))))))))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT01:\tMake date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT01\n","class CalendarT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return (((((jc.dateAdding)((jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1), 3).date2Str)() \u003d \"20010504\") and (((jc.diffOfDates)((jc.getDateFrom_yyyy_mm_dd)(2001, 5, 8), (jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1)) \u003d 7) and (((jc.dateSubtracting)((jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1), 1).get_yyyy_mm_dd)() \u003d mk_(2001, 4, 30)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT02:\tAddition and subtraction of date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT02\n","class CalendarT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return (((((jc.getVernalEquinox)(2001).date2Str)() \u003d \"20010320\") and ((((jc.getSummerSolstice)(2001).date2Str)() \u003d \"20010621\") and ((((jc.getAutumnalEquinox)(2001).date2Str)() \u003d \"20010923\") and ((((jc.getWinterSolstice)(2001).date2Str)() \u003d \"20011222\") and ((((jc.getVernalEquinox)(2999).date2Str)() \u003d \"29990320\") and ((((jc.getSummerSolstice)(2999).date2Str)() \u003d \"29990620\") and ((((jc.getAutumnalEquinox)(2999).date2Str)() \u003d \"29990922\") and ((((jc.getWinterSolstice)(2999).date2Str)() \u003d \"29991222\") and ((((jc.getWinterSolstice)(2007).date2Str)() \u003d \"20071222\") and ((((jc.getWinterSolstice)(2012).date2Str)() \u003d \"20121221\") and (((jc.getWinterSolstice)(2016).date2Str)() \u003d \"20161221\"))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT03:\tCalculation of Vernal Equinox, Summer Solstice, Autumnal Equinox, Winter Solstice.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT03\n","class CalendarT04 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), setOfDayOffIn2009:set of (Date) \u003d (jc.getSetOfDayOff)(2009), setOfDayOff:set of (Date) \u003d (jc.getSetOfDayOff)(2001), setOfDayOff2003:set of (Date) \u003d (jc.getSetOfDayOff)(2003), d0401:(Date | bool) \u003d (jc.getDateFromString)(\"20010401\"), d0408:(Date | bool) \u003d (jc.getDateFromString)(\"20010408\"), d0430:(Date | bool) \u003d (jc.getDateFromString)(\"20010430\"), setOfDayOffBy_yyyy_mm_dd:set of ((int * int * int)) \u003d {(jc.getYyyymmdd)(dayOff) | dayOff in set setOfDayOff}, setOfDayOffBy_yyyy_mm_dd2003:set of ((int * int * int)) \u003d {(jc.getYyyymmdd)(dayOff) | dayOff in set setOfDayOff2003}, setOfDayOffBy_yyyy_mm_ddIn2009:set of ((int * int * int)) \u003d {(jc.getYyyymmdd)(dayOff) | dayOff in set setOfDayOffIn2009} in return (((setOfDayOffBy_yyyy_mm_dd \u003d {mk_(2001, 1, 1), mk_(2001, 1, 8), mk_(2001, 2, 11), mk_(2001, 2, 12), mk_(2001, 3, 20), mk_(2001, 4, 29), mk_(2001, 4, 30), mk_(2001, 5, 3), mk_(2001, 5, 4), mk_(2001, 5, 5), mk_(2001, 7, 20), mk_(2001, 9, 15), mk_(2001, 9, 23), mk_(2001, 9, 24), mk_(2001, 10, 8), mk_(2001, 11, 3), mk_(2001, 11, 23), mk_(2001, 12, 23), mk_(2001, 12, 24)}) and ((setOfDayOffBy_yyyy_mm_dd2003 \u003d {mk_(2003, 1, 1), mk_(2003, 1, 13), mk_(2003, 2, 11), mk_(2003, 3, 21), mk_(2003, 4, 29), mk_(2003, 5, 3), mk_(2003, 5, 4), mk_(2003, 5, 5), mk_(2003, 7, 21), mk_(2003, 9, 15), mk_(2003, 9, 23), mk_(2003, 10, 13), mk_(2003, 11, 3), mk_(2003, 11, 23), mk_(2003, 11, 24), mk_(2003, 12, 23)}) and ((setOfDayOffBy_yyyy_mm_ddIn2009 \u003d {mk_(2009, 1, 1), mk_(2009, 1, 12), mk_(2009, 2, 11), mk_(2009, 3, 20), mk_(2009, 4, 29), mk_(2009, 5, 3), mk_(2009, 5, 4), mk_(2009, 5, 5), mk_(2009, 5, 6), mk_(2009, 7, 20), mk_(2009, 9, 21), mk_(2009, 9, 22), mk_(2009, 9, 23), mk_(2009, 10, 12), mk_(2009, 11, 3), mk_(2009, 11, 23), mk_(2009, 12, 23)}) and (((jc.getDayOffsExceptSunday)(d0401, d0430) \u003d 2) and (((card (jc.getDayOffsAndSunday)(d0401, d0430)) \u003d 1) and ((jc.getDayOffsAndSunday)(d0401, d0408) \u003d {})))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT04:\tGet set of Day off.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT04\n","class CalendarT05 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d0711:(Date | bool) \u003d (jc.getDateFromString)(\"20010711\") in (\n\njc.setToday((jc.getDateFrom_yyyy_mm_dd)(2001, 3, 1));\nlet d0301:Date \u003d (jc.today)() in return (((d0711.EQ)((jc.getDateFrom_yyyy_mm_dd)(2001, 7, 11)) and ((jc.EQ)(d0711, (jc.getDateFrom_yyyy_mm_dd)(2001, 7, 11)) and ((d0301.LT)(d0711) and ((jc.LT)(d0301, d0711) and ((d0711.GT)(d0301) and ((jc.GT)(d0711, d0301) and ((d0711.GE)(d0711) and ((d0711.GE)(d0301) and ((jc.GE)(d0711, d0711) and ((jc.GE)(d0711, d0301) and ((d0711.LE)(d0711) and ((d0301.LE)(d0711) and ((jc.LE)(d0711, d0711) and (jc.LE)(d0301, d0711)))))))))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT05:\tCompare date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT05\n","class CalendarT06 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d10010301:(Date | bool) \u003d (jc.getDateFromString)(\"10010301\"), d0711:(Date | bool) \u003d (jc.getDateFromString)(\"20010711\") in (\n\nlet d0301:Date \u003d (jc.today)() in return (((((jc.firstDayOfTheWeekInMonth)(2000, 3, \u003cWed\u003e).get_yyyy_mm_dd)() \u003d mk_(2000, 3, 1)) and ((((jc.firstDayOfTheWeekInMonth)(2001, 7, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 1)) and ((((jc.lastDayOfTheWeekInMonth)(2000, 2, \u003cTue\u003e).get_yyyy_mm_dd)() \u003d mk_(2000, 2, 29)) and ((((jc.lastDayOfTheWeekInMonth)(2001, 7, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 29)) and ((((jc.getNthDayOfTheWeek)(2001, 7, 5, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 29)) and (((jc.getNthDayOfTheWeek)(2001, 7, 6, \u003cSun\u003e) \u003d false) and (((jc.getNumberOfTheDayOfWeek)(d0711, d0301, \u003cSun\u003e) \u003d 19) and (((jc.getNumberOfTheDayOfWeek)(d0711, d10010301, \u003cSun\u003e) \u003d 52196) and (((jc.getNumberOfDayOfTheWeekFromName)(\u003cThu\u003e) \u003d 4) and (((jc.getNumberOfDayOfTheWeekFromName)(\u003cFri\u003e) \u003d 5) and (((jc.getNumberOfDayOfTheWeekFromName)(\u003cSat\u003e) \u003d 6) and ((jc.getNumberOfDayOfTheWeekFromName)(\u003cSun\u003e) \u003d 0)))))))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT06:\tGet day of the week.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT06\n","class CalendarT07 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.getDateFromString)(\"sahara\") \u003d false) and (((jc.getDateFromString)(\"20011232\") \u003d false) and (((jc.getDateFromString)(\"20011231\").date2Str)() \u003d \"20011231\"))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT07:\tgetDateFromString\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT07\n","class CalendarT09 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.today)().EQ)((jc.getDateFrom_yyyy_mm_dd)(2001, 3, 1)) and ((jc.readFromFiletoday)((homedir ^ \"/temp/BaseDay.txt\")).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 10, 24))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT09:\tRead today datefrom a file.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT09\n","class CalendarT10 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.getLastDayOfMonth)(2004, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 31)) and (((jc.getLastDayOfMonth)(2004, 2).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 29)) and (((jc.getLastDayOfMonth)(2004, 3).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 3, 31)) and (((jc.getLastDayOfMonth)(2004, 4).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 4, 30)) and (((jc.getLastDayOfMonth)(2004, 5).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 5, 31)) and (((jc.getLastDayOfMonth)(2004, 6).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 6, 30)) and (((jc.getLastDayOfMonth)(2004, 7).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 7, 31)) and (((jc.getLastDayOfMonth)(2004, 8).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 8, 31)) and (((jc.getLastDayOfMonth)(2004, 9).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 9, 30)) and (((jc.getLastDayOfMonth)(2004, 10).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 10, 31)) and (((jc.getLastDayOfMonth)(2004, 11).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 11, 30)) and (((jc.getLastDayOfMonth)(2004, 12).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 12, 31)) and (((jc.getLastDayOfMonth)(2003, 13).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 31)) and (((jc.getLastDayOfMonth)(2003, (8 + 6)).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 29)) and (((jc.getLastDayOfMonth)(2003, 15).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 3, 31)) and (((jc.getLastDayOfMonth)(2003, 16).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 4, 30)) and (((jc.getLastDayOfMonth)(2003, 17).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 5, 31)) and (((jc.getLastDayOfMonth)(2003, 18).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 6, 30)) and (((jc.getLastDayOfMonth)(2003, 19).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 7, 31)) and (((jc.getLastDayOfMonth)(2003, 20).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 8, 31)) and (((jc.getLastDayOfMonth)(2003, 21).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 9, 30)) and (((jc.getLastDayOfMonth)(2003, 22).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 10, 31)) and (((jc.getLastDayOfMonth)(2003, 23).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 11, 30)) and (((jc.getLastDayOfMonth)(2003, 24).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 12, 31)) and ((jc.getLastDayOfMonth)(2005, 2).EQ)((jc.getDateFrom_yyyy_mm_dd)(2005, 2, 28)))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT10:\tGet the end of month.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT10\n","class CalendarT11 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.getRegularDate)(2004, 1, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 1)) and (((jc.getRegularDate)(2003, 12, 32).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 1)) and (((jc.getRegularDate)(2003, 24, 32).EQ)((jc.getDateFrom_yyyy_mm_dd)(2005, 1, 1)) and (((jc.getRegularDate)(2003, 13, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 1)) and (((jc.getRegularDate)(2004, 1, 32).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 1)) and (((jc.getRegularDate)(2004, 2, 0).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 1, 31)) and (((jc.getRegularDate)(2004, 2, 28).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 28)) and (((jc.getRegularDate)(2004, 2, 29).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 29)) and (((jc.getRegularDate)(2004, 3, 0).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 29)) and (((jc.getRegularDate)(2004, 3, -1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 2, 28)) and (((jc.getRegularDate)(2003, 2, 29).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 3, 1)) and (((jc.getRegularDate)(2004, 4, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2004, 4, 1)) and (((jc.getRegularDate)(2004, 0, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 12, 1)) and (((jc.getRegularDate)(2004, -1, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 11, 1)) and (((jc.getRegularDate)(2004, -10, 29).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 3, 1)) and (((jc.getRegularDate)(2004, -10, 28).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 2, 28)) and (((jc.getRegularDate)(2004, -11, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2003, 1, 1)) and ((jc.getRegularDate)(2004, -12, 1).EQ)((jc.getDateFrom_yyyy_mm_dd)(2002, 12, 1))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT11:\tgetRegularDate\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT11\n","class CalendarT12 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.getRegularMonth)(2004, 1) \u003d mk_(2004, 1)) and (((jc.getRegularMonth)(2004, 2) \u003d mk_(2004, 2)) and (((jc.getRegularMonth)(2004, 3) \u003d mk_(2004, 3)) and (((jc.getRegularMonth)(2004, 4) \u003d mk_(2004, 4)) and (((jc.getRegularMonth)(2004, 5) \u003d mk_(2004, 5)) and (((jc.getRegularMonth)(2004, 6) \u003d mk_(2004, 6)) and (((jc.getRegularMonth)(2004, 7) \u003d mk_(2004, 7)) and (((jc.getRegularMonth)(2004, 8) \u003d mk_(2004, 8)) and (((jc.getRegularMonth)(2004, 9) \u003d mk_(2004, 9)) and (((jc.getRegularMonth)(2004, 10) \u003d mk_(2004, 10)) and (((jc.getRegularMonth)(2004, 11) \u003d mk_(2004, 11)) and (((jc.getRegularMonth)(2004, 12) \u003d mk_(2004, 12)) and (((jc.getRegularMonth)(2004, 13) \u003d mk_(2005, 1)) and (((jc.getRegularMonth)(2004, 14) \u003d mk_(2005, 2)) and (((jc.getRegularMonth)(2004, 24) \u003d mk_(2005, 12)) and (((jc.getRegularMonth)(2004, 25) \u003d mk_(2006, 1)) and (((jc.getRegularMonth)(2004, 0) \u003d mk_(2003, 12)) and (((jc.getRegularMonth)(2004, -1) \u003d mk_(2003, 11)) and (((jc.getRegularMonth)(2004, -10) \u003d mk_(2003, 2)) and (((jc.getRegularMonth)(2004, -11) \u003d mk_(2003, 1)) and (((jc.getRegularMonth)(2004, -12) \u003d mk_(2002, 12)) and ((jc.getRegularMonth)(2004, -13) \u003d mk_(2002, 11))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"CalendarT12:\tgetRegularMonth\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend CalendarT12\n","class Character\nprivate static  vNumOrderMap:map (char) to (nat1) \u003d {\u00270\u0027 |-\u003e 1, \u00271\u0027 |-\u003e 2, \u00272\u0027 |-\u003e 3, \u00273\u0027 |-\u003e 4, \u00274\u0027 |-\u003e 5, \u00275\u0027 |-\u003e 6, \u00276\u0027 |-\u003e 7, \u00277\u0027 |-\u003e 8, \u00278\u0027 |-\u003e 9, \u00279\u0027 |-\u003e 10}\nprivate static  vChapitalCharOrderMap:map (char) to (nat1) \u003d {\u0027A\u0027 |-\u003e 12, \u0027B\u0027 |-\u003e 14, \u0027C\u0027 |-\u003e 16, \u0027D\u0027 |-\u003e 18, \u0027E\u0027 |-\u003e 20, \u0027F\u0027 |-\u003e 22, \u0027G\u0027 |-\u003e 24, \u0027H\u0027 |-\u003e 26, \u0027I\u0027 |-\u003e 28, \u0027J\u0027 |-\u003e 30, \u0027K\u0027 |-\u003e 32, \u0027L\u0027 |-\u003e 34, \u0027M\u0027 |-\u003e 36, \u0027N\u0027 |-\u003e 38, \u0027O\u0027 |-\u003e 40, \u0027P\u0027 |-\u003e 42, \u0027Q\u0027 |-\u003e 44, \u0027R\u0027 |-\u003e 46, \u0027S\u0027 |-\u003e 48, \u0027T\u0027 |-\u003e 50, \u0027U\u0027 |-\u003e 52, \u0027V\u0027 |-\u003e 54, \u0027W\u0027 |-\u003e 56, \u0027X\u0027 |-\u003e 58, \u0027Y\u0027 |-\u003e 60, \u0027Z\u0027 |-\u003e 62}\nprivate static  vSmallCharOrderMap:map (char) to (nat1) \u003d {\u0027a\u0027 |-\u003e 11, \u0027b\u0027 |-\u003e 13, \u0027c\u0027 |-\u003e 15, \u0027d\u0027 |-\u003e 17, \u0027e\u0027 |-\u003e 19, \u0027f\u0027 |-\u003e 21, \u0027g\u0027 |-\u003e 23, \u0027h\u0027 |-\u003e 25, \u0027i\u0027 |-\u003e 27, \u0027j\u0027 |-\u003e 29, \u0027k\u0027 |-\u003e 31, \u0027l\u0027 |-\u003e 33, \u0027m\u0027 |-\u003e 35, \u0027n\u0027 |-\u003e 37, \u0027o\u0027 |-\u003e 39, \u0027p\u0027 |-\u003e 41, \u0027q\u0027 |-\u003e 43, \u0027r\u0027 |-\u003e 45, \u0027s\u0027 |-\u003e 47, \u0027t\u0027 |-\u003e 49, \u0027u\u0027 |-\u003e 51, \u0027v\u0027 |-\u003e 53, \u0027w\u0027 |-\u003e 55, \u0027x\u0027 |-\u003e 57, \u0027y\u0027 |-\u003e 59, \u0027z\u0027 |-\u003e 61}\nprivate static  vCharOrderMap:map (char) to (nat1) \u003d ((vNumOrderMap munion vChapitalCharOrderMap) munion vSmallCharOrderMap)\npublic static  public static asDigit: (char -\u003e (bool | int))\n\tasDigit(c) \u003d\u003d\n(if isDigit(c)\nthen let s:seq1 of (char) \u003d [c] in let mk_(-, i):(bool * [int]) \u003d (VDMUtil`seq_of_char2val)[int](s) in i\nelse false)\npublic static  public static asDictOrder: (char -\u003e int)\n\tasDictOrder(c) \u003d\u003d\n(if (c in set (dom vCharOrderMap))\nthen vCharOrderMap(c)\nelse let nonAsciiChar:nat1 \u003d 999999 in nonAsciiChar)\npublic static  public static isDigit: (char -\u003e bool)\n\tisDigit(c) \u003d\u003d\n(c in set (dom vNumOrderMap))\npublic static  public static isLetter: (char -\u003e bool)\n\tisLetter(c) \u003d\u003d\n(c in set (dom (vChapitalCharOrderMap munion vSmallCharOrderMap)))\npublic static  public static isLetterOrDigit: (char -\u003e bool)\n\tisLetterOrDigit(c) \u003d\u003d\n(isDigit(c) or isLetter(c))\npublic static  public static isCapitalLetter: (char -\u003e bool)\n\tisCapitalLetter(c) \u003d\u003d\n(c in set (dom vChapitalCharOrderMap))\npublic static  public static isLowercaseLetter: (char -\u003e bool)\n\tisLowercaseLetter(c) \u003d\u003d\n(c in set (dom vSmallCharOrderMap))\npublic static  public static LT: (char * char -\u003e bool)\n\tLT(c1, c2) \u003d\u003d\nCharacter`LT2(c1)(c2)\npublic static  public static LT2: (char -\u003e (char -\u003e bool))\n\tLT2(c1)(c2) \u003d\u003d\n(Character`asDictOrder(c1) \u003c Character`asDictOrder(c2))\npublic static  public static LE: (char * char -\u003e bool)\n\tLE(c1, c2) \u003d\u003d\nCharacter`LE2(c1)(c2)\npublic static  public static LE2: (char -\u003e (char -\u003e bool))\n\tLE2(c1)(c2) \u003d\u003d\n(Character`LT2(c1)(c2) or (c1 \u003d c2))\npublic static  public static GT: (char * char -\u003e bool)\n\tGT(c1, c2) \u003d\u003d\nCharacter`GT2(c1)(c2)\npublic static  public static GT2: (char -\u003e (char -\u003e bool))\n\tGT2(c1)(c2) \u003d\u003d\nCharacter`LT2(c2)(c1)\npublic static  public static GE: (char * char -\u003e bool)\n\tGE(c1, c2) \u003d\u003d\nCharacter`GE2(c1)(c2)\npublic static  public static GE2: (char -\u003e (char -\u003e bool))\n\tGE2(c1)(c2) \u003d\u003d\n(not Character`LT2(c1)(c2))\nend Character\n","class CommonDefinition is subclass of [Object]\npublic  public StringOrder: (seq of (char) * seq of (char) -\u003e bool)\n\tStringOrder(x, y) \u003d\u003d\nString`LT(x, y)\npublic  public NumericOrder: (NumericalValue * NumericalValue -\u003e bool)\n\tNumericOrder(x, y) \u003d\u003d\n(x \u003c y)\npublic  public DateOrder: (Date * Date -\u003e bool)\n\tDateOrder(x, y) \u003d\u003d\n(x.LT)(y)\npublic  public AmountOfMoneyOrder: (AmountOfMoney * AmountOfMoney -\u003e bool)\n\tAmountOfMoneyOrder(x, y) \u003d\u003d\n(x \u003c y)\npublic static  Identifier \u003d Identifier\n\tinv - \u003d\u003d (forall s1, s2:seq of (char), id1, id2:Identifier \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (s1 \u003c\u003e s2)))\npublic static  Quantity \u003d Quantity\npublic static  NumericalValue \u003d NumericalValue\npublic static  Percent \u003d Percent\n\tinv p \u003d\u003d ((0 \u003c\u003d p) and (p \u003c\u003d 100))\npublic static  AmountOfMoney \u003d AmountOfMoney\npublic static  NonNegativeAmountOfMoney \u003d NonNegativeAmountOfMoney\npublic static  PositiveAmountOfMoney \u003d PositiveAmountOfMoney\npublic static  AmountOfMoney2 \u003d AmountOfMoney2\n\tinv am \u003d\u003d (new Real().isNDigitsAfterTheDecimalPoint)(am, 2)\nend CommonDefinition\n","class Date is subclass of [CalendarDefinition]\nprivate  ModifiedJulianDate:real :\u003d 0\nprivate  usingCalendar:Calendar :\u003d (undefined)\npublic  public getNumberOfDayOfTheWeek: (() -\u003e NumberOfDayOfTheWeek)\n\tgetNumberOfDayOfTheWeek() \u003d\u003d\n(calendar().getNumberOfDayOfTheWeek)(self)\npublic  public getNameOfDayOfTheWeek: (() -\u003e NameOfDayOfTheWeek)\n\tgetNameOfDayOfTheWeek() \u003d\u003d\n(calendar().getNameOfDayOfTheWeek)(self)\npublic  public getNumberOfTheDayOfWeek: (Date * NameOfDayOfTheWeek -\u003e int)\n\tgetNumberOfTheDayOfWeek(date, nameOfDayOfTheWeek) \u003d\u003d\n(calendar().getNumberOfTheDayOfWeek)(self, date, nameOfDayOfTheWeek)\npublic  public getTheNumberOfDayOff: (Date -\u003e int)\n\tgetTheNumberOfDayOff(date) \u003d\u003d\n(calendar().getTheNumberOfDayOff)(self, date)\npublic  public getTheNumberOfDayOffExceptStartDate: (Date -\u003e int)\n\tgetTheNumberOfDayOffExceptStartDate(date) \u003d\u003d\n(calendar().getTheNumberOfDayOffExceptStartDate)(self, date)\npublic  public Year: (() -\u003e int)\n\tYear() \u003d\u003d\n(calendar().Year)(self)\npublic  public Month: (() -\u003e int)\n\tMonth() \u003d\u003d\n(calendar().Month)(self)\npublic  public day: (() -\u003e int)\n\tday() \u003d\u003d\n(calendar().day)(self)\npublic  public getFutureWeekday: (() -\u003e Date)\n\tgetFutureWeekday() \u003d\u003d\n(calendar().getFutureWeekday)(self)\npublic  public getPastWeekday: (() -\u003e Date)\n\tgetPastWeekday() \u003d\u003d\n(calendar().getPastWeekday)(self)\npublic  public addWeekday: (int -\u003e Date)\n\taddWeekday(addNumOfDays) \u003d\u003d\n(calendar().addWeekday)(self, addNumOfDays)\npublic  public subtractWeekday: (int -\u003e Date)\n\tsubtractWeekday(subtractNumOfDays) \u003d\u003d\n(calendar().subtractWeekday)(self, subtractNumOfDays)\npublic  public isSunday: (() -\u003e bool)\n\tisSunday() \u003d\u003d\n(calendar().isSunday)(self)\npublic  public isSaturday: (() -\u003e bool)\n\tisSaturday() \u003d\u003d\n(calendar().isSaturday)(self)\npublic  public isWeekday: (() -\u003e bool)\n\tisWeekday() \u003d\u003d\n(calendar().isWeekday)(self)\npublic  public isNotDayOff: (() -\u003e bool)\n\tisNotDayOff() \u003d\u003d\n(calendar().isNotDayOff)(self)\npublic  public isDayOff: (() -\u003e bool)\n\tisDayOff() \u003d\u003d\n(calendar().isDayOff)(self)\npublic  public isSundayOrDayoff: (() -\u003e bool)\n\tisSundayOrDayoff() \u003d\u003d\n(calendar().isSundayOrDayoff)(self)\npublic  public daysFromNewYear: (() -\u003e int)\n\tdaysFromNewYear() \u003d\u003d\n(calendar().daysFromNewYear)(self)\npublic  public get_yyyy_mm_dd: (() -\u003e (int * int * int))\n\tget_yyyy_mm_dd() \u003d\u003d\nmk_((self.Year)(), (self.Month)(), (self.day)())\nprivate  private toStringAux: (int -\u003e seq of (char))\n\ttoStringAux(i) \u003d\u003d\nlet str:(int -\u003e seq1 of (char)) \u003d Integer`asString in (if (i \u003e\u003d 10)\nthen str(i)\nelse (\"0\" ^ str(i)))\npublic  public date2Str: (() -\u003e seq of (char))\n\tdate2Str() \u003d\u003d\n(self.asString)()\npublic  asString() (() \u003d\u003d\u003e seq of (char))\n\tasString()() \u003d\u003d\n(\n\nlet asString:(int -\u003e seq1 of (char)) \u003d Integer`asString, y:int \u003d (self.Year)(), m:int \u003d (self.Month)(), d:int \u003d (self.day)(), yearStr:seq1 of (char) \u003d asString(y), monthStr:seq of (char) \u003d toStringAux(m), dateStr:seq of (char) \u003d toStringAux(d) in return (((yearStr ^ monthStr) ^ dateStr))\n)\npublic  print() (() \u003d\u003d\u003e seq of (char))\n\tprint()() \u003d\u003d\n(\n\nlet asString:(int -\u003e seq1 of (char)) \u003d Integer`asString, y:int \u003d (self.Year)(), m:int \u003d (self.Month)(), d:int \u003d (self.day)(), yearStr:seq1 of (char) \u003d asString(y), monthStr:seq of (char) \u003d toStringAux(m), dateStr:seq of (char) \u003d toStringAux(d) in return (((((((\"Year\u003d\" ^ yearStr) ^ \", Month\u003d\") ^ monthStr) ^ \", Day\u003d\") ^ dateStr) ^ \", \"))\n)\npublic  LT(Date) (Date \u003d\u003d\u003e bool)\n\tLT(Date)(date) \u003d\u003d\nreturn (((floor (self.getModifiedJulianDate)()) \u003c (floor (date.getModifiedJulianDate)())))\npublic  GT(Date) (Date \u003d\u003d\u003e bool)\n\tGT(Date)(date) \u003d\u003d\nreturn (((floor (self.getModifiedJulianDate)()) \u003e (floor (date.getModifiedJulianDate)())))\npublic  LE(Date) (Date \u003d\u003d\u003e bool)\n\tLE(Date)(date) \u003d\u003d\nreturn ((not (self.GT)(date)))\npublic  GE(Date) (Date \u003d\u003d\u003e bool)\n\tGE(Date)(date) \u003d\u003d\nreturn ((not (self.LT)(date)))\npublic  EQ(Date) (Date \u003d\u003d\u003e bool)\n\tEQ(Date)(date) \u003d\u003d\nreturn (((floor (self.getModifiedJulianDate)()) \u003d (floor (date.getModifiedJulianDate)())))\npublic  NE(Date) (Date \u003d\u003d\u003e bool)\n\tNE(Date)(date) \u003d\u003d\nreturn (((floor (self.getModifiedJulianDate)()) \u003c\u003e (floor (date.getModifiedJulianDate)())))\npublic  plus(int) (int \u003d\u003d\u003e Date)\n\tplus(int)(addNumOfDays) \u003d\u003d\nreturn ((calendar().modifiedJulianDate2Date)(((self.getModifiedJulianDate)() + addNumOfDays)))\npublic  minus(int) (int \u003d\u003d\u003e Date)\n\tminus(int)(subtractNumOfDays) \u003d\u003d\nreturn ((calendar().modifiedJulianDate2Date)(((self.getModifiedJulianDate)() - subtractNumOfDays)))\npublic  setModifiedJulianDate(real) (real \u003d\u003d\u003e ())\n\tsetModifiedJulianDate(real)(r) \u003d\u003d\nModifiedJulianDate :\u003d r\npublic  getModifiedJulianDate() (() \u003d\u003d\u003e real)\n\tgetModifiedJulianDate()() \u003d\u003d\nreturn (ModifiedJulianDate)\npublic  calendar() (() \u003d\u003d\u003e Calendar)\n\tcalendar()() \u003d\u003d\nreturn (usingCalendar)\npublic  Date(Calendar, real) (Calendar * real \u003d\u003d\u003e Date)\n\tDate(Calendar, real)(aCal, aModifiedJulianDate) \u003d\u003d\n(\n\nusingCalendar :\u003d aCal;\nsetModifiedJulianDate(aModifiedJulianDate);\nreturn (self)\n)\nend Date\n","class DateT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new DateT01(), new DateT02(), new DateT03(), new DateT04(), new DateT05(), new DateT06(), new DateT07()]\nend DateT\n","class DateT01 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1), d1:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 4, 29), d2:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 4, 28) in return ((((d.getNumberOfDayOfTheWeek)() \u003d (jc.getNumberOfDayOfTheWeekFromName)(\u003cTue\u003e)) and (((d.getNameOfDayOfTheWeek)() \u003d \u003cTue\u003e) and (((d1.getNameOfDayOfTheWeek)() \u003d \u003cSun\u003e) and (((d2.getNameOfDayOfTheWeek)() \u003d \u003cSat\u003e) and (((d.isSunday)() \u003d false) and (((d.isSaturday)() \u003d false) and (((d.isWeekday)() \u003d true) and (((d.isDayOff)() \u003d false) and (((d.isNotDayOff)() \u003d true) and ((d.isSundayOrDayoff)() \u003d false)))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT01:\tCalculate the day of the week.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT01\n","class DateT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 5, 1) in return ((((d.get_yyyy_mm_dd)() \u003d mk_(2001, 5, 1)) and (((d.date2Str)() \u003d \"20010501\") and (((d.asString)() \u003d \"20010501\") and ((d.print)() \u003d \"Year\u003d2001, Month\u003d05, Day\u003d01, \")))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT02:\tConvert date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT02\n","class DateT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d20000101:(Date | bool) \u003d (jc.getDateFromString)(\"20000101\"), d0301:(Date | bool) \u003d (jc.getDateFromString)(\"20010301\"), d0501:(Date | bool) \u003d (jc.getDateFromString)(\"20010501\"), d0711:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 7, 11) in return ((((d0301.getTheNumberOfDayOff)(d0711) \u003d 24) and (((d0501.getTheNumberOfDayOffExceptStartDate)(d0711) \u003d 13) and ((d20000101.getTheNumberOfDayOff)(d0711) \u003d 103))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT03:\tgetTheNumberOfDayOff\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT03\n","class DateT04 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d20001231:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2000, 12, 31), d1231:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 12, 31), d0626:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 6, 26), d0501:(Date | bool) \u003d (jc.getDateFromString)(\"20010501\"), d0505:(Date | bool) \u003d (jc.getDateFromString)(\"20010505\"), d0502:Date \u003d (jc.getDateFrom_yyyy_mm_dd)(2001, 5, 2) in return ((((((d0502.addWeekday)(1).getFutureWeekday)().date2Str)() \u003d \"20010507\") and (((((d0502.getPastWeekday)().subtractWeekday)(1).date2Str)() \u003d \"20010501\") and (((((d0501.getPastWeekday)().subtractWeekday)(1).date2Str)() \u003d \"20010427\") and ((((d0501.getFutureWeekday)().date2Str)() \u003d \"20010501\") and ((((d0501.addWeekday)(2).date2Str)() \u003d \"20010507\") and ((((d0502.subtractWeekday)(2).date2Str)() \u003d \"20010427\") and (((d1231.daysFromNewYear)() \u003d 365) and (((d20001231.daysFromNewYear)() \u003d 366) and (((d0501.getNumberOfTheDayOfWeek)(d0626, \u003cTue\u003e) \u003d 9) and ((((jc.getFutureWeekday)(d0505).date2Str)() \u003d \"20010507\") and ((((jc.getFutureWeekday)(d0501).date2Str)() \u003d \"20010501\") and ((((jc.getPastWeekday)(d0501).date2Str)() \u003d \"20010501\") and (((jc.getPastWeekday)(d0505).date2Str)() \u003d \"20010502\"))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT04:\tCalculate date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT04\n","class DateT05 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d0711:(Date | bool) \u003d (jc.getDateFromString)(\"20010711\") in (\n\njc.setToday((jc.getDateFrom_yyyy_mm_dd)(2001, 3, 1));\nlet d0301:Date \u003d (jc.today)() in return (((d0711.EQ)((jc.getDateFrom_yyyy_mm_dd)(2001, 7, 11)) and ((d0711.NE)((jc.getDateFrom_yyyy_mm_dd)(2001, 7, 12)) and ((jc.EQ)(d0711, (jc.getDateFrom_yyyy_mm_dd)(2001, 7, 11)) and ((d0301.LT)(d0711) and ((jc.LT)(d0301, d0711) and ((d0711.GT)(d0301) and ((jc.GT)(d0711, d0301) and ((d0711.GE)(d0711) and ((d0711.GE)(d0301) and ((jc.GE)(d0711, d0711) and ((jc.GE)(d0711, d0301) and ((d0711.LE)(d0711) and ((d0301.LE)(d0711) and ((jc.LE)(d0711, d0711) and (jc.LE)(d0301, d0711))))))))))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT05:\tCompare date.date\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT05\n","class DateT06 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar(), d10010301:(Date | bool) \u003d (jc.getDateFromString)(\"10010301\"), d0711:(Date | bool) \u003d (jc.getDateFromString)(\"20010711\") in (\n\njc.setToday((jc.getDateFrom_yyyy_mm_dd)(2001, 3, 1));\nlet d0301:Date \u003d (jc.today)() in return (((((jc.firstDayOfTheWeekInMonth)(2000, 3, \u003cWed\u003e).get_yyyy_mm_dd)() \u003d mk_(2000, 3, 1)) and ((((jc.firstDayOfTheWeekInMonth)(2001, 7, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 1)) and ((((jc.lastDayOfTheWeekInMonth)(2000, 2, \u003cTue\u003e).get_yyyy_mm_dd)() \u003d mk_(2000, 2, 29)) and ((((jc.lastDayOfTheWeekInMonth)(2001, 7, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 29)) and ((((jc.getNthDayOfTheWeek)(2001, 7, 5, \u003cSun\u003e).get_yyyy_mm_dd)() \u003d mk_(2001, 7, 29)) and (((jc.getNthDayOfTheWeek)(2001, 7, 6, \u003cSun\u003e) \u003d false) and (((jc.getNumberOfTheDayOfWeek)(d0711, d0301, \u003cSun\u003e) \u003d 19) and ((jc.getNumberOfTheDayOfWeek)(d0711, d10010301, \u003cSun\u003e) \u003d 52196)))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT06:\tGet the day of the week.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT06\n","class DateT07 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:JapaneseCalendar \u003d new JapaneseCalendar() in return ((((jc.isLeapYear)(2000) \u003d true) and (((jc.isLeapYear)(2001) \u003d false) and (((jc.isLeapYear)(1996) \u003d true) and (((jc.isLeapYear)(1900) \u003d false) and (((jc.isLeapYear)(1600) \u003d true) and (((jc.isDateString)(\"sahara\") \u003d false) and (((jc.isDateString)(\"20010723\") \u003d true) and (((jc.isDateString)(\"20011232\") \u003d false) and (((jc.isWeekday)(\u003cMon\u003e) \u003d true) and (((jc.isWeekday)(\u003cTue\u003e) \u003d true) and (((jc.isWeekday)(\u003cWed\u003e) \u003d true) and (((jc.isWeekday)(\u003cThu\u003e) \u003d true) and (((jc.isWeekday)(\u003cFri\u003e) \u003d true) and (((jc.isWeekday)(\u003cSat\u003e) \u003d false) and (((jc.isWeekday)(\u003cSun\u003e) \u003d false) and (((jc.date2Str)((jc.getLastDayOfMonth)(2000, 2)) \u003d \"20000229\") and ((jc.date2Str)((jc.getLastDayOfMonth)(2001, 2)) \u003d \"20010228\"))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DateT07:\tQuery about date.date\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DateT07\n","class DoubleListQueue\npublic static  public static empty[(T)]: (() -\u003e (seq of (@T) * seq of (@T)))\n\tempty() \u003d\u003d\nmk_([], [])\npublic static  public static isEmpty[(T)]: ((seq of (@T) * seq of (@T)) -\u003e bool)\n\tisEmpty(s) \u003d\u003d\n(s \u003d mk_([], []))\npublic static  public static enQueue[(T)]: (@T * (seq of (@T) * seq of (@T)) -\u003e (seq of (@T) * seq of (@T)))\n\tenQueue(anElem, mk_(aHeads, aTails)) \u003d\u003d\nmk_(aHeads, ([anElem] ^ aTails))\npublic static  public static deQueue[(T)]: ((seq of (@T) * seq of (@T)) -\u003e [(seq of (@T) * seq of (@T))])\n\tdeQueue(mk_(aHeads, aTails)) \u003d\u003d\n(cases aHeads :\n[-] ^ aTailsOfHeads -\u003e mk_(aTailsOfHeads, aTails),\n[] -\u003e (cases aTails :\n[] -\u003e nil\nothers mk_((tl (Sequence`freverse)[@T](aTails)), [])\n end)\n end)\npublic static  public static top[(T)]: ((seq of (@T) * seq of (@T)) -\u003e [@T])\n\ttop(mk_(aHeads, aTails)) \u003d\u003d\n(cases aHeads :\n[h] ^ - -\u003e h,\n[] -\u003e (cases aTails :\n[] -\u003e nil\nothers (hd (Sequence`freverse)[@T](aTails))\n end)\n end)\npublic static  public static fromList[(T)]: (seq of (@T) * (seq of (@T) * seq of (@T)) -\u003e (seq of (@T) * seq of (@T)))\n\tfromList(aSeq, aQueue) \u003d\u003d\n(cases aSeq :\n[] -\u003e aQueue,\n[h] ^ aTailsOfSeq -\u003e (fromList)[@T](aTailsOfSeq, (enQueue)[@T](h, aQueue))\n end)\nprivate static  private static fromListMeasure[(T)]: (seq of (@T) * (seq of (@T) * seq of (@T)) +\u003e nat)\n\tfromListMeasure(s, -) \u003d\u003d\n(len s)\npublic static  public static toList[(T)]: ((seq of (@T) * seq of (@T)) -\u003e seq of (@T))\n\ttoList(aaQueue) \u003d\u003d\n(cases aaQueue :\n(mk_([], [])) -\u003e [],\naQueue -\u003e ([(top)[@T](aQueue)] ^ (toList)[@T]((deQueue)[@T](aQueue)))\n end)\nprivate static  private static toListMeasure[(T)]: ((seq of (@T) * seq of (@T)) +\u003e nat)\n\ttoListMeasure(mk_(s1, s2)) \u003d\u003d\n((len s1) + (len s2))\nend DoubleListQueue\n","class DoubleListQueueT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new DoubleListQueueT01()]\nend DoubleListQueueT\n","class DoubleListQueueT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet q0:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`empty)[int](), q1:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`enQueue)[int](1, q0), q2:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`enQueue)[int](2, q1), q3:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`enQueue)[int](3, q2), h1:[int] \u003d (DoubleListQueue`top)[int](q3), q4:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q3), q5:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`enQueue)[int](4, q4), q6:(seq of (int) * seq of (int)) \u003d (DoubleListQueue`enQueue)[int](5, q5), q7:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q6), q8:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q7), q9:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q8), q10:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q9), h2:[int] \u003d (DoubleListQueue`top)[int](q10), q11:[(seq of (int) * seq of (int))] \u003d (DoubleListQueue`deQueue)[int](q10), q12:(seq of (char) * seq of (char)) \u003d (DoubleListQueue`fromList)[char](\"Sahara Shin\", (DoubleListQueue`empty)[char]()) in return (((DoubleListQueue`isEmpty)[int](q0) and ((q0 \u003d mk_([], [])) and (((DoubleListQueue`toList)[int](q1) \u003d [1]) and ((q1 \u003d mk_([], [1])) and (((DoubleListQueue`toList)[int](q2) \u003d [1, 2]) and ((q2 \u003d mk_([], [2, 1])) and (((DoubleListQueue`toList)[int](q3) \u003d [1, 2, 3]) and ((q3 \u003d mk_([], [3, 2, 1])) and ((h1 \u003d 1) and (((DoubleListQueue`toList)[int](q4) \u003d [2, 3]) and ((q4 \u003d mk_([2, 3], [])) and (((DoubleListQueue`toList)[int](q5) \u003d [2, 3, 4]) and ((q5 \u003d mk_([2, 3], [4])) and (((DoubleListQueue`toList)[int](q6) \u003d [2, 3, 4, 5]) and ((q6 \u003d mk_([2, 3], [5, 4])) and (((DoubleListQueue`toList)[int](q7) \u003d [3, 4, 5]) and ((q7 \u003d mk_([3], [5, 4])) and (((DoubleListQueue`toList)[int](q8) \u003d [4, 5]) and ((q8 \u003d mk_([], [5, 4])) and (((DoubleListQueue`toList)[int](q9) \u003d [5]) and ((q9 \u003d mk_([5], [])) and (((DoubleListQueue`toList)[int](q10) \u003d []) and ((DoubleListQueue`isEmpty)[int](q10) and ((q10 \u003d mk_([], [])) and ((h2 \u003d nil) and ((q11 \u003d nil) and (((DoubleListQueue`toList)[char](q12) \u003d \"Sahara Shin\") and (q12 \u003d mk_([], \"nihS arahaS\"))))))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"DoubleListQueueT01:\t Test Queue\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend DoubleListQueueT01\n","class FHashtable\npublic static  public static Put[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e (@T2 -\u003e map (@T1) to (map (@T1) to (@T2))))))\n\tPut(aHashtable)(aHashCode)(aKey)(aValue) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in (if (hashcode in set (dom aHashtable))\nthen (aHashtable ++ {hashcode |-\u003e (aHashtable(hashcode) ++ {aKey |-\u003e aValue})})\nelse (aHashtable munion {hashcode |-\u003e {aKey |-\u003e aValue}}))\npublic static  public static PutAll[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (map (@T1) to (@T2) -\u003e map (@T1) to (map (@T1) to (@T2)))))\n\tPutAll(aHashtable)(aHashCode)(aMap) \u003d\u003d\n(PutAllAux)[@T1, @T2](aHashtable)(aHashCode)(aMap)((dom aMap))\npublic static  public static PutAllAux[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (map (@T1) to (@T2) -\u003e (set of (@T1) -\u003e map (@T1) to (map (@T1) to (@T2))))))\n\tPutAllAux(aHashtable)(aHashCode)(aMap)(aKeySet) \u003d\u003d\n(if (aKeySet \u003d {})\nthen aHashtable\nelse let aKey in set aKeySet in let newHashtable:map (@T1) to (map (@T1) to (@T2)) \u003d (Put)[@T1, @T2](aHashtable)(aHashCode)(aKey)(aMap(aKey)) in (PutAllAux)[@T1, @T2](newHashtable)(aHashCode)(aMap)((aKeySet \\ {aKey})))\npublic static  public static Get[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e [@T2])))\n\tGet(aHashtable)(aHashCode)(aKey) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in (if (hashcode in set (dom aHashtable))\nthen (FMap`Get)[@T1, @T2](aHashtable(hashcode))(aKey)\nelse nil)\npublic static  public static Remove[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e map (@T1) to (map (@T1) to (@T2)))))\n\tRemove(aHashtable)(aHashCode)(aKey) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in ({h |-\u003e ({aKey} \u003c-: aHashtable(hashcode)) | h in set {hashcode}} munion ({hashcode} \u003c-: aHashtable))\npublic static  public static Clear[(T1, T2)]: (() -\u003e map (@T1) to (map (@T1) to (@T2)))\n\tClear() \u003d\u003d\n{|-\u003e}\npublic static  public static KeySet[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e set of (@T1))\n\tKeySet(aHashtable) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (dunion {(dom s) | s in set aMapSet})\nelse {})\npublic static  public static ValueSet[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e set of (@T2))\n\tValueSet(aHashtable) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (dunion {(rng s) | s in set aMapSet})\nelse {})\npublic static  public static Size[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e nat)\n\tSize(aHashtable) \u003d\u003d\n(card (KeySet)[@T1, @T2](aHashtable))\npublic static  public static IsEmpty[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e bool)\n\tIsEmpty(aHashtable) \u003d\u003d\n((KeySet)[@T1, @T2](aHashtable) \u003d {})\npublic static  public static Contains[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e (@T2 -\u003e bool))\n\tContains(aHashtable)(aValue) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (exists aMap in set aMapSet \u0026 (aValue in set (rng aMap)))\nelse false)\npublic static  public static ContainsKey[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e (@T1 -\u003e bool))\n\tContainsKey(aHashtable)(aKey) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (exists aMap in set aMapSet \u0026 (aKey in set (dom aMap)))\nelse false)\nend FHashtable\n","class FHashtableT\npublic static  public static run: (() +\u003e bool)\n\trun() \u003d\u003d\nlet testcases:seq1 of (TestCase) \u003d [t1(), t2(), t3(), t4(), t5(), t6()] in FTestDriver`run(testcases)\nprivate static  private static t1: (() -\u003e TestCase)\n\tt1() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT01:\t Test Contains, PutAll\", let aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), p1:map (int) to (map (int) to (seq of (char))) \u003d (FHashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode)({1 |-\u003e \"Sahara\", 2 |-\u003e \"Sato\", 14 |-\u003e \"Sakoh\"}), c1:(seq of (char) +\u003e bool) \u003d (FHashtable`Contains)[int, seq of (char)](p1) in (c1(\"Sahara\") and (c1(\"Sato\") and (c1(\"Sakoh\") and (c1(\"\") \u003d false)))))\nprivate static  private static t2: (() -\u003e TestCase)\n\tt2() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT02:\t Test Clear, Remove, ContainsKey\", let aHashCode:(seq of (char) -\u003e seq of (char)) \u003d (lambda [x:seq of (char)] \u0026 (if (x \u003d \"\")\nthen \"\"\nelse (FSequence`Take)[char](1)(x))), h2:map (seq of (char)) to (map (seq of (char)) to (int)) \u003d (FHashtable`PutAll)[seq of (char), int]({|-\u003e})(aHashCode)({\"a\" |-\u003e 1, \"b\" |-\u003e 2, \"c\" |-\u003e 3}), h3:map (int) to (map (int) to (seq of (char))) \u003d (FHashtable`Clear)[int, seq of (char)](), deletedh2:map (seq of (char)) to (map (seq of (char)) to (int)) \u003d (FHashtable`Remove)[seq of (char), int](h2)(aHashCode)(\"b\"), c1:(int +\u003e bool) \u003d (FHashtable`Contains)[seq of (char), int](deletedh2), ck1:(seq of (char) +\u003e bool) \u003d (FHashtable`ContainsKey)[seq of (char), int](deletedh2) in ((h3 \u003d {|-\u003e}) and (((FHashtable`Get)[seq of (char), int](deletedh2)(aHashCode)(\"b\") \u003d nil) and ((c1(2) \u003d false) and (c1(1) and (c1(3) and ((ck1(\"b\") \u003d false) and (ck1(\"a\") and ck1(\"c\")))))))))\nprivate static  private static t3: (() -\u003e TestCase)\n\tt3() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT03:\t Test Put, Get\", let aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), put:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e (seq of (char) +\u003e map (int) to (map (int) to (seq of (char))))))) \u003d (FHashtable`Put)[int, seq of (char)], p1:map (int) to (map (int) to (seq of (char))) \u003d put({|-\u003e})(aHashCode)(1)(\"Sahara\"), p2:map (int) to (map (int) to (seq of (char))) \u003d put(p1)(aHashCode)(2)(\"Bush\"), p3:map (int) to (map (int) to (seq of (char))) \u003d put(p2)(aHashCode)(2)(\"Sato\"), p4:map (int) to (map (int) to (seq of (char))) \u003d put(p3)(aHashCode)(14)(\"Sakoh\"), get:((int +\u003e int) +\u003e (int +\u003e [seq of (char)])) \u003d (FHashtable`Get)[int, seq of (char)](p4), g:(int +\u003e [seq of (char)]) \u003d (FHashtable`Get)[int, seq of (char)](p4)(aHashCode) in ((get(aHashCode)(1) \u003d \"Sahara\") and ((get(aHashCode)(2) \u003d \"Sato\") and ((get(aHashCode)(14) \u003d \"Sakoh\") and ((get(aHashCode)(99) \u003d nil) and (((FSequence`Fmap)[int, seq of (char)](g)([1, 14]) \u003d [\"Sahara\", \"Sakoh\"]) and ((FSequence`Fmap)[int, seq of (char)](g)([1, 2]) \u003d [\"Sahara\", \"Sato\"])))))))\nprivate static  private static t4: (() -\u003e TestCase)\n\tt4() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT04:\t Test KeySet, ValueSet\", let aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), put:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e (seq of (char) +\u003e map (int) to (map (int) to (seq of (char))))))) \u003d (FHashtable`Put)[int, seq of (char)], p1:map (int) to (map (int) to (seq of (char))) \u003d put({|-\u003e})(aHashCode)(1)(\"Sahara\"), p2:map (int) to (map (int) to (seq of (char))) \u003d put(p1)(aHashCode)(2)(\"Bush\"), p3:map (int) to (map (int) to (seq of (char))) \u003d put(p2)(aHashCode)(2)(\"Sato\"), p4:map (int) to (map (int) to (seq of (char))) \u003d put(p3)(aHashCode)(14)(\"Sakoh\"), k:(map (int) to (map (int) to (seq of (char))) +\u003e set of (int)) \u003d (FHashtable`KeySet)[int, seq of (char)], v:(map (int) to (map (int) to (seq of (char))) +\u003e set of (seq of (char))) \u003d (FHashtable`ValueSet)[int, seq of (char)] in ((k(p1) \u003d {1}) and ((v(p1) \u003d {\"Sahara\"}) and ((k(p2) \u003d {1, 2}) and ((v(p2) \u003d {\"Sahara\", \"Bush\"}) and ((k(p4) \u003d {1, 2, 14}) and (v(p4) \u003d {\"Sahara\", \"Sato\", \"Sakoh\"})))))))\nprivate static  private static t5: (() -\u003e TestCase)\n\tt5() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT05:\t Test hashCode is duplicate\", let aHashCode1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), h1:map (int) to (map (int) to (seq of (char))) \u003d (FHashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode1)({1 |-\u003e \"SaharaShin\", 2 |-\u003e \"SatoKei\", 14 |-\u003e \"SakohHiroshi\", 27 |-\u003e \"NishikawaNoriko\"}), h2:map (int) to (map (int) to (seq of (char))) \u003d (FHashtable`Remove)[int, seq of (char)](h1)(aHashCode1)(14) in (((FHashtable`KeySet)[int, seq of (char)](h2) \u003d {1, 2, 27}) and ((FHashtable`ValueSet)[int, seq of (char)](h2) \u003d {\"SaharaShin\", \"SatoKei\", \"NishikawaNoriko\"})))\nprivate static  private static t6: (() -\u003e TestCase)\n\tt6() \u003d\u003d\nmk_FTestDriver`TestCase(\"FHashtableT06:\t Test Size\", let aHashCode1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), remove:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e map (int) to (map (int) to (seq of (char)))))) \u003d (FHashtable`Remove)[int, seq of (char)], h1:map (int) to (map (int) to (seq of (char))) \u003d (FHashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode1)({1 |-\u003e \"SaharaShin\", 2 |-\u003e \"SatoKei\", 14 |-\u003e \"SakohHiroshi\"}), h2:map (int) to (map (int) to (seq of (char))) \u003d remove(h1)(aHashCode1)(1), h3:map (int) to (map (int) to (seq of (char))) \u003d remove(h2)(aHashCode1)(2), h4:map (int) to (map (int) to (seq of (char))) \u003d remove(h3)(aHashCode1)(14), isempty:(map (int) to (map (int) to (seq of (char))) +\u003e bool) \u003d (FHashtable`IsEmpty)[int, seq of (char)], size:(map (int) to (map (int) to (seq of (char))) +\u003e nat) \u003d (FHashtable`Size)[int, seq of (char)] in (isempty(h4) and ((size(h4) \u003d 0) and ((isempty(h3) \u003d false) and ((size(h3) \u003d 1) and ((size(h2) \u003d 2) and (size(h1) \u003d 3)))))))\nend FHashtableT\n","class FMap\npublic static  public static Get[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T1 -\u003e [@T2]))\n\tGet(aMap)(aKey) \u003d\u003d\n(if (aKey in set (dom aMap))\nthen aMap(aKey)\nelse nil)\npublic static  public static Contains[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T2 -\u003e bool))\n\tContains(aMap)(aValue) \u003d\u003d\n(aValue in set (rng aMap))\npublic static  public static ContainsKey[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T1 -\u003e bool))\n\tContainsKey(aMap)(aKey) \u003d\u003d\n(aKey in set (dom aMap))\nend FMap\n","class FSequence\npublic static  public static Sum[(T)]: (seq of (@T) -\u003e @T)\n\tSum(s) \u003d\u003d\n(Foldl)[@T, @T]((Plus)[@T])(0)(s)\n\tpre (is_(s, seq of (int)) or (is_(s, seq of (nat)) or (is_(s, seq of (nat1)) or (is_(s, seq of (real)) or is_(s, seq of (rat))))))\npublic static  public static Prod[(T)]: (seq of (@T) -\u003e @T)\n\tProd(s) \u003d\u003d\n(Foldl)[@T, @T]((Product)[@T])(1)(s)\n\tpre (is_(s, seq of (int)) or (is_(s, seq of (nat)) or (is_(s, seq of (nat1)) or (is_(s, seq of (real)) or is_(s, seq of (rat))))))\npublic static  public static Plus[(T)]: (@T -\u003e (@T -\u003e @T))\n\tPlus(a)(b) \u003d\u003d\n(if (is_(a, real) and is_(b, real))\nthen (a + b)\nelse (undefined))\npublic static  public static Product[(T)]: (@T -\u003e (@T -\u003e @T))\n\tProduct(a)(b) \u003d\u003d\n(if (is_(a, real) and is_(b, real))\nthen (a * b)\nelse (undefined))\npublic static  public static Append[(T)]: (seq of (@T) -\u003e (@T -\u003e seq of (@T)))\n\tAppend(s)(e) \u003d\u003d\n(s ^ [e])\npublic static  public static Average[(T)]: (seq of (@T) -\u003e [real])\n\tAverage(s) \u003d\u003d\n(if (s \u003d [])\nthen nil\nelse (AverageAux)[@T](0)(0)(s))\n\tpost (if (s \u003d [])\nthen (RESULT \u003d nil)\nelse let sum:@T \u003d (Sum)[@T](s) in (RESULT \u003d (if is_(sum, real)\nthen (sum / (len s))\nelse (undefined))))\nprivate static  private static AverageAux[(T)]: (@T -\u003e (@T -\u003e (seq of (@T) -\u003e real)))\n\tAverageAux(total)(numOfElem)(s) \u003d\u003d\n(if (is_(s, seq of (real)) and (is_(total, real) and is_(numOfElem, real)))\nthen (cases s :\n[x] ^ xs -\u003e (AverageAux)[@T]((total + x))((numOfElem + 1))(xs),\n[] -\u003e (total / numOfElem)\n end)\nelse (undefined))\npublic static  public static IsAscendingInTotalOrder[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e bool))\n\tIsAscendingInTotalOrder(f)(s) \u003d\u003d\n(forall i, j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (f(s(i), s(j)) or (s(i) \u003d s(j)))))\npublic static  public static IsDescendingInTotalOrder[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e bool))\n\tIsDescendingInTotalOrder(f)(s) \u003d\u003d\n(forall i, j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (f(s(j), s(i)) or (s(i) \u003d s(j)))))\npublic static  public static IsAscending[(T)]: (seq of (@T) -\u003e bool)\n\tIsAscending(s) \u003d\u003d\n(IsAscendingInTotalOrder)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\npublic static  public static IsDescending[(T)]: (seq of (@T) -\u003e bool)\n\tIsDescending(s) \u003d\u003d\n(IsDescendingInTotalOrder)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\npublic static  public static Sort[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tSort(f)(s) \u003d\u003d\n(cases s :\n[] -\u003e [],\n[x] ^ xs -\u003e (((Sort)[@T](f)([xs(i) | i in set (inds xs) \u0026 f(xs(i), x)]) ^ [x]) ^ (Sort)[@T](f)([xs(i) | i in set (inds xs) \u0026 (not f(xs(i), x))]))\n end)\npublic static  public static AscendingSort[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tAscendingSort(s) \u003d\u003d\n(Sort)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\n\tpost (IsAscending)[@T](RESULT)\npublic static  public static DescendingSort[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tDescendingSort(s) \u003d\u003d\n(Sort)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003e y)\nelse (undefined))))(s)\n\tpost (IsDescending)[@T](RESULT)\npublic static  public static IsOrdered[(T)]: (seq of ((@T * @T -\u003e bool)) -\u003e (seq of (@T) -\u003e (seq of (@T) -\u003e bool)))\n\tIsOrdered(f)(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([], []) -\u003e false,\nmk_([], -) -\u003e true,\nmk_(-, []) -\u003e false,\nmk_([x1] ^ xs1, [x2] ^ xs2) -\u003e (if (hd f)(x1, x2)\nthen true\nelseif (hd f)(x2, x1)\nthen false\nelse (IsOrdered)[@T]((tl f))(xs1)(xs2))\n end)\npublic static  public static Merge[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tMerge(f)(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([], y) -\u003e y,\nmk_(x, []) -\u003e x,\nmk_([x1] ^ xs1, [x2] ^ xs2) -\u003e (if f(x1, x2)\nthen ([x1] ^ (FSequence`Merge)[@T](f)(xs1)(s2))\nelse ([x2] ^ (FSequence`Merge)[@T](f)(s1)(xs2)))\n end)\npublic static  public static InsertAt[(T)]: (nat1 -\u003e (@T -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tInsertAt(i)(e)(s) \u003d\u003d\n(cases mk_(i, s) :\nmk_(1, s1) -\u003e ([e] ^ s1),\nmk_(-, []) -\u003e [e],\nmk_(i1, [x] ^ xs) -\u003e ([x] ^ (InsertAt)[@T]((i1 - 1))(e)(xs))\n end)\npublic static  public static RemoveAt[(T)]: (nat1 -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveAt(i)(s) \u003d\u003d\n(cases mk_(i, s) :\nmk_(1, [-] ^ xs) -\u003e xs,\nmk_(i1, [x] ^ xs) -\u003e ([x] ^ (RemoveAt)[@T]((i1 - 1))(xs)),\nmk_(-, []) -\u003e []\n end)\npublic static  public static RemoveDup[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tRemoveDup(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e ([x] ^ (RemoveDup)[@T]((Filter)[@T]((lambda [e:@T] \u0026 (e \u003c\u003e x)))(xs))),\n[] -\u003e []\n end)\n\tpost (not (IsDup)[@T](RESULT))\npublic static  public static RemoveMember[(T)]: (@T -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveMember(e)(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e (if (e \u003d x)\nthen xs\nelse ([x] ^ (RemoveMember)[@T](e)(xs))),\n[] -\u003e []\n end)\npublic static  public static RemoveMembers[(T)]: (seq of (@T) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveMembers(es)(s) \u003d\u003d\n(cases es :\n[] -\u003e s,\n[x] ^ xs -\u003e (RemoveMembers)[@T](xs)((RemoveMember)[@T](x)(s))\n end)\npublic static  public static UpdateAt[(T)]: (nat1 -\u003e (@T -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tUpdateAt(i)(e)(s) \u003d\u003d\n(cases mk_(i, s) :\nmk_(-, []) -\u003e [],\nmk_(1, [-] ^ xs) -\u003e ([e] ^ xs),\nmk_(i1, [x] ^ xs) -\u003e ([x] ^ (UpdateAt)[@T]((i1 - 1))(e)(xs))\n end)\npublic static  public static Take[(T)]: (int -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tTake(i)(s) \u003d\u003d\n(s(1, ... ,i))\npublic static  public static TakeWhile[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tTakeWhile(f)(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e (if f(x)\nthen ([x] ^ (TakeWhile)[@T](f)(xs))\nelse []),\n[] -\u003e []\n end)\npublic static  public static Drop[(T)]: (int -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tDrop(i)(s) \u003d\u003d\n(s((i + 1), ... ,(len s)))\npublic static  public static DropWhile[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tDropWhile(f)(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e (if f(x)\nthen (DropWhile)[@T](f)(xs)\nelse s),\n[] -\u003e []\n end)\npublic static  public static Span[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e (seq of (@T) * seq of (@T))))\n\tSpan(f)(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e (if f(x)\nthen let mk_(satisfied, notSatisfied):(seq of (@T) * seq of (@T)) \u003d (Span)[@T](f)(xs) in mk_(([x] ^ satisfied), notSatisfied)\nelse mk_([], s)),\n[] -\u003e mk_([], [])\n end)\npublic static  public static SubSeq[(T)]: (nat -\u003e (nat -\u003e (seq1 of (@T) -\u003e seq of (@T))))\n\tSubSeq(i)(numOfElems)(s) \u003d\u003d\n(s(i, ... ,((i + numOfElems) - 1)))\npublic static  public static Last[(T)]: (seq of (@T) -\u003e @T)\n\tLast(s) \u003d\u003d\ns((len s))\npublic static  public static Fmap[(T1, T2)]: ((@T1 -\u003e @T2) -\u003e (seq of (@T1) -\u003e seq of (@T2)))\n\tFmap(f)(s) \u003d\u003d\n[f(s(i)) | i in set (inds s)]\npublic static  public static Filter[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tFilter(f)(s) \u003d\u003d\n[s(i) | i in set (inds s) \u0026 f(s(i))]\npublic static  public static Foldl[(T1, T2)]: ((@T1 -\u003e (@T2 -\u003e @T1)) -\u003e (@T1 -\u003e (seq of (@T2) -\u003e @T1)))\n\tFoldl(f)(args)(s) \u003d\u003d\n(cases s :\n[] -\u003e args,\n[x] ^ xs -\u003e (Foldl)[@T1, @T2](f)(f(args)(x))(xs)\n end)\npublic static  public static Foldr[(T1, T2)]: ((@T1 -\u003e (@T2 -\u003e @T2)) -\u003e (@T2 -\u003e (seq of (@T1) -\u003e @T2)))\n\tFoldr(f)(args)(s) \u003d\u003d\n(cases s :\n[] -\u003e args,\n[x] ^ xs -\u003e f(x)((Foldr)[@T1, @T2](f)(args)(xs))\n end)\npublic static  public static IsMember[(T)]: (@T -\u003e (seq of (@T) -\u003e bool))\n\tIsMember(e)(s) \u003d\u003d\n(cases s :\n[x] ^ xs -\u003e ((e \u003d x) or (IsMember)[@T](e)(xs)),\n[] -\u003e false\n end)\npublic static  public static IsAnyMember[(T)]: (seq of (@T) -\u003e (seq of (@T) -\u003e bool))\n\tIsAnyMember(es)(s) \u003d\u003d\n(cases es :\n[x] ^ xs -\u003e ((IsMember)[@T](x)(s) or (IsAnyMember)[@T](xs)(s)),\n[] -\u003e false\n end)\npublic static  public static IsDup[(T)]: (seq of (@T) -\u003e bool)\n\tIsDup(s) \u003d\u003d\n(not ((card (elems s)) \u003d (len s)))\n\tpost (if (s \u003d [])\nthen (RESULT \u003d false)\nelse (RESULT \u003d (not (forall i, j in set (inds s) \u0026 ((s(i) \u003c\u003e s(j)) \u003c\u003d\u003e (i \u003c\u003e j))))))\npublic static  public static Index[(T)]: (@T -\u003e (seq of (@T) -\u003e int))\n\tIndex(e)(s) \u003d\u003d\nlet i:nat \u003d 0 in (IndexAux)[@T](e)(s)(i)\npublic static  public static IndexAux[(T)]: (@T -\u003e (seq of (@T) -\u003e (int -\u003e int)))\n\tIndexAux(e)(s)(i) \u003d\u003d\n(cases s :\n[] -\u003e 0,\n[x] ^ xs -\u003e (if (x \u003d e)\nthen (i + 1)\nelse (IndexAux)[@T](e)(xs)((i + 1)))\n end)\npublic static  public static IndexAll[(T)]: (@T -\u003e (seq of (@T) -\u003e set of (nat1)))\n\tIndexAll(e)(s) \u003d\u003d\n{i | i in set (inds s) \u0026 (s(i) \u003d e)}\npublic static  public static Flatten[(T)]: (seq of (seq of (@T)) -\u003e seq of (@T))\n\tFlatten(s) \u003d\u003d\n(conc s)\npublic static  public static Compact[(T)]: (seq of ([@T]) -\u003e seq of (@T))\n\tCompact(s) \u003d\u003d\n[s(i) | i in set (inds s) \u0026 (s(i) \u003c\u003e nil)]\n\tpost (forall i in set (inds RESULT) \u0026 (RESULT(i) \u003c\u003e nil))\npublic static  public static Freverse[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tFreverse(s) \u003d\u003d\n[s((((len s) + 1) - i)) | i in set (inds s)]\npublic static  public static Permutations[(T)]: (seq of (@T) -\u003e set of (seq of (@T)))\n\tPermutations(s) \u003d\u003d\n(cases s :\n[] -\u003e {s},\n[-] -\u003e {s}\nothers (dunion {{([s(i)] ^ j) | j in set (Permutations)[@T]((RemoveAt)[@T](i)(s))} | i in set (inds s)})\n end)\n\tpost (forall x in set RESULT \u0026 ((elems x) \u003d (elems s)))\npublic static  public static IsPermutations[(T)]: (seq of (@T) -\u003e (seq of (@T) -\u003e bool))\n\tIsPermutations(s)(t) \u003d\u003d\n(((RemoveMembers)[@T](s)(t) \u003d []) and ((RemoveMembers)[@T](t)(s) \u003d []))\npublic static  public static Unzip[(T1, T2)]: (seq of ((@T1 * @T2)) -\u003e (seq of (@T1) * seq of (@T2)))\n\tUnzip(s) \u003d\u003d\n(cases s :\n[] -\u003e mk_([], []),\n[mk_(x, y)] ^ xs -\u003e let mk_(s1, t):(seq of (@T1) * seq of (@T2)) \u003d (Unzip)[@T1, @T2](xs) in mk_(([x] ^ s1), ([y] ^ t))\n end)\npublic static  public static Zip[(T1, T2)]: (seq of (@T1) * seq of (@T2) -\u003e seq of ((@T1 * @T2)))\n\tZip(s1, s2) \u003d\u003d\n(Zip2)[@T1, @T2](s1)(s2)\npublic static  public static Zip2[(T1, T2)]: (seq of (@T1) -\u003e (seq of (@T2) -\u003e seq of ((@T1 * @T2))))\n\tZip2(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([x1] ^ xs1, [x2] ^ xs2) -\u003e ([mk_(x1, x2)] ^ (Zip2)[@T1, @T2](xs1)(xs2)),\nmk_(-, -) -\u003e []\n end)\nend FSequence\n","class FTestDriver\npublic static  TestCase \u003d TestCase\npublic static  public static run: (seq of (TestCase) +\u003e bool)\n\trun(t) \u003d\u003d\nlet m:seq1 of (char) \u003d \"Result-of-testcases.\", r:seq of (bool) \u003d [isOK(t(i)) | i in set (inds t)] in (if (forall i in set (inds r) \u0026 r(i))\nthen FTestLogger`SuccessAll(m)\nelse FTestLogger`FailureAll(m))\npublic static  public static isOK: (TestCase +\u003e bool)\n\tisOK(t) \u003d\u003d\n(if GetTestResult(t)\nthen FTestLogger`Success(t)\nelse FTestLogger`Failure(t))\npublic static  public static GetTestResult: (TestCase +\u003e bool)\n\tGetTestResult(t) \u003d\u003d\n(t.testResult)\npublic static  public static GetTestName: (TestCase +\u003e seq of (char))\n\tGetTestName(t) \u003d\u003d\n(t.testCaseName)\nend FTestDriver\n","class FTestLogger\nprivate static  historyFileName:seq1 of (char) \u003d \"VDMTESTLOG.TXT\"\npublic static  public static Success: (TestCase +\u003e bool)\n\tSuccess(t) \u003d\u003d\nlet message:seq1 of (char) \u003d (FTestDriver`GetTestName(t) ^ \"\tOK.\n\"), -:bool \u003d Fprint(message), -:bool \u003d Print(message) in true\npublic static  public static Failure: (TestCase +\u003e bool)\n\tFailure(t) \u003d\u003d\nlet message:seq1 of (char) \u003d (FTestDriver`GetTestName(t) ^ \"\tNG.\n\"), -:bool \u003d Fprint(message), -:bool \u003d Print(message) in false\npublic static  public static SuccessAll: (seq of (char) +\u003e bool)\n\tSuccessAll(m) \u003d\u003d\nlet message:seq1 of (char) \u003d (m ^ \"\tOK!!\n\"), -:bool \u003d Fprint(message), -:bool \u003d Print(message) in true\npublic static  public static FailureAll: (seq of (char) +\u003e bool)\n\tFailureAll(m) \u003d\u003d\nlet message:seq1 of (char) \u003d (m ^ \"\tNG!!\n\"), -:bool \u003d Fprint(message), -:bool \u003d Print(message) in false\npublic static  public static Print: (seq of (char) -\u003e bool)\n\tPrint(s) \u003d\u003d\n(new IO().echo)(s)\npublic static  public static Fprint: (seq of (char) -\u003e bool)\n\tFprint(s) \u003d\u003d\n(new IO().fecho)(historyFileName, s, \u003cappend\u003e)\npublic static  Pr(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPr(seq of (char))(s) \u003d\u003d\nlet -:bool \u003d (new IO().echo)(s) in skip\npublic static  Fpr(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tFpr(seq of (char))(s) \u003d\u003d\nlet -:bool \u003d (new IO().fecho)(historyFileName, s, \u003cappend\u003e) in skip\nend FTestLogger\n","class Function\npublic static  public static Funtil[(T)]: ((@T -\u003e bool) -\u003e ((@T -\u003e @T) -\u003e (@T -\u003e @T)))\n\tFuntil(p)(f)(x) \u003d\u003d\n(if p(x)\nthen x\nelse (Funtil)[@T](p)(f)(f(x)))\npublic static  public static Fwhile[(T)]: ((@T -\u003e bool) -\u003e ((@T -\u003e @T) -\u003e (@T -\u003e @T)))\n\tFwhile(p)(f)(x) \u003d\u003d\n(if p(x)\nthen (Fwhile)[@T](p)(f)(f(x))\nelse x)\npublic static  public static Seq[(T)]: (seq of ((@T -\u003e @T)) -\u003e (@T -\u003e @T))\n\tSeq(fs)(p) \u003d\u003d\n(cases fs :\n[xf] ^ xfs -\u003e (Seq)[@T](xfs)(xf(p)),\n[] -\u003e p\n end)\npublic static  public static readFn[(T)]: (seq of (char) -\u003e [@T])\n\treadFn(fname) \u003d\u003d\nlet io:IO \u003d new IO(), mk_(aResult, f):(bool * [@T]) \u003d ((io.freadval))[@T](fname) in (if aResult\nthen f\nelse let -:bool \u003d (io.echo)((\"Can\u0027t read values from the data file \u003d \" ^ fname)) in nil)\nend Function\n","class FunctionT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new FunctionT01(), new FunctionT02(), new FunctionT03()]\nend FunctionT\n","class FunctionT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet f1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x * 2)), p1:(int -\u003e bool) \u003d (lambda [x:int] \u0026 (x \u003e 1000)), p11:(int -\u003e bool) \u003d (lambda [x:int] \u0026 (x \u003c\u003d 1000)), f2:(seq of (char) -\u003e seq1 of (char)) \u003d (lambda [x:seq of (char)] \u0026 (x ^ \"0\")), p2:(seq of (char) -\u003e bool) \u003d (lambda [x:seq of (char)] \u0026 ((len x) \u003e 9)), p21:(seq of (char) -\u003e bool) \u003d (lambda [x:seq of (char)] \u0026 ((len x) \u003c\u003d 9)) in return ((((Function`Fwhile)[int](p11)(f1)(1) \u003d 1024) and (((Function`Fwhile)[seq of (char)](p21)(f2)(\"123456\") \u003d \"1234560000\") and (((Function`Funtil)[int](p1)(f1)(1) \u003d 1024) and ((Function`Funtil)[seq of (char)](p2)(f2)(\"123456\") \u003d \"1234560000\")))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"FunctionT01:\tTest Fwhile, Funtil.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend FunctionT01\n","class FunctionT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet f1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x * 2)), f2:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x * 3)), f3:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x ** 2)), funcSeq1:seq1 of ((int -\u003e int)) \u003d [f1, f2, f3], f10:(seq of (char) -\u003e seq of (char)) \u003d (lambda [x:seq of (char)] \u0026 (x ^ x)), f11:(seq of (char) +\u003e seq of (char)) \u003d (Sequence`take)[char](10), f12:(seq of (char) +\u003e seq of (char)) \u003d (Sequence`drop)[char](4), funcSeq2:seq1 of (((seq of (char) +\u003e seq of (char)) | (seq of (char) -\u003e seq of (char)))) \u003d [f10, f11, f12] in return ((((Function`Seq)[int](funcSeq1)(2) \u003d (((2 * 2) * 3) ** 2)) and ((Function`Seq)[seq of (char)](funcSeq2)(\"12345678\") \u003d \"567812\")))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"FunctionT02:\tTest function apply.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend FunctionT02\n","class FunctionT03 is subclass of [TestCase]\npublic static  INT \u003d INT\npublic static  ReadingFunctionType \u003d ReadingFunctionType\npublic  public ReadingFunction: (() -\u003e ReadingFunctionType)\n\tReadingFunction() \u003d\u003d\nlet fn:seq1 of (char) \u003d \"./fread-func.txt\" in (Function`readFn)[ReadingFunctionType](fn)\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((ReadingFunction()(3)(2) \u003d 1) and ((ReadingFunction()(4)(4) \u003d 0) and ((ReadingFunction()(4)(-3) \u003d -2) and (ReadingFunction()(-4)(3) \u003d 2)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"FunctionT03:\tTest of reading function.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend FunctionT03\n","class Hashtable is subclass of [CommonDefinition]\npublic static  Contents \u003d Contents\npublic static  Bucket \u003d Bucket\nprivate  sBucket:Bucket :\u003d {|-\u003e}\npublic  Hashtable() (() \u003d\u003d\u003e Hashtable)\n\tHashtable()() \u003d\u003d\n(\n\nsBucket :\u003d {|-\u003e};\nreturn (self)\n)\npublic  Hashtable(Contents) (Contents \u003d\u003d\u003e Hashtable)\n\tHashtable(Contents)(aContents) \u003d\u003d\n(\n\nself.putAll(aContents);\nreturn (self)\n)\npublic  clear() (() \u003d\u003d\u003e ())\n\tclear()() \u003d\u003d\nsetBuckets({|-\u003e})\npublic  getBuckets() (() \u003d\u003d\u003e Bucket)\n\tgetBuckets()() \u003d\u003d\nreturn (sBucket)\npublic  setBuckets(Bucket) (Bucket \u003d\u003d\u003e ())\n\tsetBuckets(Bucket)(aBucket) \u003d\u003d\nsBucket :\u003d aBucket\npublic  keySet() (() \u003d\u003d\u003e set of (Object))\n\tkeySet()() \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)() in (\nallKeySet:set of (Object) :\u003d {}\n\nfor all aContents in set (rng buckets) do\nallKeySet :\u003d (allKeySet union (dom aContents));\nreturn (allKeySet)\n)\npublic  put(Object, Object) (Object * Object \u003d\u003d\u003e ())\n\tput(Object, Object)(akey, aValue) \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)(), hashcode:int \u003d (akey.hashCode)() in (\n\nif (hashcode in set (dom buckets))\nthen\nself.setBuckets((buckets ++ {hashcode |-\u003e (buckets(hashcode) ++ {akey |-\u003e aValue})}))else\nself.setBuckets((buckets munion {hashcode |-\u003e {akey |-\u003e aValue}}))\n)\npublic  putAll(Contents) (Contents \u003d\u003d\u003e ())\n\tputAll(Contents)(aContents) \u003d\u003d\nfor all key in set (dom aContents) do\n(\n\nself.put(key, aContents(key))\n)\npublic  get(Object) (Object \u003d\u003d\u003e [Object])\n\tget(Object)(key) \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)(), hashcode:int \u003d (key.hashCode)() in (\n\nif (hashcode in set (dom buckets))\nthen\nlet aContents:Contents \u003d buckets(hashcode) in for all aKey in set (dom aContents) do\n(\n\nif (key.equals)(aKey)\nthen\nreturn (aContents(aKey))\n);\nreturn (nil)\n)\npublic  remove(Object) (Object \u003d\u003d\u003e [Object])\n\tremove(Object)(key) \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)(), hashcode:int \u003d (key.hashCode)(), deleteObj:[Object] \u003d (self.get)(key) in (\n\nif (deleteObj \u003c\u003e nil)\nthen\nlet aContents:Contents \u003d buckets(hashcode), newContents:Contents \u003d (aContents :-\u003e {deleteObj}) in (\n\nself.setBuckets((buckets ++ {hashcode |-\u003e newContents}));\nreturn (deleteObj)\n)else\nreturn (nil)\n)\npublic  valueSet() (() \u003d\u003d\u003e set of (Object))\n\tvalueSet()() \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)() in (\naValueSet:set of (Object) :\u003d {}\n\nfor all aContents in set (rng buckets) do\naValueSet :\u003d (aValueSet union (rng aContents));\nreturn (aValueSet)\n)\npublic  public size: (() -\u003e nat)\n\tsize() \u003d\u003d\n(card (self.keySet)())\npublic  public isEmpty: (() -\u003e bool)\n\tisEmpty() \u003d\u003d\n((self.keySet)() \u003d {})\npublic  public contains: (Object -\u003e bool)\n\tcontains(anObject) \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)() in (exists hashcode in set (dom buckets) \u0026 let aContents:Contents \u003d buckets(hashcode) in (exists key in set (dom aContents) \u0026 (aContents(key).equals)(anObject)))\npublic  public containsKey: (Object -\u003e bool)\n\tcontainsKey(aKey) \u003d\u003d\nlet buckets:Bucket \u003d (self.getBuckets)() in (exists hashcode in set (dom buckets) \u0026 (exists key in set (dom buckets(hashcode)) \u0026 (aKey.equals)(key)))\npublic static  public static Put[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e (@T2 -\u003e map (@T1) to (map (@T1) to (@T2))))))\n\tPut(aHashtable)(aHashCode)(aKey)(aValue) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in (if (hashcode in set (dom aHashtable))\nthen (aHashtable ++ {hashcode |-\u003e (aHashtable(hashcode) ++ {aKey |-\u003e aValue})})\nelse (aHashtable munion {hashcode |-\u003e {aKey |-\u003e aValue}}))\npublic static  public static PutAll[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (map (@T1) to (@T2) -\u003e map (@T1) to (map (@T1) to (@T2)))))\n\tPutAll(aHashtable)(aHashCode)(aMap) \u003d\u003d\n(PutAllAux)[@T1, @T2](aHashtable)(aHashCode)(aMap)((dom aMap))\npublic static  public static PutAllAux[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (map (@T1) to (@T2) -\u003e (set of (@T1) -\u003e map (@T1) to (map (@T1) to (@T2))))))\n\tPutAllAux(aHashtable)(aHashCode)(aMap)(aKeySet) \u003d\u003d\n(if (aKeySet \u003d {})\nthen aHashtable\nelse let aKey in set aKeySet in let newHashtable:map (@T1) to (map (@T1) to (@T2)) \u003d (Put)[@T1, @T2](aHashtable)(aHashCode)(aKey)(aMap(aKey)) in (PutAllAux)[@T1, @T2](newHashtable)(aHashCode)(aMap)((aKeySet \\ {aKey})))\npublic static  public static Get[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e [@T2])))\n\tGet(aHashtable)(aHashCode)(aKey) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in (if (hashcode in set (dom aHashtable))\nthen (Map`Get)[@T1, @T2](aHashtable(hashcode))(aKey)\nelse nil)\npublic static  public static Remove[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e ((@T1 -\u003e @T1) -\u003e (@T1 -\u003e map (@T1) to (map (@T1) to (@T2)))))\n\tRemove(aHashtable)(aHashCode)(aKey) \u003d\u003d\nlet hashcode:@T1 \u003d aHashCode(aKey) in ({h |-\u003e ({aKey} \u003c-: aHashtable(hashcode)) | h in set {hashcode}} munion ({hashcode} \u003c-: aHashtable))\npublic static  public static Clear[(T1, T2)]: (() -\u003e map (@T1) to (map (@T1) to (@T2)))\n\tClear() \u003d\u003d\n{|-\u003e}\npublic static  public static KeySet[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e set of (@T1))\n\tKeySet(aHashtable) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (dunion {(dom s) | s in set aMapSet})\nelse {})\npublic static  public static ValueSet[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e set of (@T2))\n\tValueSet(aHashtable) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (dunion {(rng s) | s in set aMapSet})\nelse {})\npublic static  public static Size[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e nat)\n\tSize(aHashtable) \u003d\u003d\n(card (KeySet)[@T1, @T2](aHashtable))\npublic static  public static IsEmpty[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e bool)\n\tIsEmpty(aHashtable) \u003d\u003d\n((KeySet)[@T1, @T2](aHashtable) \u003d {})\npublic static  public static Contains[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e (@T2 -\u003e bool))\n\tContains(aHashtable)(aValue) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (exists aMap in set aMapSet \u0026 (aValue in set (rng aMap)))\nelse false)\npublic static  public static ContainsKey[(T1, T2)]: (map (@T1) to (map (@T1) to (@T2)) -\u003e (@T1 -\u003e bool))\n\tContainsKey(aHashtable)(aKey) \u003d\u003d\nlet aMapSet:set of (map (@T1) to (@T2)) \u003d (rng aHashtable) in (if (aMapSet \u003c\u003e {})\nthen (exists aMap in set aMapSet \u0026 (aKey in set (dom aMap)))\nelse false)\nend Hashtable\n","class StringObj is subclass of [CommonDefinition]\npublic  content:seq of (char) :\u003d (undefined)\npublic  public hashCode: (() -\u003e int)\n\thashCode() \u003d\u003d\nlet c:[seq of (char)] \u003d getContent() in (if (c \u003c\u003e nil)\nthen ((len c) mod 17)\nelse -1)\npublic  public equals: (Object -\u003e bool)\n\tequals(anObject) \u003d\u003d\n(if isofclass(StringObj,anObject)\nthen ((self.getContent)() \u003d (anObject.getContent)())\nelse false)\npublic  StringObj(seq of (char)) (seq of (char) \u003d\u003d\u003e StringObj)\n\tStringObj(seq of (char))(aString) \u003d\u003d\n(\n\ncontent :\u003d aString;\nreturn (self)\n)\npublic  getContent() (() \u003d\u003d\u003e [seq of (char)])\n\tgetContent()() \u003d\u003d\nif isofclass(StringObj,self)\nthen\nreturn (content)else\nreturn (nil)\nend StringObj\n","class IntObj is subclass of [CommonDefinition]\npublic  content:int :\u003d (undefined)\npublic  public hashCode: (() -\u003e int)\n\thashCode() \u003d\u003d\nlet c:[int] \u003d getContent() in (if (c \u003c\u003e nil)\nthen (c mod 13)\nelse -1)\npublic  public equals: (Object -\u003e bool)\n\tequals(anObject) \u003d\u003d\n(if isofclass(IntObj,anObject)\nthen ((self.getContent)() \u003d (anObject.getContent)())\nelse false)\npublic  IntObj(int) (int \u003d\u003d\u003e IntObj)\n\tIntObj(int)(i) \u003d\u003d\n(\n\ncontent :\u003d i;\nreturn (self)\n)\npublic  getContent() (() \u003d\u003d\u003e [int])\n\tgetContent()() \u003d\u003d\nif isofclass(IntObj,self)\nthen\nreturn (content)else\nreturn (nil)\nend IntObj\n","class HashtableT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new HashtableT52(), new HashtableT53(), new HashtableT54(), new HashtableT55(), new HashtableT56(), new HashtableT57(), new HashtableT01(), new HashtableT02(), new HashtableT03(), new HashtableT04(), new HashtableT05(), new HashtableT06(), new HashtableT07()]\nend HashtableT\n","class HashtableT01 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable(), k1:IntObj \u003d new IntObj(1), k2:IntObj \u003d new IntObj(2), k3:IntObj \u003d new IntObj(3), h2:Hashtable \u003d new Hashtable({k1 |-\u003e new StringObj(\"Shin Sahara\"), k2 |-\u003e new StringObj(\"Kei Sato\"), k3 |-\u003e new StringObj(\"Hiroshi Sakoh\")}) in return ((((h1.getBuckets)() \u003d {|-\u003e}) and (((h2.get)(k1).equals)(new StringObj(\"Shin Sahara\")) and (((h2.get)(k2).equals)(new StringObj(\"Kei Sato\")) and (((h2.get)(k3).equals)(new StringObj(\"Hiroshi Sakoh\")) and (((h2.get)(new IntObj(1)).equals)(new StringObj(\"Shin Sahara\")) and (((h2.get)(new IntObj(2)).equals)(new StringObj(\"Kei Sato\")) and ((h2.get)(new IntObj(3)).equals)(new StringObj(\"Hiroshi Sakoh\")))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT01:\tConstructor test.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT01\n","class HashtableT02 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable({new IntObj(1) |-\u003e new StringObj(\"Shin Sahara\"), new IntObj(2) |-\u003e new StringObj(\"Kei Sato\"), new IntObj(3) |-\u003e new StringObj(\"Hiroshi Sakoh\")}), h2:Hashtable \u003d new Hashtable({new StringObj(\"a\") |-\u003e new IntObj(1), new StringObj(\"b\") |-\u003e new IntObj(2), new StringObj(\"c\") |-\u003e new IntObj(3)}) in return (((h1.contains)(new StringObj(\"Shin Sahara\")) and ((h1.contains)(new StringObj(\"Kei Sato\")) and (((h1.contains)(new StringObj(\"Shin Sakoh\")) \u003d false) and ((h1.containsKey)(new IntObj(1)) and (((h1.containsKey)(new IntObj(4)) \u003d false) and ((h2.contains)(new IntObj(3)) and (((h2.contains)(new IntObj(7)) \u003d false) and ((h2.containsKey)(new StringObj(\"a\")) and ((h2.containsKey)(new StringObj(\"d\")) \u003d false))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT02:\tsearch test.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT02\n","class HashtableT03 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable({new IntObj(1) |-\u003e new StringObj(\"Shin Sahara\"), new IntObj(2) |-\u003e new StringObj(\"Kei Sato\"), new IntObj(3) |-\u003e new StringObj(\"Hiroshi Sakoh\")}), h2:Hashtable \u003d new Hashtable({new StringObj(\"a\") |-\u003e new IntObj(1), new StringObj(\"b\") |-\u003e new IntObj(2), new StringObj(\"c\") |-\u003e new IntObj(3)}), deleteObj:[Object] \u003d (h2.remove)(new StringObj(\"b\")) in (\n\nh1.clear();\nreturn ((((h1.getBuckets)() \u003d {|-\u003e}) and ((deleteObj.equals)(new IntObj(2)) and (((h2.get)(new StringObj(\"b\")) \u003d nil) and (((h2.contains)(new IntObj(2)) \u003d false) and (((h2.containsKey)(new StringObj(\"b\")) \u003d false) and ((h2.remove)(new StringObj(\"d\")) \u003d nil)))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT03:\tDelete test.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT03\n","class HashtableT04 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\n(\nh1:Hashtable :\u003d new Hashtable()\nh2:Hashtable :\u003d new Hashtable()\n\nh1.putAll({new IntObj(1) |-\u003e new StringObj(\"Shin Sahara\"), new IntObj(2) |-\u003e new StringObj(\"Kei Sato\"), new IntObj(14) |-\u003e new StringObj(\"Hiroshi Sakoh\")});\nh2.put(new StringObj(\"a\"), new IntObj(1));\nh2.put(new StringObj(\"b\"), new IntObj(2));\nlet c \u003d new StringObj(\"c\") in (\n\nh2.put(c, new IntObj(4));\nh2.put(c, new IntObj(3))\n);\nreturn ((((h1.get)(new IntObj(1)).equals)(new StringObj(\"Shin Sahara\")) and (((h1.get)(new IntObj(2)).equals)(new StringObj(\"Kei Sato\")) and (((h1.get)(new IntObj(14)).equals)(new StringObj(\"Hiroshi Sakoh\")) and (((h1.get)(new IntObj(4)) \u003d nil) and (((h2.get)(new StringObj(\"a\")).equals)(new IntObj(1)) and (((h2.get)(new StringObj(\"b\")).equals)(new IntObj(2)) and (((h2.get)(new StringObj(\"c\")).equals)(new IntObj(3)) and ((h2.get)(new StringObj(\"d\")) \u003d nil)))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT04:\tTest of put, get.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT04\n","class HashtableT05 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable(), h2:Hashtable \u003d new Hashtable(), h1k1:IntObj \u003d new IntObj(1), h1k2:IntObj \u003d new IntObj(2), h1k3:IntObj \u003d new IntObj(14), h1v1:StringObj \u003d new StringObj(\"Shin Sahara\"), h1v2:StringObj \u003d new StringObj(\"Kei Sato\"), h1v3:StringObj \u003d new StringObj(\"Hiroshi Sakoh\"), h2k1:StringObj \u003d new StringObj(\"a\"), h2k2:StringObj \u003d new StringObj(\"b\"), h2k3:StringObj \u003d new StringObj(\"c\"), h2v1:IntObj \u003d new IntObj(1), h2v2:IntObj \u003d new IntObj(2), h2v3:IntObj \u003d new IntObj(18) in (\n\nh1.putAll({h1k1 |-\u003e h1v1, h1k2 |-\u003e h1v2, h1k3 |-\u003e h1v3});\nh2.put(h2k1, h2v1);\nh2.put(h2k2, h2v2);\nh2.put(h2k3, h2v3);\nlet keySet1:set of (Object) \u003d (h1.keySet)(), valueSet1:set of (Object) \u003d (h1.valueSet)(), keySet2:set of (Object) \u003d (h2.keySet)(), valueSet2:set of (Object) \u003d (h2.valueSet)() in return (((keySet1 \u003d {h1k1, h1k2, h1k3}) and ((valueSet1 \u003d {h1v1, h1v2, h1v3}) and ((keySet2 \u003d {h2k1, h2k2, h2k3}) and (valueSet2 \u003d {h2v1, h2v2, h2v3})))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT05:\tTest of getting keys and values.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT05\n","class HashtableT06 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable(), h1k1:IntObj \u003d new IntObj(1), h1k2:IntObj \u003d new IntObj(14), h1k3:IntObj \u003d new IntObj(16), h1k4:IntObj \u003d new IntObj(27), h1v1:StringObj \u003d new StringObj(\"a\"), h1v2:StringObj \u003d new StringObj(\"b\"), h1v3:StringObj \u003d new StringObj(\"c\") in (\n\nh1.putAll({h1k1 |-\u003e h1v1, h1k2 |-\u003e h1v2, h1k3 |-\u003e h1v3});\nlet -:[Object] \u003d (h1.remove)(new IntObj(14)) in h1.put(h1k4, h1v3);\nreturn ((((h1.keySet)() \u003d {h1k1, h1k3, h1k4}) and ((h1.valueSet)() \u003d {h1v1, h1v3, h1v3})))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT06:\tTest when hashCode overlaps.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT06\n","class HashtableT07 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet h1:Hashtable \u003d new Hashtable(), h2:Hashtable \u003d new Hashtable(), h1k1:IntObj \u003d new IntObj(1), h1k2:IntObj \u003d new IntObj(14), h1k3:IntObj \u003d new IntObj(16), h1v1:StringObj \u003d new StringObj(\"a\"), h1v2:StringObj \u003d new StringObj(\"b\"), h1v3:StringObj \u003d new StringObj(\"c\") in (\n\nh1.putAll({h1k1 |-\u003e h1v1, h1k2 |-\u003e h1v2, h1k3 |-\u003e h1v3});\nh2.putAll({h1k1 |-\u003e h1v1, h1k2 |-\u003e h1v2, h1k3 |-\u003e h1v3});\nlet -:[Object] \u003d (h1.remove)(new IntObj(1)), -:[Object] \u003d (h1.remove)(new IntObj(14)), -:[Object] \u003d (h1.remove)(new IntObj(16)), -:[Object] \u003d (h2.remove)(new IntObj(14)) in return (((h1.isEmpty)() and (((h1.size)() \u003d 0) and (((h2.isEmpty)() \u003d false) and ((h2.size)() \u003d 2)))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT07:\tTest of size.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT07\n","class HashtableT52 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), p1:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode)({1 |-\u003e \"Sahara\", 2 |-\u003e \"Sato\", 14 |-\u003e \"Sakoh\"}), c1:(seq of (char) +\u003e bool) \u003d (Hashtable`Contains)[int, seq of (char)](p1) in return ((c1(\"Sahara\") and (c1(\"Sato\") and (c1(\"Sakoh\") and (c1(\"\") \u003d false)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT52:\tFunctional finding.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT52\n","class HashtableT53 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), aHashCode2:(seq of (char) -\u003e seq of (char)) \u003d (lambda [x:seq of (char)] \u0026 (if (x \u003d \"\")\nthen \"\"\nelse (Sequence`take)[char](1)(x))), -:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode1)({1 |-\u003e \"Shin Sahara\", 2 |-\u003e \"Kei Sato\", 14 |-\u003e \"Hiroshi Sakoh\"}), h2:map (seq of (char)) to (map (seq of (char)) to (int)) \u003d (Hashtable`PutAll)[seq of (char), int]({|-\u003e})(aHashCode2)({\"a\" |-\u003e 1, \"b\" |-\u003e 2, \"c\" |-\u003e 3}), h3:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`Clear)[int, seq of (char)](), afterRemoveh2:map (seq of (char)) to (map (seq of (char)) to (int)) \u003d (Hashtable`Remove)[seq of (char), int](h2)(aHashCode2)(\"b\"), c1:(int +\u003e bool) \u003d (Hashtable`Contains)[seq of (char), int](afterRemoveh2), ck1:(seq of (char) +\u003e bool) \u003d (Hashtable`ContainsKey)[seq of (char), int](afterRemoveh2) in (\n\nreturn (((h3 \u003d {|-\u003e}) and (((Hashtable`Get)[seq of (char), int](afterRemoveh2)(aHashCode2)(\"b\") \u003d nil) and ((c1(2) \u003d false) and (c1(1) and (c1(3) and ((ck1(\"b\") \u003d false) and (ck1(\"a\") and ck1(\"c\")))))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT53:\tTest of functional remove.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT53\n","class HashtableT54 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), put:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e (seq of (char) +\u003e map (int) to (map (int) to (seq of (char))))))) \u003d (Hashtable`Put)[int, seq of (char)], p1:map (int) to (map (int) to (seq of (char))) \u003d put({|-\u003e})(aHashCode)(1)(\"Sahara\"), p2:map (int) to (map (int) to (seq of (char))) \u003d put(p1)(aHashCode)(2)(\"Bush\"), p3:map (int) to (map (int) to (seq of (char))) \u003d put(p2)(aHashCode)(2)(\"Sato\"), p4:map (int) to (map (int) to (seq of (char))) \u003d put(p3)(aHashCode)(14)(\"Sakoh\"), get:((int +\u003e int) +\u003e (int +\u003e [seq of (char)])) \u003d (Hashtable`Get)[int, seq of (char)](p4) in return (((get(aHashCode)(1) \u003d \"Sahara\") and ((get(aHashCode)(2) \u003d \"Sato\") and ((get(aHashCode)(14) \u003d \"Sakoh\") and (get(aHashCode)(99) \u003d nil)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT54:\tFunctional Put and Get.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT54\n","class HashtableT55 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), put:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e (seq of (char) +\u003e map (int) to (map (int) to (seq of (char))))))) \u003d (Hashtable`Put)[int, seq of (char)], p1:map (int) to (map (int) to (seq of (char))) \u003d put({|-\u003e})(aHashCode)(1)(\"Sahara\"), p2:map (int) to (map (int) to (seq of (char))) \u003d put(p1)(aHashCode)(2)(\"Bush\"), p3:map (int) to (map (int) to (seq of (char))) \u003d put(p2)(aHashCode)(2)(\"Sato\"), p4:map (int) to (map (int) to (seq of (char))) \u003d put(p3)(aHashCode)(14)(\"Sakoh\"), k:(map (int) to (map (int) to (seq of (char))) +\u003e set of (int)) \u003d (Hashtable`KeySet)[int, seq of (char)], v:(map (int) to (map (int) to (seq of (char))) +\u003e set of (seq of (char))) \u003d (Hashtable`ValueSet)[int, seq of (char)] in return (((k(p1) \u003d {1}) and ((v(p1) \u003d {\"Sahara\"}) and ((k(p2) \u003d {1, 2}) and ((v(p2) \u003d {\"Sahara\", \"Bush\"}) and ((k(p4) \u003d {1, 2, 14}) and (v(p4) \u003d {\"Sahara\", \"Sato\", \"Sakoh\"})))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT55:\tFunctional getting information.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT55\n","class HashtableT56 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), h1:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode1)({1 |-\u003e \"Shin Sahara\", 2 |-\u003e \"Kei Sato\", 14 |-\u003e \"Hiroshi Sakoh\", 27 |-\u003e \"Nishikawa\"}), h2:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`Remove)[int, seq of (char)](h1)(aHashCode1)(14) in (\n\nreturn ((((Hashtable`KeySet)[int, seq of (char)](h2) \u003d {1, 2, 27}) and ((Hashtable`ValueSet)[int, seq of (char)](h2) \u003d {\"Shin Sahara\", \"Kei Sato\", \"Nishikawa\"})))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT56:\tWhen hashode overlapped.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT56\n","class HashtableT57 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet aHashCode1:(int -\u003e int) \u003d (lambda [x:int] \u0026 (x mod 13)), remove:(map (int) to (map (int) to (seq of (char))) +\u003e ((int +\u003e int) +\u003e (int +\u003e map (int) to (map (int) to (seq of (char)))))) \u003d (Hashtable`Remove)[int, seq of (char)], h1:map (int) to (map (int) to (seq of (char))) \u003d (Hashtable`PutAll)[int, seq of (char)]({|-\u003e})(aHashCode1)({1 |-\u003e \"Shin Sahara\", 2 |-\u003e \"Kei Sato\", 14 |-\u003e \"Hiroshi Sakoh\"}), h2:map (int) to (map (int) to (seq of (char))) \u003d remove(h1)(aHashCode1)(1), h3:map (int) to (map (int) to (seq of (char))) \u003d remove(h2)(aHashCode1)(2), h4:map (int) to (map (int) to (seq of (char))) \u003d remove(h3)(aHashCode1)(14), isempty:(map (int) to (map (int) to (seq of (char))) +\u003e bool) \u003d (Hashtable`IsEmpty)[int, seq of (char)], size:(map (int) to (map (int) to (seq of (char))) +\u003e nat) \u003d (Hashtable`Size)[int, seq of (char)] in (\n\nreturn ((isempty(h4) and ((size(h4) \u003d 0) and ((isempty(h3) \u003d false) and ((size(h3) \u003d 1) and ((size(h2) \u003d 2) and (size(h1) \u003d 3)))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"HashtableT57:\tTest of functional Size.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend HashtableT57\n","class Integer\npublic static  public static asString: (int -\u003e seq1 of (char))\n\tasString(i) \u003d\u003d\n(if (i \u003c 0)\nthen (\"-\" ^ asStringAux(-i))\nelse asStringAux(i))\npublic static  public static asStringAux: (nat -\u003e seq1 of (char))\n\tasStringAux(n) \u003d\u003d\nlet r:int \u003d (n mod 10), q:int \u003d (n div 10) in (cases q :\n0 -\u003e asChar(r)\nothers (asStringAux(q) ^ asChar(r))\n end)\nprivate static  private static ndiv10: (nat +\u003e nat)\n\tndiv10(n) \u003d\u003d\n(n div 10)\npublic static  public static asStringZ: (seq of (char) -\u003e (int -\u003e seq1 of (char)))\n\tasStringZ(cobolStrConversionCommand)(i) \u003d\u003d\nlet minusSymbol:char \u003d \u0027-\u0027 in (if (i \u003c 0)\nthen (if (cobolStrConversionCommand(1) \u003d minusSymbol)\nthen ([minusSymbol] ^ asStringZAux(String`subStr(cobolStrConversionCommand, 2, (len cobolStrConversionCommand)))(-i, true))\nelse asStringZAux(cobolStrConversionCommand)(-i, true))\nelse (if (cobolStrConversionCommand(1) \u003d minusSymbol)\nthen asStringZAux(String`subStr(cobolStrConversionCommand, 2, (len cobolStrConversionCommand)))(i, true)\nelse asStringZAux(cobolStrConversionCommand)(i, true)))\npublic static  public static asStringZAux: (seq of (char) -\u003e (nat * bool -\u003e seq1 of (char)))\n\tasStringZAux(cobolStrConversionCommand)(n, wasZero) \u003d\u003d\nlet cobolStrConversionCommandStrLen:nat \u003d (len cobolStrConversionCommand), cobolStrConversionCommandChar:char \u003d cobolStrConversionCommand(cobolStrConversionCommandStrLen), cobolStrConversionCommandStr:seq of (char) \u003d String`subStr(cobolStrConversionCommand, 1, (cobolStrConversionCommandStrLen - 1)), r:int \u003d (n mod 10), q:int \u003d (n div 10), isZero:bool \u003d ((r \u003d 0) and (wasZero and (q \u003c\u003e 0))) in (cases cobolStrConversionCommandStr :\n[] -\u003e asCharZ(cobolStrConversionCommandChar)(r, isZero)\nothers (asStringZAux(cobolStrConversionCommandStr)(q, isZero) ^ asCharZ(cobolStrConversionCommandChar)(r, isZero))\n end)\nprivate static  private static length: (seq of (char) -\u003e (nat * bool -\u003e nat))\n\tlength(cobolStrConversionCommand)(-, -) \u003d\u003d\n(len cobolStrConversionCommand)\npublic static  public static asCharZ: (char -\u003e (nat * bool -\u003e (bool | seq1 of (char))))\n\tasCharZ(cobolStrConversionCommandChar)(n, wasZero) \u003d\u003d\n(cases n :\n0 -\u003e (if ((cobolStrConversionCommandChar in set {\u0027z\u0027, \u0027Z\u0027}) and wasZero)\nthen \"0\"\nelseif ((cobolStrConversionCommandChar \u003d \u00270\u0027) or (cobolStrConversionCommandChar \u003d \u00279\u0027))\nthen \"0\"\nelse \" \"),\n1 -\u003e \"1\",\n2 -\u003e \"2\",\n3 -\u003e \"3\",\n4 -\u003e \"4\",\n5 -\u003e \"5\",\n6 -\u003e \"6\",\n7 -\u003e \"7\",\n8 -\u003e \"8\",\n9 -\u003e \"9\"\nothers false\n end)\npublic static  public static asChar: (int -\u003e (bool | seq1 of (char)))\n\tasChar(i) \u003d\u003d\n(cases i :\n0 -\u003e \"0\",\n1 -\u003e \"1\",\n2 -\u003e \"2\",\n3 -\u003e \"3\",\n4 -\u003e \"4\",\n5 -\u003e \"5\",\n6 -\u003e \"6\",\n7 -\u003e \"7\",\n8 -\u003e \"8\",\n9 -\u003e \"9\"\nothers false\n end)\npublic static  public static GCD: (nat -\u003e (nat -\u003e nat))\n\tGCD(x)(y) \u003d\u003d\n(if (y \u003d 0)\nthen x\nelse GCD(y)((x rem y)))\nprivate static  private static GCDMeasure: (nat -\u003e (nat -\u003e nat))\n\tGCDMeasure(x)(-) \u003d\u003d\nx\npublic static  public static LCM: (nat -\u003e (nat -\u003e nat))\n\tLCM(x)(y) \u003d\u003d\n(cases mk_(x, y) :\nmk_(-, 0) -\u003e 0,\nmk_(0, -) -\u003e 0,\nmk_(z, w) -\u003e ((z / GCD(z)(w)) * w)\n end)\nend Integer\n","class IntegerT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new IntegerT01(), new IntegerT02()]\nend IntegerT\n","class IntegerT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet i:Integer \u003d new Integer() in return ((((i.asString)(1234567890) \u003d \"1234567890\") and (((i.asString)(-1234567890) \u003d \"-1234567890\") and (((i.asStringZ)(\"zzz9\")(9900) \u003d \"9900\") and (((i.asStringZ)(\"9\")(0) \u003d \"0\") and (((i.asStringZ)(\"z\")(0) \u003d \" \") and (((i.asStringZ)(\"z\")(9) \u003d \"9\") and (((i.asStringZ)(\"zzz9\")(9) \u003d \"   9\") and (((i.asStringZ)(\"0009\")(9) \u003d \"0009\") and (((i.asStringZ)(\"-0009\")(9) \u003d \"0009\") and (((i.asStringZ)(\"-zzz9\")(-9999) \u003d \"-9999\") and (((i.asStringZ)(\"-zzz9\")(-9) \u003d \"-   9\") and (((i.asStringZ)(\"zzz9\")(-9999) \u003d \"9999\") and (((i.asStringZ)(\"zzz9\")(-9) \u003d \"   9\") and (((i.asString)(0) \u003d \"0\") and (((i.asChar)(0) \u003d \"0\") and (((i.asChar)(1) \u003d \"1\") and (((i.asChar)(2) \u003d \"2\") and (((i.asChar)(3) \u003d \"3\") and (((i.asChar)(4) \u003d \"4\") and (((i.asChar)(5) \u003d \"5\") and (((i.asChar)(6) \u003d \"6\") and (((i.asChar)(7) \u003d \"7\") and (((i.asChar)(8) \u003d \"8\") and (((i.asChar)(9) \u003d \"9\") and ((i.asChar)(10) \u003d false))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"IntegerT01:\tConvert integer to string.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend IntegerT01\n","class IntegerT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet gcd:(nat -\u003e nat) \u003d Integer`GCD(24), lcm:(nat -\u003e nat) \u003d Integer`LCM(7) in return ((((Sequence`fmap)[nat, nat](gcd)([36, 48, 16]) \u003d [12, 24, 8]) and ((Sequence`fmap)[nat, nat](lcm)([3, 4, 5]) \u003d [21, 28, 35])))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"IntegerT02:\tGet GCD and LCM.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend IntegerT02\n","class JapaneseCalendar is subclass of [Calendar]\npublic static  differenceBetweenGMTandJST:real \u003d 0.375\npublic static  differenceBetweenADandJapaneseCal:nat1 \u003d 1988\nprivate static  private static toStringAux: (int -\u003e seq of (char))\n\ttoStringAux(i) \u003d\u003d\nlet str:(int -\u003e seq1 of (char)) \u003d Integer`asString in (if (i \u003e\u003d 10)\nthen str(i)\nelse (\" \" ^ str(i)))\npublic static  public static getJapaneseDateStr: (Date -\u003e seq of (char))\n\tgetJapaneseDateStr(ADdate) \u003d\u003d\nlet asString:(int -\u003e seq1 of (char)) \u003d Integer`asString, yearOfJapaneseCal:int \u003d ((ADdate.Year)() - differenceBetweenADandJapaneseCal), m:int \u003d (ADdate.Month)(), d:int \u003d (ADdate.day)(), yearStr:seq1 of (char) \u003d asString(yearOfJapaneseCal), monthStr:seq of (char) \u003d toStringAux(m), dateStr:seq of (char) \u003d toStringAux(d) in ((yearStr ^ monthStr) ^ dateStr)\n\tpre ((ADdate.Year)() \u003e\u003d differenceBetweenADandJapaneseCal)\npublic  setTheSetOfDayOffs(int) (int \u003d\u003d\u003e ())\n\tsetTheSetOfDayOffs(int)(year) \u003d\u003d\nlet comingOfAgeDay:(Date | bool) \u003d getNthDayOfTheWeek(year, 1, 2, \u003cMon\u003e), marineDay:(Date | bool) \u003d (if (year \u003e\u003d 2003)\nthen getNthDayOfTheWeek(year, 7, 3, \u003cMon\u003e)\nelse getDateFrom_yyyy_mm_dd(year, 7, 20)), respect4TheAgedDay:(Date | bool) \u003d (if (year \u003e\u003d 2003)\nthen getNthDayOfTheWeek(year, 9, 3, \u003cMon\u003e)\nelse getDateFrom_yyyy_mm_dd(year, 9, 15)), healthSportsDay:(Date | bool) \u003d getNthDayOfTheWeek(year, 10, 2, \u003cMon\u003e), nationalHolidaySet:set of ((Date | bool)) \u003d {getDateFrom_yyyy_mm_dd(year, 1, 1), comingOfAgeDay, getDateFrom_yyyy_mm_dd(year, 2, 11), getVernalEquinox(year), getDateFrom_yyyy_mm_dd(year, 4, 29), getDateFrom_yyyy_mm_dd(year, 5, 3), getDateFrom_yyyy_mm_dd(year, 5, 4), getDateFrom_yyyy_mm_dd(year, 5, 5), marineDay, respect4TheAgedDay, getAutumnalEquinox(year), healthSportsDay, getDateFrom_yyyy_mm_dd(year, 11, 3), getDateFrom_yyyy_mm_dd(year, 11, 23), getDateFrom_yyyy_mm_dd(year, 12, 23)}, mondayMakeupHolidat:set of (Date) \u003d (if (year \u003e\u003d 2007)\nthen {getNotNationalHolidaysInFuture(nationalHolidaySet, d) | d in set nationalHolidaySet \u0026 isSunday(d)}\nelse {(d.plus)(1) | d in set nationalHolidaySet \u0026 isSunday(d)}), weekdayBetweenDayOff:(set of (Date) | {}) \u003d (if (year \u003e\u003d 2007)\nthen getWeekdayBetweenDayOff(nationalHolidaySet)\nelse {}) in Year2Holidays :\u003d (Year2Holidays munion {year |-\u003e ((nationalHolidaySet union mondayMakeupHolidat) union weekdayBetweenDayOff)})\n\tpre (year \u003e\u003d 2000)\npublic  JapaneseCalendar() (() \u003d\u003d\u003e JapaneseCalendar)\n\tJapaneseCalendar()() \u003d\u003d\n(\n\nsetDifferenceWithGMT(differenceBetweenGMTandJST);\nreturn (self)\n)\npublic  getWeekdayBetweenDayOff(set of (Date)) (set of (Date) \u003d\u003d\u003e set of (Date))\n\tgetWeekdayBetweenDayOff(set of (Date))(aNationalHolidaySet) \u003d\u003d\n(\n\nlet candidatesOfWeekdayBetweenDayOff:set of (Date) \u003d (dunion {{(d.minus)(1), (d.plus)(1)} | d in set aNationalHolidaySet \u0026 ((((d.minus)(1).Year)() \u003d (d.Year)()) and (((d.plus)(1).Year)() \u003d (d.Year)()))}), weekdayBetweenHoliday:set of (Date) \u003d {d | d in set candidatesOfWeekdayBetweenDayOff \u0026 let yesterday:Date \u003d (d.minus)(1), tomorrow:Date \u003d (d.plus)(1) in (isInDateSet(yesterday, aNationalHolidaySet) and isInDateSet(tomorrow, aNationalHolidaySet))} in return (weekdayBetweenHoliday)\n)\npublic  public getNotNationalHolidaysInFuture: (set of (Date) * Date -\u003e Date)\n\tgetNotNationalHolidaysInFuture(aNationalHolidaySet, date) \u003d\u003d\n(cases isInDateSet(date, aNationalHolidaySet) :\n(true) -\u003e getNotNationalHolidaysInFuture(aNationalHolidaySet, (date.plus)(1))\nothers date\n end)\nend JapaneseCalendar\n","class Map\npublic static  public static Get[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T1 -\u003e [@T2]))\n\tGet(aMap)(aKey) \u003d\u003d\n(if (aKey in set (dom aMap))\nthen aMap(aKey)\nelse nil)\npublic static  public static Contains[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T2 -\u003e bool))\n\tContains(aMap)(aValue) \u003d\u003d\n(aValue in set (rng aMap))\npublic static  public static ContainsKey[(T1, T2)]: (map (@T1) to (@T2) -\u003e (@T1 -\u003e bool))\n\tContainsKey(aMap)(aKey) \u003d\u003d\n(aKey in set (dom aMap))\nend Map\n","class MapT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new MapT01(), new MapT02()]\nend MapT\n","class MapT01 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet m1:map (nat1) to (seq1 of (char)) \u003d {1 |-\u003e \"Kei Sato\", 19 |-\u003e \"Shin Sahara\", 20 |-\u003e \"Hiroshi Sakoh\"}, m2:map (seq1 of (char)) to (nat1) \u003d {\"Kei Sato\" |-\u003e 1, \"Shin Sahara\" |-\u003e 19, \"Hiroshi Sakoh\" |-\u003e 20}, get1:(map (int) to (seq of (char)) +\u003e (int +\u003e [seq of (char)])) \u003d (Map`Get)[int, seq of (char)], get2:(map (seq of (char)) to (int) +\u003e (seq of (char) +\u003e [int])) \u003d (Map`Get)[seq of (char), int] in return (((get1(m1)(19) \u003d \"Shin Sahara\") and ((get1(m1)(2) \u003d nil) and ((get2(m2)(\"Shin Sahara\") \u003d 19) and (get2(m2)(\"Worst Prime Minister Koizumi\") \u003d nil)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"MapT01:\tTest of Get function.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend MapT01\n","class MapT02 is subclass of [TestCase, CommonDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet m1:map (nat1) to (seq1 of (char)) \u003d {1 |-\u003e \"Kei Sato\", 19 |-\u003e \"Shin Sahara\", 20 |-\u003e \"Hiroshi Sakoh\"}, m2:map (seq1 of (char)) to (nat1) \u003d {\"Kei Sato\" |-\u003e 1, \"Shin Sahara\" |-\u003e 19, \"Hiroshi Sakoh\" |-\u003e 20}, c1:(map (int) to (seq of (char)) +\u003e (seq of (char) +\u003e bool)) \u003d (Map`Contains)[int, seq of (char)], k1:(map (int) to (seq of (char)) +\u003e (int +\u003e bool)) \u003d (Map`ContainsKey)[int, seq of (char)], c2:(map (seq of (char)) to (int) +\u003e (int +\u003e bool)) \u003d (Map`Contains)[seq of (char), int], k2:(map (seq of (char)) to (int) +\u003e (seq of (char) +\u003e bool)) \u003d (Map`ContainsKey)[seq of (char), int] in return ((c1(m1)(\"Kei Sato\") and (c1(m1)(\"Shin Sahara\") and (c1(m1)(\"Hiroshi Sakoh\") and ((c1(m1)(\"Worst Prime Minister Koizumi\") \u003d false) and (k1(m1)(1) and (k1(m1)(19) and (k1(m1)(20) and ((not k1(m1)(99)) and (c2(m2)(1) and (c2(m2)(19) and (c2(m2)(20) and ((c2(m2)(30) \u003d false) and (k2(m2)(\"Kei Sato\") and (k2(m2)(\"Shin Sahara\") and (k2(m2)(\"Hiroshi Sakoh\") and (k2(m2)(\"Worst Prime Minister Koizumi\") \u003d false)))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"MapT02:\tTest of Contains related functions.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend MapT02\n","class Number\npublic static  public static isComputable[(e)]: (@e -\u003e bool)\n\tisComputable(n) \u003d\u003d\n(is_(n, int) or (is_(n, nat) or (is_(n, nat1) or (is_(n, real) or is_(n, rat)))))\npublic static  public static min[(e)]: ((@e * @e -\u003e bool) -\u003e (@e -\u003e (@e -\u003e @e)))\n\tmin(f)(n1)(n2) \u003d\u003d\n(if f(n1, n2)\nthen n1\nelse n2)\npublic static  public static max[(e)]: ((@e * @e -\u003e bool) -\u003e (@e -\u003e (@e -\u003e @e)))\n\tmax(f)(n1)(n2) \u003d\u003d\n(if f(n1, n2)\nthen n2\nelse n1)\nend Number\n","class NumberT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new NumberT01(), new NumberT02(), new NumberT03()]\nend NumberT\n","class NumberT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Number`min)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))(-3)(4) \u003d -3) and (((Number`min)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))(4)(-3) \u003d -3) and (((Number`min)[nat]((lambda [x:nat, y:nat] \u0026 (x \u003c y)))(2)(10) \u003d 2) and (((Number`min)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))(0)(0) \u003d 0) and (((Number`max)[real]((lambda [x:real, y:real] \u0026 (x \u003c y)))(0.001)(-0.001) \u003d 0.001) and (((Number`max)[real]((lambda [x:real, y:real] \u0026 (x \u003c y)))(-0.001)(0.001) \u003d 0.001) and ((Number`max)[real]((lambda [x:real, y:real] \u0026 (x \u003c y)))(0.0)(0.0) \u003d 0.0))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"NumberT01:\tSummary of integer.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend NumberT01\n","class NumberT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Number`isComputable)[char](\u0027a\u0027) \u003d false) and (((Number`isComputable)[int](-9) \u003d true) and (((Number`isComputable)[nat](0) \u003d true) and (((Number`isComputable)[nat1](1) \u003d true) and (((Number`isComputable)[real](1.234) \u003d true) and ((Number`isComputable)[rat](1.234) \u003d true)))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"NumberT02:\tIs computable?\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend NumberT02\n","class NumberT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Number`min)[seq of (int)]((lambda [s1:seq of (int), s2:seq of (int)] \u0026 ((len s1) \u003c (len s2))))([1, 2])([1, 2, 3]) \u003d [1, 2]) and ((Number`max)[seq of (int)]((lambda [s1:seq of (int), s2:seq of (int)] \u0026 ((len s1) \u003c (len s2))))([1, 2])([1, 2, 3]) \u003d [1, 2, 3])))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"NumberT03:\tType is not computable, but...\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend NumberT03\n","class Object\npublic  public hashCode: (() -\u003e int)\n\thashCode() \u003d\u003d\n1\npublic  public equals: (Object -\u003e bool)\n\tequals(-) \u003d\u003d\ntrue\npublic  getContent() (() \u003d\u003d\u003e [(int | seq of (char))])\n\tgetContent()() \u003d\u003d\nreturn (1374)\nend Object\n","class Product\npublic static  public static Curry[(T1, T2, T3)]: ((@T1 * @T2 -\u003e @T3) -\u003e (@T1 -\u003e (@T2 -\u003e @T3)))\n\tCurry(f)(x)(y) \u003d\u003d\nf(x, y)\npublic static  public static Uncurry[(T1, T2, T3)]: ((@T1 -\u003e (@T2 -\u003e @T3)) -\u003e (@T1 * @T2 -\u003e @T3))\n\tUncurry(f)(x, y) \u003d\u003d\nf(x)(y)\nend Product\n","class ProductT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new ProductT01()]\nend ProductT\n","class ProductT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet lt:(seq of (char) * seq of (char) -\u003e bool) \u003d String`LT, lt2:(int * int -\u003e bool) \u003d (lambda [x:int, y:int] \u0026 (x \u003c y)) in return (((Product`Curry)[seq of (char), seq of (char), bool](lt)(\"abc\")(\"abcd\") and (((Product`Curry)[seq of (char), seq of (char), bool](lt)(\"abcde\")(\"abcd\") \u003d false) and ((Product`Curry)[int, int, bool](lt2)(3)(4) and ((Product`Uncurry)[seq of (char), seq of (char), bool](String`LT2)(\"abc\", \"abcd\") and (((Product`Uncurry)[seq of (char), seq of (char), bool](String`LT2)(\"abcde\", \"abcd\") \u003d false) and (Product`Uncurry)[seq of (char), seq of (char), bool](String`LE2)(\"3\", \"4\")))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"ProductT01:\t Test of curry function.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend ProductT01\n","class Queue\npublic static  public static empty[(T)]: (() -\u003e seq of (@T))\n\tempty() \u003d\u003d\n[]\npublic static  public static isEmpty[(T)]: (seq of (@T) -\u003e bool)\n\tisEmpty(s) \u003d\u003d\n(s \u003d [])\npublic static  public static enQueue[(T)]: (@T * seq of (@T) -\u003e seq of (@T))\n\tenQueue(anElem, aQueue) \u003d\u003d\n(aQueue ^ [anElem])\npublic static  public static deQueue[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tdeQueue(aQueue) \u003d\u003d\n(if (aQueue \u003d [])\nthen []\nelse (tl aQueue))\npublic static  public static top[(T)]: (seq of (@T) -\u003e [@T])\n\ttop(aQueue) \u003d\u003d\n(if (aQueue \u003d [])\nthen nil\nelse (hd aQueue))\nend Queue\n","class QueueT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new QueueT01()]\nend QueueT\n","class QueueT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet q0:seq of (int) \u003d (Queue`empty)[int](), q1:seq of (int) \u003d (Queue`enQueue)[int](1, q0), q2:seq of (int) \u003d (Queue`enQueue)[int](2, q1), q3:seq of (int) \u003d (Queue`enQueue)[int](3, q2), h1:[int] \u003d (Queue`top)[int](q3), q4:seq of (int) \u003d (Queue`deQueue)[int](q3), q5:seq of (int) \u003d (Queue`deQueue)[int](q4), q6:seq of (int) \u003d (Queue`deQueue)[int](q5), h2:[int] \u003d (Queue`top)[int](q6), q7:seq of (int) \u003d (Queue`deQueue)[int](q6) in return (((q0 \u003d []) and ((q1 \u003d [1]) and ((q2 \u003d [1, 2]) and ((q3 \u003d [1, 2, 3]) and ((h1 \u003d 1) and ((q4 \u003d [2, 3]) and ((q5 \u003d [3]) and ((q6 \u003d []) and ((h2 \u003d nil) and ((q7 \u003d []) and ((Queue`isEmpty)[int](q7) and (not (Queue`isEmpty)[int](q5))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"QueueT01:\t Test Queue\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend QueueT01\n","class Real\nprivate static  Tolerance:real \u003d 1.0E-8\nprivate static  Variation:real \u003d 1.0E-5\npublic static  public static EQ: (real -\u003e (real -\u003e bool))\n\tEQ(r1)(r2) \u003d\u003d\n((abs (r1 - r2)) \u003c Tolerance)\npublic static  public static EQE: (real -\u003e (real -\u003e (real -\u003e bool)))\n\tEQE(e)(r1)(r2) \u003d\u003d\n((abs (r1 - r2)) \u003c e)\npublic static  public static numberOfDigit: (real -\u003e nat)\n\tnumberOfDigit(x) \u003d\u003d\nlet i:int \u003d (floor x) in (if (x \u003d i)\nthen aNumberOfIntegerPartDigit(i)\nelse ((aNumberOfIntegerPartDigit(i) + 1) + getNumberOfDigitsAfterTheDecimalPoint(x)))\npublic static  public static aNumberOfIntegerPartDigit: (int -\u003e nat)\n\taNumberOfIntegerPartDigit(i) \u003d\u003d\naNumberOfIntegerPartDigitAux(i, 1)\npublic static  public static aNumberOfIntegerPartDigitAux: (int * nat -\u003e nat)\n\taNumberOfIntegerPartDigitAux(i, numberOfDigit) \u003d\u003d\nlet q:int \u003d (i div 10) in (cases q :\n0 -\u003e numberOfDigit\nothers Real`aNumberOfIntegerPartDigitAux(q, (numberOfDigit + 1))\n end)\nprivate static  private static idiv10: (int * nat +\u003e nat)\n\tidiv10(i, -) \u003d\u003d\n(i div 10)\npublic static  public static isNDigitsAfterTheDecimalPoint: (real * nat -\u003e bool)\n\tisNDigitsAfterTheDecimalPoint(x, numberOfDigit) \u003d\u003d\n(getNumberOfDigitsAfterTheDecimalPoint(x) \u003d numberOfDigit)\npublic static  public static getNumberOfDigitsAfterTheDecimalPoint: (real -\u003e nat)\n\tgetNumberOfDigitsAfterTheDecimalPoint(x) \u003d\u003d\ngetNumberOfDigitsAfterTheDecimalPointAux(x, 0)\nprivate static  private static getNumberOfDigitsAfterTheDecimalPointAux: (real * nat -\u003e nat)\n\tgetNumberOfDigitsAfterTheDecimalPointAux(x, numberOfDigit) \u003d\u003d\n(if (x \u003d (floor x))\nthen numberOfDigit\nelse getNumberOfDigitsAfterTheDecimalPointAux((x * 10), (numberOfDigit + 1)))\npublic static  public static roundAterDecimalPointByNdigit: (real * nat -\u003e real)\n\troundAterDecimalPointByNdigit(r, numberOfDigit) \u003d\u003d\nlet multiple:nat1 \u003d (10 ** numberOfDigit) in ((floor ((r * multiple) + 0.5)) / multiple)\n\tpre (r \u003e\u003d 0)\npublic static  public static Differentiate: ((real -\u003e real) -\u003e (real -\u003e real))\n\tDifferentiate(f)(x) \u003d\u003d\n((f((x + Variation)) - f(x)) / Variation)\npublic static  public static NewtonMethod: ((real -\u003e real) -\u003e (real -\u003e real))\n\tNewtonMethod(f)(x) \u003d\u003d\nlet terminationCondition:(real -\u003e bool) \u003d (lambda [y:real] \u0026 ((abs f(y)) \u003c Tolerance)), nextApproximation:(real -\u003e real) \u003d (lambda [y:real] \u0026 (y - (f(y) / Differentiate(f)(y)))) in ((new Function().Funtil))[real](terminationCondition)(nextApproximation)(x)\npublic static  public static integrate: ((real -\u003e real) -\u003e (nat1 -\u003e (real -\u003e (real -\u003e real))))\n\tintegrate(f)(n)(a)(b) \u003d\u003d\nlet h:real \u003d ((b - a) / n), s:seq of (real) \u003d seqGenerate(n, a, h) in (h * (((f(a) / 2) + (Sequence`Sum)[real]((Sequence`fmap)[real, real](f)(s))) + (f(b) / 2)))\nprivate static  seqGenerate(nat1, real, real) (nat1 * real * real \u003d\u003d\u003e seq of (real))\n\tseqGenerate(nat1, real, real)(n, a, h) \u003d\u003d\n(\ns:seq of (real) :\u003d []\n\nfor i \u003d 1 to n\ns :\u003d (s ^ [(a + (i * h))]);\nreturn (s)\n)\npublic static  public static root: (real -\u003e real)\n\troot(x) \u003d\u003d\nlet f:(real -\u003e real) \u003d (lambda [y:real] \u0026 ((y ** 2) - x)) in NewtonMethod(f)(x)\npublic static  public static getTotalPrincipal: (real * int -\u003e real)\n\tgetTotalPrincipal(Interest, year) \u003d\u003d\n((1 + Interest) ** year)\n\tpre ((Interest \u003e\u003d 0) and (year \u003e 0))\nprivate static  private static getInterestImplicitSpec_Math_version: (real * int -\u003e real)\n\tgetInterestImplicitSpec_Math_version(multiple, year) \u003d\u003d\nis not yet specified\n\tpre ((multiple \u003e 1.0) and (year \u003e 0))\n\tpost ((multiple \u003e 1.0) and ((year \u003e 0) and (exists1 Interest:real \u0026 let totalPrincipalAndInterest:real \u003d getTotalPrincipal(Interest, year) in ((multiple \u003d totalPrincipalAndInterest) and (RESULT \u003d Interest)))))\nprivate static  private static getInterestImplicitSpec_Computer_version: (real * int -\u003e real)\n\tgetInterestImplicitSpec_Computer_version(multiple, years) \u003d\u003d\nis not yet specified\n\tpre ((multiple \u003e 1.0) and (years \u003e 0))\n\tpost ((multiple \u003e 1.0) and ((years \u003e 0) and (exists1 Interest:real \u0026 let totalPrincipalAndInterest:real \u003d getTotalPrincipal(Interest, years) in (EQ(multiple)(totalPrincipalAndInterest) and (RESULT \u003d Interest)))))\npublic static  public static getInterest: (real * int -\u003e real)\n\tgetInterest(multiple, years) \u003d\u003d\nlet f:(real -\u003e real) \u003d (lambda [Interest:real] \u0026 (multiple - getTotalPrincipal(Interest, years))) in NewtonMethod(f)(0)\nend Real\n","class RealT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new RealT01(), new RealT02(), new RealT03(), new RealT04(), new RealT05(), new RealT06(), new RealT07(), new RealT08()]\nend RealT\n","class RealT01 is subclass of [TestCase]\nprivate static  Tolelance:real \u003d 1.0E-10\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet r:Real \u003d new Real() in return (Real`EQ((r.getInterest)(2, 10))(0.07177346254161253))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT01:\tTest of getInterest\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT01\n","class RealT02 is subclass of [TestCase]\nprivate static  Tolelance:real \u003d 1.0E-10\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet r:Real \u003d new Real() in return (Real`EQ((r.root)(2))(1.414213562382246))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT02:\tTest of root.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT02\n","class RealT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet r:Real \u003d new Real() in return (((r.isNDigitsAfterTheDecimalPoint)(10.01, 2) and ((not (r.isNDigitsAfterTheDecimalPoint)(10.01, 3)) and ((r.isNDigitsAfterTheDecimalPoint)(10.012, 3) and ((r.isNDigitsAfterTheDecimalPoint)(10.0, 0) and (((r.isNDigitsAfterTheDecimalPoint)(10.011, 2) \u003d false) and (((r.isNDigitsAfterTheDecimalPoint)(10.1, 0) \u003d false) and (((r.getNumberOfDigitsAfterTheDecimalPoint)(-1.2) \u003d 1) and (((r.getNumberOfDigitsAfterTheDecimalPoint)(1.0) \u003d 0) and (((r.getNumberOfDigitsAfterTheDecimalPoint)(1) \u003d 0) and ((r.getNumberOfDigitsAfterTheDecimalPoint)(1.23) \u003d 2)))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT03:\tTest isNDigitsAfterTheDecimalPoint and getNumberOfDigitsAfterTheDecimalPoint.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT03\n","class RealT04 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet r:Real \u003d new Real() in return ((((r.numberOfDigit)(0) \u003d 1) and (((r.numberOfDigit)(1) \u003d 1) and (((r.numberOfDigit)(9) \u003d 1) and (((r.numberOfDigit)(10) \u003d 2) and (((r.numberOfDigit)(99) \u003d 2) and (((r.numberOfDigit)(100) \u003d 3) and (((r.numberOfDigit)(0.1) \u003d 3) and (((r.numberOfDigit)(9.1) \u003d 3) and (((r.numberOfDigit)(10.1) \u003d 4) and ((r.numberOfDigit)(10.123) \u003d 6)))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT04:\tTest numberOfDigit.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT04\n","class RealT05 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((Real`EQ(Real`roundAterDecimalPointByNdigit(10.12345, 4))(10.1235) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.12345, 3))(10.123) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.12345, 2))(10.12) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.125, 2))(10.13) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.14, 1))(10.1) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.15, 1))(10.2) and (Real`EQ(Real`roundAterDecimalPointByNdigit(10.5, 0))(11) and Real`EQ(Real`roundAterDecimalPointByNdigit(10.4, 0))(10)))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT05:\tTest roundAterDecimalPointByNdigit.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT05\n","class RealT06 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((Real`EQ(10.0123456678)(10.0123456789) \u003d false) and (Real`EQ(10.01234567891)(10.01234567892) and (Real`EQ(10.012345678801)(10.0123456789) and Real`EQE(0.01)(10.12345)(10.12987)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT06:\tTest EQ (Equal).\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT06\n","class RealT07 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet f1:(real -\u003e real) \u003d (lambda [x:real] \u0026 (x ** 2)) in return ((Real`EQ(Real`integrate(f1)(10)(1)(2))(2.735) and (Real`EQ(Real`integrate(f1)(100)(1)(2))(2.37335) and Real`EQ(Real`integrate(f1)(1000)(1)(2))(2.3373335))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT07:\tTest integrate(x ** 2)\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT07\n","class RealT08 is subclass of [TestCase]\nprivate static  pi:? \u003d MATH`pi\nprivate static  sin:(real +\u003e real) \u003d MATH`sin\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((Real`EQ(Real`integrate(sin)(2)(0)(pi))(1.5707963278) and (Real`EQ(Real`integrate(sin)(3)(0)(pi))(1.8137993649) and (Real`EQ(Real`integrate(sin)(4)(0)(pi))(1.8961188984) and (Real`EQ(Real`integrate(sin)(5)(0)(pi))(1.9337655984) and Real`EQ(Real`integrate(sin)(2000)(1)(pi))(1.5403021586))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"RealT08:\tTest integrate(sin) .\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend RealT08\n","class SBCalendar is subclass of [JapaneseCalendar]\nprivate static  io:IO \u003d new IO()\nprivate static  calendar:SBCalendar \u003d new SBCalendar()\npublic  iTodayOnBusiness:[Date] :\u003d nil\npublic  iTodayOnCompanyMap:[map (seq of (char)) to (Date)] :\u003d {|-\u003e}\npublic  timeOfSystem:[Time] :\u003d nil\npublic static  public static isCorrectContractMonth: (seq of (char) -\u003e bool)\n\tisCorrectContractMonth(aContractMonth) \u003d\u003d\n((calendar.getDateFromString)((aContractMonth ^ \"01\")) \u003c\u003e false)\npublic static  public static getExerciseDate: (seq of (char) -\u003e Date)\n\tgetExerciseDate(aContractMonth) \u003d\u003d\nlet firstDayOfContractMonth:(Date | bool) \u003d (calendar.getDateFromString)((aContractMonth ^ \"01\")), designatedYear:int \u003d (firstDayOfContractMonth.Year)(), designatedMonth:int \u003d (firstDayOfContractMonth.Month)() in ((calendar.getNthDayOfTheWeek)(designatedYear, designatedMonth, 2, \u003cFri\u003e).getPastWeekday)()\n\tpre isCorrectContractMonth(aContractMonth)\npublic static  public static getContractDate: (Date -\u003e Date)\n\tgetContractDate(aDate) \u003d\u003d\nlet mk_(year, month):(int * int) \u003d (calendar.getMonthOf6monthsLater)((aDate.Year)(), (aDate.Month)()), date:int \u003d (aDate.day)(), candidateDate:Date \u003d getCandidateDate(year, month, date) in (candidateDate.getPastWeekday)()\n\tpost let mk_(year, month):(int * int) \u003d (calendar.getMonthOf6monthsLater)((aDate.Year)(), (aDate.Month)()), date:int \u003d (aDate.day)(), candidateDate:Date \u003d getCandidateDate(year, month, date) in ((RESULT.EQ)((candidateDate.getPastWeekday)()) and (if isDayoffFromTheBeginingOfMonthToCandidateDate(candidateDate)\nthen ((RESULT.Month)() \u003d getPreviousMonth(year, month))\nelse ((RESULT.Month)() \u003d month)))\npublic static  public static getMonthOf6monthsLater: (int * int -\u003e (int * int))\n\tgetMonthOf6monthsLater(year, month) \u003d\u003d\n(calendar.getRegularMonth)(year, (month + 6))\npublic static  public static getCandidateDate: (int * int * int -\u003e Date)\n\tgetCandidateDate(year, month, date) \u003d\u003d\nlet dateOfEndOfMonth:Date \u003d (calendar.getLastDayOfMonth)(year, month) in (if ((dateOfEndOfMonth.day)() \u003c date)\nthen dateOfEndOfMonth\nelse (calendar.getDateFrom_yyyy_mm_dd)(year, month, date))\npublic static  public static isDayoffFromTheBeginingOfMonthToCandidateDate: (Date -\u003e bool)\n\tisDayoffFromTheBeginingOfMonthToCandidateDate(candidateDate) \u003d\u003d\n(forall day in set {1, ... ,(candidateDate.day)()} \u0026 (calendar.isSundayOrDayoff)((calendar.getDateFrom_yyyy_mm_dd)((candidateDate.Year)(), (candidateDate.Month)(), day)))\npublic static  public static getPreviousMonth: (int * int -\u003e int)\n\tgetPreviousMonth(year, month) \u003d\u003d\nlet mk_(-, previousMonth):(int * int) \u003d (calendar.getRegularMonth)(year, (month - 1)) in previousMonth\npublic static  public static isDateNil: ([Date] -\u003e bool)\n\tisDateNil(date) \u003d\u003d\n(date \u003d nil)\npublic static  public static systemDate: (() -\u003e Date)\n\tsystemDate() \u003d\u003d\n(calendar.today)()\npublic  setTheSetOfDayOffs(int) (int \u003d\u003d\u003e ())\n\tsetTheSetOfDayOffs(int)(year) \u003d\u003d\nlet japaneseCalendar:JapaneseCalendar \u003d new JapaneseCalendar(), japaneseDayoffSet:set of (Date) \u003d (japaneseCalendar.getSetOfDayOff)(year), TR1のsetOfDayOff:set of (Date) \u003d {(japaneseCalendar.getDateFrom_yyyy_mm_dd)(year, 1, 2), (japaneseCalendar.getDateFrom_yyyy_mm_dd)(year, 1, 3), (japaneseCalendar.getDateFrom_yyyy_mm_dd)(year, 12, 29), (japaneseCalendar.getDateFrom_yyyy_mm_dd)(year, 12, 30), (japaneseCalendar.getDateFrom_yyyy_mm_dd)(year, 12, 31)}, saturdaySet:set of (Date) \u003d (japaneseCalendar.getDayOfTheWeekInYear)(year, \u003cSat\u003e) in Year2Holidays :\u003d (Year2Holidays munion {year |-\u003e ((japaneseDayoffSet union TR1のsetOfDayOff) union saturdaySet)})\n\tpre (year \u003e\u003d 2000)\npublic  readTodayOnBusiness(seq of (char)) (seq of (char) \u003d\u003d\u003e [Date])\n\treadTodayOnBusiness(seq of (char))(fname) \u003d\u003d\nlet mk_(rslt, mk_(y, m, d)):(bool * [(int * int * int)]) \u003d ((io.freadval))[(int * int * int)](fname) in if rslt\nthen\nreturn (getDateFrom_yyyy_mm_dd(y, m, d))else\nlet -:bool \u003d (io.echo)(\"Can\u0027t read BaseDay\u0027s data file.\") in return (nil)\npublic  todayOnBusiness() (() \u003d\u003d\u003e Date)\n\ttodayOnBusiness()() \u003d\u003d\nif (iTodayOnBusiness \u003d nil)\nthen\nreturn (readTodayOnBusiness((homedir ^ \"/temp/BaseDay.txt\")))else\nreturn (iTodayOnBusiness)\npublic  readFromFiletodayOnBusiness(seq of (char)) (seq of (char) \u003d\u003d\u003e Date)\n\treadFromFiletodayOnBusiness(seq of (char))(fname) \u003d\u003d\nif (iTodayOnBusiness \u003d nil)\nthen\nreturn (readTodayOnBusiness(fname))else\nreturn (iTodayOnBusiness)\npublic  setTodayOnBusiness(Date) (Date \u003d\u003d\u003e ())\n\tsetTodayOnBusiness(Date)(date) \u003d\u003d\niTodayOnBusiness :\u003d date\npublic  todayOnCompany(seq of (char)) (seq of (char) \u003d\u003d\u003e Date)\n\ttodayOnCompany(seq of (char))(companyCode) \u003d\u003d\n(\n\nif (iTodayOnCompanyMap \u003d nil)\nthen\nsetTodayOnCompany(companyCode, todayOnBusiness());\nreturn (iTodayOnCompanyMap(companyCode))\n)\npublic  setTodayOnCompany(seq of (char), Date) (seq of (char) * Date \u003d\u003d\u003e ())\n\tsetTodayOnCompany(seq of (char), Date)(companyCode, date) \u003d\u003d\niTodayOnCompanyMap :\u003d (iTodayOnCompanyMap ++ {companyCode |-\u003e date})\npublic  readSystemTime() (() \u003d\u003d\u003e [Time])\n\treadSystemTime()() \u003d\u003d\nlet mk_(rslt, now):(bool * [Time]) \u003d ((io.freadval))[Time]((homedir ^ \"/temp/SystemTime.txt\")) in if rslt\nthen\nreturn (now)else\nlet -:bool \u003d (io.echo)(\"Can\u0027t read System Time data file.\") in return (nil)\npublic  systemTime() (() \u003d\u003d\u003e Time)\n\tsystemTime()() \u003d\u003d\nif (timeOfSystem \u003d nil)\nthen\nreadSystemTime()else\nreturn (timeOfSystem)\npublic  setSystemTime(Time) (Time \u003d\u003d\u003e ())\n\tsetSystemTime(Time)(t) \u003d\u003d\ntimeOfSystem :\u003d t\npublic  SBCalendar() (() \u003d\u003d\u003e SBCalendar)\n\tSBCalendar()() \u003d\u003d\n(\n\nsetDifferenceWithGMT(differenceBetweenGMTandJST);\nreturn (self)\n)\nend SBCalendar\n","class SBCalendarT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new SBCalendarT06(), new SBCalendarT05(), new SBCalendarT04(), new SBCalendarT03(), new SBCalendarT02(), new SBCalendarT01()]\nend SBCalendarT\n","class SBCalendarT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:SBCalendar \u003d new SBCalendar() in (\n\nc.setTodayOnBusiness((c.getDateFrom_yyyy_mm_dd)(2001, 9, 12));\nc.setSystemTime(new Time(c, 2003, 10, 23, 13, 12, 34, 567));\nreturn ((((c.todayOnBusiness)().EQ)((c.getDateFrom_yyyy_mm_dd)(2001, 9, 12)) and (((c.isDateNil)(nil) \u003d true) and (((c.isDateNil)((c.todayOnBusiness)()) \u003d false) and (((c.systemDate)().EQ)((c.today)()) and ((c.systemTime)().EQ)(new Time(c, 2003, 10, 23, 13, 12, 34, 567)))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT01:\tTest maxDate and date is nil.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT01\n","class SBCalendarT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet jc:SBCalendar \u003d new SBCalendar(), setOfDayOff:set of (Date) \u003d (jc.getSetOfDayOff)(2001), setOfDayOff2006:set of (Date) \u003d (jc.getSetOfDayOff)(2006), d0401:(Date | bool) \u003d (jc.getDateFromString)(\"20010401\"), d0408:(Date | bool) \u003d (jc.getDateFromString)(\"20010408\"), d0430:(Date | bool) \u003d (jc.getDateFromString)(\"20010430\"), setOfDayOffBy_yyyy_mm_dd:set of ((int * int * int)) \u003d {(jc.getYyyymmdd)(dayOff) | dayOff in set setOfDayOff}, setOfDayOffBy_yyyy_mm_dd2006:set of ((int * int * int)) \u003d {(jc.getYyyymmdd)(dayOff) | dayOff in set setOfDayOff2006} in return (((setOfDayOffBy_yyyy_mm_dd \u003d {mk_(2001, 1, 1), mk_(2001, 1, 2), mk_(2001, 1, 3), mk_(2001, 1, 6), mk_(2001, 1, 8), mk_(2001, 1, 13), mk_(2001, 1, 20), mk_(2001, 1, 27), mk_(2001, 2, 3), mk_(2001, 2, 10), mk_(2001, 2, 11), mk_(2001, 2, 12), mk_(2001, 2, 17), mk_(2001, 2, 24), mk_(2001, 3, 3), mk_(2001, 3, 10), mk_(2001, 3, 17), mk_(2001, 3, 20), mk_(2001, 3, 24), mk_(2001, 3, 31), mk_(2001, 4, 7), mk_(2001, 4, 14), mk_(2001, 4, 21), mk_(2001, 4, 28), mk_(2001, 4, 29), mk_(2001, 4, 30), mk_(2001, 5, 3), mk_(2001, 5, 4), mk_(2001, 5, 5), mk_(2001, 5, 12), mk_(2001, 5, 19), mk_(2001, 5, 26), mk_(2001, 6, 2), mk_(2001, 6, 9), mk_(2001, 6, 16), mk_(2001, 6, 23), mk_(2001, 6, 30), mk_(2001, 7, 7), mk_(2001, 7, 14), mk_(2001, 7, 20), mk_(2001, 7, 21), mk_(2001, 7, 28), mk_(2001, 8, 4), mk_(2001, 8, 11), mk_(2001, 8, 18), mk_(2001, 8, 25), mk_(2001, 9, 1), mk_(2001, 9, 8), mk_(2001, 9, 15), mk_(2001, 9, 22), mk_(2001, 9, 23), mk_(2001, 9, 24), mk_(2001, 9, 29), mk_(2001, 10, 6), mk_(2001, 10, 8), mk_(2001, 10, 13), mk_(2001, 10, 20), mk_(2001, 10, 27), mk_(2001, 11, 3), mk_(2001, 11, 10), mk_(2001, 11, 17), mk_(2001, 11, 23), mk_(2001, 11, 24), mk_(2001, 12, 1), mk_(2001, 12, 8), mk_(2001, 12, 15), mk_(2001, 12, 22), mk_(2001, 12, 23), mk_(2001, 12, 24), mk_(2001, 12, 29), mk_(2001, 12, 30), mk_(2001, 12, 31)}) and ((setOfDayOffBy_yyyy_mm_dd2006 \u003d {mk_(2006, 1, 1), mk_(2006, 1, 2), mk_(2006, 1, 3), mk_(2006, 1, 7), mk_(2006, 1, 9), mk_(2006, 1, 14), mk_(2006, 1, 21), mk_(2006, 1, 28), mk_(2006, 2, 4), mk_(2006, 2, 11), mk_(2006, 2, 18), mk_(2006, 2, 25), mk_(2006, 3, 4), mk_(2006, 3, 11), mk_(2006, 3, 18), mk_(2006, 3, 21), mk_(2006, 3, 25), mk_(2006, 4, 1), mk_(2006, 4, 8), mk_(2006, 4, 15), mk_(2006, 4, 22), mk_(2006, 4, 29), mk_(2006, 5, 3), mk_(2006, 5, 4), mk_(2006, 5, 5), mk_(2006, 5, 6), mk_(2006, 5, 13), mk_(2006, 5, 20), mk_(2006, 5, 27), mk_(2006, 6, 3), mk_(2006, 6, 10), mk_(2006, 6, 17), mk_(2006, 6, 24), mk_(2006, 7, 1), mk_(2006, 7, 8), mk_(2006, 7, 15), mk_(2006, 7, 17), mk_(2006, 7, 22), mk_(2006, 7, 29), mk_(2006, 8, 5), mk_(2006, 8, 12), mk_(2006, 8, 19), mk_(2006, 8, 26), mk_(2006, 9, 2), mk_(2006, 9, 9), mk_(2006, 9, 16), mk_(2006, 9, 18), mk_(2006, 9, 23), mk_(2006, 9, 30), mk_(2006, 10, 7), mk_(2006, 10, 9), mk_(2006, 10, 14), mk_(2006, 10, 21), mk_(2006, 10, 28), mk_(2006, 11, 3), mk_(2006, 11, 4), mk_(2006, 11, 11), mk_(2006, 11, 18), mk_(2006, 11, 23), mk_(2006, 11, 25), mk_(2006, 12, 2), mk_(2006, 12, 9), mk_(2006, 12, 16), mk_(2006, 12, 23), mk_(2006, 12, 29), mk_(2006, 12, 30), mk_(2006, 12, 31)}) and (((jc.getDayOffsExceptSunday)(d0401, d0430) \u003d 6) and (((card (jc.getDayOffsAndSunday)(d0401, d0430)) \u003d 1) and ((jc.getDayOffsAndSunday)(d0401, d0408) \u003d {}))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT02:\tGetting set of day off.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT02\n","class SBCalendarT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:SBCalendar \u003d new SBCalendar() in (\n\nc.setTodayOnBusiness((c.getDateFrom_yyyy_mm_dd)(2001, 9, 12));\nreturn ((((c.getExerciseDate)(\"200111\").EQ)((c.getDateFrom_yyyy_mm_dd)(2001, 11, 9)) and (((c.getExerciseDate)(\"200109\").EQ)((c.getDateFrom_yyyy_mm_dd)(2001, 9, 14)) and (((c.isCorrectContractMonth)(\"200206\") \u003d true) and (((c.isCorrectContractMonth)(\"200206.01\") \u003d false) and ((c.isCorrectContractMonth)(\"Shin Sahara\") \u003d false))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT03:\tTest validity checking of contract month and getting execution date.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT03\n","class SBCalendarT04 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:SBCalendar \u003d new SBCalendar(), d0929:Date \u003d (c.getDateFrom_yyyy_mm_dd)(2001, 9, 29), d0104:Date \u003d (c.getDateFrom_yyyy_mm_dd)(20021, 1, 4) in (\n\nc.setTodayOnCompany(\"007\", d0104);\nc.setTodayOnCompany(\"009\", d0929);\nreturn ((((c.todayOnCompany)(\"007\") \u003d d0104) and ((c.todayOnCompany)(\"009\") \u003d d0929)))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT04:\tTest of todayOnCompany\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT04\n","class SBCalendarT05 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:SBCalendar \u003d new SBCalendar() in return ((((c.todayOnBusiness)().EQ)((c.getDateFrom_yyyy_mm_dd)(2003, 10, 24)) and ((c.readFromFiletodayOnBusiness)((homedir ^ \"/temp/Today.txt\")).EQ)((c.getDateFrom_yyyy_mm_dd)(2001, 3, 1))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT05:\tTest todayOnBusiness from a file.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT05\n","class SBCalendarT06 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:SBCalendar \u003d new SBCalendar(), sDate:(Date -\u003e Date) \u003d SBCalendar`getContractDate in return (((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 1, 5)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 7, 5)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 1, 31)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 7, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 2, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 7, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 2, 2)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 8, 2)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 2, 27)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 8, 27)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 3, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 9, 1)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 3, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 9, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 3, 31)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 9, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 4, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 10, 1)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 4, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 10, 29)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 5, 6)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 11, 5)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 5, 7)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 11, 5)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 5, 10)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 11, 10)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 6, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 1)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 6, 28)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 6, 29)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 6, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 7, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 7, 2)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 12, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 7, 5)).EQ)((c.getDateFrom_yyyy_mm_dd)(2005, 1, 5)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2004, 7, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2005, 1, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 8, 2)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 2, 2)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 8, 28)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 2, 27)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 8, 29)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 2, 27)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 9, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 3, 1)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 9, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 3, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 10, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 4, 1)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 10, 29)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 4, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 11, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 4, 30)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 11, 30)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 5, 28)) and ((sDate((c.getDateFrom_yyyy_mm_dd)(2003, 12, 1)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 6, 1)) and (sDate((c.getDateFrom_yyyy_mm_dd)(2003, 12, 26)).EQ)((c.getDateFrom_yyyy_mm_dd)(2004, 6, 25))))))))))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SBCalendarT06:\tGetting contract date of margin trading.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SBCalendarT06\n","class Sequence\npublic static  public static Sum[(T)]: (seq of (@T) -\u003e @T)\n\tSum(s) \u003d\u003d\n(SumAux)[@T](s)(0)\n\tpre is_(s, seq of (real))\nprivate static  private static SumAux[(T)]: (seq of (@T) -\u003e (@T -\u003e @T))\n\tSumAux(s)(sum) \u003d\u003d\n(if (is_(s, seq of (real)) and is_(sum, real))\nthen (if (s \u003d [])\nthen sum\nelse (SumAux)[@T]((tl s))((sum + (hd s))))\nelse (undefined))\nprivate static  private static length_measure[(T)]: (seq of (@T) +\u003e nat)\n\tlength_measure(s) \u003d\u003d\n(len s)\npublic static  public static Product[(T)]: (seq of (@T) -\u003e @T)\n\tProduct(s) \u003d\u003d\n(ProductAux)[@T](s)(1)\n\tpre is_(s, seq of (real))\nprivate static  private static ProductAux[(T)]: (seq of (@T) -\u003e (@T -\u003e @T))\n\tProductAux(s)(p) \u003d\u003d\n(if (is_(s, seq of (real)) and is_(p, real))\nthen (cases s :\n[h] ^ tail -\u003e (ProductAux)[@T](tail)((p * h)),\n[] -\u003e p\n end)\nelse (undefined))\npublic static  public static GetAverage[(T)]: (seq of (@T) -\u003e [real])\n\tGetAverage(s) \u003d\u003d\n(if (s \u003d [])\nthen nil\nelse (GetAverageAux)[@T](s)(0)((len s)))\nprivate static  private static GetAverageAux[(T)]: (seq of (@T) -\u003e (@T -\u003e (@T -\u003e real)))\n\tGetAverageAux(s)(sum)(numberOfElem) \u003d\u003d\n(if (is_(s, seq of (real)) and (is_(sum, real) and is_(numberOfElem, real)))\nthen (cases s :\n[h] ^ tail -\u003e (GetAverageAux)[@T](tail)((sum + h))(numberOfElem),\n[] -\u003e (sum / numberOfElem)\n end)\nelse (undefined))\npublic static  public static isAscendingTotalOrder[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e bool))\n\tisAscendingTotalOrder(decideOrderFunc)(s) \u003d\u003d\n(forall i, j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (decideOrderFunc(s(i), s(j)) or (s(i) \u003d s(j)))))\npublic static  public static isDescendingTotalOrder[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e bool))\n\tisDescendingTotalOrder(decideOrderFunc)(s) \u003d\u003d\n(forall i, j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (decideOrderFunc(s(j), s(i)) or (s(i) \u003d s(j)))))\npublic static  public static isAscendingOrder[(T)]: (seq of (@T) -\u003e bool)\n\tisAscendingOrder(s) \u003d\u003d\n(isAscendingTotalOrder)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\npublic static  public static isDescendingOrder[(T)]: (seq of (@T) -\u003e bool)\n\tisDescendingOrder(s) \u003d\u003d\n(isDescendingTotalOrder)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\npublic static  public static sort[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tsort(decideOrderFunc)(s) \u003d\u003d\n(cases s :\n[] -\u003e [],\n[h] ^ tail -\u003e (((sort)[@T](decideOrderFunc)([tail(i) | i in set (inds tail) \u0026 decideOrderFunc(tail(i), h)]) ^ [h]) ^ (sort)[@T](decideOrderFunc)([tail(i) | i in set (inds tail) \u0026 (not decideOrderFunc(tail(i), h))]))\n end)\npublic static  public static ascendingOrderSort[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tascendingOrderSort(s) \u003d\u003d\n(sort)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003c y)\nelse (undefined))))(s)\npublic static  public static descendingOrderSort[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tdescendingOrderSort(s) \u003d\u003d\n(sort)[@T]((lambda [x:@T, y:@T] \u0026 (if (is_(x, real) and is_(y, real))\nthen (x \u003e y)\nelse (undefined))))(s)\npublic static  public static isOrdered[(T)]: (seq of ((@T * @T -\u003e bool)) -\u003e (seq of (@T) -\u003e (seq of (@T) -\u003e bool)))\n\tisOrdered(decideOrderFuncSeq)(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([], []) -\u003e false,\nmk_([], -) -\u003e true,\nmk_(-, []) -\u003e false,\nmk_([h1] ^ tail1, [h2] ^ tail2) -\u003e (if (hd decideOrderFuncSeq)(h1, h2)\nthen true\nelseif (hd decideOrderFuncSeq)(h2, h1)\nthen false\nelse (Sequence`isOrdered)[@T]((tl decideOrderFuncSeq))(tail1)(tail2))\n end)\npublic static  public static Merge[(T)]: ((@T * @T -\u003e bool) -\u003e (seq of (@T) -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tMerge(decideOrderFunc)(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([], y) -\u003e y,\nmk_(x, []) -\u003e x,\nmk_([h1] ^ tail1, [h2] ^ tail2) -\u003e (if decideOrderFunc(h1, h2)\nthen ([h1] ^ (Sequence`Merge)[@T](decideOrderFunc)(tail1)(s2))\nelse ([h2] ^ (Sequence`Merge)[@T](decideOrderFunc)(s1)(tail2)))\n end)\npublic static  public static InsertAt[(T)]: (nat1 -\u003e (@T -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tInsertAt(position)(e)(s) \u003d\u003d\n(cases mk_(position, s) :\nmk_(1, str) -\u003e ([e] ^ str),\nmk_(-, []) -\u003e [e],\nmk_(pos, [h] ^ tail) -\u003e ([h] ^ (InsertAt)[@T]((pos - 1))(e)(tail))\n end)\npublic static  public static RemoveAt[(T)]: (nat1 -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveAt(position)(s) \u003d\u003d\n(cases mk_(position, s) :\nmk_(1, [-] ^ tail) -\u003e tail,\nmk_(pos, [h] ^ tail) -\u003e ([h] ^ (RemoveAt)[@T]((pos - 1))(tail)),\nmk_(-, []) -\u003e []\n end)\npublic static  public static RemoveDup[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tRemoveDup(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e ([h] ^ (RemoveDup)[@T]((filter)[@T]((lambda [x:@T] \u0026 (x \u003c\u003e h)))(tail))),\n[] -\u003e []\n end)\npublic static  public static RemoveMember[(T)]: (@T -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveMember(e)(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e (if (e \u003d h)\nthen tail\nelse ([h] ^ (RemoveMember)[@T](e)(tail))),\n[] -\u003e []\n end)\npublic static  public static RemoveMembers[(T)]: (seq of (@T) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tRemoveMembers(elemSeq)(s) \u003d\u003d\n(cases elemSeq :\n[] -\u003e s,\n[h] ^ tail -\u003e (RemoveMembers)[@T](tail)((RemoveMember)[@T](h)(s))\n end)\npublic static  public static UpdateAt[(T)]: (nat1 -\u003e (@T -\u003e (seq of (@T) -\u003e seq of (@T))))\n\tUpdateAt(position)(e)(s) \u003d\u003d\n(cases mk_(position, s) :\nmk_(-, []) -\u003e [],\nmk_(1, [-] ^ tail) -\u003e ([e] ^ tail),\nmk_(pos, [h] ^ tail) -\u003e ([h] ^ (UpdateAt)[@T]((pos - 1))(e)(tail))\n end)\npublic static  public static take[(T)]: (int -\u003e (seq of (@T) -\u003e seq of (@T)))\n\ttake(i)(s) \u003d\u003d\n(s(1, ... ,i))\npublic static  public static TakeWhile[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tTakeWhile(f)(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e (if f(h)\nthen ([h] ^ (TakeWhile)[@T](f)(tail))\nelse []),\n[] -\u003e []\n end)\npublic static  public static drop[(T)]: (int -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tdrop(i)(s) \u003d\u003d\n(s((i + 1), ... ,(len s)))\npublic static  public static DropWhile[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tDropWhile(f)(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e (if f(h)\nthen (DropWhile)[@T](f)(tail)\nelse s),\n[] -\u003e []\n end)\npublic static  public static Span[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e (seq of (@T) * seq of (@T))))\n\tSpan(f)(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e (if f(h)\nthen let mk_(matchSeq, otherSeq):(seq of (@T) * seq of (@T)) \u003d (Span)[@T](f)(tail) in mk_(([h] ^ matchSeq), otherSeq)\nelse mk_([], s)),\n[] -\u003e mk_([], [])\n end)\npublic static  public static SubSeq[(T)]: (nat -\u003e (nat -\u003e (seq1 of (@T) -\u003e seq of (@T))))\n\tSubSeq(startPos)(numOfElem)(s) \u003d\u003d\n(s(startPos, ... ,((startPos + numOfElem) - 1)))\npublic static  public static last[(T)]: (seq of (@T) -\u003e @T)\n\tlast(s) \u003d\u003d\ns((len s))\npublic static  public static fmap[(T1, T2)]: ((@T1 -\u003e @T2) -\u003e (seq of (@T1) -\u003e seq of (@T2)))\n\tfmap(f)(s) \u003d\u003d\n[f(s(i)) | i in set (inds s)]\npublic  public Fmap[(elem)]: ((@elem -\u003e @elem) -\u003e (seq of (@elem) -\u003e seq of (@elem)))\n\tFmap(f)(l) \u003d\u003d\n(if (l \u003d [])\nthen []\nelse ([f((hd l))] ^ (Fmap)[@elem](f)((tl l))))\npublic static  public static filter[(T)]: ((@T -\u003e bool) -\u003e (seq of (@T) -\u003e seq of (@T)))\n\tfilter(f)(s) \u003d\u003d\n[s(i) | i in set (inds s) \u0026 f(s(i))]\npublic static  public static Foldl[(T1, T2)]: ((@T1 -\u003e (@T2 -\u003e @T1)) -\u003e (@T1 -\u003e (seq of (@T2) -\u003e @T1)))\n\tFoldl(f)(arg)(s) \u003d\u003d\n(cases s :\n[] -\u003e arg,\n[h] ^ tail -\u003e (Foldl)[@T1, @T2](f)(f(arg)(h))(tail)\n end)\npublic static  public static Foldr[(T1, T2)]: ((@T1 -\u003e (@T2 -\u003e @T2)) -\u003e (@T2 -\u003e (seq of (@T1) -\u003e @T2)))\n\tFoldr(f)(arg)(s) \u003d\u003d\n(cases s :\n[] -\u003e arg,\n[h] ^ tail -\u003e f(h)((Foldr)[@T1, @T2](f)(arg)(tail))\n end)\npublic static  public static isMember[(T)]: (@T -\u003e (seq of (@T) -\u003e bool))\n\tisMember(e)(s) \u003d\u003d\n(cases s :\n[h] ^ tail -\u003e ((e \u003d h) or (isMember)[@T](e)(tail)),\n[] -\u003e false\n end)\npublic static  public static isAnyMember[(T)]: (seq of (@T) -\u003e (seq of (@T) -\u003e bool))\n\tisAnyMember(elemSeq)(s) \u003d\u003d\n(cases elemSeq :\n[h] ^ tail -\u003e ((isMember)[@T](h)(s) or (isAnyMember)[@T](tail)(s)),\n[] -\u003e false\n end)\npublic static  public static Index[(T)]: (@T -\u003e (seq of (@T) -\u003e int))\n\tIndex(e)(s) \u003d\u003d\nlet i:nat \u003d 0 in (IndexAux)[@T](e)(s)(i)\nprivate static  private static IndexAux[(T)]: (@T -\u003e (seq of (@T) -\u003e (int -\u003e int)))\n\tIndexAux(e)(s)(indx) \u003d\u003d\n(cases s :\n[] -\u003e 0,\n[x] ^ xs -\u003e (if (x \u003d e)\nthen (indx + 1)\nelse (IndexAux)[@T](e)(xs)((indx + 1)))\n end)\npublic static  public static IndexAll2[(T)]: (@T -\u003e (seq of (@T) -\u003e set of (int)))\n\tIndexAll2(e)(s) \u003d\u003d\n{i | i in set (inds s) \u0026 (s(i) \u003d e)}\npublic static  public static flatten[(T)]: (seq of (seq of (@T)) -\u003e seq of (@T))\n\tflatten(s) \u003d\u003d\n(conc s)\npublic static  public static compact[(T)]: (seq of ([@T]) -\u003e seq of (@T))\n\tcompact(s) \u003d\u003d\n[s(i) | i in set (inds s) \u0026 (s(i) \u003c\u003e nil)]\npublic static  public static freverse[(T)]: (seq of (@T) -\u003e seq of (@T))\n\tfreverse(s) \u003d\u003d\n[s((((len s) + 1) - i)) | i in set (inds s)]\npublic static  public static Permutations[(T)]: (seq of (@T) -\u003e set of (seq of (@T)))\n\tPermutations(s) \u003d\u003d\n(cases s :\n[] -\u003e {s},\n[-] -\u003e {s}\nothers (dunion {{([s(i)] ^ j) | j in set (Permutations)[@T]((RestSeq)[@T](s, i))} | i in set (inds s)})\n end)\npublic static  public static RestSeq[(T)]: (seq of (@T) * nat -\u003e seq of (@T))\n\tRestSeq(s, i) \u003d\u003d\n[s(j) | j in set ((inds s) \\ {i})]\npublic static  public static Unzip[(T1, T2)]: (seq of ((@T1 * @T2)) -\u003e (seq of (@T1) * seq of (@T2)))\n\tUnzip(s) \u003d\u003d\n(cases s :\n[] -\u003e mk_([], []),\n[mk_(x, y)] ^ tail -\u003e let mk_(xs, ys):(seq of (@T1) * seq of (@T2)) \u003d (Unzip)[@T1, @T2](tail) in mk_(([x] ^ xs), ([y] ^ ys))\n end)\nprivate static  private static lengthUnzip[(T1, T2)]: (seq of ((@T1 * @T2)) +\u003e nat)\n\tlengthUnzip(s) \u003d\u003d\n(len s)\npublic static  public static Zip[(T1, T2)]: (seq of (@T1) * seq of (@T2) -\u003e seq of ((@T1 * @T2)))\n\tZip(s1, s2) \u003d\u003d\n(Zip2)[@T1, @T2](s1)(s2)\npublic static  public static Zip2[(T1, T2)]: (seq of (@T1) -\u003e (seq of (@T2) -\u003e seq of ((@T1 * @T2))))\n\tZip2(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([h1] ^ tail1, [h2] ^ tail2) -\u003e ([mk_(h1, h2)] ^ (Zip2)[@T1, @T2](tail1)(tail2)),\nmk_(-, -) -\u003e []\n end)\nend Sequence\n","class SequenceT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new SequenceT25(), new SequenceT23(), new SequenceT24(), new SequenceT19(), new SequenceT20(), new SequenceT21(), new SequenceT22(), new SequenceT01(), new SequenceT02(), new SequenceT03(), new SequenceT04(), new SequenceT05(), new SequenceT06(), new SequenceT07(), new SequenceT08(), new SequenceT09(), new SequenceT10(), new SequenceT11(), new SequenceT12(), new SequenceT13(), new SequenceT14(), new SequenceT15(), new SequenceT16(), new SequenceT17(), new SequenceT18()]\nend SequenceT\n","class SequenceT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return ((((((sq.Sum))[int]([1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003d 45) and (((sq.Sum))[int]([]) \u003d 0)) and (((Sequence`Product)[int]([2, 3, 4]) \u003d 24) and ((Sequence`Product)[int]([]) \u003d 1))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT01:\t Integer sum and product.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT01\n","class SequenceT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return (((((sq.Sum))[real]([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) \u003d 4.5) and ((((sq.Sum))[real]([]) \u003d 0.0) and (((Sequence`Product)[real]([2.0, 3.0, 4.0]) \u003d 24.0) and (((Sequence`Product)[real]([]) \u003d 1.0) and ((Sequence`Product)[real]([2.1, 3.2, 4.3]) \u003d ((2.1 * 3.2) * 4.3)))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT02:\t Real sum and product.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT02\n","class SequenceT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return ((((sq.isAscendingOrder))[int]([1, 2, 4, 4, 7, 8, 8, 8]) and (not ((sq.isAscendingOrder))[real]([1.0, 2.0, 3.0, 1.5]))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT03:\t Test isAscendingOrder (integer and real)\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT03\n","class SequenceT04 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return ((((sq.isDescendingOrder))[int]([3, 2, 2, 1, 1]) and ((Sequence`isDescendingTotalOrder)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))([3, 2, 2, 1, 1]) and ((Sequence`isDescendingTotalOrder)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))([3, 2, 2, 1, 2]) \u003d false))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT04:\t Test isDescendingTotalOrder (integer).\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT04\n","class SequenceT05 is subclass of [TestCase]\npublic static  TestType \u003d TestType\npublic static  RecordType \u003d RecordType\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence(), decideOrderFuncSeq:seq1 of (((char * char -\u003e bool) | (int * int -\u003e bool) | (seq of (char) * seq of (char) -\u003e bool))) \u003d [(lambda [x:int, y:int] \u0026 (x \u003c y)), (lambda [x:seq of (char), y:seq of (char)] \u0026 String`LT(x, y)), (lambda [x:char, y:char] \u0026 Character`LT(x, y))], decideOrderFunc:(RecordType * RecordType -\u003e bool) \u003d (lambda [x:(unresolved SequenceT05`RecordType), y:(unresolved SequenceT05`RecordType)] \u0026 (Sequence`isOrdered)[TestType](decideOrderFuncSeq)([(x.val), (x.str), (x.chr)])([(y.val), (y.str), (y.chr)])) in return ((((Sequence`sort)[int]((lambda [x:int, y:int] \u0026 (x \u003c y)))([3, 1, 5, 4]) \u003d [1, 3, 4, 5]) and (((Sequence`sort)[seq of (char)]((lambda [x:seq of (char), y:seq of (char)] \u0026 String`LT(x, y)))([\"12\", \"111\", \"01\"]) \u003d [\"01\", \"111\", \"12\"]) and (((Sequence`sort)[RecordType](decideOrderFunc)([mk_RecordType(10, \"sahara\", \u0027c\u0027), mk_RecordType(10, \"sahara\", \u0027a\u0027)]) \u003d [mk_RecordType(10, \"sahara\", \u0027a\u0027), mk_RecordType(10, \"sahara\", \u0027c\u0027)]) and ((((sq.isOrdered))[TestType](decideOrderFuncSeq)([3, \"123\", \u0027a\u0027])([3, \"123\", \u0027A\u0027]) \u003d true) and ((((sq.isOrdered))[TestType](decideOrderFuncSeq)([3, \"123\", \u0027a\u0027])([3, \"123\", \u00270\u0027]) \u003d false) and ((((sq.isOrdered))[(char | int | seq of (char))](decideOrderFuncSeq)([])([]) \u003d false) and ((((sq.isOrdered))[(char | int | seq of (char))](decideOrderFuncSeq)([])([3, \"123\", \u00270\u0027]) \u003d true) and (((sq.isOrdered))[(char | int | seq of (char))](decideOrderFuncSeq)([3, \"123\", \u00270\u0027])([]) \u003d false)))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT05:\t test sort and isOrdered.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT05\n","class SequenceT06 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence(), decideOrderFunc1:(int * int -\u003e bool) \u003d (lambda [x:int, y:int] \u0026 (x \u003c y)), decideOrderFunc2:(char * char -\u003e bool) \u003d (lambda [x:char, y:char] \u0026 Character`LT(x, y)) in return (((((sq.Merge))[int](decideOrderFunc1)([1, 4, 6])([2, 3, 4, 5]) \u003d [1, 2, 3, 4, 4, 5, 6]) and ((((sq.Merge))[char](decideOrderFunc2)(\"146\")(\"2345\") \u003d \"1234456\") and ((((sq.Merge))[char](decideOrderFunc2)(\"\")(\"2345\") \u003d \"2345\") and (((sq.Merge))[char](decideOrderFunc2)(\"146\")(\"\") \u003d \"146\")))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT06:\t Merge sequences.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT06\n","class SequenceT07 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return (((((sq.take))[int](2)([2, 3, 4, 5]) \u003d [2, 3]) and ((((sq.drop))[char](5)(\"Shin Sahara\") \u003d \"Sahara\") and ((((sq.last))[int]([1, 2, 3]) \u003d 3) and ((((sq.filter))[int]((lambda [x:int] \u0026 ((x mod 2) \u003d 0)))([1, 2, 3, 4, 5, 6]) \u003d [2, 4, 6]) and (((Sequence`SubSeq)[char](4)(3)(\"1234567890\") \u003d \"456\") and ((Sequence`flatten)[int]([[1, 2, 3], [3, 4], [4, 5, 6]]) \u003d [1, 2, 3, 3, 4, 4, 5, 6])))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT07:\t Handling sequences.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT07\n","class SequenceT08 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Sequence`ascendingOrderSort)[int]([3, 1, 6, 4, 2, 6, 5]) \u003d [1, 2, 3, 4, 5, 6, 6]) and ((Sequence`descendingOrderSort)[int]([3, 1, 6, 4, 2, 6, 5]) \u003d [6, 6, 5, 4, 3, 2, 1])))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT08:\t Test sort.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT08\n","class SequenceT09 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Sequence`compact)[[int]]([3, 1, 6, 4, nil, 2, 6, 5, nil]) \u003d [3, 1, 6, 4, 2, 6, 5]) and (((Sequence`compact)[[int]]([nil, nil]) \u003d []) and ((Sequence`compact)[[int]]([]) \u003d []))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT09:\t Delete nil elements.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT09\n","class SequenceT10 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Sequence`freverse)[[int]]([3, 1, 6, 4, nil, 2, 6, 5, nil]) \u003d [nil, 5, 6, 2, nil, 4, 6, 1, 3]) and ((Sequence`freverse)[[int]]([]) \u003d [])))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT10:\t Get inverse sequence.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT10\n","class SequenceT11 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Sequence`Permutations)[[int]]([1, 2, 3]) \u003d {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]}) and ((Sequence`Permutations)[[int]]([]) \u003d {[]})))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT11:\t Get permutation.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT11\n","class SequenceT12 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((Sequence`isMember)[int](2)([1, 2, 3, 4, 5, 6]) and (((Sequence`isMember)[int](0)([1, 2, 3, 4, 5, 6]) \u003d false) and ((Sequence`isMember)[int](6)([1, 2, 3, 4, 5, 6]) and ((Sequence`isAnyMember)[int]([6])([1, 2, 3, 4, 5, 6]) and (((Sequence`isAnyMember)[int]([0, 7])([1, 2, 3, 4, 5, 6]) \u003d false) and ((Sequence`isAnyMember)[int]([4, 6])([1, 2, 3, 4, 5, 6]) and ((Sequence`isAnyMember)[int]([])([1, 2, 3, 4, 5, 6]) \u003d false))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT12:\t Search sequence.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT12\n","class SequenceT13 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Sequence`fmap)[int, int]((lambda [x:int] \u0026 (x mod 3)))([1, 2, 3, 4, 5]) \u003d [1, 2, 0, 1, 2]) and ((Sequence`fmap)[seq of (char), seq of (char)]((Sequence`take)[char](2))([\"Shin Sahara\", \"Hiroshi Sakoh\"]) \u003d [\"Sh\", \"Hi\"])))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT13:\tTest fmap.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT13\n","class SequenceT14 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet index:(@T -\u003e (seq of (@T) -\u003e int)) \u003d Sequence`Index, indexAll:(@T -\u003e (seq of (@T) -\u003e set of (int))) \u003d Sequence`IndexAll2 in return ((((index)[int](1)([1, 2, 3, 4, 5]) \u003d 1) and (((index)[int](5)([1, 2, 3, 4, 5]) \u003d 5) and (((index)[int](9)([1, 2, 3, 4, 5]) \u003d 0) and (((index)[char](\u0027b\u0027)([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003d 2) and (((index)[char](\u0027z\u0027)([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003d 0) and (((indexAll)[int](9)([1, 2, 3, 4, 5]) \u003d {}) and (((indexAll)[int](9)([]) \u003d {}) and (((indexAll)[int](1)([1, 2, 3, 4, 1]) \u003d {1, 5}) and ((indexAll)[int](1)([1, 2, 3, 4, 1, 1]) \u003d {1, 5, 6}))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT14:\t Test Index.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT14\n","class SequenceT15 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet avg1:(seq of (int) +\u003e [real]) \u003d (Sequence`GetAverage)[int], avg2:(seq of (real) +\u003e [real]) \u003d (Sequence`GetAverage)[real] in return (((avg1([]) \u003d nil) and ((avg1([1, 2, 3, 4]) \u003d ((((1 + 2) + 3) + 4) / 4)) and (avg2([1.3, 2.4, 3.5]) \u003d (7.2 / 3)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT15:\t Test GetAverage.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT15\n","class SequenceT16 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet ins1:(nat1 +\u003e (int +\u003e (seq of (int) +\u003e seq of (int)))) \u003d (Sequence`InsertAt)[int], ins2:(nat1 +\u003e (char +\u003e (seq of (char) +\u003e seq of (char)))) \u003d (Sequence`InsertAt)[char] in return (((ins1(1)(1)([2, 3, 4, 5]) \u003d [1, 2, 3, 4, 5]) and ((ins1(3)(3)([1, 2, 4, 5]) \u003d [1, 2, 3, 4, 5]) and ((ins1(3)(3)([1, 2]) \u003d [1, 2, 3]) and ((ins1(4)(3)([1, 2]) \u003d [1, 2, 3]) and ((ins1(5)(3)([1, 2]) \u003d [1, 2, 3]) and ((ins2(1)(\u00271\u0027)(\"2345\") \u003d \"12345\") and ((ins2(3)(\u00273\u0027)(\"1245\") \u003d \"12345\") and (ins2(3)(\u00273\u0027)(\"12\") \u003d \"123\")))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT16:\t Test InsertAt.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT16\n","class SequenceT17 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet rm1:(nat1 +\u003e (seq of (int) +\u003e seq of (int))) \u003d (Sequence`RemoveAt)[int], rm2:(nat1 +\u003e (seq of (char) +\u003e seq of (char))) \u003d (Sequence`RemoveAt)[char] in return (((rm1(1)([1, 2, 3, 4, 5]) \u003d [2, 3, 4, 5]) and ((rm1(3)([1, 2, 4, 3]) \u003d [1, 2, 3]) and ((rm1(3)([1, 2]) \u003d [1, 2]) and ((rm1(4)([1, 2]) \u003d [1, 2]) and ((rm1(5)([1, 2]) \u003d [1, 2]) and ((rm2(1)(\"12345\") \u003d \"2345\") and ((rm2(3)(\"1243\") \u003d \"123\") and (rm2(3)(\"12\") \u003d \"12\")))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT17:\t Test RemoveAt.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT17\n","class SequenceT18 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet up1:(nat1 +\u003e (int +\u003e (seq of (int) +\u003e seq of (int)))) \u003d (Sequence`UpdateAt)[int], up2:(nat1 +\u003e (char +\u003e (seq of (char) +\u003e seq of (char)))) \u003d (Sequence`UpdateAt)[char] in return (((up1(1)(10)([1, 2, 3, 4, 5]) \u003d [10, 2, 3, 4, 5]) and ((up1(3)(40)([1, 2, 4, 3]) \u003d [1, 2, 40, 3]) and ((up1(2)(30)([1, 2]) \u003d [1, 30]) and ((up1(3)(30)([1, 2]) \u003d [1, 2]) and ((up1(4)(30)([1, 2]) \u003d [1, 2]) and ((up2(1)(\u0027a\u0027)(\"12345\") \u003d \"a2345\") and ((up2(3)(\u0027b\u0027)(\"1243\") \u003d \"12b3\") and ((up2(3)(\u0027c\u0027)(\"123\") \u003d \"12c\") and (up2(3)(\u0027c\u0027)(\"12\") \u003d \"12\"))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT18:\t Test UpdateAt.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT18\n","class SequenceT19 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet removeDup:(seq of (int) +\u003e seq of (int)) \u003d (Sequence`RemoveDup)[int], removeMember:(int +\u003e (seq of (int) +\u003e seq of (int))) \u003d (Sequence`RemoveMember)[int], removeMembers:(seq of (int) +\u003e (seq of (int) +\u003e seq of (int))) \u003d (Sequence`RemoveMembers)[int] in return (((removeDup([]) \u003d []) and ((removeDup([1, 1, 2, 2, 2, 3, 4, 4, 4, 4]) \u003d [1, 2, 3, 4]) and ((removeDup([1, 2, 3, 4]) \u003d [1, 2, 3, 4]) and ((removeMember(1)([]) \u003d []) and ((removeMember(1)([1, 2, 3]) \u003d [2, 3]) and ((removeMember(4)([1, 2, 3]) \u003d [1, 2, 3]) and ((removeMembers([])([]) \u003d []) and ((removeMembers([])([1, 2, 3]) \u003d [1, 2, 3]) and ((removeMembers([1, 2, 3])([]) \u003d []) and ((removeMembers([1, 2, 3])([1, 2, 3]) \u003d []) and (removeMembers([1, 4, 5])([1, 2, 3, 4]) \u003d [2, 3]))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT19:\t Test removes.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT19\n","class SequenceT20 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet zip:(seq of (int) * seq of (char) +\u003e seq of ((int * char))) \u003d (Sequence`Zip)[int, char], zip2:(seq of (int) +\u003e (seq of (char) +\u003e seq of ((int * char)))) \u003d (Sequence`Zip2)[int, char], unzip:(seq of ((int * char)) +\u003e (seq of (int) * seq of (char))) \u003d (Sequence`Unzip)[int, char] in return (((zip([], []) \u003d []) and ((zip([1, 2, 3], [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003d [mk_(1, \u0027a\u0027), mk_(2, \u0027b\u0027), mk_(3, \u0027c\u0027)]) and ((zip([1, 2], [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003d [mk_(1, \u0027a\u0027), mk_(2, \u0027b\u0027)]) and ((zip([1, 2, 3], [\u0027a\u0027, \u0027b\u0027]) \u003d [mk_(1, \u0027a\u0027), mk_(2, \u0027b\u0027)]) and ((zip2([])([]) \u003d []) and ((zip2([1, 2, 3])([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003d [mk_(1, \u0027a\u0027), mk_(2, \u0027b\u0027), mk_(3, \u0027c\u0027)]) and ((unzip([]) \u003d mk_([], [])) and (unzip([mk_(1, \u0027a\u0027), mk_(2, \u0027b\u0027), mk_(3, \u0027c\u0027)]) \u003d mk_([1, 2, 3], [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT20:\t Test zip related functions.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT20\n","class SequenceT21 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet span:((int +\u003e bool) +\u003e (seq of (int) +\u003e (seq of (int) * seq of (int)))) \u003d (Sequence`Span)[int], p1:(int -\u003e bool) \u003d (lambda [x:int] \u0026 ((x mod 2) \u003d 0)), p2:(int -\u003e bool) \u003d (lambda [x:int] \u0026 (x \u003c 10)) in return (((span(p1)([]) \u003d mk_([], [])) and ((span(p1)([2, 4, 6, 1, 3]) \u003d mk_([2, 4, 6], [1, 3])) and ((span(p2)([1, 2, 3, 4, 5]) \u003d mk_([1, 2, 3, 4, 5], [])) and (span(p2)([1, 2, 12, 13, 4, 15]) \u003d mk_([1, 2], [12, 13, 4, 15]))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT21:\t Test span.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT21\n","class SequenceT22 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet takeWhile:((int +\u003e bool) +\u003e (seq of (int) +\u003e seq of (int))) \u003d (Sequence`TakeWhile)[int], dropWhile:((int +\u003e bool) +\u003e (seq of (int) +\u003e seq of (int))) \u003d (Sequence`DropWhile)[int], p1:(int -\u003e bool) \u003d (lambda [x:int] \u0026 ((x mod 2) \u003d 0)) in return (((takeWhile(p1)([]) \u003d []) and ((takeWhile(p1)([2, 4, 6, 8, 1, 3, 5, 2, 4]) \u003d [2, 4, 6, 8]) and ((dropWhile(p1)([]) \u003d []) and (dropWhile(p1)([2, 4, 6, 8, 1, 2, 3, 4, 5]) \u003d [1, 2, 3, 4, 5])))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT22:\t Test TakeWhile and DropWhile.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT22\n","class SequenceT23 is subclass of [TestCase]\npublic  public plus: (int -\u003e (int -\u003e int))\n\tplus(a)(b) \u003d\u003d\n(a + b)\npublic  public product: (int -\u003e (int -\u003e int))\n\tproduct(a)(b) \u003d\u003d\n(a * b)\npublic  public append: (seq of (char) -\u003e (char -\u003e seq of (char)))\n\tappend(s)(e) \u003d\u003d\n(s ^ [e])\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet foldl:((int +\u003e (int +\u003e int)) +\u003e (int +\u003e (seq of (int) +\u003e int))) \u003d (Sequence`Foldl)[int, int], f2:((seq of (char) +\u003e (char +\u003e seq of (char))) +\u003e (seq of (char) +\u003e (seq of (char) +\u003e seq of (char)))) \u003d (Sequence`Foldl)[seq of (char), char] in return (((foldl(plus)(0)([1, 2, 3]) \u003d 6) and ((foldl(product)(1)([2, 3, 4]) \u003d 24) and (f2(append)([])(\"abc\") \u003d \"abc\"))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT23:\t Test Foldl.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT23\n","class SequenceT24 is subclass of [TestCase]\npublic  public plus: (int -\u003e (int -\u003e int))\n\tplus(a)(b) \u003d\u003d\n(a + b)\npublic  public product: (int -\u003e (int -\u003e int))\n\tproduct(a)(b) \u003d\u003d\n(a * b)\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet removeAt:(nat1 +\u003e (seq of (char) +\u003e seq of (char))) \u003d (Sequence`RemoveAt)[char], foldr:((int +\u003e (int +\u003e int)) +\u003e (int +\u003e (seq of (int) +\u003e int))) \u003d (Sequence`Foldr)[int, int], f3:((nat1 +\u003e (seq of (char) +\u003e seq of (char))) +\u003e (seq of (char) +\u003e (seq of (nat1) +\u003e seq of (char)))) \u003d (Sequence`Foldr)[nat1, seq of (char)] in return (((foldr(plus)(0)([1, 2, 3]) \u003d 6) and ((foldr(product)(1)([2, 3, 4]) \u003d 24) and (f3(removeAt)(\"12345\")([1, 3, 5]) \u003d \"24\"))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT24:\t Test Foldr.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT24\n","class SequenceT25 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet sq:Sequence \u003d new Sequence() in return ((Real`EQ(((sq.GetAverage))[real]([1.1, 2.2, 3.3]))(2.2) and Real`EQ(((sq.GetAverage))[real]([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))(5.5)))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SequenceT25:\t Test GetAverage\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SequenceT25\n","class Set\npublic static  public static asSequence[(T)]: (set of (@T) -\u003e seq of (@T))\n\tasSequence(aSet) \u003d\u003d\n(cases aSet :\n{} -\u003e [],\n{x} union xs -\u003e ([x] ^ (asSequence)[@T](xs))\n end)\n\tpost (hasSameElems)[@T](RESULT, aSet)\nprivate static  private static cardinality[(T)]: (set of (@T) +\u003e nat)\n\tcardinality(aSet) \u003d\u003d\n(card aSet)\npublic static  public static hasSameElems[(T)]: (seq of (@T) * set of (@T) -\u003e bool)\n\thasSameElems(aSeq, aSet) \u003d\u003d\n(((elems aSeq) \u003d aSet) and ((len aSeq) \u003d (card aSet)))\npublic static  public static Combinations[(T)]: (nat1 -\u003e (set of (@T) -\u003e set of (set of (@T))))\n\tCombinations(n)(aSet) \u003d\u003d\n{aElem | aElem in set (power aSet) \u0026 ((card aElem) \u003d n)}\npublic static  public static fmap[(T1, T2)]: ((@T1 -\u003e @T2) -\u003e (set of (@T1) -\u003e set of (@T2)))\n\tfmap(f)(aSet) \u003d\u003d\n{f(s) | s in set aSet}\npublic static  public static Sum[(T)]: (set of (@T) -\u003e @T)\n\tSum(aSet) \u003d\u003d\n(SumAux)[@T](aSet)(0)\n\tpre (is_(aSet, set of (int)) or (is_(aSet, set of (nat)) or (is_(aSet, set of (nat1)) or (is_(aSet, set of (real)) or is_(aSet, set of (rat))))))\nprivate static  private static SumAux[(T)]: (set of (@T) -\u003e (@T -\u003e @T))\n\tSumAux(aSet)(aSum) \u003d\u003d\n(cases aSet :\n({}) -\u003e aSum,\n{e} union s -\u003e (SumAux)[@T](s)((if (is_(aSum, real) and is_(e, real))\nthen (aSum + e)\nelse (undefined)))\n end)\n\tpre (pre_Sum)[@T](aSet)\nend Set\n","class SetT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new SetT01(), new SetT02(), new SetT03(), new SetT04()]\nend SetT\n","class SetT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((Set`hasSameElems)[int]((Set`asSequence)[int]({1, 2, 3, 4}), {1, 2, 3, 4}) and ((elems (Set`asSequence)[int]({1, 2, 3, 3, 4})) \u003d {1, 2, 3, 4})))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SetT01:\t Compare sequences and convert to sequence.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SetT01\n","class SetT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Set`Combinations)[int](2)({1, 2, 3}) \u003d {{1, 2}, {1, 3}, {2, 3}}) and (((Set`Combinations)[int](2)({1, 2, 3, 4}) \u003d {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}}) and (((Set`fmap)[set of (int), set of (set of (int))]((Set`Combinations)[int](2))({{1, 2, 3}, {1, 2, 3, 4}}) \u003d {{{1, 2}, {1, 3}, {2, 3}}, {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}}}) and (((Set`Combinations)[int](3)({1, 2, 3, 4}) \u003d {{1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}}) and ((Set`Combinations)[seq of (char)](2)({\"Sahara\", \"Sato\", \"Sakoh\", \"Yatsu\", \"Nishikawa\"}) \u003d {{\"Sahara\", \"Sato\"}, {\"Sahara\", \"Nishikawa\"}, {\"Sahara\", \"Yatsu\"}, {\"Sahara\", \"Sakoh\"}, {\"Sato\", \"Nishikawa\"}, {\"Sato\", \"Yatsu\"}, {\"Sato\", \"Sakoh\"}, {\"Nishikawa\", \"Yatsu\"}, {\"Nishikawa\", \"Sakoh\"}, {\"Yatsu\", \"Sakoh\"}}))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SetT02:\t Get combination.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SetT02\n","class SetT03 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Set`fmap)[int, int]((lambda [x:int] \u0026 (x mod 3)))({1, 2, 3, 4, 5}) \u003d {0, 1, 2}) and ((Set`fmap)[seq of (char), seq of (char)]((Sequence`take)[char](2))({\"Shin Sahara\", \"Hiroshi Sakoh\"}) \u003d {\"Sh\", \"Hi\"})))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SetT03:\t Test fmap.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SetT03\n","class SetT04 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn ((((Set`Sum)[int]({1, ... ,10}) \u003d 55) and (((Set`Sum)[int]({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) \u003d 55) and (((abs ((Set`Sum)[real]({0.1, 0.2, 0.3}) - 0.6)) \u003c\u003d 1.0E-5) and ((Set`Sum)[nat]({1, 2, 3, 3}) \u003d 6)))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"SetT04:\tTest sum of set elements.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend SetT04\n","class String is subclass of [Sequence]\npublic static  public static asInteger: (seq of (char) -\u003e int)\n\tasInteger(s) \u003d\u003d\nString`AsIntegerAux(s)(0)\nprivate static  private static AsIntegerAux: (seq of (char) -\u003e (int -\u003e int))\n\tAsIntegerAux(s)(sum) \u003d\u003d\n(if (s \u003d [])\nthen sum\nelse AsIntegerAux((tl s))(((10 * sum) + Character`asDigit((hd s)))))\nprivate static  private static length: (seq of (char) +\u003e nat)\n\tlength(s) \u003d\u003d\n(len s)\nprivate static  private static lengthNil: ([seq of (char)] +\u003e nat)\n\tlengthNil(s) \u003d\u003d\n(if (s \u003d nil)\nthen 0\nelse (len s))\npublic static  public static isSomeString: ((char -\u003e bool) -\u003e (seq of (char) -\u003e bool))\n\tisSomeString(f)(s) \u003d\u003d\n(forall i in set (inds s) \u0026 f(s(i)))\npublic static  public static isDigits: (seq of (char) -\u003e bool)\n\tisDigits(s) \u003d\u003d\nisSomeString(Character`isDigit)(s)\npublic static  public static isLetters: (seq of (char) -\u003e bool)\n\tisLetters(s) \u003d\u003d\nisSomeString(Character`isLetter)(s)\npublic static  public static isLetterOrDigits: (seq of (char) -\u003e bool)\n\tisLetterOrDigits(s) \u003d\u003d\nisSomeString(Character`isLetterOrDigit)(s)\npublic static  public static isSpaces: ([seq of (char)] -\u003e bool)\n\tisSpaces(s) \u003d\u003d\nisSomeString((lambda [c:char] \u0026 ((c \u003d \u0027 \u0027) or (c \u003d \u0027\t\u0027))))(s)\npublic static  public static LT: (seq of (char) * seq of (char) -\u003e bool)\n\tLT(s1, s2) \u003d\u003d\nString`LT2(s1)(s2)\npublic static  public static LT2: (seq of (char) -\u003e (seq of (char) -\u003e bool))\n\tLT2(s1)(s2) \u003d\u003d\n(cases mk_(s1, s2) :\nmk_([], []) -\u003e false,\nmk_([], -) -\u003e true,\nmk_(- ^ -, []) -\u003e false,\nmk_([head1] ^ tails1, [head2] ^ tails2) -\u003e (if Character`LT(head1, head2)\nthen true\nelseif Character`LT(head2, head1)\nthen false\nelse String`LT(tails1, tails2))\n end)\npublic static  public static LE: (seq of (char) * seq of (char) -\u003e bool)\n\tLE(s1, s2) \u003d\u003d\nString`LE2(s1)(s2)\npublic static  public static LE2: (seq of (char) -\u003e (seq of (char) -\u003e bool))\n\tLE2(s1)(s2) \u003d\u003d\n(String`LT2(s1)(s2) or (s1 \u003d s2))\npublic static  public static GT: (seq of (char) * seq of (char) -\u003e bool)\n\tGT(s1, s2) \u003d\u003d\nString`GT2(s1)(s2)\npublic static  public static GT2: (seq of (char) -\u003e (seq of (char) -\u003e bool))\n\tGT2(s1)(s2) \u003d\u003d\nString`LT(s2, s1)\npublic static  public static GE: (seq of (char) * seq of (char) -\u003e bool)\n\tGE(s1, s2) \u003d\u003d\nString`GE2(s1)(s2)\npublic static  public static GE2: (seq of (char) -\u003e (seq of (char) -\u003e bool))\n\tGE2(s1)(s2) \u003d\u003d\n(not String`LT2(s1)(s2))\npublic static  public static Index: (char -\u003e (seq of (char) -\u003e int))\n\tIndex(c)(aStr) \u003d\u003d\n(Sequence`Index)[char](c)(aStr)\npublic static  public static indexAll: (seq of (char) * char -\u003e set of (int))\n\tindexAll(aStr, c) \u003d\u003d\n(Sequence`IndexAll2)[char](c)(aStr)\npublic static  public static IndexAll2: (char -\u003e (seq of (char) -\u003e set of (int)))\n\tIndexAll2(c)(aStr) \u003d\u003d\n(Sequence`IndexAll2)[char](c)(aStr)\npublic static  public static isInclude: (seq of (char) -\u003e (seq of (char) -\u003e bool))\n\tisInclude(aStr)(aTargetStr) \u003d\u003d\nlet indexSet:set of (int) \u003d indexAll(aStr, aTargetStr(1)) in (exists i in set indexSet \u0026 (SubStr(i)((len aTargetStr))(aStr) \u003d aTargetStr))\n\tpre (aTargetStr \u003c\u003e \"\")\npublic static  public static subStr: (seq1 of (char) * nat * nat -\u003e seq of (char))\n\tsubStr(aStr, fromPos, length) \u003d\u003d\n(aStr(fromPos, ... ,((fromPos + length) - 1)))\npublic static  public static SubStr: (nat -\u003e (nat -\u003e (seq1 of (char) -\u003e seq of (char))))\n\tSubStr(fromPos)(length)(aStr) \u003d\u003d\n(aStr(fromPos, ... ,((fromPos + length) - 1)))\npublic static  public static GetToken: (seq of (char) * set of (char) -\u003e seq of (char))\n\tGetToken(s, aDelimitterSet) \u003d\u003d\n(TakeWhile)[char]((lambda [c:char] \u0026 (c not in set aDelimitterSet)))(s)\npublic static  public static DropToken: (seq of (char) * set of (char) -\u003e seq of (char))\n\tDropToken(s, aDelimitterSet) \u003d\u003d\n(DropWhile)[char]((lambda [c:char] \u0026 (c not in set aDelimitterSet)))(s)\npublic static  public static getLines: (seq of (char) -\u003e seq of (seq of (char)))\n\tgetLines(s) \u003d\u003d\ngetLinesAux(s)([])\npublic static  public static getLinesAux: (seq of (char) -\u003e (seq of (seq of (char)) -\u003e seq of (seq of (char))))\n\tgetLinesAux(s)(line) \u003d\u003d\n(if (s \u003d [])\nthen line\nelse let wDelimitterSet:set of (char) \u003d {\u0027\n\u0027}, wHeadLine:seq of (char) \u003d GetToken(s, wDelimitterSet), wTailStringCandidate:seq of (char) \u003d DropToken(s, wDelimitterSet), wTailString:seq of (char) \u003d (if ((wTailStringCandidate \u003c\u003e []) and ((hd wTailStringCandidate) \u003d \u0027\n\u0027))\nthen (tl wTailStringCandidate)\nelse wTailStringCandidate) in getLinesAux(wTailString)((line ^ [wHeadLine])))\npublic static  index(seq of (char), char) (seq of (char) * char \u003d\u003d\u003e int)\n\tindex(seq of (char), char)(aStr, c) \u003d\u003d\n(\n\nfor i \u003d 1 to (len aStr)\nif (aStr(i) \u003d c)\nthen\nreturn (i);\nreturn (0)\n)\npublic static  subStrFill(seq of (char), nat, nat, char) (seq of (char) * nat * nat * char \u003d\u003d\u003e seq of (char))\n\tsubStrFill(seq of (char), nat, nat, char)(aStr, fromPos, length, fillChar) \u003d\u003d\nlet lastPos:int \u003d ((fromPos + length) - 1) in (\naResult:seq of (char) :\u003d \"\"\n\nfor i \u003d fromPos to lastPos\n(\n\nif (i \u003c\u003d (len aStr))\nthen\naResult :\u003d (aResult ^ [aStr(i)])else\naResult :\u003d (aResult ^ [fillChar])\n);\nreturn (aResult)\n)\n\tpre ((fromPos \u003e 0) and (length \u003e\u003d 0))\nend String\n","class StringT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new StringT01(), new StringT02(), new StringT03(), new StringT04(), new StringT05(), new StringT06(), new StringT07(), new StringT08(), new StringT09(), new StringT11(), new StringT12(), new StringT13(), new StringT14()]\nend StringT\n","class StringT01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:Character \u003d new Character() in return ((((c.isDigit)(\u00270\u0027) \u003d true) and (((c.isDigit)(\u00271\u0027) \u003d true) and (((c.isDigit)(\u00272\u0027) \u003d true) and (((c.isDigit)(\u00273\u0027) \u003d true) and (((c.isDigit)(\u00274\u0027) \u003d true) and (((c.isDigit)(\u00275\u0027) \u003d true) and (((c.isDigit)(\u00276\u0027) \u003d true) and (((c.isDigit)(\u00277\u0027) \u003d true) and (((c.isDigit)(\u00278\u0027) \u003d true) and (((c.isDigit)(\u00279\u0027) \u003d true) and (((c.isDigit)(\u0027a\u0027) \u003d false) and (((c.asDigit)(\u00270\u0027) \u003d 0) and (((c.asDigit)(\u00271\u0027) \u003d 1) and (((c.asDigit)(\u00272\u0027) \u003d 2) and (((c.asDigit)(\u00273\u0027) \u003d 3) and (((c.asDigit)(\u00274\u0027) \u003d 4) and (((c.asDigit)(\u00275\u0027) \u003d 5) and (((c.asDigit)(\u00276\u0027) \u003d 6) and (((c.asDigit)(\u00277\u0027) \u003d 7) and (((c.asDigit)(\u00278\u0027) \u003d 8) and (((c.asDigit)(\u00279\u0027) \u003d 9) and ((c.asDigit)(\u0027a\u0027) \u003d false)))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT01:\tConvert digit to integer.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT01\n","class StringT02 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet c:Character \u003d new Character() in return ((((c.asDictOrder)(\u00270\u0027) \u003d 1) and (((c.asDictOrder)(\u00279\u0027) \u003d 10) and (((c.asDictOrder)(\u0027a\u0027) \u003d 11) and (((c.asDictOrder)(\u0027A\u0027) \u003d 12) and (((c.asDictOrder)(\u0027z\u0027) \u003d 61) and (((c.asDictOrder)(\u0027Z\u0027) \u003d 62) and (((c.asDictOrder)(\u0027\n\u0027) \u003d 999999) and ((c.asDictOrder)(\u0027\t\u0027) \u003d 999999)))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT02:\tReturn dictionary order of character.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT02\n","class StringT03 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet s:String \u003d new String(), LT:(seq of (char) -\u003e (seq of (char) -\u003e bool)) \u003d String`LT2, LE:(seq of (char) -\u003e (seq of (char) -\u003e bool)) \u003d String`LE2, GT:(seq of (char) -\u003e (seq of (char) -\u003e bool)) \u003d String`GT2, GE:(seq of (char) -\u003e (seq of (char) -\u003e bool)) \u003d String`GE2 in return ((((s.LT)(\"123\", \"123\") \u003d false) and ((LT(\"123\")(\"123\") \u003d false) and (((s.GT)(\"123\", \"123\") \u003d false) and ((GT(\"123\")(\"123\") \u003d false) and (((s.LT)(\"\", \"\") \u003d false) and (((s.GT)(\"\", \"\") \u003d false) and (((s.LT)(\"\", \"123\") \u003d true) and (((s.GT)(\"\", \"123\") \u003d false) and (((s.LT)(\"123\", \"\") \u003d false) and ((s.GT)(\"123\", \"\") and ((s.LT)(\"123\", \"1234\") and (((s.GT)(\"123\", \"1234\") \u003d false) and (((s.LT)(\"1234\", \"123\") \u003d false) and ((s.GT)(\"1234\", \"123\") and ((s.LT)(\"123\", \"223\") and (((s.GT)(\"123\", \"223\") \u003d false) and ((s.LE)(\"123\", \"123\") and (LE(\"123\")(\"123\") and ((s.GE)(\"123\", \"123\") and ((s.LE)(\"123\", \"1234\") and (LE(\"123\")(\"1234\") and (((s.GE)(\"123\", \"1234\") \u003d false) and ((GE(\"123\")(\"1234\") \u003d false) and (((s.LE)(\"1234\", \"123\") \u003d false) and ((not LE(\"1234\")(\"123\")) and ((s.GE)(\"1234\", \"123\") and ((s.LE)(\"\", \"\") and (LE(\"\")(\"\") and (((Sequence`fmap)[seq of (char), bool](LT(\"123\"))([\"123\", \"1234\", \"\", \"223\"]) \u003d [false, true, false, true]) and (((Sequence`fmap)[seq of (char), bool](LE(\"123\"))([\"1234\", \"\"]) \u003d [true, false]) and (((Sequence`fmap)[seq of (char), bool](GT(\"123\"))([\"123\", \"\", \"23\"]) \u003d [false, true, false]) and ((Sequence`fmap)[seq of (char), bool](GE(\"123\"))([\"1234\", \"\"]) \u003d [false, true])))))))))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT03:\tCompare magnitude of string.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT03\n","class StringT04 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet s1234:seq1 of (char) \u003d \"1234\", s:String \u003d new String() in return (((s1234 \u003d \"1234\") and (((s.isSpaces)(\"\") \u003d true) and (((s.isSpaces)(\"  \") \u003d true) and (((s.isSpaces)(\" \t  \") \u003d true) and ((s.isSpaces)([]) \u003d true))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT04:\tCompare 2 strings is equal.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT04\n","class StringT05 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet LT:(char * char -\u003e bool) \u003d Character`LT, GT:(char * char -\u003e bool) \u003d Character`GT, LE:(char * char -\u003e bool) \u003d Character`LE, GE:(char * char -\u003e bool) \u003d Character`GE in return (((LT(\u0027a\u0027, \u0027a\u0027) \u003d false) and ((Character`LT2(\u0027a\u0027)(\u0027a\u0027) \u003d false) and ((GT(\u0027a\u0027, \u0027a\u0027) \u003d false) and ((Character`GT2(\u0027a\u0027)(\u0027a\u0027) \u003d false) and (LT(\u00271\u0027, \u00272\u0027) and (Character`LT2(\u00271\u0027)(\u00272\u0027) and (GT(\u00271\u0027, \u00270\u0027) and (Character`GT2(\u00271\u0027)(\u00270\u0027) and (LT(\u00279\u0027, \u0027a\u0027) and (Character`LT2(\u00279\u0027)(\u0027a\u0027) and (GT(\u0027\n\u0027, \u00270\u0027) and (Character`GT2(\u0027\n\u0027)(\u00270\u0027) and ((LE(\u0027a\u0027, \u00270\u0027) \u003d false) and ((Character`LE2(\u0027a\u0027)(\u00270\u0027) \u003d false) and (GE(\u0027a\u0027, \u00270\u0027) and (Character`GE2(\u0027a\u0027)(\u00270\u0027) and ((Sequence`fmap)[char, bool](Character`LT2(\u00275\u0027))(\"456\") \u003d [false, false, true]))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT05:\tCompare magnitude of character.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT05\n","class StringT06 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet s:String \u003d new String(), substr:(nat -\u003e (nat -\u003e (seq1 of (char) -\u003e seq of (char)))) \u003d String`SubStr in return ((((s.subStr)(\"Shin Sahara\", 6, 6) \u003d \"Sahara\") and (((s.subStr)(\"Shin Sahara\", 6, 8) \u003d \"Sahara\") and (((s.subStr)(\"Shin Sahara\", 6, 3) \u003d \"Sah\") and (((s.subStr)(\"Shin Sahara\", 1, 0) \u003d \"\") and (((s.subStrFill)(\"sahara\", 1, 3, \u0027*\u0027) \u003d \"sah\") and (((s.subStrFill)(\"sahara\", 1, 6, \u0027*\u0027) \u003d \"sahara\") and (((s.subStrFill)(\"sahara\", 1, 10, \u0027*\u0027) \u003d \"sahara****\") and (((s.subStrFill)(\"sahara\", 3, 4, \u0027*\u0027) \u003d \"hara\") and (((s.subStrFill)(\"sahara\", 3, 10, \u0027*\u0027) \u003d \"hara******\") and (((s.subStrFill)(\"sahara\", 1, 0, \u0027*\u0027) \u003d \"\") and (((s.subStrFill)(\"\", 1, 6, \u0027*\u0027) \u003d \"******\") and ((String`SubStr(6)(6)(\"Shin Sahara\") \u003d \"Sahara\") and ((substr(6)(8)(\"Shin Sahara\") \u003d \"Sahara\") and ((Sequence`fmap)[seq of (char), seq of (char)](substr(6)(8))([\"1234567890\", \"12345671\"]) \u003d [\"67890\", \"671\"])))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT06:\tGet substring.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT06\n","class StringT07 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((String`isDigits(\"1234567890\") \u003d true) and ((String`asInteger(\"1234567890\") \u003d 1234567890) and (String`asInteger(\"\") \u003d 0))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT07:\tHandling digit strings.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT07\n","class StringT08 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (((String`index(\"1234567890\", \u00271\u0027) \u003d 1) and ((String`index(\"1234567890\", \u00270\u0027) \u003d 10) and ((String`index(\"1234567890\", \u0027a\u0027) \u003d 0) and ((String`indexAll(\"1234567890\", \u00271\u0027) \u003d {1}) and ((String`indexAll(\"1234567890\", \u00270\u0027) \u003d {10}) and ((String`indexAll(\"1234567890\", \u0027a\u0027) \u003d {}) and ((String`indexAll(\"1231567190\", \u00271\u0027) \u003d {1, 4, 8}) and ((String`indexAll(\"1231567191\", \u00271\u0027) \u003d {1, 4, 8, 10}) and ((String`Index(\u00271\u0027)(\"1234567890\") \u003d 1) and ((String`Index(\u00270\u0027)(\"1234567890\") \u003d 10) and ((String`Index(\u0027a\u0027)(\"1234567890\") \u003d 0) and ((String`IndexAll2(\u00271\u0027)(\"1234567890\") \u003d {1}) and ((String`IndexAll2(\u00270\u0027)(\"1234567890\") \u003d {10}) and ((String`IndexAll2(\u0027a\u0027)(\"1234567890\") \u003d {}) and ((String`IndexAll2(\u00271\u0027)(\"1231567190\") \u003d {1, 4, 8}) and ((String`IndexAll2(\u00271\u0027)(\"1231567191\") \u003d {1, 4, 8, 10}) and (((Sequence`fmap)[seq of (char), int](String`Index(\u00271\u0027))([\"1234567890\", \"2345671\"]) \u003d [1, 7]) and ((Sequence`fmap)[seq of (char), set of (int)](String`IndexAll2(\u00271\u0027))([\"1231567190\", \"1231567191\"]) \u003d [{1, 4, 8}, {1, 4, 8, 10}])))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT08:\tGet first position of a character in a string.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT08\n","class StringT09 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet isInclude:(seq of (char) -\u003e (seq of (char) -\u003e bool)) \u003d String`isInclude in return (((String`isInclude(\"1234567890\")(\"abc\") \u003d false) and ((isInclude(\"Shin\")(\"Shin\") \u003d true) and ((isInclude(\"Shin\")(\"S\") \u003d true) and ((isInclude(\"Shin\")(\"h\") \u003d true) and (isInclude(\"Shin\")(\"n\") \u003d true))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT09:\tIs a string the substring of another string.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT09\n","class StringT10 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\ntixe {[in \u0027StringT10\u0027 (StringT.vdmpp) at line 281:15\u003cRuntimeError\u003eADefPatternBind[]ADefPatternBindreturn (true)?]} in return (String`isInclude(\"Shin Sahara\")(\"\"))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT10:\tIs a string the substring of another string. In case of pre-condition error\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT10\n","class StringT11 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (let 区切り文字:set of (char) \u003d (elems \"\t\n \") in ((String`GetToken(\"sahara\tshin\", 区切り文字) \u003d \"sahara\") and ((String`GetToken(\"sahara\tshin SCSK\", 区切り文字) \u003d \"sahara\") and ((String`DropToken(\"sahara\tshin\", 区切り文字) \u003d \"\tshin\") and ((String`DropToken(\"sahara\tshin SCSK\", 区切り文字) \u003d \"\tshin SCSK\") and (String`DropToken(\"sahara\tshin SCSK\n\", 区切り文字) \u003d \"\tshin SCSK\n\"))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT11:\t指定した文字列の先頭tokenを得る。\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT11\n","class StringT12 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (let 対象文字列1:seq1 of (char) \u003d \"private 次状態を得る : () \u003d\u003d\u003e 「状態」\n次状態を得る(aガード, aガード引数, aイベント, aイベント引数,  a処理時間) \u003d\u003d (\ncases mk_(aガード, 現在状態, aイベント)  :\n\tmk_(-,-,(エラー検知)) -\u003e return エラー中,\n\", ss1:seq of (seq of (char)) \u003d String`getLines(対象文字列1), 対象文字列2:seq1 of (char) \u003d \"佐原\n伸\", ss2:seq of (seq of (char)) \u003d String`getLines(対象文字列2) in ((ss1(1) \u003d \"private 次状態を得る : () \u003d\u003d\u003e 「状態」\") and ((ss1(2) \u003d \"次状態を得る(aガード, aガード引数, aイベント, aイベント引数,  a処理時間) \u003d\u003d (\") and ((ss1(3) \u003d \"cases mk_(aガード, 現在状態, aイベント)  :\") and ((ss1(4) \u003d \"\tmk_(-,-,(エラー検知)) -\u003e return エラー中,\") and ((ss2(1) \u003d \"佐原\") and (ss2(2) \u003d \"伸\")))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT12:\t文字列を行に分解する。\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT12\n","class StringT13 is subclass of [TestCase]\npublic  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nreturn (let w英字列:seq1 of (char) \u003d \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\", w数字列:seq1 of (char) \u003d \"0123456789\", w英数字列:seq1 of (char) \u003d (w英字列 ^ w数字列) in (String`isLetters(w英字列) and ((not String`isLetters((\" \" ^ w英字列))) and (String`isDigits(w数字列) and ((not String`isDigits((\" \" ^ w数字列))) and ((not String`isDigits((\"a\" ^ w数字列))) and (String`isLetterOrDigits(w英数字列) and (not String`isLetterOrDigits((w英数字列 ^ \" \"))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT13:\t英数字かの判定が正しいかを検査する。\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT13\n","class StringT14 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet isSomeString:((char -\u003e bool) -\u003e (seq of (char) -\u003e bool)) \u003d String`isSomeString in return ((isSomeString(Character`isLetterOrDigit)(\"007isTheMmurder\") and ((not isSomeString(Character`isLetterOrDigit)(\"007 is the mmurder\")) and (isSomeString(Character`isCapitalLetter)(\"SAHARA\") and ((not isSomeString(Character`isCapitalLetter)(\"Sahara\")) and (isSomeString(Character`isLowercaseLetter)(\"sahara\") and (not isSomeString(Character`isLowercaseLetter)(\"Sahara\"))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"StringT11:\tIs a some kind of string?\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend StringT14\n","class Term\nprivate static  Rcsid:seq1 of (char) \u003d \"$Id: Term.vpp,v 1.1 2005/10/31 02:15:42 vdmtools Exp $\"\nprivate  startTime:[Time] :\u003d (undefined)\nprivate  endTime:[Time] :\u003d (undefined)\npublic static  public static isInThePeriod: (Time * Term -\u003e bool)\n\tisInThePeriod(aTime, aPeriod) \u003d\u003d\n((((aPeriod.getStartTime)() \u003d nil) or ((aPeriod.getStartTime)().LE)(aTime)) and (((aPeriod.getEndTime)() \u003d nil) or ((aPeriod.getEndTime)().GE)(aTime)))\npublic  public EQ: (Term -\u003e bool)\n\tEQ(aPeriod) \u003d\u003d\n(((self.getStartTime)().EQ)((aPeriod.getStartTime)()) and ((self.getEndTime)().EQ)((aPeriod.getEndTime)()))\npublic  Term([Time], [Time]) ([Time] * [Time] \u003d\u003d\u003e Term)\n\tTerm([Time], [Time])(astartTime, aendTime) \u003d\u003d\n(\n\nstartTime :\u003d astartTime;\nendTime :\u003d aendTime;\nreturn (self)\n)\npublic  getStartTime() (() \u003d\u003d\u003e [Time])\n\tgetStartTime()() \u003d\u003d\nreturn (startTime)\npublic  getEndTime() (() \u003d\u003d\u003e [Time])\n\tgetEndTime()() \u003d\u003d\nreturn (endTime)\nend Term\n","class TermT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new TermT01()]\nend TermT\n","class TermT01 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), astartTime:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 20), aendTime:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 22), t1:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 19), t2:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 20), t3:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 21), t4:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 22), t5:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 23), t6:Time \u003d new Time(cal, 2003, 7, 29, 14, 29, 30, 20), t7:Time \u003d new Time(cal, 2003, 7, 31, 14, 29, 30, 20), t8:Time \u003d new Time(cal, 2003, 7, 29, 14, 29, 29, 20), t9:Time \u003d new Time(cal, 2003, 7, 29, 14, 29, 31, 20), term1:Term \u003d new Term(astartTime, aendTime) in return (((not (term1.isInThePeriod)(t1, term1)) and ((term1.isInThePeriod)(t2, term1) and ((term1.isInThePeriod)(t3, term1) and ((term1.isInThePeriod)(t4, term1) and ((not (term1.isInThePeriod)(t5, term1)) and ((not (term1.isInThePeriod)(t6, term1)) and ((not (term1.isInThePeriod)(t7, term1)) and ((not (term1.isInThePeriod)(t8, term1)) and (not (term1.isInThePeriod)(t9, term1)))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TermT01:\tTest of term constructor and isInThePeriod()\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TermT01\n","class TestCase\npublic  TestName:seq of (char) :\u003d \"** anonymous regression test **\"\npublic  TestACase() (() \u003d\u003d\u003e bool)\n\tTestACase()() \u003d\u003d\n(\nr:bool :\u003d (undefined)\n\nsetUp();\nr :\u003d test();\ntearDown();\nreturn (r)\n)\npublic  getTestName() (() \u003d\u003d\u003e seq of (char))\n\tgetTestName()() \u003d\u003d\nreturn (TestName)\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nis subclass responsibility\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nreturn\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TestCase\n","class TestDriver\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\nis subclass responsibility\npublic  public isOK: (TestCase -\u003e bool)\n\tisOK(t) \u003d\u003d\n(if (t.TestACase)()\nthen (new TestLogger().Succeeded)(t)\nelse (new TestLogger().Failed)(t))\npublic  run() (() \u003d\u003d\u003e bool)\n\trun()() \u003d\u003d\nlet Message:seq1 of (char) \u003d \"Test result of a testcase seaquence.\", TestcaseSeq:seq of (TestCase) \u003d tests(), aResult:seq of (bool) \u003d [isOK(TestcaseSeq(i)) | i in set (inds TestcaseSeq)] in if (forall i in set (inds aResult) \u0026 aResult(i))\nthen\nreturn ((new TestLogger().succeededInAllTestcases)(Message))else\nreturn ((new TestLogger().notSucceededInAllTestcases)(Message))\nend TestDriver\n","class TestLogger\nprivate static  hisotoryFileName:seq1 of (char) \u003d \"VDMTESTLOG.TXT\"\npublic  public Succeeded: (TestCase -\u003e bool)\n\tSucceeded(t) \u003d\u003d\nlet Message:seq1 of (char) \u003d ((t.getTestName)() ^ \"\t OK.\n\"), -:bool \u003d (new IO().fecho)(hisotoryFileName, Message, \u003cappend\u003e), -:bool \u003d (new IO().echo)(Message) in true\npublic  public Failed: (TestCase -\u003e bool)\n\tFailed(t) \u003d\u003d\nlet Message:seq1 of (char) \u003d ((t.getTestName)() ^ \"\t NG.\n\"), -:bool \u003d (new IO().fecho)(hisotoryFileName, Message, \u003cappend\u003e), -:bool \u003d (new IO().echo)(Message) in false\npublic  public succeededInAllTestcases: (seq of (char) -\u003e bool)\n\tsucceededInAllTestcases(m) \u003d\u003d\nlet Message:seq1 of (char) \u003d (m ^ \"\t OK!!\n\"), -:bool \u003d (new IO().fecho)(hisotoryFileName, Message, \u003cappend\u003e), -:bool \u003d (new IO().echo)(Message) in true\npublic  public notSucceededInAllTestcases: (seq of (char) -\u003e bool)\n\tnotSucceededInAllTestcases(m) \u003d\u003d\nlet Message:seq1 of (char) \u003d (m ^ \"\t NG!!\n\"), -:bool \u003d (new IO().fecho)(hisotoryFileName, Message, \u003cappend\u003e), -:bool \u003d (new IO().echo)(Message) in false\nend TestLogger\n","class Time is subclass of [CalendarDefinition]\npublic static  hoursPerDay:nat1 \u003d 24\npublic static  minutesPerHour:nat1 \u003d 60\npublic static  secondsPerMinute:nat1 \u003d 60\npublic static  ミリ:nat1 \u003d 1000\npublic static  milliSecondsPerDay:nat1 \u003d (((hoursPerDay * minutesPerHour) * secondsPerMinute) * ミリ)\npublic static  milliSecondsPerHour:nat1 \u003d ((minutesPerHour * secondsPerMinute) * ミリ)\nprivate static  io:IO \u003d new IO()\npublic static  TimeInMilliSeconds \u003d TimeInMilliSeconds\nprivate  sDate:Date :\u003d (undefined)\nprivate  sTime:TimeInMilliSeconds :\u003d (undefined)\npublic  Time(Calendar, int, int, int, nat, nat, nat, nat) (Calendar * int * int * int * nat * nat * nat * nat \u003d\u003d\u003e Time)\n\tTime(Calendar, int, int, int, nat, nat, nat, nat)(cal, year, month, 日, 時, aMinute, aSecond, milliSecond) \u003d\u003d\n(\n\nsDate :\u003d (cal.getDateFrom_yyyy_mm_dd)(year, month, 日);\nsTime :\u003d (self.IntProduct2TimeMillieSeconds)(時, aMinute, aSecond, milliSecond);\nreturn (self)\n)\npublic  Time(Calendar, int, int, int) (Calendar * int * int * int \u003d\u003d\u003e Time)\n\tTime(Calendar, int, int, int)(cal, year, month, 日) \u003d\u003d\n(\n\nsDate :\u003d (cal.getDateFrom_yyyy_mm_dd)(year, month, 日);\nsTime :\u003d (self.IntProduct2TimeMillieSeconds)(0, 0, 0, 0);\nreturn (self)\n)\npublic  Time(Date) (Date \u003d\u003d\u003e Time)\n\tTime(Date)(aDate) \u003d\u003d\n(\n\nsDate :\u003d aDate;\nsTime :\u003d (self.IntProduct2TimeMillieSeconds)(0, 0, 0, 0);\nreturn (self)\n)\npublic  Time(Calendar) (Calendar \u003d\u003d\u003e Time)\n\tTime(Calendar)(cal) \u003d\u003d\n(\n\nlet currentDateTime:[Time] \u003d readCurrentDateTime((homedir ^ \"/temp/Today.txt\"), (homedir ^ \"/temp/Now.txt\"), cal) in (\n\nsDate :\u003d (currentDateTime.getDate)();\nsTime :\u003d (currentDateTime.getTime)()\n);\nreturn (self)\n)\npublic  Time(seq of (char), seq of (char), Calendar) (seq of (char) * seq of (char) * Calendar \u003d\u003d\u003e Time)\n\tTime(seq of (char), seq of (char), Calendar)(dateFileName, 時間fname, cal) \u003d\u003d\n(\n\nlet currentDateTime:[Time] \u003d readCurrentDateTime(dateFileName, 時間fname, cal) in (\n\nsDate :\u003d (currentDateTime.getDate)();\nsTime :\u003d (currentDateTime.getTime)()\n);\nreturn (self)\n)\npublic  readCurrentDateTime(seq of (char), seq of (char), Calendar) (seq of (char) * seq of (char) * Calendar \u003d\u003d\u003e [Time])\n\treadCurrentDateTime(seq of (char), seq of (char), Calendar)(dateFileName, 時間fname, cal) \u003d\u003d\nlet mk_(結果, mk_(h, m, s, ms)):(bool * [(int * int * int * int)]) \u003d ((io.freadval))[(int * int * int * int)](時間fname) in if 結果\nthen\nlet d:Date \u003d (cal.readFromFiletoday)(dateFileName) in return (new Time(cal, (d.Year)(), (d.Month)(), (d.day)(), h, m, s, ms))else\nlet -:bool \u003d (io.echo)(\"Can\u0027t read Current Date-Time data file.\") in return (nil)\npublic  getDate() (() \u003d\u003d\u003e Date)\n\tgetDate()() \u003d\u003d\nreturn (sDate)\npublic  setDate(Date) (Date \u003d\u003d\u003e ())\n\tsetDate(Date)(aDate) \u003d\u003d\nsDate :\u003d aDate\npublic  getTime() (() \u003d\u003d\u003e TimeInMilliSeconds)\n\tgetTime()() \u003d\u003d\nreturn (sTime)\npublic  setTime(TimeInMilliSeconds) (TimeInMilliSeconds \u003d\u003d\u003e ())\n\tsetTime(TimeInMilliSeconds)(aTime) \u003d\u003d\nsTime :\u003d aTime\npublic  hour() (() \u003d\u003d\u003e nat)\n\thour()() \u003d\u003d\nlet mk_(hour, -, -, -):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (hour)\npublic  setTimeFromNat(nat) (nat \u003d\u003d\u003e ())\n\tsetTimeFromNat(nat)(aTime) \u003d\u003d\nlet mk_(-, aMinute, aSecond, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in self.setTime(IntProduct2TimeMillieSeconds(aTime, aMinute, aSecond, milliSecond))\npublic  minute() (() \u003d\u003d\u003e nat)\n\tminute()() \u003d\u003d\nlet mk_(-, aMinute, -, -):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (aMinute)\npublic  setMinuteFromNat(nat) (nat \u003d\u003d\u003e ())\n\tsetMinuteFromNat(nat)(minute) \u003d\u003d\nlet mk_(hour, -, aSecond, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in self.setTime(IntProduct2TimeMillieSeconds(hour, minute, aSecond, milliSecond))\npublic  second() (() \u003d\u003d\u003e nat)\n\tsecond()() \u003d\u003d\nlet mk_(-, -, aSecond, -):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (aSecond)\npublic  setSecond(nat) (nat \u003d\u003d\u003e ())\n\tsetSecond(nat)(aSecond) \u003d\u003d\nlet mk_(hour, aMinute, -, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in self.setTime(IntProduct2TimeMillieSeconds(hour, aMinute, aSecond, milliSecond))\npublic  milliSecond() (() \u003d\u003d\u003e nat)\n\tmilliSecond()() \u003d\u003d\nlet mk_(-, -, -, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (milliSecond)\npublic  setMilliSecond(nat) (nat \u003d\u003d\u003e ())\n\tsetMilliSecond(nat)(aMilliSecond) \u003d\u003d\nlet mk_(hour, aMinute, aSecond, -):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in self.setTime(IntProduct2TimeMillieSeconds(hour, aMinute, aSecond, aMilliSecond))\npublic  public calendar: (() -\u003e Calendar)\n\tcalendar() \u003d\u003d\n(getDate().calendar)()\npublic  public Year: (() -\u003e int)\n\tYear() \u003d\u003d\n(((self.getDate)().calendar)().Year)((self.getDate)())\npublic  public Month: (() -\u003e int)\n\tMonth() \u003d\u003d\n(((self.getDate)().calendar)().Month)((self.getDate)())\npublic  public day: (() -\u003e int)\n\tday() \u003d\u003d\n(((self.getDate)().calendar)().day)((self.getDate)())\npublic  public getTimeAsNat: (() -\u003e nat)\n\tgetTimeAsNat() \u003d\u003d\n(self.getTime)()\npublic  public LT: (Time -\u003e bool)\n\tLT(aTime) \u003d\u003d\nlet date1:int \u003d (floor ((self.getDate)().getModifiedJulianDate)()), date2:int \u003d (floor ((aTime.getDate)().getModifiedJulianDate)()) in (cases true :\n((date1 \u003c date2)) -\u003e true,\n((date1 \u003d date2)) -\u003e (if ((self.getTimeAsNat)() \u003c (aTime.getTimeAsNat)())\nthen true\nelse false)\nothers false\n end)\npublic  public GT: (Time -\u003e bool)\n\tGT(aTime) \u003d\u003d\n(not ((self.LT)(aTime) or (self.EQ)(aTime)))\npublic  public LE: (Time -\u003e bool)\n\tLE(aTime) \u003d\u003d\n(not (self.GT)(aTime))\npublic  public GE: (Time -\u003e bool)\n\tGE(aTime) \u003d\u003d\n(not (self.LT)(aTime))\npublic  public EQ: (Time -\u003e bool)\n\tEQ(aTime) \u003d\u003d\n(((self.getDate)().EQ)((aTime.getDate)()) and ((self.getTimeAsNat)() \u003d (aTime.getTimeAsNat)()))\npublic  public NE: (Time -\u003e bool)\n\tNE(aTime) \u003d\u003d\n(not (self.EQ)(aTime))\npublic  public IntProduct2TimeMillieSeconds: (int * int * int * int -\u003e int)\n\tIntProduct2TimeMillieSeconds(hour, aMinute, aSecond, milliSecond) \u003d\u003d\n((((((hour * minutesPerHour) + aMinute) * secondsPerMinute) + aSecond) * ミリ) + milliSecond)\npublic  public Time2IntProduct: (TimeInMilliSeconds -\u003e (nat * nat * nat * nat))\n\tTime2IntProduct(aTime) \u003d\u003d\nlet hms:int \u003d (aTime div ミリ), milliSecond:int \u003d (aTime mod ミリ), hm:int \u003d (hms div secondsPerMinute), aSecond:int \u003d (hms mod secondsPerMinute), hour:int \u003d (hm div minutesPerHour), aMinute:int \u003d (hm mod minutesPerHour) in mk_(hour, aMinute, aSecond, milliSecond)\npublic  asString() (() \u003d\u003d\u003e seq of (char))\n\tasString()() \u003d\u003d\nlet mk_(hour, aMinute, aSecond, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (((((((self.getDate)().asString)() ^ Integer`asString(hour)) ^ Integer`asString(aMinute)) ^ Integer`asString(aSecond)) ^ Integer`asStringZ(\"009\")(milliSecond)))\npublic  print() (() \u003d\u003d\u003e seq of (char))\n\tprint()() \u003d\u003d\nlet mk_(hour, aMinute, aSecond, milliSecond):(nat * nat * nat * nat) \u003d (self.Time2IntProduct)((self.getTime)()) in return (((((((((((self.getDate)().print)() ^ Integer`asString(hour)) ^ \"Hour, \") ^ Integer`asString(aMinute)) ^ \"Minute, \") ^ Integer`asString(aSecond)) ^ \"Second, \") ^ Integer`asStringZ(\"009\")(milliSecond)) ^ \"MilliSecond\"))\npublic  plusmilliSecond(int) (int \u003d\u003d\u003e Time)\n\tplusmilliSecond(int)(aMilliSecond) \u003d\u003d\nlet time:int \u003d ((self.getTime)() + aMilliSecond), CarriedNumOfDays:int \u003d (if (time \u003e\u003d 0)\nthen (time div milliSecondsPerDay)\nelse ((time div milliSecondsPerDay) - 1)), newTime:int \u003d (time mod milliSecondsPerDay) in (\naTime:Time :\u003d new Time((self.calendar)(), (self.Year)(), (self.Month)(), (self.day)())\n\naTime.setTime(newTime);\naTime.setDate(((aTime.getDate)().plus)(CarriedNumOfDays));\nreturn (aTime)\n)\npublic  plussecond(int) (int \u003d\u003d\u003e Time)\n\tplussecond(int)(aSecond) \u003d\u003d\nself.plusmilliSecond((aSecond * ミリ))\npublic  plusminute(int) (int \u003d\u003d\u003e Time)\n\tplusminute(int)(minute) \u003d\u003d\nself.plusmilliSecond(((minute * secondsPerMinute) * ミリ))\npublic  plushour(int) (int \u003d\u003d\u003e Time)\n\tplushour(int)(hour) \u003d\u003d\nself.plusmilliSecond((((hour * minutesPerHour) * secondsPerMinute) * ミリ))\npublic  plus(int, int, int, int) (int * int * int * int \u003d\u003d\u003e Time)\n\tplus(int, int, int, int)(hour, aMinute, aSecond, milliSecond) \u003d\u003d\nself.plusmilliSecond(IntProduct2TimeMillieSeconds(hour, aMinute, aSecond, milliSecond))\npublic  minusmilliSecond(int) (int \u003d\u003d\u003e Time)\n\tminusmilliSecond(int)(aMilliSecond) \u003d\u003d\nreturn ((self.plusmilliSecond)(-aMilliSecond))\npublic  minus(int, int, int, int) (int * int * int * int \u003d\u003d\u003e Time)\n\tminus(int, int, int, int)(hour, aMinute, aSecond, milliSecond) \u003d\u003d\nself.minusmilliSecond(IntProduct2TimeMillieSeconds(hour, aMinute, aSecond, milliSecond))\nend Time\n","class TimeT is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new TimeT06(), new TimeT05(), new TimeT04(), new TimeT03(), new TimeT02(), new TimeT01()]\nend TimeT\n","class TimeT01 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), d1:Date \u003d (cal.getDateFrom_yyyy_mm_dd)(2003, 7, 30), d3:Date \u003d (cal.getDateFrom_yyyy_mm_dd)(2003, 8, 15), t1:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 20), t2:Time \u003d new Time(cal, 2003, 8, 1), t3:Time \u003d new Time(d3) in return ((((t1.getDate)().EQ)(d1) and (((t1.Time2IntProduct)((t1.getTime)()) \u003d mk_(14, 29, 30, 20)) and ((mk_((t1.hour)(), (t1.minute)(), (t1.second)()) \u003d mk_(14, 29, 30)) and ((mk_((t2.Year)(), (t2.Month)(), (t2.day)()) \u003d mk_(2003, 8, 1)) and (((t2.getTime)() \u003d (t2.IntProduct2TimeMillieSeconds)(0, 0, 0, 0)) and (((t3.getDate)().EQ)(d3) and ((t3.getTime)() \u003d (t2.IntProduct2TimeMillieSeconds)(0, 0, 0, 0)))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"Ｔｉｍｅ０１：¥tＴｅｓｔ　ｏｆ　ｃｏｎｓｔｒｕｃｔｏｒ．\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT01\n","class TimeT02 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), t1:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t2:Time \u003d new Time(cal, 2003, 8, 1), t4:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 31, 0), t5:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 31, 0), t6:Time \u003d t1 in return (((t1.LT)(t2) and ((t1.LT)(t4) and ((t1.LE)(t2) and ((t1.LE)(t4) and ((t2.GT)(t1) and ((t4.GT)(t1) and ((t2.GE)(t1) and ((t4.GE)(t1) and ((t4.EQ)(t5) and ((t4.NE)(t1) and ((t4 \u003c\u003e t5) and (t1 \u003d t6)))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TimeT02:\tATime comparing.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT02\n","class TimeT03 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), t:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t1:Time \u003d (t.plussecond)(20), t2:Time \u003d (t.plussecond)(30), t3:Time \u003d (t.plussecond)(50), t4:Time \u003d (t.plussecond)(90), t5:Time \u003d (t.plussecond)(150), t6:Time \u003d (t.plussecond)(3600), t7:Time \u003d (t.plusminute)(30), t8:Time \u003d (t.plusminute)(31), t9:Time \u003d (t.plusminute)(40), t10:Time \u003d (t.plusminute)(91), t11:Time \u003d (t.plusminute)(1440), t12:Time \u003d (t.plus)(9, 30, 30, 123), t13:Time \u003d (t.plushour)(48), t14:Time \u003d (t.plus)(0, 0, 0, 0) in return ((((t1.minute)() \u003d 29) and (((t1.second)() \u003d 50) and (((t2.minute)() \u003d 30) and (((t2.second)() \u003d 0) and (((t3.minute)() \u003d 30) and (((t3.second)() \u003d 20) and (((t4.minute)() \u003d 31) and (((t4.second)() \u003d 0) and (((t5.hour)() \u003d 14) and (((t5.minute)() \u003d 32) and (((t5.second)() \u003d 0) and (((t6.hour)() \u003d 15) and (((t6.minute)() \u003d 29) and (((t6.second)() \u003d 30) and (((t7.hour)() \u003d 14) and (((t7.minute)() \u003d 59) and (((t8.hour)() \u003d 15) and (((t8.minute)() \u003d 0) and (((t9.hour)() \u003d 15) and (((t9.minute)() \u003d 9) and (((t10.hour)() \u003d 16) and (((t10.minute)() \u003d 0) and (((t10.second)() \u003d 30) and (((t11.Year)() \u003d 2003) and (((t11.Month)() \u003d 7) and (((t11.day)() \u003d 31) and (((t11.hour)() \u003d 14) and (((t11.minute)() \u003d 29) and (((t11.second)() \u003d 30) and (((t12.Year)() \u003d 2003) and (((t12.Month)() \u003d 7) and (((t12.day)() \u003d 31) and (((t12.hour)() \u003d 0) and (((t12.minute)() \u003d 0) and (((t12.second)() \u003d 0) and (((t12.milliSecond)() \u003d 123) and (((t13.Year)() \u003d 2003) and (((t13.Month)() \u003d 8) and (((t13.day)() \u003d 1) and (((t13.hour)() \u003d 14) and (((t13.minute)() \u003d 29) and (((t13.second)() \u003d 30) and (((t13.milliSecond)() \u003d 0) and (((t13.asString)() \u003d \"20030801142930000\") and (((t13.print)() \u003d \"Year\u003d2003, Month\u003d08, Day\u003d01, 14Hour, 29Minute, 30Second, 000MilliSecond\") and ((t14.asString)() \u003d \"20030730142930000\")))))))))))))))))))))))))))))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TimeT03:\tTime ading.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT03\n","class TimeT04 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), t:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t1:Time \u003d (t.minus)(14, 30, 30, 0), t2:Time \u003d (t.minus)(38, 30, 30, 0), t3:Time \u003d (t.plus)(-38, -30, -30, 0), t4:Time \u003d (t.plus)(-0, -0, -0, -0) in return ((((t1.Time2IntProduct)((t1.getTime)()) \u003d mk_(23, 59, 0, 0)) and ((((t1.getDate)().date2Str)() \u003d \"20030729\") and (((t2.Time2IntProduct)((t2.getTime)()) \u003d mk_(23, 59, 0, 0)) and ((((t2.getDate)().date2Str)() \u003d \"20030728\") and (((t3.Time2IntProduct)((t3.getTime)()) \u003d mk_(23, 59, 0, 0)) and ((((t3.getDate)().date2Str)() \u003d \"20030728\") and ((t4.print)() \u003d \"Year\u003d2003, Month\u003d07, Day\u003d30, 14Hour, 29Minute, 30Second, 000MilliSecond\"))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TimeT04:\tATime subtracting.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT04\n","class TimeT05 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:JapaneseCalendar \u003d new JapaneseCalendar(), t1:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t2:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t3:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0), t4:Time \u003d new Time(cal, 2003, 7, 30, 14, 29, 30, 0) in (\n\nt1.setTimeFromNat(15);\nt2.setMinuteFromNat(19);\nt3.setSecond(47);\nt4.setMilliSecond(789);\nreturn ((((t1.Time2IntProduct)((t1.getTime)()) \u003d mk_(15, 29, 30, 0)) and (((t2.Time2IntProduct)((t2.getTime)()) \u003d mk_(14, 19, 30, 0)) and (((t3.Time2IntProduct)((t3.getTime)()) \u003d mk_(14, 29, 47, 0)) and (((t4.Time2IntProduct)((t4.getTime)()) \u003d mk_(14, 29, 30, 789)) and (((t4.getDate)().date2Str)() \u003d \"20030730\"))))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TimeT05:\tSet instance variables.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT05\n","class TimeT06 is subclass of [TestCase, CalendarDefinition]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet cal:SBCalendar \u003d new SBCalendar() in (\n\nreturn (((new Time(cal).EQ)(new Time(cal, 2001, 3, 1, 10, 11, 23, 456)) and (new Time((homedir ^ \"/temp/BaseDay.txt\"), (homedir ^ \"/temp/Now2.txt\"), cal).EQ)(new Time(cal, 2003, 10, 24, 12, 34, 56, 789))))\n)\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \"TimeT06:\tTest currentDateTime from file.\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend TimeT06\n","class ＵｎｉｑｕｅＮｕｍｂｅｒ is subclass of [CommonDefinition]\nprivate static  ＤｅｆａｕｌｔＶａｌｕｅ:nat1 \u003d 1\nprotected  UniqNum:int :\u003d ＤｅｆａｕｌｔＶａｌｕｅ\npublic  public getUniqNum: (int * nat1 -\u003e int)\n\tgetUniqNum(aCandidateNum, aNumberOfDigit) \u003d\u003d\n(if (aCandidateNum \u003e\u003d (10 ** aNumberOfDigit))\nthen initialize()\nelse aCandidateNum)\npublic  ｇｅｔＵｎｉｑＮｕｍＳｔｒ(nat1) (nat1 \u003d\u003d\u003e seq of (char))\n\tｇｅｔＵｎｉｑＮｕｍＳｔｒ(nat1)(aNumberOfDigit) \u003d\u003d\nlet n:int \u003d getUniqNum(UniqNum, aNumberOfDigit) in (\n\nUniqNum :\u003d (UniqNum + 1);\nreturn (Integer`asString(n))\n)\npublic  initialize() (() \u003d\u003d\u003e int)\n\tinitialize()() \u003d\u003d\n(\n\nUniqNum :\u003d ＤｅｆａｕｌｔＶａｌｕｅ;\nreturn (UniqNum)\n)\nend ＵｎｉｑｕｅＮｕｍｂｅｒ\n","class ＵｎｉｑｕｅＮｕｍｂｅｒＴ is subclass of [TestDriver]\npublic  public tests: (() -\u003e seq of (TestCase))\n\ttests() \u003d\u003d\n[new ＵｎｉｑｕｅＮｕｍｂｅｒＴ01()]\nend ＵｎｉｑｕｅＮｕｍｂｅｒＴ\n","class ＵｎｉｑｕｅＮｕｍｂｅｒＴ01 is subclass of [TestCase]\nprotected  test() (() \u003d\u003d\u003e bool)\n\ttest()() \u003d\u003d\nlet o:ＵｎｉｑｕｅＮｕｍｂｅｒ \u003d new ＵｎｉｑｕｅＮｕｍｂｅｒ() in return ((((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"1\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"2\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"3\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"4\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"5\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"6\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"7\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"8\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"9\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"1\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(1) \u003d \"2\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"3\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"4\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"5\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"6\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"7\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"8\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"9\") and (((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"10\") and ((o.ｇｅｔＵｎｉｑＮｕｍＳｔｒ)(2) \u003d \"11\")))))))))))))))))))))\nprotected  setUp() (() \u003d\u003d\u003e ())\n\tsetUp()() \u003d\u003d\nTestName :\u003d \" ＵｎｉｑｕｅＮｕｍｂｅｒＴ01:\t ＵｎｉｑｕｅＮｕｍｂｅｒＴ01 Unit test\"\nprotected  tearDown() (() \u003d\u003d\u003e ())\n\ttearDown()() \u003d\u003d\nreturn\nend ＵｎｉｑｕｅＮｕｍｂｅｒＴ01\n","class UseCalendar\nprivate  sJC:JapaneseCalendar :\u003d new JapaneseCalendar()\npublic  [S1][[y in set {2010, ... ,2012}ALetBeStBindingTraceDefinitionm in set {1, ... ,12}ALetBeStBindingTraceDefinitiond in set {1, ... ,31}ALetBeStBindingTraceDefinitionsJC.getDateFrom_yyyy_mm_dd(y, m, d).asString(){1,1}def d in set {1, ... ,31}def m in set {1, ... ,12}def y in set {2010, ... ,2012}]]\npublic  [S2][[y in set {2010, ... ,2100}ALetBeStBindingTraceDefinitionsJC.getVernalEquinox(y).date2Str(){1,1}def y in set {2010, ... ,2100}]]\nend UseCalendar\n","class UseReal\nprivate  r:Real :\u003d new Real()\npublic  [S1][[n in set {0, 1, 9, 10, 99, 199, 0.1, 9.1, 10.1, 10.123}ALetBeStBindingTraceDefinitionr.numberOfDigit(n){1,1}def n in set {0, 1, 9, 10, 99, 199, 0.1, 9.1, 10.1, 10.123}]]\nend UseReal\n","class UseUniqueNumber\nprivate  sUN:ＵｎｉｑｕｅＮｕｍｂｅｒ :\u003d new ＵｎｉｑｕｅＮｕｍｂｅｒ()\npublic  [S1][[n in set {1, ... ,4}ALetBeStBindingTraceDefinitionsUN.ｇｅｔＵｎｉｑＮｕｍＳｔｒ(n){100,100}def n in set {1, ... ,4}]]\nend UseUniqueNumber\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n","class VDMUtil\npublic static  public static set2seq[(T)]: (set of (@T) +\u003e seq of (@T))\n\tset2seq(x) \u003d\u003d\nis not yet specified\npublic static  public static get_file_pos: (() +\u003e [(seq of (char) * nat * nat * seq of (char) * seq of (char))])\n\tget_file_pos() \u003d\u003d\nis not yet specified\npublic static  public static val2seq_of_char[(T)]: (@T +\u003e seq of (char))\n\tval2seq_of_char(x) \u003d\u003d\nis not yet specified\npublic static  public static seq_of_char2val[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tseq_of_char2val(s) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic static  public static classname[(T)]: (@T -\u003e [seq1 of (char)])\n\tclassname(s) \u003d\u003d\nis not yet specified\nend VDMUtil\n"]