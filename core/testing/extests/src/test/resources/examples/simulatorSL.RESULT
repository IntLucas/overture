["Quadrant \u003d Quadrant","M \u003d M\n\tinv mk_M(-, a, b) \u003d\u003d (b \u003e\u003d a)","state Memoryof\n[rseed : nat, Q3 : Quadrant, Q4 : Quadrant]\n\tinv mk_Memory(-, q3, q4) \u003d\u003d (((len q3) \u003e 0) and ((len q4) \u003e 0))\n\tinit q \u003d\u003d (q \u003d mk_Memory(87654321, [mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))], [mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))]))","MAXMEM:nat1 \u003d 10000","CHUNK:nat1 \u003d 100","private sizeof: (M -\u003e nat1)\n\tsizeof(m) \u003d\u003d\n(((m.stop) - (m.start)) + 1)","private least: (nat1 * nat1 -\u003e nat1)\n\tleast(a, b) \u003d\u003d\n(if (a \u003c b)\nthen a\nelse b)","private spacefor: (nat1 * Quadrant -\u003e nat1)\n\tspacefor(size, Q) \u003d\u003d\n(cases Q :\n[] -\u003e (MAXMEM + 1),\n[h] ^ tail -\u003e (if (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))\nthen sizeof(h)\nelse spacefor(size, tail))\n end)","private QuadrantLen: (nat1 * Quadrant -\u003e nat)\n\tQuadrantLen(-, list) \u003d\u003d\n(len list)","private bestfit: (nat1 * Quadrant -\u003e nat1)\n\tbestfit(size, Q) \u003d\u003d\n(cases Q :\n[] -\u003e (MAXMEM + 1),\n[h] ^ tail -\u003e (if (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))\nthen least(sizeof(h), bestfit(size, tail))\nelse bestfit(size, tail))\n end)","private add: (nat1 * nat1 * Quadrant -\u003e Quadrant)\n\tadd(size, hole, Q) \u003d\u003d\n(cases Q :\n[h] ^ tail -\u003e (if (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole))\nthen (if (hole \u003d size)\nthen ([mk_M(\u003cUSED\u003e, (h.start), (h.stop))] ^ tail)\nelse ([mk_M(\u003cUSED\u003e, (h.start), (((h.start) + size) - 1)), mk_M(\u003cFREE\u003e, ((h.start) + size), (h.stop))] ^ tail))\nelse ([h] ^ add(size, hole, tail)))\nothers Q\n end)\n\tpre (hole \u003e\u003d size)","private QuadrantLen2: (nat1 * nat1 * Quadrant -\u003e nat)\n\tQuadrantLen2(-, -, list) \u003d\u003d\n(len list)","private combine: (Quadrant -\u003e Quadrant)\n\tcombine(Q) \u003d\u003d\n(cases Q :\n[h1, h2] ^ tail -\u003e (if (((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e))\nthen combine(([mk_M(\u003cFREE\u003e, (h1.start), (h2.stop))] ^ tail))\nelse ([h1] ^ combine((tl Q))))\nothers Q\n end)","private QuadrantLen0: (Quadrant -\u003e nat)\n\tQuadrantLen0(list) \u003d\u003d\n(len list)","private delete: (M * Quadrant -\u003e Quadrant)\n\tdelete(item, Q) \u003d\u003d\n(if ((hd Q) \u003d item)\nthen combine(([mk_M(\u003cFREE\u003e, (item.start), (item.stop))] ^ (tl Q)))\nelse ([(hd Q)] ^ delete(item, (tl Q))))","private MQuadrantLen: (M * Quadrant -\u003e nat)\n\tMQuadrantLen(-, list) \u003d\u003d\n(len list)","private fragments: (Quadrant -\u003e nat)\n\tfragments(Q) \u003d\u003d\n((card {x | x in set (elems Q) \u0026 ((x.type) \u003d \u003cFREE\u003e)}) - 1)","seed (nat1 \u003d\u003d\u003e ())\n\tseed(n) \u003d\u003d\nrseed :\u003d n","inc (() \u003d\u003d\u003e ())\n\tinc() \u003d\u003d\nfor i \u003d 1 to ((rseed mod 7) + 3)\nrseed :\u003d (((rseed * 69069) + 5) mod 4294967296)","rand (nat1 \u003d\u003d\u003e nat1)\n\trand(n) \u003d\u003d\n(\n\ninc();\nreturn (((rseed mod n) + 1))\n)","FirstFit (nat1 \u003d\u003d\u003e bool)\n\tFirstFit(size) \u003d\u003d\n(\n\nlet q4:nat1 \u003d spacefor(size, Q4) in if (q4 \u003c\u003d MAXMEM)\nthen\nQ4 :\u003d add(size, q4, Q4)else\nlet q3:nat1 \u003d spacefor(size, Q3) in if (q3 \u003c\u003d MAXMEM)\nthen\nQ3 :\u003d add(size, q3, Q3)else\nreturn (false);\nreturn (true)\n)","BestFit (nat1 \u003d\u003d\u003e bool)\n\tBestFit(size) \u003d\u003d\n(\n\nlet q4:nat1 \u003d bestfit(size, Q4) in if (q4 \u003c\u003d MAXMEM)\nthen\nQ4 :\u003d add(size, q4, Q4)else\nlet q3:nat1 \u003d bestfit(size, Q3) in if (q3 \u003c\u003d MAXMEM)\nthen\nQ3 :\u003d add(size, q3, Q3)else\nreturn (false);\nreturn (true)\n)","Reset (() \u003d\u003d\u003e ())\n\tReset() \u003d\u003d\n(\n\nQ3 :\u003d [mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))];\nQ4 :\u003d [mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))]\n)","DeleteOne (() \u003d\u003d\u003e ())\n\tDeleteOne() \u003d\u003d\n(\n\nif (rand(2) \u003d 1)\nthen\nlet i:nat1 \u003d rand((len Q3)) in if ((Q3(i).type) \u003d \u003cUSED\u003e)\nthen\nQ3 :\u003d delete(Q3(i), Q3)else\nDeleteOne()else\nlet i:nat1 \u003d rand((len Q4)) in if ((Q4(i).type) \u003d \u003cUSED\u003e)\nthen\nQ4 :\u003d delete(Q4(i), Q4)else\nDeleteOne()\n)\n\tpre ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e)))","TryFirst (nat \u003d\u003d\u003e nat)\n\tTryFirst(loops) \u003d\u003d\n(\ncount:int :\u003d 0\n\nwhile ((count \u003c loops) and FirstFit(rand(CHUNK))) do (\n\nif (count \u003e 50)\nthen\nDeleteOne();\ncount :\u003d (count + 1)\n);\nreturn ((fragments(Q3) + fragments(Q4)))\n)","TryBest (nat \u003d\u003d\u003e nat)\n\tTryBest(loops) \u003d\u003d\n(\ncount:int :\u003d 0\n\nwhile ((count \u003c loops) and BestFit(rand(CHUNK))) do (\n\nif (count \u003e 50)\nthen\nDeleteOne();\ncount :\u003d (count + 1)\n);\nreturn ((fragments(Q3) + fragments(Q4)))\n)","main (nat1 * nat1 \u003d\u003d\u003e seq of ((\u003cBEST\u003e | \u003cFIRST\u003e | \u003cSAME\u003e)))\n\tmain(tries, loops) \u003d\u003d\n(\nresult:seq of ((\u003cBEST\u003e | \u003cFIRST\u003e | \u003cSAME\u003e)) :\u003d []\n\nfor i \u003d 1 to tries\n(\nbest:int :\u003d (undefined)\nfirst:int :\u003d (undefined)\n\nReset();\nseed(i);\nbest :\u003d TryBest(loops);\nReset();\nseed(i);\nfirst :\u003d TryFirst(loops);\nif (best \u003d first)\nthen\nresult :\u003d (result ^ [\u003cSAME\u003e])elseif (best \u003e first)\nthen\nresult :\u003d (result ^ [\u003cBEST\u003e])else\nresult :\u003d (result ^ [\u003cFIRST\u003e])\n);\nreturn (result)\n)"]