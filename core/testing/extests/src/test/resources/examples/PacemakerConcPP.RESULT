["class MessageChannelBuffer\nprivate  data:[MessageChannel] :\u003d nil\npublic  Put(MessageChannel) (MessageChannel \u003d\u003d\u003e ())\n\tPut(MessageChannel)(msg) \u003d\u003d\ndata :\u003d msg\npublic  Get() (() \u003d\u003d\u003e MessageChannel)\n\tGet()() \u003d\u003d\nlet d:[MessageChannel] \u003d data in (\n\ndata :\u003d nil;\nreturn (d)\n)\nprivate  per Get \u003d\u003e (data \u003c\u003e nil)\nprivate  per Put \u003d\u003e (data \u003d nil)\nprivate  mutex(Put, Get)\nprivate  mutex(Put)\nprivate  mutex(Get)\nend MessageChannelBuffer\n","class MessageChannel\nprivate  data:[(ClientCommand | ServerResponse)] :\u003d nil\nprivate  io:IO :\u003d new IO()\nprivate  debug:bool :\u003d true\nprivate  Send((ClientCommand | ServerResponse)) ((ClientCommand | ServerResponse) \u003d\u003d\u003e ())\n\tSend((ClientCommand | ServerResponse))(msg) \u003d\u003d\ndata :\u003d msg\nprivate  Listen() (() \u003d\u003d\u003e (ClientCommand | ServerResponse))\n\tListen()() \u003d\u003d\nlet d:[(ClientCommand | ServerResponse)] \u003d data in (\n\ndata :\u003d nil;\nreturn (d)\n)\npublic  ServerSend(ServerResponse) (ServerResponse \u003d\u003d\u003e ())\n\tServerSend(ServerResponse)(p) \u003d\u003d\n(\n\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e ServerSend\") in skip;\nSend(p);\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e fin ServerSend\") in skip\n)\npublic  ClientListen() (() \u003d\u003d\u003e ServerResponse)\n\tClientListen()() \u003d\u003d\n(\n\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e ClientListen\") in skip;\nlet r:(ClientCommand | ServerResponse) \u003d Listen(), -:bool \u003d (if debug\nthen (io.echo)(\"***\u003e fin ClientListen\")\nelse false) in return (r)\n)\npublic  ClientSend(ClientCommand) (ClientCommand \u003d\u003d\u003e ())\n\tClientSend(ClientCommand)(p) \u003d\u003d\n(\n\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e ClientSend\") in skip;\nSend(p);\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e fin ClientSend\") in skip\n)\npublic  ServerListen() (() \u003d\u003d\u003e ClientCommand)\n\tServerListen()() \u003d\u003d\n(\n\nif debug\nthen\nlet -:bool \u003d (io.echo)(\"***\u003e ServerListen\") in skip;\nlet c:(ClientCommand | ServerResponse) \u003d Listen(), -:bool \u003d (if debug\nthen (io.echo)(\"***\u003e fin ServerListen\")\nelse false) in return (c)\n)\nprivate  per ServerListen \u003d\u003e ((#fin[ClientSend] - 1) \u003d #fin[ServerListen])\nprivate  per ClientListen \u003d\u003e ((#fin[ServerSend] - 1) \u003d #fin[ClientListen])\nprivate  per ServerSend \u003d\u003e ((#fin[ClientSend] \u003d #fin[ServerListen]) and ((#fin[ServerListen] - 1) \u003d #fin[ServerSend]))\nprivate  per ClientSend \u003d\u003e ((#fin[ServerSend] \u003d #fin[ClientListen]) and ((#fin[ClientSend] \u003d #fin[ServerListen]) and (#fin[ServerSend] \u003d #fin[ClientSend])))\nend MessageChannel\n","class POP3ClientHandler\nprivate static  ServerState \u003d ServerState\nprivate static  unknownMessageMsg:seq of (char) \u003d \"No such message\"\nprivate static  negativeStatusMsg:seq of (char) \u003d \"Wrong state for this command\"\nprivate static  alreadyDeletedMsg:seq of (char) \u003d \"Message already deleted\"\nprivate static  deleteFailMsg:seq of (char) \u003d \"Some deleted messages not removed\"\nprivate static  maildropLockedMsg:seq of (char) \u003d \"Maildrop already locked\"\nprivate static  maildropReadyMsg:seq of (char) \u003d \"Maildrop locked and ready\"\nprivate static  passwordFailedMsg:seq of (char) \u003d \"User/password authentication failed\"\nprivate static  quitMsg:seq of (char) \u003d \"Quitting POP3 Server\"\nprivate static  submitPasswordMsg:seq of (char) \u003d \"Enter password\"\nprivate  ss:ServerState :\u003d (undefined)\nprivate  parent:POP3Server :\u003d (undefined)\nprivate  user:UserName :\u003d (undefined)\nprivate  msgChannel:MessageChannel :\u003d (undefined)\nprivate  id:ClientHandlerId :\u003d (undefined)\nprivate  lastWasUser:bool :\u003d false\npublic  POP3ClientHandler(POP3Server, MessageChannel) (POP3Server * MessageChannel \u003d\u003d\u003e POP3ClientHandler)\n\tPOP3ClientHandler(POP3Server, MessageChannel)(nparent, nch) \u003d\u003d\n(\n\nlet -:bool \u003d (new IO().echo)(\"Creating POP3ClientHandler\") in skip;\nss :\u003d \u003cAuthorization\u003e;\nparent :\u003d nparent;\nmsgChannel :\u003d nch\n)\nprivate  ReceiveCommand(ClientCommand) (ClientCommand \u003d\u003d\u003e ServerResponse)\n\tReceiveCommand(ClientCommand)(c) \u003d\u003d\nlet response:ServerResponse \u003d (cases c :\nmk_QUIT() -\u003e ReceiveQUIT(c),\nmk_STAT() -\u003e ReceiveSTAT(c),\nmk_LIST(-) -\u003e ReceiveLIST(c),\nmk_RETR(-) -\u003e ReceiveRETR(c),\nmk_DELE(-) -\u003e ReceiveDELE(c),\nmk_NOOP() -\u003e ReceiveNOOP(c),\nmk_RSET() -\u003e ReceiveRSET(c),\nmk_TOP(-, -) -\u003e ReceiveTOP(c),\nmk_UIDL(-) -\u003e ReceiveUIDL(c),\nmk_USER(-) -\u003e ReceiveUSER(c),\nmk_PASS(-) -\u003e ReceivePASS(c)\n end) in (\n\nif is_(c, POP3Types`USER)\nthen\nlastWasUser :\u003d trueelse\nlastWasUser :\u003d false;\nreturn (response)\n)\nprivate  ReceiveQUIT(QUIT) (QUIT \u003d\u003d\u003e ServerResponse)\n\tReceiveQUIT(QUIT)(-) \u003d\u003d\n(\nresponse:ServerResponse :\u003d (undefined)\n\ncases ss :\n  \u003cAuthorization\u003e -\u003e response :\u003d mk_POP3Types`OkResponse(quitMsg)  \u003cTransaction\u003e -\u003e let b:bool \u003d (parent.RemoveDeletedMessages)(user) in (\n\nss :\u003d \u003cUpdate\u003e;\nparent.ReleaseLock(id);\nresponse :\u003d (if b\nthen mk_POP3Types`OkResponse(quitMsg)\nelse mk_POP3Types`ErrResponse(deleteFailMsg))\n)  others -\u003e error end;\nreturn (response)\n)\nprivate  ReceiveSTAT(STAT) (STAT \u003d\u003d\u003e ServerResponse)\n\tReceiveSTAT(STAT)(-) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nreturn (mk_POP3Types`OkResponse((((\" \" ^ int2string((parent.GetNumberOfMessages)(user))) ^ \" \") ^ int2string((parent.GetMailBoxSize)(user)))))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveLIST(LIST) (LIST \u003d\u003d\u003e ServerResponse)\n\tReceiveLIST(LIST)(list) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nif (((list.messageNumber) \u003d nil) or (parent.IsValidMessageNumber)(user, (list.messageNumber)))\nthen\nlet msgs:set of (MessageInfo) \u003d (parent.GetMessageInfo)(user, (list.messageNumber)) in return (mk_POP3Types`OkResponse(((MakeScanListHeader(msgs) ^ \"\n\") ^ MakeScanListing(msgs))))else\nreturn (mk_POP3Types`ErrResponse(unknownMessageMsg))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  private MakeScanListHeader: (set of (MessageInfo) -\u003e seq of (char))\n\tMakeScanListHeader(msgs) \u003d\u003d\nlet lp:nat \u003d (card msgs) in (((int2string(lp) ^ (if (lp \u003d 1)\nthen \" message(\"\nelse \" messages(\")) ^ int2string(sum({(msg.size) | msg in set msgs}))) ^ \" octets)\")\nprivate  private set2seq[(tp)]: (set of (@tp) -\u003e seq of (@tp))\n\tset2seq(s) \u003d\u003d\n(if (s \u003d {})\nthen []\nelse let v in set s in ([v] ^ (set2seq)[@tp]((s \\ {v}))))\nprivate  private MakeScanListing: (set of (MessageInfo) -\u003e seq of (char))\n\tMakeScanListing(msgs) \u003d\u003d\nlet msgSeq:seq of (MessageInfo) \u003d (set2seq)[MessageInfo](msgs) in MakeMultilineResponse([((int2string((msgSeq(i).index)) ^ \" \") ^ int2string((msgSeq(i).size))) | i in set (inds msgSeq)])\nprivate  private MakeMultilineResponse: (seq of (seq of (char)) -\u003e seq of (char))\n\tMakeMultilineResponse(resps) \u003d\u003d\n(if (resps \u003d [])\nthen []\nelseif ((len resps) \u003d 1)\nthen (hd resps)\nelse (((hd resps) ^ \"\n\") ^ MakeMultilineResponse((tl resps))))\nprivate  private MakeLineSeq: (seq of (char) -\u003e seq of (seq of (char)))\n\tMakeLineSeq(text) \u003d\u003d\n(if (text \u003d [])\nthen []\nelse let mk_(line, rest):(seq of (char) * seq of (char)) \u003d GetLine(text) in ([line] ^ MakeLineSeq(rest)))\nprivate  private GetLine: (seq of (char) -\u003e (seq of (char) * seq of (char)))\n\tGetLine(text) \u003d\u003d\n(if (text \u003d [])\nthen mk_([], [])\nelseif ((hd text) \u003d \u0027\n\u0027)\nthen mk_([], (tl text))\nelse let mk_(line, rest):(seq of (char) * seq of (char)) \u003d GetLine((tl text)) in mk_(([(hd text)] ^ line), rest))\nprivate  private Len: ((seq of (char) | seq of (seq of (char))) -\u003e nat)\n\tLen(l) \u003d\u003d\n(len l)\nprivate  private sum: (set of (nat) -\u003e nat)\n\tsum(s) \u003d\u003d\n(if (s \u003d {})\nthen 0\nelse let e in set s in (sum((s \\ {e})) + e))\nprivate  private Card: (set of (nat) -\u003e nat)\n\tCard(s) \u003d\u003d\n(card s)\nprivate  ReceiveRETR(RETR) (RETR \u003d\u003d\u003e ServerResponse)\n\tReceiveRETR(RETR)(retr) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nif (parent.IsValidMessageNumber)(user, (retr.messageNumber))\nthen\nlet msgText:seq of (char) \u003d (parent.GetMessageText)(user, (retr.messageNumber)), sizeText:seq of (char) \u003d int2string((parent.GetMessageSize)(user, (retr.messageNumber))) in return (mk_POP3Types`OkResponse(((sizeText ^ \"\n\") ^ msgText)))else\nreturn (mk_POP3Types`ErrResponse(unknownMessageMsg))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveDELE(DELE) (DELE \u003d\u003d\u003e ServerResponse)\n\tReceiveDELE(DELE)(retr) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nif (parent.IsValidMessageNumber)(user, (retr.messageNumber))\nthen\n(\n\nparent.DeleteMessage(user, (retr.messageNumber));\nreturn (mk_POP3Types`OkResponse(((\"message \" ^ int2string((retr.messageNumber))) ^ \" deleted\")))\n)else\nif (parent.MessageIsDeleted)(user, (retr.messageNumber))\nthen\nreturn (mk_POP3Types`ErrResponse(alreadyDeletedMsg))else\nreturn (mk_POP3Types`ErrResponse(unknownMessageMsg))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveNOOP(NOOP) (NOOP \u003d\u003d\u003e ServerResponse)\n\tReceiveNOOP(NOOP)(-) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nreturn (mk_POP3Types`OkResponse(\"\"))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveRSET(RSET) (RSET \u003d\u003d\u003e ServerResponse)\n\tReceiveRSET(RSET)(-) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\n(\n\nparent.ResetDeletedMessages(user);\nreturn (mk_POP3Types`OkResponse(((\"maildrop has \" ^ int2string((parent.GetNumberOfMessages)(user))) ^ \" messages\")))\n)else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveTOP(TOP) (TOP \u003d\u003d\u003e ServerResponse)\n\tReceiveTOP(TOP)(top) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nif (parent.IsValidMessageNumber)(user, (top.messageNumber))\nthen\nlet header:seq of (char) \u003d (parent.GetMsgHeader)(user, (top.messageNumber)), body:seq of (char) \u003d (parent.GetMsgBody)(user, (top.messageNumber)), lines:seq of (seq of (char)) \u003d MakeLineSeq(body) in return (mk_POP3Types`OkResponse(((header ^ \"\n\") ^ MakeMultilineResponse((lines(1, ... ,(top.numLines)))))))else\nreturn (mk_POP3Types`ErrResponse(unknownMessageMsg))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveUIDL(UIDL) (UIDL \u003d\u003d\u003e ServerResponse)\n\tReceiveUIDL(UIDL)(uidl) \u003d\u003d\nif (ss \u003d \u003cTransaction\u003e)\nthen\nif ((uidl.messageNumber) \u003d nil)\nthen\nlet uidlTxt:seq of (seq of (char)) \u003d (parent.GetAllUidls)(user) in return (mk_POP3Types`OkResponse(MakeMultilineResponse(uidlTxt)))elseif (parent.IsMessageNumber)(user, (uidl.messageNumber))\nthen\nreturn (mk_POP3Types`OkResponse((parent.GetUidl)(user, (uidl.messageNumber))))else\nreturn (mk_POP3Types`ErrResponse(unknownMessageMsg))else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceiveUSER(USER) (USER \u003d\u003d\u003e ServerResponse)\n\tReceiveUSER(USER)(usercmd) \u003d\u003d\nif (ss \u003d \u003cAuthorization\u003e)\nthen\n(\n\nuser :\u003d (usercmd.name);\nreturn (mk_POP3Types`OkResponse(submitPasswordMsg))\n)else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\nprivate  ReceivePASS(PASS) (PASS \u003d\u003d\u003e ServerResponse)\n\tReceivePASS(PASS)(pass) \u003d\u003d\nif ((ss \u003d \u003cAuthorization\u003e) and lastWasUser)\nthen\n(\n\nlastWasUser :\u003d false;\nif (parent.AuthenticateUser)(user, (pass.string))\nthen\nif (parent.IsLocked)(user)\nthen\nreturn (mk_POP3Types`ErrResponse(maildropLockedMsg))else\n(\n\nparent.AcquireLock(id, user);\nss :\u003d \u003cTransaction\u003e;\nreturn (mk_POP3Types`OkResponse(maildropReadyMsg))\n)else\nreturn (mk_POP3Types`ErrResponse(passwordFailedMsg))\n)else\nreturn (mk_POP3Types`ErrResponse(negativeStatusMsg))\npublic static  public static int2string: (int -\u003e seq of (char))\n\tint2string(i) \u003d\u003d\n(if (i \u003d 0)\nthen \"0\"\nelseif (i \u003c 0)\nthen (\"-\" ^ int2string(-i))\nelse int2stringR(i))\nprivate static  private static Abs: (int -\u003e nat)\n\tAbs(i) \u003d\u003d\n(abs i)\nprivate static  private static int2stringR: (nat -\u003e seq of (char))\n\tint2stringR(n) \u003d\u003d\n(if (n \u003d 0)\nthen \"\"\nelse let first:int \u003d (n div 10), last:int \u003d (n mod 10) in (int2stringR(first) ^ (cases last :\n0 -\u003e \"0\",\n1 -\u003e \"1\",\n2 -\u003e \"2\",\n3 -\u003e \"3\",\n4 -\u003e \"4\",\n5 -\u003e \"5\",\n6 -\u003e \"6\",\n7 -\u003e \"7\",\n8 -\u003e \"8\",\n9 -\u003e \"9\"\n end)))\nprivate static  private static Id: (nat -\u003e nat)\n\tId(n) \u003d\u003d\nn\nprotected  thread (\ncmd:ClientCommand :\u003d (undefined)\n\nid :\u003d threadid;\ncmd :\u003d (msgChannel.ServerListen)();\nwhile (cmd \u003c\u003e mk_POP3Types`QUIT()) do (\n\nmsgChannel.ServerSend(ReceiveCommand(cmd));\ncmd :\u003d (msgChannel.ServerListen)()\n);\nmsgChannel.ServerSend(ReceiveCommand(cmd))\n)\nend POP3ClientHandler\n","class POP3Message\nprivate  header:seq of (char) :\u003d (undefined)\nprivate  body:seq of (char) :\u003d (undefined)\nprivate  deleted:bool :\u003d (undefined)\nprivate  uniqueId:seq of (char) :\u003d (undefined)\npublic  POP3Message(seq of (char), seq of (char), seq of (char)) (seq of (char) * seq of (char) * seq of (char) \u003d\u003d\u003e POP3Message)\n\tPOP3Message(seq of (char), seq of (char), seq of (char))(nheader, nbody, nuniqueId) \u003d\u003d\n(\n\nheader :\u003d nheader;\nbody :\u003d nbody;\ndeleted :\u003d false;\nuniqueId :\u003d nuniqueId\n)\npublic  GetBody() (() \u003d\u003d\u003e seq of (char))\n\tGetBody()() \u003d\u003d\nreturn (body)\npublic  GetHeader() (() \u003d\u003d\u003e seq of (char))\n\tGetHeader()() \u003d\u003d\nreturn (header)\npublic  GetText() (() \u003d\u003d\u003e seq of (char))\n\tGetText()() \u003d\u003d\nreturn (((header ^ \"\n\") ^ body))\npublic  Delete() (() \u003d\u003d\u003e POP3Message)\n\tDelete()() \u003d\u003d\n(\n\ndeleted :\u003d true;\nreturn (self)\n)\npublic  IsDeleted() (() \u003d\u003d\u003e bool)\n\tIsDeleted()() \u003d\u003d\nreturn (deleted)\npublic  Undelete() (() \u003d\u003d\u003e POP3Message)\n\tUndelete()() \u003d\u003d\n(\n\ndeleted :\u003d false;\nreturn (self)\n)\npublic  GetSize() (() \u003d\u003d\u003e nat)\n\tGetSize()() \u003d\u003d\nreturn (((len body) + (len header)))\npublic  GetUniqueId() (() \u003d\u003d\u003e seq of (char))\n\tGetUniqueId()() \u003d\u003d\nreturn (uniqueId)\nend POP3Message\n","class POP3Server\npublic static  MessageInfo \u003d MessageInfo\nprivate  connChannel:MessageChannelBuffer :\u003d (undefined)\nprivate  maildrop:MailDrop :\u003d (undefined)\nprivate  passwords:map (UserName) to (Password) :\u003d (undefined)\nprivate  locks:map (ClientHandlerId) to (UserName) :\u003d (undefined)\nprivate  serverStarted:bool :\u003d false\nprivate  inv(((dom passwords) \u003d (dom maildrop)) and ((rng locks) subset (dom maildrop)))\npublic static  MailDrop \u003d MailDrop\npublic static  MailBox \u003d MailBox\npublic static  ClientHandlerId \u003d ClientHandlerId\npublic  POP3Server(MailDrop, MessageChannelBuffer, map (UserName) to (Password)) (MailDrop * MessageChannelBuffer * map (UserName) to (Password) \u003d\u003d\u003e POP3Server)\n\tPOP3Server(MailDrop, MessageChannelBuffer, map (UserName) to (Password))(nmd, nch, npasswords) \u003d\u003d\n(\n\nmaildrop :\u003d nmd;\nconnChannel :\u003d nch;\nlocks :\u003d {|-\u003e};\npasswords :\u003d npasswords\n)\npublic  AuthenticateUser(UserName, Password) (UserName * Password \u003d\u003d\u003e bool)\n\tAuthenticateUser(UserName, Password)(user, password) \u003d\u003d\nreturn (((user in set (dom passwords)) and (passwords(user) \u003d password)))\npublic  IsLocked(UserName) (UserName \u003d\u003d\u003e bool)\n\tIsLocked(UserName)(user) \u003d\u003d\nreturn ((user in set (rng locks)))\nprivate  SetUserMessages(UserName, seq of (POP3Message)) (UserName * seq of (POP3Message) \u003d\u003d\u003e ())\n\tSetUserMessages(UserName, seq of (POP3Message))(user, newMsgs) \u003d\u003d\nmaildrop(user) :\u003d mu(maildrop(user), msgs |-\u003e newMsgs)\nprivate  GetUserMail(UserName) (UserName \u003d\u003d\u003e MailBox)\n\tGetUserMail(UserName)(user) \u003d\u003d\nreturn (maildrop(user))\nprivate  mutex(SetUserMessages)\nprivate  mutex(SetUserMessages, GetUserMail)\nprivate  GetUserMessages(UserName) (UserName \u003d\u003d\u003e seq of (POP3Message))\n\tGetUserMessages(UserName)(user) \u003d\u003d\nreturn ((GetUserMail(user).msgs))\npublic  RemoveDeletedMessages(UserName) (UserName \u003d\u003d\u003e bool)\n\tRemoveDeletedMessages(UserName)(user) \u003d\u003d\nlet oldMsgs:seq of (POP3Message) \u003d GetUserMessages(user), newMsgs:seq of (POP3Message) \u003d [oldMsgs(i) | i in set (inds oldMsgs) \u0026 (not (oldMsgs(i).IsDeleted)())] in (\n\nSetUserMessages(user, newMsgs);\nreturn (true)\n)\npublic  AcquireLock(ClientHandlerId, UserName) (ClientHandlerId * UserName \u003d\u003d\u003e ())\n\tAcquireLock(ClientHandlerId, UserName)(clId, user) \u003d\u003d\nlocks :\u003d (locks ++ {clId |-\u003e user})\n\tpre ((clId not in set (dom locks)) and (user in set (dom maildrop)))\npublic  ReleaseLock(ClientHandlerId) (ClientHandlerId \u003d\u003d\u003e ())\n\tReleaseLock(ClientHandlerId)(clId) \u003d\u003d\nlocks :\u003d ({clId} \u003c-: locks)\n\tpre (clId in set (dom locks))\nprivate  mutex(AcquireLock)\nprivate  mutex(ReleaseLock)\nprivate  mutex(AcquireLock, ReleaseLock, IsLocked)\nprivate  CreateClientHandler(MessageChannel) (MessageChannel \u003d\u003d\u003e ())\n\tCreateClientHandler(MessageChannel)(mc) \u003d\u003d\nstart (new POP3ClientHandler(self, mc))\npublic  IsMessageNumber(UserName, nat) (UserName * nat \u003d\u003d\u003e bool)\n\tIsMessageNumber(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return ((index in set (inds mb)))\npublic  IsValidMessageNumber(UserName, nat) (UserName * nat \u003d\u003d\u003e bool)\n\tIsValidMessageNumber(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return (((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  MessageIsDeleted(UserName, nat) (UserName * nat \u003d\u003d\u003e bool)\n\tMessageIsDeleted(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return (((index in set (inds mb)) and (mb(index).IsDeleted)()))\npublic  DeleteMessage(UserName, nat) (UserName * nat \u003d\u003d\u003e ())\n\tDeleteMessage(UserName, nat)(user, index) \u003d\u003d\nlet oldMsg:POP3Message \u003d GetUserMessages(user)(index), newMsg:POP3Message \u003d (oldMsg.Delete)() in SetUserMessages(user, (GetUserMessages(user) ++ {index |-\u003e newMsg}))\n\tpre ((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  GetMsgHeader(UserName, nat) (UserName * nat \u003d\u003d\u003e seq of (char))\n\tGetMsgHeader(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return ((mb(index).GetHeader)())\n\tpre ((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  GetMsgBody(UserName, nat) (UserName * nat \u003d\u003d\u003e seq of (char))\n\tGetMsgBody(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return ((mb(index).GetBody)())\n\tpre ((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  ResetDeletedMessages(UserName) (UserName \u003d\u003d\u003e ())\n\tResetDeletedMessages(UserName)(user) \u003d\u003d\nlet oldMsgs:seq of (POP3Message) \u003d GetUserMessages(user), newMsgs:seq of (POP3Message) \u003d [(oldMsgs(i).Undelete)() | i in set (inds oldMsgs)] in SetUserMessages(user, newMsgs)\n\tpre (user in set (dom maildrop))\npublic  GetMessageText(UserName, nat) (UserName * nat \u003d\u003d\u003e seq of (char))\n\tGetMessageText(UserName, nat)(user, index) \u003d\u003d\nreturn ((GetUserMessages(user)(index).GetText)())\n\tpre ((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d GetUserMessages(user) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  GetMessageSize(UserName, nat) (UserName * nat \u003d\u003d\u003e nat)\n\tGetMessageSize(UserName, nat)(user, index) \u003d\u003d\nreturn ((GetUserMessages(user)(index).GetSize)())\n\tpre ((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)())))\npublic  GetMessageInfo(UserName, [nat]) (UserName * [nat] \u003d\u003d\u003e set of (MessageInfo))\n\tGetMessageInfo(UserName, [nat])(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in if (index \u003d nil)\nthen\nreturn ((elems [mk_MessageInfo(i, GetMessageSize(user, i)) | i in set (inds mb) \u0026 (not (mb(i).IsDeleted)())]))else\nreturn ({mk_MessageInfo(index, GetMessageSize(user, index))})\n\tpre ((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)())))\npublic  GetUidl(UserName, nat) (UserName * nat \u003d\u003d\u003e seq of (char))\n\tGetUidl(UserName, nat)(user, index) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return (((POP3ClientHandler`int2string(index) ^ \" \") ^ (mb(index).GetUniqueId)()))\npublic  GetAllUidls(UserName) (UserName \u003d\u003d\u003e seq of (seq of (char)))\n\tGetAllUidls(UserName)(user) \u003d\u003d\nlet mb:seq of (POP3Message) \u003d GetUserMessages(user) in return ([GetUidl(user, index) | index in set (inds mb)])\npublic  GetNumberOfMessages(UserName) (UserName \u003d\u003d\u003e nat)\n\tGetNumberOfMessages(UserName)(user) \u003d\u003d\nreturn ((len GetUserMessages(user)))\n\tpre (user in set (dom maildrop))\npublic  GetMailBoxSize(UserName) (UserName \u003d\u003d\u003e nat)\n\tGetMailBoxSize(UserName)(user) \u003d\u003d\nlet mb:MailBox \u003d GetUserMail(user) in return (sumseq([((mb.msgs)(i).GetSize)() | i in set (inds (mb.msgs))]))\n\tpre (user in set (dom maildrop))\npublic  GetChannel() (() \u003d\u003d\u003e MessageChannelBuffer)\n\tGetChannel()() \u003d\u003d\nreturn (connChannel)\npublic  public sumseq: (seq of (nat) -\u003e nat)\n\tsumseq(s) \u003d\u003d\n(if (s \u003d [])\nthen 0\nelse ((hd s) + sumseq((tl s))))\nprivate  private Len: (seq of (nat) -\u003e nat)\n\tLen(l) \u003d\u003d\n(len l)\nprotected  thread while true do (\n\nlet msgChannel:MessageChannel \u003d (connChannel.Get)() in CreateClientHandler(msgChannel);\nserverStarted :\u003d true\n)\npublic  WaitForServerStart() (() \u003d\u003d\u003e ())\n\tWaitForServerStart()() \u003d\u003d\nskip\nprivate  per WaitForServerStart \u003d\u003e serverStarted\nend POP3Server\n","class POP3Test\nprivate static  users:seq of (UserName) \u003d [\"paul\", \"peter\", \"nico\", \"john\", \"marcel\"]\nprivate static  passwords:seq of (Password) \u003d [\"laup\", \"retep\", \"ocin\", \"nhoj\", \"lecram\"]\nprivate static  headers:seq of (seq of (char)) \u003d [((\"From paul@mail.domain\n\" ^ \"Subject Subject 1 \n\") ^ \"Date Fri, 19 Oct 2001 10:52:58 -0500\"), ((\"From peter@mail.domain\n\" ^ \"Subject Subject 2 \n\") ^ \"Date Sat, 20 Oct 2001 10:52:58 -0500\"), ((\"From nico@mail.domain\n\" ^ \"Subject Subject 3 \n\") ^ \"Date Sun, 21 Oct 2001 10:52:58 -0500\"), ((\"From john@mail.domain\n\" ^ \"Subject Subject 4 \n\") ^ \"Date Mon, 22 Oct 2001 10:52:58 -0500\"), ((\"From marcel@mail.domain\n\" ^ \"Subject Subject 5 \n\") ^ \"Date Tues, 23 Oct 2001 10:52:58 -0500\")]\nprivate static  bodies:seq of (seq of (char)) \u003d [\"Greetings from Paul\", \"Greetings from Peter\", \"Greetings from Nico\", \"Greetings from John\", \"Greetings from Marcel\"]\npublic  public MakePasswordMap: (() -\u003e map (UserName) to (Password))\n\tMakePasswordMap() \u003d\u003d\n{users(i) |-\u003e passwords(i) | i in set (inds users)}\npublic  public MakeMailDrop: (() -\u003e MailDrop)\n\tMakeMailDrop() \u003d\u003d\n{users(i) |-\u003e mk_POP3Server`MailBox(MakeMessages(users(i)), false) | i in set (inds users)}\npublic  public MakeMessages: (UserName -\u003e seq of (POP3Message))\n\tMakeMessages(user) \u003d\u003d\n[new POP3Message(headers(i), ((bodies(i) ^ \" to \") ^ user), (user ^ POP3ClientHandler`int2string(i))) | i in set (inds headers)]\nprivate  private TestRun1: (() -\u003e seq of (ClientCommand))\n\tTestRun1() \u003d\u003d\n[mk_POP3Types`USER(users(1)), mk_POP3Types`PASS(passwords(1)), mk_POP3Types`STAT(), mk_POP3Types`LIST(nil), mk_POP3Types`RETR(1), mk_POP3Types`DELE(1), mk_POP3Types`RETR(1), mk_POP3Types`RSET(), mk_POP3Types`NOOP(), mk_POP3Types`LIST(3), mk_POP3Types`LIST(8), mk_POP3Types`TOP(2, 5), mk_POP3Types`UIDL(nil), mk_POP3Types`UIDL(3), mk_POP3Types`DELE(1), mk_POP3Types`DELE(1), mk_POP3Types`UIDL(1), mk_POP3Types`QUIT()]\nprivate  server:POP3Server :\u003d (undefined)\nprivate  ch:MessageChannelBuffer :\u003d (undefined)\nprivate  mc1:MessageChannel :\u003d (undefined)\nprivate  mc2:MessageChannel :\u003d (undefined)\nprivate  mc3:MessageChannel :\u003d (undefined)\nprivate  send1:POP3TestSender :\u003d (undefined)\nprivate  send2:POP3TestSender :\u003d (undefined)\nprivate  listen1:POP3TestListener :\u003d (undefined)\nprivate  listen2:POP3TestListener :\u003d (undefined)\npublic  StartServer(POP3Server) (POP3Server \u003d\u003d\u003e ())\n\tStartServer(POP3Server)(myserver) \u003d\u003d\n(\n\nstart (myserver)\n)\npublic  Test1() (() \u003d\u003d\u003e ())\n\tTest1()() \u003d\u003d\nlet ch:MessageChannelBuffer \u003d new MessageChannelBuffer(), server:POP3Server \u003d new POP3Server(MakeMailDrop(), ch, MakePasswordMap()) in (\nmc:MessageChannel :\u003d new MessageChannel()\n\nstart (server);\nch.Put(mc);\nlet run:seq of (ClientCommand) \u003d TestRun1(), send:POP3TestSender \u003d new POP3TestSender(\"c\", run, mc), listen:POP3TestListener \u003d new POP3TestListener(\"l\", mc) in (\n\nstart (send);\nstart (listen);\nlisten.IsFinished()\n)\n)\npublic  Test2() (() \u003d\u003d\u003e ())\n\tTest2()() \u003d\u003d\nlet ch:MessageChannelBuffer \u003d new MessageChannelBuffer(), server:POP3Server \u003d new POP3Server(MakeMailDrop(), ch, MakePasswordMap()) in (\nmc1:MessageChannel :\u003d new MessageChannel()\nmc2:MessageChannel :\u003d new MessageChannel()\n\nstart (server);\nch.Put(mc1);\nch.Put(mc2);\nlet run:seq of (ClientCommand) \u003d TestRun1(), send1:POP3TestSender \u003d new POP3TestSender(\"c1\", run, mc1), send2:POP3TestSender \u003d new POP3TestSender(\"c2\", run, mc2), listen1:POP3TestListener \u003d new POP3TestListener(\"l1\", mc1), listen2:POP3TestListener \u003d new POP3TestListener(\"l2\", mc2) in (\n\nstart (send1);\nstart (send2);\nstart (listen1);\nstart (listen2);\nlisten1.IsFinished();\nlisten2.IsFinished()\n)\n)\nprivate  Start((POP3TestListener | POP3TestSender)) ((POP3TestListener | POP3TestSender) \u003d\u003d\u003e ())\n\tStart((POP3TestListener | POP3TestSender))(obj) \u003d\u003d\nstart (obj)\npublic  POP3Test() (() \u003d\u003d\u003e POP3Test)\n\tPOP3Test()() \u003d\u003d\n(\n\nch :\u003d new MessageChannelBuffer();\nserver :\u003d new POP3Server(MakeMailDrop(), ch, MakePasswordMap());\nmc1 :\u003d new MessageChannel();\nmc2 :\u003d new MessageChannel();\nmc3 :\u003d new MessageChannel();\nsend1 :\u003d new POP3TestSender(\"c1\", TestRun1(), mc1);\nsend2 :\u003d new POP3TestSender(\"c2\", TestRun1(), mc2);\nlisten1 :\u003d new POP3TestListener(\"l1\", mc1);\nlisten2 :\u003d new POP3TestListener(\"l2\", mc2)\n)\npublic  [Two][[StartServer(server){1,1}], [([[ch.Put(mc1){1,1}, ch.Put(mc2){1,1}, ch.Put(mc3){1,1}]]){3,3}], [Start(send1){1,1}], [Start(send2){1,1}], [Start(listen1){1,1}], [Start(listen2){1,1}], [listen1.IsFinished(){1,1}], [listen2.IsFinished(){1,1}]]\nend POP3Test\n","class POP3TestSender\nprivate  id:seq of (char) :\u003d (undefined)\nprivate  cmds:seq of (ClientCommand) :\u003d (undefined)\nprivate  mc:MessageChannel :\u003d (undefined)\npublic  POP3TestSender(seq of (char), seq of (ClientCommand), MessageChannel) (seq of (char) * seq of (ClientCommand) * MessageChannel \u003d\u003d\u003e POP3TestSender)\n\tPOP3TestSender(seq of (char), seq of (ClientCommand), MessageChannel)(idarg, cmdsarg, mcarg) \u003d\u003d\n(\n\nid :\u003d idarg;\ncmds :\u003d cmdsarg;\nmc :\u003d mcarg\n)\nprivate  LogClient(ClientCommand) (ClientCommand \u003d\u003d\u003e ())\n\tLogClient(ClientCommand)(cmd) \u003d\u003d\nlet io:IO \u003d new IO(), -:bool \u003d (io.echo)(((\"Client \" ^ id) ^ \" says -\u003e \")), -:bool \u003d ((io.writeval))[ClientCommand](cmd) in skip\nprivate  SendCmd(MessageChannel, ClientCommand) (MessageChannel * ClientCommand \u003d\u003d\u003e ())\n\tSendCmd(MessageChannel, ClientCommand)(mcarg, cmd) \u003d\u003d\n(\n\nmcarg.ClientSend(cmd);\nLogClient(cmd)\n)\nprotected  thread for in \u0027POP3TestSender\u0027 (pop3test.vdmpp) at line 212:7cmdADefPatternBind[cmd \u003d ClientCommand]ADefPatternBind in cmds do\nSendCmd(mc, cmd)\nend POP3TestSender\n","class POP3TestListener\nprivate  id:seq of (char) :\u003d (undefined)\nprivate  mc:MessageChannel :\u003d (undefined)\nprivate  finished:bool :\u003d (undefined)\npublic  POP3TestListener(seq of (char), MessageChannel) (seq of (char) * MessageChannel \u003d\u003d\u003e POP3TestListener)\n\tPOP3TestListener(seq of (char), MessageChannel)(idarg, mcarg) \u003d\u003d\n(\n\nid :\u003d idarg;\nmc :\u003d mcarg;\nfinished :\u003d false\n)\nprivate  LogServer(ServerResponse) (ServerResponse \u003d\u003d\u003e ())\n\tLogServer(ServerResponse)(resp) \u003d\u003d\nlet io:IO \u003d new IO(), -:bool \u003d (io.echo)(((\"Server \" ^ id) ^ \" responds -\u003e \")), -:bool \u003d ((io.writeval))[ServerResponse](resp) in skip\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprivate  per IsFinished \u003d\u003e finished\nprotected  thread (\nresponse:ServerResponse :\u003d (mc.ClientListen)()\n\nwhile (response \u003c\u003e mk_POP3Types`OkResponse(\"Quitting POP3 Server\")) do (\n\nLogServer(response);\nresponse :\u003d (mc.ClientListen)()\n);\nLogServer(response);\nfinished :\u003d true\n)\nend POP3TestListener\n","class POP3Types\npublic static  ClientCommand \u003d ClientCommand\npublic static  StandardClientCommand \u003d StandardClientCommand\npublic static  OptionalClientCommand \u003d OptionalClientCommand\npublic static  QUIT \u003d QUIT\npublic static  STAT \u003d STAT\npublic static  LIST \u003d LIST\npublic static  RETR \u003d RETR\npublic static  DELE \u003d DELE\npublic static  NOOP \u003d NOOP\npublic static  RSET \u003d RSET\npublic static  TOP \u003d TOP\npublic static  UIDL \u003d UIDL\npublic static  USER \u003d USER\npublic static  PASS \u003d PASS\npublic static  APOP \u003d APOP\npublic static  UserName \u003d UserName\npublic static  Password \u003d Password\npublic static  ServerResponse \u003d ServerResponse\npublic static  OkResponse \u003d OkResponse\npublic static  ErrResponse \u003d ErrResponse\nend POP3Types\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]