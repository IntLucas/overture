["Definitions \u003d Definitions","ValueDef \u003d ValueDef","ExplFnDef \u003d ExplFnDef","Expr \u003d Expr","BracketedExpr \u003d BracketedExpr","LetExpr \u003d LetExpr","LetBeSTExpr \u003d LetBeSTExpr","IfExpr \u003d IfExpr","CasesExpr \u003d CasesExpr","CaseAltn \u003d CaseAltn","UnaryExpr \u003d UnaryExpr","UnaryOp \u003d UnaryOp","BinaryExpr \u003d BinaryExpr","BinaryOp \u003d BinaryOp","SetEnumerationExpr \u003d SetEnumerationExpr","ApplyExpr \u003d ApplyExpr","Name \u003d Name","Id \u003d Id","Pattern \u003d Pattern","PatternName \u003d PatternName","MatchVal \u003d MatchVal","SetPattern \u003d SetPattern","SetEnumPattern \u003d SetEnumPattern","SetUnionPattern \u003d SetUnionPattern","Position \u003d Position","Bind \u003d Bind","SetBind \u003d SetBind","Literal \u003d Literal","BoolLit \u003d BoolLit","NumLit \u003d NumLit","pat:Pattern \u003d mk_PatternName(mk_(mk_Name([\"x\"]), mk_(1, 1)))","sexpr:Expr \u003d mk_SetEnumerationExpr([mk_NumLit(1), mk_NumLit(2)])","expr:Expr \u003d mk_LetBeSTExpr(mk_SetBind(pat, sexpr), mk_BoolLit(true), mk_Name([\"x\"]))","expr2:Expr \u003d mk_BinaryExpr(expr, \u003cNUMPLUS\u003e, expr)","SeqOfSetOf2SetOfSeqOf (seq of (set of ((BlkEnv | VAL))) \u003d\u003d\u003e set of (seq of ((BlkEnv | VAL))))\n\tSeqOfSetOf2SetOfSeqOf(seq_ls) \u003d\u003d\n(\nres_s:set of (seq of ((BlkEnv | VAL))) :\u003d {[]}\ntmpres_s:set of (seq of ((BlkEnv | VAL))) :\u003d (undefined)\n\nfor in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 14:7tmp_sADefPatternBind[tmp_s \u003d set of ((BlkEnv | VAL))]ADefPatternBind in seq_ls do\n(\n\ntmpres_s :\u003d {};\nfor all tmp_l in set res_s do\nfor all e in set tmp_s do\ntmpres_s :\u003d (tmpres_s union {(tmp_l ^ [e])});\nres_s :\u003d tmpres_s\n);\nreturn (res_s)\n)","private Consistent: (LVAL * Model -\u003e LVAL)\n\tConsistent(lval, bind) \u003d\u003d\n{mk_(val, (b munion bind)) | mk_(val, b) in set lval \u0026 (forall id in set ((dom b) inter (dom bind)) \u0026 (b(id) \u003d bind(id)))}","private SetToSeq: (set of (VAL) +\u003e seq of (VAL))\n\tSetToSeq(s) \u003d\u003d\n(if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ SetToSeq((s \\ {e}))))\n\tpost (s \u003d (elems RESULT))","private Permute: (seq of (VAL) -\u003e set of (seq of (VAL)))\n\tPermute(l) \u003d\u003d\n(cases l :\n[] -\u003e {l},\n[-] -\u003e {l}\nothers (dunion {{([l(i)] ^ j) | j in set Permute(RestSeq(l, i))} | i in set (inds l)})\n end)","private RestSeq: (seq of (VAL) * nat1 -\u003e seq of (VAL))\n\tRestSeq(l, i) \u003d\u003d\n[l(j) | j in set ((inds l) \\ {i})]","private PatternIds: (Pattern +\u003e set of (UniqueId))\n\tPatternIds(pat) \u003d\u003d\n(cases pat :\nmk_PatternName(mk_(nm, pos)) -\u003e {mk_(nm, pos, FnInfo())},\nmk_MatchVal(-) -\u003e {},\nmk_SetEnumPattern(els) -\u003e (dunion {PatternIds(elem) | elem in set (elems els)}),\nmk_SetUnionPattern(lp, rp) -\u003e (PatternIds(lp) union PatternIds(rp))\n end)","ENVL \u003d ENVL","ENV \u003d ENV","BlkEnv \u003d BlkEnv","NameVal \u003d NameVal","UniqueId \u003d UniqueId","LVAL \u003d LVAL","Model \u003d Model","VAL \u003d VAL","NUM \u003d NUM","BOOL \u003d BOOL","SET \u003d SET","state Sigmaof\n[env_l : ENVL, val_m : map (UniqueId) to (LVAL), fn_m : map (Name) to ((Pattern * Expr)), curfn : seq of ((Name * VAL)), fnparms : set of (UniqueId)]\n\tinit s \u003d\u003d (s \u003d mk_Sigma([[]], {|-\u003e}, {|-\u003e}, [], {}))","CreateContext (Definitions \u003d\u003d\u003e ())\n\tCreateContext(mk_Definitions(valuem, fnm)) \u003d\u003d\n(\n\nInstallValueDefs(valuem);\nInstallFnDefs(fnm)\n)","InstallValueDefs (seq of (ValueDef) \u003d\u003d\u003e ())\n\tInstallValueDefs(val_l) \u003d\u003d\nfor in \u0027DEFAULT\u0027 (env.vdmsl) at line 152:9mk_ValueDef(pat, expr)ADefPatternBind[expr \u003d Expr, pat \u003d Pattern]ADefPatternBind in val_l do\nlet lval:LVAL \u003d LooseEvalExpr(expr) in for all mk_(val, model) in set lval do\nlet env_s:set of (BlkEnv) \u003d PatternMatch(pat, val) in val_m :\u003d Extend(val_m, {id |-\u003e {mk_(Look(env, id), model) | env in set env_s} | id in set (dinter {SelDom(env) | env in set env_s})})","InstallFnDefs (map (Name) to (ExplFnDef) \u003d\u003d\u003e ())\n\tInstallFnDefs(fn_marg) \u003d\u003d\nfn_m :\u003d {nm |-\u003e mk_((fn_marg(nm).pat), (fn_marg(nm).body)) | nm in set (dom fn_marg)}","InstallCurFn (Name * VAL * set of (UniqueId) \u003d\u003d\u003e ())\n\tInstallCurFn(nm, val, patids) \u003d\u003d\n(\n\ncurfn :\u003d ([mk_(nm, val)] ^ curfn);\nfnparms :\u003d (fnparms union patids)\n)","LeaveCurFn (() \u003d\u003d\u003e ())\n\tLeaveCurFn() \u003d\u003d\ncurfn :\u003d (tl curfn)\n\tpre (curfn \u003c\u003e [])","PopEnvL (() \u003d\u003d\u003e ())\n\tPopEnvL() \u003d\u003d\nenv_l :\u003d (tl env_l)","TopEnvL (() \u003d\u003d\u003e ENV)\n\tTopEnvL() \u003d\u003d\nreturn ((hd env_l))","PushEmptyEnv (() \u003d\u003d\u003e ())\n\tPushEmptyEnv() \u003d\u003d\nenv_l :\u003d ([[]] ^ env_l)","PopBlkEnv (() \u003d\u003d\u003e ())\n\tPopBlkEnv() \u003d\u003d\nenv_l :\u003d ([(tl (hd env_l))] ^ (tl env_l))","PushBlkEnv (BlkEnv \u003d\u003d\u003e ())\n\tPushBlkEnv(benv) \u003d\u003d\nenv_l :\u003d ([([benv] ^ (hd env_l))] ^ (tl env_l))","MkEmptyBlkEnv (() \u003d\u003d\u003e BlkEnv)\n\tMkEmptyBlkEnv() \u003d\u003d\nreturn ([])","CombineBlkEnv (BlkEnv * BlkEnv \u003d\u003d\u003e BlkEnv)\n\tCombineBlkEnv(env1, env2) \u003d\u003d\nreturn ((env1 ^ env2))","MkBlkEnv ((Name * Position) * VAL \u003d\u003d\u003e BlkEnv)\n\tMkBlkEnv(mk_(nm, pos), val_v) \u003d\u003d\nlet fninfo:[(Name * VAL)] \u003d FnInfo() in return ([mk_(mk_(nm, pos, fninfo), val_v)])","FnInfo (() \u003d\u003d\u003e [(Name * VAL)])\n\tFnInfo() \u003d\u003d\nif ((len curfn) \u003d 0)\nthen\nreturn (nil)else\nreturn ((hd curfn))","LooseLookUp (Name \u003d\u003d\u003e LVAL)\n\tLooseLookUp(nm) \u003d\u003d\n(\n\nlet topenv:ENV \u003d TopEnvL() in for in \u0027DEFAULT\u0027 (env.vdmsl) at line 241:10envADefPatternBind[env \u003d BlkEnv]ADefPatternBind in topenv do\nfor in \u0027DEFAULT\u0027 (env.vdmsl) at line 242:12mk_(id, val)ADefPatternBind[id \u003d UniqueId, val \u003d VAL]ADefPatternBind in env do\nif (SelName(id) \u003d nm)\nthen\nreturn ({mk_(val, (if (id in set fnparms)\nthen {|-\u003e}\nelse {id |-\u003e val}))})else\nskip;\nLookUpValueDefs(nm)\n)","LookUpValueDefs (Name \u003d\u003d\u003e LVAL)\n\tLookUpValueDefs(nm) \u003d\u003d\n(\n\nfor all id in set (dom val_m) do\nif (SelName(id) \u003d nm)\nthen\nreturn ({mk_(v, (m munion {id |-\u003e v})) | mk_(v, m) in set val_m(id)});\nerror\n)","LookUpFn (Name \u003d\u003d\u003e (Pattern * Expr))\n\tLookUpFn(nm) \u003d\u003d\nreturn (fn_m(nm))\n\tpre (nm in set (dom fn_m))","private SelName: (UniqueId +\u003e Name)\n\tSelName(mk_(nm, -, -)) \u003d\u003d\nnm","private SelNameAndPos: (UniqueId +\u003e (Name * Position))\n\tSelNameAndPos(mk_(nm, pos, -)) \u003d\u003d\nmk_(nm, pos)","private SelDom: (BlkEnv +\u003e set of (UniqueId))\n\tSelDom(blkenv) \u003d\u003d\n{id | mk_(id, -) in set (elems blkenv)}","private Look: (BlkEnv * UniqueId +\u003e VAL)\n\tLook(env, id) \u003d\u003d\n(if (env \u003d [])\nthen (undefined)\nelse let mk_(nm, val):NameVal \u003d (hd env) in (if (nm \u003d id)\nthen val\nelse Look((tl env), id)))\n\tpre (exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id))","private Extend: (map (UniqueId) to (LVAL) * map (UniqueId) to (LVAL) +\u003e map (UniqueId) to (LVAL))\n\tExtend(val_m, upd_m) \u003d\u003d\n(val_m ++ {id |-\u003e (if (id in set (dom val_m))\nthen (val_m(id) union upd_m(id))\nelse upd_m(id)) | id in set (dom upd_m)})","LooseEvalExpr (Expr \u003d\u003d\u003e LVAL)\n\tLooseEvalExpr(expr) \u003d\u003d\ncases true :\n  (is_(expr, LetExpr)) -\u003e LooseEvalLetExpr(expr)  (is_(expr, LetBeSTExpr)) -\u003e LooseEvalLetBeSTExpr(expr)  (is_(expr, IfExpr)) -\u003e LooseEvalIfExpr(expr)  (is_(expr, CasesExpr)) -\u003e LooseEvalCasesExpr(expr)  (is_(expr, BinaryExpr)) -\u003e LooseEvalBinaryExpr(expr)  (is_(expr, SetEnumerationExpr)) -\u003e LooseEvalSetEnumerationExpr(expr)  (is_(expr, ApplyExpr)) -\u003e LooseEvalApplyExpr(expr)  (is_(expr, NumLit)) -\u003e LooseEvalLiteral(expr)  (is_(expr, BoolLit)) -\u003e LooseEvalLiteral(expr)  (is_(expr, Name)) -\u003e LooseLookUp(expr)  (is_(expr, BracketedExpr)) -\u003e LooseEvalBracketedExpr(expr)  others -\u003e error end","LooseEvalBracketedExpr (BracketedExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalBracketedExpr(mk_BracketedExpr(expr)) \u003d\u003d\nLooseEvalExpr(expr)","LooseEvalLetExpr (LetExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalLetExpr(mk_LetExpr(pat, expr, in_e)) \u003d\u003d\n(\nlval:LVAL :\u003d {}\n\nlet val_lv:LVAL \u003d LooseEvalExpr(expr) in for all mk_(val_v, m) in set val_lv do\nlet env_s:set of (BlkEnv) \u003d PatternMatch(pat, val_v) in if (env_s \u003c\u003e {})\nthen\nfor all env in set env_s do\n(\n\nPushBlkEnv(env);\nlet in_lv:LVAL \u003d LooseEvalExpr(in_e) in (\n\nPopBlkEnv();\nlval :\u003d (lval union Consistent(in_lv, m))\n)\n)else\nerror;\nreturn (lval)\n)","LooseEvalLetBeSTExpr (LetBeSTExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalLetBeSTExpr(mk_LetBeSTExpr(lhs, st_e, in_e)) \u003d\u003d\n(\nlval:LVAL :\u003d {}\nem_s:set of ((BlkEnv * Model)) :\u003d {}\n\nfor all mk_(env, m) in set EvalBind(lhs) do\n(\n\nPushBlkEnv(env);\nlet st_lv:LVAL \u003d LooseEvalExpr(st_e) in for all mk_(val, m2) in set Consistent(st_lv, m) do\nif (val \u003d mk_BOOL(true))\nthen\nem_s :\u003d (em_s union {mk_(env, (m2 munion m))});\nPopBlkEnv()\n);\nif (em_s \u003c\u003e {})\nthen\nfor all mk_(env, m3) in set em_s do\n(\n\nPushBlkEnv(env);\nlet in_lv:LVAL \u003d LooseEvalExpr(in_e) in (\n\nPopBlkEnv();\nlval :\u003d (lval union Consistent(in_lv, m3))\n)\n)else\nerror;\nreturn (lval)\n)","LooseEvalIfExpr (IfExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalIfExpr(mk_IfExpr(test, cons, altn)) \u003d\u003d\n(\nlval:set of ((VAL * Model)) :\u003d {}\n\nlet test_lv:LVAL \u003d LooseEvalExpr(test) in for all mk_(test_v, m) in set test_lv do\nif is_(test_v, BOOL)\nthen\nlet mk_BOOL(b):BOOL \u003d test_v in if b\nthen\nlval :\u003d (lval union Consistent(LooseEvalExpr(cons), m))else\nlval :\u003d (lval union Consistent(LooseEvalExpr(altn), m))else\nerror;\nreturn (lval)\n)","LooseEvalCasesExpr (CasesExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalCasesExpr(mk_CasesExpr(sel, altns, Others)) \u003d\u003d\n(\nlval:set of ((VAL * Model)) :\u003d {}\nalt_l:seq of (CaseAltn) :\u003d altns\ncont:bool :\u003d true\n\nlet sel_lv:LVAL \u003d LooseEvalExpr(sel) in for all mk_(sel_v, m) in set sel_lv do\n(\n\nwhile ((alt_l \u003c\u003e []) and cont) do (\n\nlet mk_CaseAltn(pat, body):CaseAltn \u003d (hd alt_l) in let env_s:set of (BlkEnv) \u003d PatternMatch(pat, sel_v) in if (env_s \u003c\u003e {})\nthen\n(\n\ncont :\u003d false;\nfor all env in set env_s do\n(\n\nPushBlkEnv(env);\nlval :\u003d (lval union Consistent(LooseEvalExpr(body), m));\nPopBlkEnv()\n)\n);\nalt_l :\u003d (tl alt_l)\n);\nif (not cont)\nthen\ncont :\u003d trueelseif (Others \u003d nil)\nthen\nerrorelse\nlval :\u003d (lval union LooseEvalExpr(Others))\n);\nreturn (lval)\n)","LooseEvalBinaryExpr (BinaryExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalBinaryExpr(mk_BinaryExpr(left_e, opr, right_e)) \u003d\u003d\nlet left_lv:LVAL \u003d LooseEvalExpr(left_e), right_lv:LVAL \u003d LooseEvalExpr(right_e) in if (opr \u003d \u003cSETMINUS\u003e)\nthen\nLooseEvalSetBinaryExpr(left_lv, right_lv)elseif (opr \u003d \u003cEQ\u003e)\nthen\nLooseEvalEqBinaryExpr(left_lv, right_lv)else\nLooseEvalNumBinaryExpr(left_lv, opr, right_lv)","LooseEvalSetBinaryExpr (LVAL * LVAL \u003d\u003d\u003e LVAL)\n\tLooseEvalSetBinaryExpr(l_lv, r_lv) \u003d\u003d\n(\nlval:LVAL :\u003d {}\n\nfor all mk_(mk_SET(lv), lm) in set l_lv do\nfor all mk_(mk_SET(rv), rm) in set Consistent(r_lv, lm) do\nlval :\u003d (lval union {mk_(mk_SET((lv \\ rv)), (rm munion lm))});\nreturn (lval)\n)\n\tpre (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, SET))","LooseEvalEqBinaryExpr (LVAL * LVAL \u003d\u003d\u003e LVAL)\n\tLooseEvalEqBinaryExpr(l_lv, r_lv) \u003d\u003d\n(\nlval:LVAL :\u003d {}\n\nfor all mk_(lv, lm) in set l_lv do\nfor all mk_(rv, rm) in set Consistent(r_lv, lm) do\nlval :\u003d (lval union {mk_(mk_BOOL((lv \u003d rv)), (rm munion lm))});\nreturn (lval)\n)","LooseEvalNumBinaryExpr (LVAL * BinaryOp * LVAL \u003d\u003d\u003e LVAL)\n\tLooseEvalNumBinaryExpr(l_lv, opr, r_lv) \u003d\u003d\n(\nlval:LVAL :\u003d {}\n\nfor all mk_(mk_NUM(lv), lm) in set l_lv do\nfor all mk_(mk_NUM(rv), rm) in set Consistent(r_lv, lm) do\ncases opr :\n  \u003cNUMMINUS\u003e -\u003e lval :\u003d (lval union {mk_(mk_NUM((lv - rv)), (rm munion lm))})  \u003cNUMPLUS\u003e -\u003e lval :\u003d (lval union {mk_(mk_NUM((lv + rv)), (rm munion lm))})  \u003cNUMMULT\u003e -\u003e lval :\u003d (lval union {mk_(mk_NUM((lv * rv)), (rm munion lm))}) end;\nreturn (lval)\n)\n\tpre (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM))","LooseEvalSetEnumerationExpr (SetEnumerationExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalSetEnumerationExpr(mk_SetEnumerationExpr(els)) \u003d\u003d\n(\nsm_s:set of ((set of (VAL) * Model)) :\u003d {}\n\nif ((len els) \u003d 0)\nthen\nreturn ({mk_(mk_SET({}), {|-\u003e})})else\n(\n\nsm_s :\u003d {mk_({elem}, m) | mk_(elem, m) in set LooseEvalExpr(els(1))};\nfor index \u003d 2 to (len els)\nlet elm_llv:LVAL \u003d LooseEvalExpr(els(index)) in sm_s :\u003d {mk_((s union {e}), (m munion m2)) | mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 (forall id in set ((dom m) inter (dom m2)) \u0026 (m(id) \u003d m2(id)))};\nreturn ({mk_(mk_SET(s), m) | mk_(s, m) in set sm_s})\n)\n)","LooseEvalApplyExpr (ApplyExpr \u003d\u003d\u003e LVAL)\n\tLooseEvalApplyExpr(mk_ApplyExpr(fct_e, arg_e)) \u003d\u003d\n(\nlval:LVAL :\u003d {}\n\nlet arg_lv:LVAL \u003d LooseEvalExpr(arg_e), mk_(pat, body):(Pattern * Expr) \u003d LookUpFn(fct_e) in (\n\nPushEmptyEnv();\nfor all mk_(arg_v, m) in set arg_lv do\nlet env_s:set of (BlkEnv) \u003d PatternMatch(pat, arg_v) in (\n\nInstallCurFn(fct_e, arg_v, PatternIds(pat));\nfor all env in set env_s do\n(\n\nPushBlkEnv(env);\nlet ap_lv:LVAL \u003d LooseEvalExpr(body) in (\n\nPopBlkEnv();\nlval :\u003d (lval union Consistent(ap_lv, m))\n)\n)\n);\nLeaveCurFn()\n);\nPopEnvL();\nreturn (lval)\n)","LooseEvalLiteral (Literal \u003d\u003d\u003e LVAL)\n\tLooseEvalLiteral(lit) \u003d\u003d\nreturn ((if is_(lit, NumLit)\nthen {mk_(mk_NUM((lit.val)), {|-\u003e})}\nelse {mk_(mk_BOOL((lit.val)), {|-\u003e})}))","PatternMatch (Pattern * VAL \u003d\u003d\u003e set of (BlkEnv))\n\tPatternMatch(pat_p, val_v) \u003d\u003d\ncases true :\n  (is_(pat_p, PatternName)) -\u003e let mk_PatternName(id):Pattern \u003d pat_p in return ({MkBlkEnv(id, val_v)})  (is_(pat_p, MatchVal)) -\u003e let lval:LVAL \u003d LooseEvalExpr((pat_p.val)) in (\n\nfor all mk_(v, m) in set lval do\nif (v \u003d val_v)\nthen\nreturn ({MkEmptyBlkEnv()});\nreturn ({})\n)  (is_(pat_p, SetEnumPattern)) -\u003e MatchSetEnumPattern(pat_p, val_v)  (is_(pat_p, SetUnionPattern)) -\u003e MatchSetUnionPattern(pat_p, val_v)  others -\u003e error end","MatchSetEnumPattern (SetEnumPattern * VAL \u003d\u003d\u003e set of (BlkEnv))\n\tMatchSetEnumPattern(mk_SetEnumPattern(elems_lp), val_v) \u003d\u003d\nif is_(val_v, SET)\nthen\nlet mk_SET(val_sv):SET \u003d val_v in if ((card val_sv) \u003d (card (elems elems_lp)))\nthen\nlet perm_slv:set of (seq of (VAL)) \u003d Permute(SetToSeq(val_sv)) in return ((dunion {MatchLists(elems_lp, tmp_lv) | tmp_lv in set perm_slv}))else\nreturn ({})else\nreturn ({})","MatchSetUnionPattern (SetUnionPattern * VAL \u003d\u003d\u003e set of (BlkEnv))\n\tMatchSetUnionPattern(mk_SetUnionPattern(lp_p, rp_p), val_v) \u003d\u003d\n(\nenvres_sl:set of (BlkEnv) :\u003d {}\n\nif is_(val_v, SET)\nthen\nlet mk_SET(val_sv):SET \u003d val_v in (\n\nfor all mk_(setl_sv, setr_sv) in set {mk_(setl_sv, setr_sv) | setl_sv, setr_sv in set (power val_sv) \u0026 (((setl_sv union setr_sv) \u003d val_sv) and ((setl_sv inter setr_sv) \u003d {}))} do\nlet envl_s:set of (BlkEnv) \u003d PatternMatch(lp_p, mk_SET(setl_sv)), envr_s:set of (BlkEnv) \u003d PatternMatch(rp_p, mk_SET(setr_sv)) in if ((envl_s \u003c\u003e {}) and (envr_s \u003c\u003e {}))\nthen\nlet tmpenv:set of (BlkEnv) \u003d {CombineBlkEnv(tmp1, tmp2) | tmp1 in set envl_s, tmp2 in set envr_s} in envres_sl :\u003d (envres_sl union UnionMatch(tmpenv));\nreturn (envres_sl)\n)else\nreturn ({})\n)","MatchLists (seq of (Pattern) * seq of (VAL) \u003d\u003d\u003e set of (BlkEnv))\n\tMatchLists(els_lp, val_lv) \u003d\u003d\nlet tmp_ls:seq of (set of (BlkEnv)) \u003d [PatternMatch(els_lp(i), val_lv(i)) | i in set (inds els_lp)] in if ({} not in set (elems tmp_ls))\nthen\nlet perm_s:set of (seq of ((BlkEnv | VAL))) \u003d SeqOfSetOf2SetOfSeqOf(tmp_ls) in UnionMatch({(conc l) | l in set perm_s})else\nreturn ({})","UnionMatch (set of (BlkEnv) \u003d\u003d\u003e set of (BlkEnv))\n\tUnionMatch(blk_sl) \u003d\u003d\nreturn ({StripDoubles(blk_l) | blk_l in set blk_sl \u0026 (forall mk_(id1, v1_v) in set (elems blk_l), mk_(id2, v2_v) in set (elems blk_l) \u0026 ((SelName(id1) \u003d SelName(id2)) \u003d\u003e (v1_v \u003d v2_v)))})","StripDoubles (BlkEnv \u003d\u003d\u003e BlkEnv)\n\tStripDoubles(blk_l) \u003d\u003d\n(\ntmpblk_l:BlkEnv :\u003d blk_l\nres_l:BlkEnv :\u003d []\n\nwhile (tmpblk_l \u003c\u003e []) do let mk_(id, val_v):NameVal \u003d (hd tmpblk_l) in (\n\nif (not (exists mk_(id1, -) in set (elems (tl tmpblk_l)) \u0026 (id1 \u003d id)))\nthen\nres_l :\u003d CombineBlkEnv(res_l, MkBlkEnv(SelNameAndPos(id), val_v));\ntmpblk_l :\u003d (tl tmpblk_l)\n);\nreturn (res_l)\n)","EvalBind (Bind \u003d\u003d\u003e set of ((BlkEnv * Model)))\n\tEvalBind(bind) \u003d\u003d\nEvalSetBind(bind)","EvalSetBind (SetBind \u003d\u003d\u003e set of ((BlkEnv * Model)))\n\tEvalSetBind(mk_SetBind(pat_p, set_e)) \u003d\u003d\n(\nenv_s:set of ((BlkEnv * Model)) :\u003d {}\n\nlet set_lv:LVAL \u003d LooseEvalExpr(set_e) in (\n\nfor all mk_(set_v, m) in set set_lv do\n(\n\nif is_(set_v, SET)\nthen\nlet mk_SET(set_sv):SET \u003d set_v in (\n\nfor all elm_v in set set_sv do\n(\n\nlet new_envs:set of (BlkEnv) \u003d PatternMatch(pat_p, elm_v) in env_s :\u003d (env_s union {mk_(env, m) | env in set new_envs})\n)\n)else\nerror\n);\nreturn (env_s)\n)\n)"]