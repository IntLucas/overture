["class AVLTree is subclass of [Tree]\nprivate  private tree_isAVLTree: (tree -\u003e bool)\n\ttree_isAVLTree(t) \u003d\u003d\ntrue\nend AVLTree\n","class BinarySearchTree is subclass of [Tree]\npublic  public isBst: (tree -\u003e bool)\n\tisBst(t) \u003d\u003d\n(cases t :\n\u003cEmpty\u003e -\u003e true,\nmk_node(lt, v, rt) -\u003e ((forall n in set (lt.nodes)() \u0026 ((n.nval) \u003c\u003d v)) and ((forall n in set (rt.nodes)() \u0026 (v \u003c\u003d (n.nval))) and (isBst((lt.gettree)()) and isBst((rt.gettree)()))))\n end)\nprivate  BinarySearchTree_inv() (() \u003d\u003d\u003e bool)\n\tBinarySearchTree_inv()() \u003d\u003d\nreturn (isBst(root))\npublic  Insert(int) (int \u003d\u003d\u003e ())\n\tInsert(int)(x) \u003d\u003d\n(\ncurr_node:Tree :\u003d self\n\nwhile (not (curr_node.isEmpty)()) do if ((curr_node.rootval)() \u003c x)\nthen\ncurr_node :\u003d (curr_node.rightBranch)()else\ncurr_node :\u003d (curr_node.leftBranch)();\ncurr_node.addRoot(x)\n)\nend BinarySearchTree\n","class BalancedBST is subclass of [BinarySearchTree]\nprivate static  v:nat1 \u003d 1\nend BalancedBST\n","class Queue\nprivate  vals:seq of (node) :\u003d []\npublic  Enqueue(node) (node \u003d\u003d\u003e ())\n\tEnqueue(node)(x) \u003d\u003d\nvals :\u003d (vals ^ [x])\npublic  Dequeue() (() \u003d\u003d\u003e node)\n\tDequeue()() \u003d\u003d\nlet x \u003d (hd vals) in (\n\nvals :\u003d (tl vals);\nreturn (x)\n)\n\tpre (not isEmpty())\npublic  isEmpty() (() \u003d\u003d\u003e bool)\n\tisEmpty()() \u003d\u003d\nreturn ((vals \u003d []))\nend Queue\n","class Tree\npublic static  tree \u003d tree\npublic static  node \u003d node\nprotected  root:tree :\u003d \u003cEmpty\u003e\nprotected  nodes() (() \u003d\u003d\u003e set of (node))\n\tnodes()() \u003d\u003d\ncases root :\n  \u003cEmpty\u003e -\u003e return ({})  mk_node(lt, v, rt) -\u003e return (((lt.nodes)() union (rt.nodes)()))  others -\u003e error end\nprotected  addRoot(int) (int \u003d\u003d\u003e ())\n\taddRoot(int)(x) \u003d\u003d\nroot :\u003d mk_node(new Tree(), x, new Tree())\nprotected  rootval() (() \u003d\u003d\u003e int)\n\trootval()() \u003d\u003d\nreturn ((root.nval))\n\tpre (root \u003c\u003e \u003cEmpty\u003e)\nprotected  gettree() (() \u003d\u003d\u003e tree)\n\tgettree()() \u003d\u003d\nreturn (root)\nprotected  leftBranch() (() \u003d\u003d\u003e Tree)\n\tleftBranch()() \u003d\u003d\nreturn ((root.lt))\n\tpre (not isEmpty())\nprotected  rightBranch() (() \u003d\u003d\u003e Tree)\n\trightBranch()() \u003d\u003d\nreturn ((root.rt))\n\tpre (not isEmpty())\npublic  isEmpty() (() \u003d\u003d\u003e bool)\n\tisEmpty()() \u003d\u003d\nreturn ((root \u003d \u003cEmpty\u003e))\npublic  breadth_first_search() (() \u003d\u003d\u003e seq of (int))\n\tbreadth_first_search()() \u003d\u003d\nif isEmpty()\nthen\nreturn ([])else\n(\nto_visit:Queue :\u003d new Queue()\nvisited:seq of (int) :\u003d []\n\nto_visit.Enqueue(gettree());\nwhile (not (to_visit.isEmpty)()) do let curr_node \u003d (to_visit.Dequeue)() in (\n\nvisited :\u003d (visited ^ [(curr_node.nval)]);\nif (not ((curr_node.lt).isEmpty)())\nthen\nto_visit.Enqueue(((curr_node.lt).gettree)());\nif (not ((curr_node.rt).isEmpty)())\nthen\nto_visit.Enqueue(((curr_node.rt).gettree)())\n);\nreturn (visited)\n)\npublic  depth_first_search() (() \u003d\u003d\u003e seq of (int))\n\tdepth_first_search()() \u003d\u003d\ncases root :\n  \u003cEmpty\u003e -\u003e return ([])  mk_node(lt, v, rt) -\u003e let ln:seq of (int) \u003d (lt.depth_first_search)(), rn:seq of (int) \u003d (rt.depth_first_search)() in return ((([v] ^ ln) ^ rn))  others -\u003e error end\npublic  inorder() (() \u003d\u003d\u003e seq of (int))\n\tinorder()() \u003d\u003d\ncases root :\n  \u003cEmpty\u003e -\u003e return ([])  mk_node(lt, v, rt) -\u003e let ln:seq of (int) \u003d (lt.inorder)(), rn:seq of (int) \u003d (rt.inorder)() in return (((ln ^ [v]) ^ rn))  others -\u003e error end\nend Tree\n","class UseTree\nprivate  t1:BinarySearchTree :\u003d new BinarySearchTree()\nprivate  t2:Tree :\u003d new BinarySearchTree()\npublic  [insertion_BST][[([[n in set {1, ... ,5}ALetBeStBindingTraceDefinitiont1.Insert(n){1,1}def n in set {1, ... ,5}]]){2,2}], [([[t1.breadth_first_search(){1,1}, t1.depth_first_search(){1,1}, t1.inorder(){1,1}, t1.isEmpty(){1,1}]]){1,1}]]\nend UseTree\n"]