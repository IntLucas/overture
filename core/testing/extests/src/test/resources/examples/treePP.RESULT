["class AllocatorOneTray is subclass of [AllocatorStrategy]\npublic  AllocatorOneTray(TrayAllocator) (TrayAllocator \u003d\u003d\u003e AllocatorOneTray)\n\tAllocatorOneTray(TrayAllocator)(ta) \u003d\u003d\n(\n\ntrayAllocator :\u003d ta\n)\npublic  AllocateTray(nat) (nat \u003d\u003d\u003e set of (Tray))\n\tAllocateTray(nat)(icid) \u003d\u003d\nlet posTray \u003d InductionOffset((trayAllocator.trayAtCardReader), icid) in if ((trayAllocator.sorterRing)(posTray).IsTrayEmpty)()\nthen\nreturn ({(trayAllocator.sorterRing)(posTray)})else\nreturn ({})\n\tpre (icid in set (inds (trayAllocator.inductionGroup)))\npublic  InductionsWithHigherPriority(InductionController) (InductionController \u003d\u003d\u003e bool)\n\tInductionsWithHigherPriority(InductionController)(ic) \u003d\u003d\nreturn ((exists i in set (elems ((trayAllocator.inductionGroup)(1, ... ,(len (trayAllocator.inductionGroup))))) \u0026 (((i.GetId)() \u003c\u003e (ic.GetId)()) and ((i.GetPriority)() \u003e (ic.GetPriority)()))))\n\tpre (ic in set (elems (trayAllocator.inductionGroup)))\nend AllocatorOneTray\n","class AllocatorStrategy\nprotected  trayAllocator:[TrayAllocator] :\u003d nil\npublic  AllocateTray(nat) (nat \u003d\u003d\u003e set of (Tray))\n\tAllocateTray(nat)(-) \u003d\u003d\nis subclass responsibility\npublic  InductionsWithHigherPriority(InductionController) (InductionController \u003d\u003d\u003e bool)\n\tInductionsWithHigherPriority(InductionController)(ic) \u003d\u003d\nis subclass responsibility\nprotected  protected InductionOffset: (UID * nat -\u003e UID)\n\tInductionOffset(trayAtCardReader, icid) \u003d\u003d\n(((trayAtCardReader + (icid * TrayAllocator`InductionSeperation)) mod TrayAllocator`NumOfTrays) + 1)\nend AllocatorStrategy\n","class AllocatorTwoTray is subclass of [AllocatorStrategy]\npublic  AllocatorTwoTray(TrayAllocator) (TrayAllocator \u003d\u003d\u003e AllocatorTwoTray)\n\tAllocatorTwoTray(TrayAllocator)(ta) \u003d\u003d\n(\n\ntrayAllocator :\u003d ta\n)\npublic  AllocateTray(nat) (nat \u003d\u003d\u003e set of (Tray))\n\tAllocateTray(nat)(icid) \u003d\u003d\nlet posTray:UID \u003d InductionOffset((trayAllocator.trayAtCardReader), icid), posTrayNext:int \u003d (if ((posTray - 1) \u003d 0)\nthen TrayAllocator`NumOfTrays\nelse (posTray - 1)) in if (((trayAllocator.sorterRing)(posTray).IsTrayEmpty)() and ((trayAllocator.sorterRing)(posTrayNext).IsTrayEmpty)())\nthen\nreturn ({(trayAllocator.sorterRing)(posTray), (trayAllocator.sorterRing)(posTrayNext)})else\nreturn ({})\n\tpre (icid in set (inds (trayAllocator.inductionGroup)))\npublic  InductionsWithHigherPriority(InductionController) (InductionController \u003d\u003d\u003e bool)\n\tInductionsWithHigherPriority(InductionController)(ic) \u003d\u003d\nreturn ((exists i in set (elems ((trayAllocator.inductionGroup)(1, ... ,(len (trayAllocator.inductionGroup))))) \u0026 (((i.GetId)() \u003c\u003e (ic.GetId)()) and ((i.GetPriority)() \u003e (ic.GetPriority)()))))\n\tpre (ic in set (elems (trayAllocator.inductionGroup)))\nend AllocatorTwoTray\n","class InductionController\npublic static  InductionRate:nat \u003d 2\nprivate  priority:nat :\u003d 0\nprivate  id:nat1 :\u003d (undefined)\nprivate  allocator:TrayAllocator :\u003d (undefined)\nprivate  items:seq of (Item) :\u003d []\nprivate  stepCount:nat :\u003d 0\nprivate  inv((priority \u003e 0) \u003d\u003e ((len items) \u003e 0))\npublic  InductionController(TrayAllocator, nat) (TrayAllocator * nat \u003d\u003d\u003e InductionController)\n\tInductionController(TrayAllocator, nat)(a, n) \u003d\u003d\n(\n\nallocator :\u003d a;\nid :\u003d n\n)\npublic  GetId() (() \u003d\u003d\u003e nat)\n\tGetId()() \u003d\u003d\nreturn (id)\npublic  GetPriority() (() \u003d\u003d\u003e nat)\n\tGetPriority()() \u003d\u003d\nreturn (priority)\npublic  IsItemWaiting() (() \u003d\u003d\u003e bool)\n\tIsItemWaiting()() \u003d\u003d\nreturn ((priority \u003e 0))\npublic  GetSizeOfWaitingItem() (() \u003d\u003d\u003e nat)\n\tGetSizeOfWaitingItem()() \u003d\u003d\nif (not IsItemWaiting())\nthen\nreturn (0)else\nlet item:Item \u003d (hd items) in item.GetSizeOfTrays()\npublic  FeedItem(Item) (Item \u003d\u003d\u003e ())\n\tFeedItem(Item)(i) \u003d\u003d\nitems :\u003d (items ^ [i])\npublic  TrayStep() (() \u003d\u003d\u003e ())\n\tTrayStep()() \u003d\u003d\n(\n\nstepCount :\u003d (stepCount + 1);\nif (IsItemWaiting() or (stepCount \u003e\u003d InductionRate))\nthen\n(\n\nInductNextItem();\nstepCount :\u003d 0\n)\n)\nprivate  InductNextItem() (() \u003d\u003d\u003e ())\n\tInductNextItem()() \u003d\u003d\nlet n:nat \u003d (len items) in if (n \u003e 0)\nthen\nlet item:Item \u003d (hd items) in if (allocator.InductItem)(self, item)\nthen\n(\n\natomic (items :\u003d (tl items), priority :\u003d 0)\n)else\npriority :\u003d (priority + 1)\nend InductionController\n","class Item\npublic static  ItemTraySize \u003d ItemTraySize\n\tinv it \u003d\u003d (it \u003c\u003d ItemMaxTrays)\npublic static  ItemMaxSize:nat \u003d 1500\npublic static  ItemMinSize:nat \u003d 100\npublic static  ItemMaxTrays:nat \u003d 2\nprivate  id:nat :\u003d (undefined)\nprivate  size:nat1 :\u003d (undefined)\nprivate  inv((size \u003e\u003d ItemMinSize) and (size \u003c\u003d ItemMaxSize))\nprivate  sizeOfTrays:ItemTraySize :\u003d (undefined)\nprivate  trays:set of (Tray) :\u003d {}\npublic  Item(nat1, nat) (nat1 * nat \u003d\u003d\u003e Item)\n\tItem(nat1, nat)(s, i) \u003d\u003d\n(\n\nsize :\u003d s;\nsizeOfTrays :\u003d ((size div Tray`TraySize) + 1);\nid :\u003d i\n)\npublic  GetId() (() \u003d\u003d\u003e nat)\n\tGetId()() \u003d\u003d\nreturn (id)\npublic  GetSizeOfTrays() (() \u003d\u003d\u003e ItemTraySize)\n\tGetSizeOfTrays()() \u003d\u003d\nreturn (sizeOfTrays)\npublic  GetSize() (() \u003d\u003d\u003e nat)\n\tGetSize()() \u003d\u003d\nreturn (size)\npublic  AssignItemToTray(Tray) (Tray \u003d\u003d\u003e ())\n\tAssignItemToTray(Tray)(tray) \u003d\u003d\ntrays :\u003d (trays union {tray})\npublic  RemoveItemFromTray()()\n\text [wr[trays]set of (Tray)]\n\tpost (trays \u003d {})\nend Item\n","class ItemLoader\nprivate static  inline \u003d inline\nprivate static  InputTP \u003d InputTP\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d [mk_(0, 1, 100), mk_(0, 2, 800), mk_(0, 3, 200), mk_(2, 1, 200), mk_(2, 2, 400), mk_(2, 3, 700), mk_(4, 1, 800), mk_(4, 2, 300), mk_(4, 3, 400), mk_(6, 1, 600), mk_(6, 2, 400), mk_(6, 3, 300), mk_(8, 1, 900), mk_(8, 2, 300), mk_(8, 3, 200), mk_(10, 1, 500), mk_(10, 2, 300), mk_(10, 3, 200)]\nprivate  numTimeSteps:nat :\u003d 21\npublic  ItemLoader(seq1 of (char)) (seq1 of (char) \u003d\u003d\u003e ItemLoader)\n\tItemLoader(seq1 of (char))(fname) \u003d\u003d\n(\n\nlet mk_(-, mk_(timeval, input)) \u003d ((io.freadval))[InputTP](fname) in (\n\nnumTimeSteps :\u003d timeval;\ninlines :\u003d input\n)\n)\npublic  GetNumTimeSteps() (() \u003d\u003d\u003e nat)\n\tGetNumTimeSteps()() \u003d\u003d\nreturn (numTimeSteps)\npublic  GetItemAtTimeStep(nat, nat1) (nat * nat1 \u003d\u003d\u003e nat)\n\tGetItemAtTimeStep(nat, nat1)(timeStep, icid) \u003d\u003d\n(\n\nlet elm:set of (inline) \u003d {e | e in set (elems inlines) \u0026 (((e.#1) \u003d timeStep) and ((e.#2) \u003d icid))} in if (elm \u003d {})\nthen\nreturn (0)else\nlet {mk_(-, -, size)}:set of (inline) \u003d elm in return (size)\n)\nend ItemLoader\n","class SC\npublic  allocator:TrayAllocator :\u003d (undefined)\npublic  SC(SorterEnviroment) (SorterEnviroment \u003d\u003d\u003e SC)\n\tSC(SorterEnviroment)(e) \u003d\u003d\n(\n\nallocator :\u003d new TrayAllocator(e)\n)\npublic  TrayStep(UID, State) (UID * State \u003d\u003d\u003e ())\n\tTrayStep(UID, State)(uid, state) \u003d\u003d\n(\n\nIO`print(((\"Card reader tray id \" ^ String`NatToStr(uid)) ^ \"\n\"));\nallocator.CardReader(uid, state)\n)\nend SC\n","class SorterEnviroment\npublic static  Speed:nat \u003d 2000\npublic static  Throughput:nat \u003d 10000\npublic  sc:SC :\u003d (undefined)\npublic  inductionGroup:seq of (InductionController) :\u003d []\nprivate  itemId:nat :\u003d 0\nprivate  itemLoader:[ItemLoader] :\u003d nil\npublic  SorterEnviroment() (() \u003d\u003d\u003e SorterEnviroment)\n\tSorterEnviroment()() \u003d\u003d\n(\n\nsc :\u003d new SC(self)\n)\npublic  AssignItemLoader(ItemLoader) (ItemLoader \u003d\u003d\u003e ())\n\tAssignItemLoader(ItemLoader)(il) \u003d\u003d\n(\n\nitemLoader :\u003d il\n)\npublic  AssignInductionGroup(seq of (InductionController)) (seq of (InductionController) \u003d\u003d\u003e ())\n\tAssignInductionGroup(seq of (InductionController))(ig) \u003d\u003d\n(\n\ninductionGroup :\u003d ig\n)\npublic  FeedItemOnInduction(nat, Item) (nat * Item \u003d\u003d\u003e ())\n\tFeedItemOnInduction(nat, Item)(ic, item) \u003d\u003d\ninductionGroup(ic).FeedItem(item)\npublic  TimeStep(nat) (nat \u003d\u003d\u003e ())\n\tTimeStep(nat)(t) \u003d\u003d\n(\n\nfor all i in set {1, ... ,TrayAllocator`NumOfInductions} do\n(\n\nlet size:nat \u003d (itemLoader.GetItemAtTimeStep)(t, i) in if (size \u003e 0)\nthen\n(\n\nitemId :\u003d (itemId + 1);\ninductionGroup(i).FeedItem(new Item(size, itemId))\n)\n);\nsc.TrayStep(((t mod TrayAllocator`NumOfTrays) + 1), \u003cEmpty\u003e);\nfor all i in set {1, ... ,TrayAllocator`NumOfInductions} do\ninductionGroup(i).TrayStep()\n)\nend SorterEnviroment\n","class String\nprivate static  numeric:seq1 of (char) :\u003d \"0123456789\"\npublic static  NatToStr(nat) (nat \u003d\u003d\u003e seq1 of (char))\n\tNatToStr(nat)(val) \u003d\u003d\n(\nstring:seq1 of (char) :\u003d \" \"\nx1:nat :\u003d val\nx2:nat :\u003d (undefined)\n\nif (val \u003d 0)\nthen\nstring :\u003d \"0\";\nwhile (x1 \u003e 0) do (\n\nx2 :\u003d ((x1 mod 10) + 1);\nstring :\u003d ([numeric(x2)] ^ string);\nx1 :\u003d (x1 div 10)\n);\nreturn (string)\n)\nend String\n","class TestTraces\nprivate  env:SorterEnviroment :\u003d new SorterEnviroment()\nprivate  testfile1:seq1 of (char) :\u003d \"\\scenario1.txt\"\nprivate  loader1:ItemLoader :\u003d new ItemLoader(testfile1)\nprivate  testfile2:seq1 of (char) :\u003d \"\\scenario2.txt\"\nprivate  loader2:ItemLoader :\u003d new ItemLoader(testfile2)\nprivate  tests:set of (ItemLoader) :\u003d {loader1, loader2}\npublic  [TestSenario1][[([[loader in set testsALetBeStBindingTraceDefinition([[env.AssignItemLoader(loader){1,1}], [step in set {1, ... ,(loader.GetNumTimeSteps)()}ALetBeStBindingTraceDefinition([[env.TimeStep(step){1,1}]]){1,1}def step in set {1, ... ,(loader.GetNumTimeSteps)()}]]){1,1}def loader in set tests]]){1,1}]]\nend TestTraces\n","class Tray\npublic static  State \u003d State\npublic static  UID \u003d UID\n\tinv u \u003d\u003d (u \u003c\u003d TrayAllocator`NumOfTrays)\npublic static  TraySize:nat1 \u003d 600\nprivate  state:State :\u003d \u003cEmpty\u003e\nprivate  item:[Item] :\u003d nil\nprivate  inv((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e))\nprivate  id:UID :\u003d (undefined)\npublic  Tray(UID) (UID \u003d\u003d\u003e Tray)\n\tTray(UID)(i) \u003d\u003d\n(\n\nid :\u003d i\n)\npublic  GetId() (() \u003d\u003d\u003e nat)\n\tGetId()() \u003d\u003d\nreturn (id)\npublic  IsTrayEmpty() (() \u003d\u003d\u003e bool)\n\tIsTrayEmpty()() \u003d\u003d\nreturn ((state \u003d \u003cEmpty\u003e))\npublic  IsTrayFull() (() \u003d\u003d\u003e bool)\n\tIsTrayFull()() \u003d\u003d\nreturn ((state \u003d \u003cFull\u003e))\npublic  GetItem() (() \u003d\u003d\u003e [Item])\n\tGetItem()() \u003d\u003d\nreturn (item)\npublic  SetState(State) (State \u003d\u003d\u003e ())\n\tSetState(State)(s) \u003d\u003d\n(\n\nif (s \u003d \u003cEmpty\u003e)\nthen\nitem :\u003d nil;\nstate :\u003d s\n)\npublic  GetState() (() \u003d\u003d\u003e State)\n\tGetState()() \u003d\u003d\nreturn (state)\npublic  ItemOnTray(Item) (Item \u003d\u003d\u003e ())\n\tItemOnTray(Item)(i) \u003d\u003d\n(\n\natomic (item :\u003d i, state :\u003d \u003cFull\u003e);\nitem.AssignItemToTray(self);\nIO`print(((((((\"-\u003e Item id \" ^ String`NatToStr((item.GetId)())) ^ \"size \") ^ String`NatToStr((item.GetSize)())) ^ \"on tray id \") ^ String`NatToStr(id)) ^ \"\n\"))\n)\n\tpre ((state \u003d \u003cEmpty\u003e) and (item \u003d nil))\nend Tray\n","class TrayAllocator\npublic static  ThroughputResult \u003d ThroughputResult\npublic static  InductionSeperation:nat \u003d 2\npublic static  NumOfInductions:nat \u003d 3\npublic static  NumOfTrays:nat \u003d 20\npublic static  SecInHour:nat \u003d 3600\nprivate  inv(NumOfTrays \u003e (InductionSeperation * NumOfInductions))\nprivate  countTraySteps:nat :\u003d 0\nprivate  countItemsInducted:nat :\u003d 0\npublic  inductionGroup:seq of (InductionController) :\u003d []\nprivate  inv((len inductionGroup) \u003d NumOfInductions)\nprivate  inv(forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))\npublic  sorterRing:inmap (UID) to (Tray) :\u003d (undefined)\nprivate  inv((card (dom sorterRing)) \u003d NumOfTrays)\nprivate  inv(forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))\npublic  trayAtCardReader:UID :\u003d 0\nprivate  inv((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))\nprivate  oneTrayStrategy:AllocatorOneTray :\u003d (undefined)\nprivate  twoTrayStrategy:AllocatorTwoTray :\u003d (undefined)\npublic  TrayAllocator(SorterEnviroment) (SorterEnviroment \u003d\u003d\u003e TrayAllocator)\n\tTrayAllocator(SorterEnviroment)(e) \u003d\u003d\n(\n\nsorterRing :\u003d {num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}};\ninductionGroup :\u003d [new InductionController(self, num) | num in set {1, ... ,NumOfInductions}];\ne.AssignInductionGroup(inductionGroup);\noneTrayStrategy :\u003d new AllocatorOneTray(self);\ntwoTrayStrategy :\u003d new AllocatorTwoTray(self)\n)\npublic  CardReader(UID, State) (UID * State \u003d\u003d\u003e ())\n\tCardReader(UID, State)(uid, state) \u003d\u003d\n(\n\ntrayAtCardReader :\u003d uid;\ncountTraySteps :\u003d (countTraySteps + 1)\n)\n\tpre (uid in set (dom sorterRing))\npublic  InductItem(InductionController, Item) (InductionController * Item \u003d\u003d\u003e bool)\n\tInductItem(InductionController, Item)(ic, item) \u003d\u003d\n(\nstrategy:AllocatorStrategy :\u003d (undefined)\n\nlet numTrays:ItemTraySize \u003d (item.GetSizeOfTrays)() in cases numTrays :\n  1 -\u003e strategy :\u003d oneTrayStrategy  2 -\u003e strategy :\u003d twoTrayStrategy end;\nif (strategy.InductionsWithHigherPriority)(ic)\nthen\nreturn (false)else\nlet trays:set of (Tray) \u003d (strategy.AllocateTray)((ic.GetId)()) in if (trays \u003d {})\nthen\nreturn (false)else\n(\n\ncountItemsInducted :\u003d (countItemsInducted + 1);\nIO`print(((\"*Induction id \" ^ String`NatToStr((ic.GetId)())) ^ \"\n\"));\nPutItemOnTrays(item, trays);\nreturn (true)\n)\n)\n\tpre ((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2))\nprivate  PutItemOnTrays(Item, set of (Tray)) (Item * set of (Tray) \u003d\u003d\u003e ())\n\tPutItemOnTrays(Item, set of (Tray))(item, trays) \u003d\u003d\nfor all t in set trays do\nt.ItemOnTray(item)\n\tpre ((trays \u003c\u003e {}) and (forall t in set trays \u0026 (t.IsTrayEmpty)()))\npublic  IsSorterFull() (() \u003d\u003d\u003e bool)\n\tIsSorterFull()() \u003d\u003d\nreturn ((forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetState)() \u003d \u003cFull\u003e)))\npublic  GetThroughput() (() \u003d\u003d\u003e ThroughputResult)\n\tGetThroughput()() \u003d\u003d\nCalculateThroughput(countTraySteps, (rng sorterRing), countItemsInducted)\nprivate  private CalculateThroughput: (nat * set of (Tray) * nat -\u003e ThroughputResult)\n\tCalculateThroughput(steps, trays, items) \u003d\u003d\nlet runTime:real \u003d (steps * (Tray`TraySize / SorterEnviroment`Speed)), traysWithItems:set of (Tray) \u003d {twi | twi in set trays \u0026 (twi.IsTrayFull)()}, traysWith2Items:set of (Tray) \u003d {tw2i | tw2i in set traysWithItems \u0026 (((tw2i.GetItem)() \u003c\u003e nil) and (((tw2i.GetItem)().GetSizeOfTrays)() \u003d 2))}, itemsOnSorter:nat \u003d (card traysWithItems), twoTrayItemsOnSorter:nat \u003d (card traysWith2Items), throughput:real \u003d ((itemsOnSorter * SecInHour) / runTime) in mk_ThroughputResult(itemsOnSorter, twoTrayItemsOnSorter, steps, items, throughput)\n\tpre (trays \u003c\u003e {})\nend TrayAllocator\n","class World\nprivate  env:[SorterEnviroment] :\u003d nil\nprivate  loader:[ItemLoader] :\u003d nil\nprivate  testfile1:seq1 of (char) :\u003d \"scenario1.txt\"\nprivate  testfile2:seq1 of (char) :\u003d \"scenario2.txt\"\nprivate  testfile3:seq1 of (char) :\u003d \"scenario3.txt\"\nprivate  testfile4:seq1 of (char) :\u003d \"scenario4.txt\"\nprivate  testfile5:seq1 of (char) :\u003d \"scenario5.txt\"\nprivate  testfiles:seq of (seq1 of (char)) :\u003d [testfile1, testfile2, testfile3, testfile4, testfile5]\npublic  PrintSimulationResult() (() \u003d\u003d\u003e ())\n\tPrintSimulationResult()() \u003d\u003d\n(\n\nIO`print(\"---------------------------------------------\n\");\nIO`print(\"Simulation completed for sorter configuration\n\");\nIO`print(\"---------------------------------------------\n\");\nIO`print(((\"Specified throughput [items/hour]: \" ^ String`NatToStr(SorterEnviroment`Throughput)) ^ \"\n\"));\nIO`print(((\"Sorter speed             [mm/sec]: \" ^ String`NatToStr(SorterEnviroment`Speed)) ^ \"\n\"));\nIO`print(((\"Item max size                [mm]: \" ^ String`NatToStr(Item`ItemMaxSize)) ^ \"\n\"));\nIO`print(((\"Item min size                [mm]: \" ^ String`NatToStr(Item`ItemMinSize)) ^ \"\n\"));\nIO`print(((\"Tray size                    [mm]: \" ^ String`NatToStr(Tray`TraySize)) ^ \"\n\"));\nIO`print(((\"Number of trays                  : \" ^ String`NatToStr(TrayAllocator`NumOfTrays)) ^ \"\n\"));\nIO`print(((\"Number of inductions             : \" ^ String`NatToStr(TrayAllocator`NumOfInductions)) ^ \"\n\"));\nIO`print(((\"Induction rate                   : \" ^ String`NatToStr(InductionController`InductionRate)) ^ \"\n\"));\nIO`print(((\"Induction separation      [trays]: \" ^ String`NatToStr(TrayAllocator`InductionSeperation)) ^ \"\n\"));\nIO`print(\"----------------------------------------------\n\");\nlet r:ThroughputResult \u003d (((env.sc).allocator).GetThroughput)() in (\n\nIO`print(((\"Number of trays with items       : \" ^ String`NatToStr((r.traysWithItemOnSorter))) ^ \"\n\"));\nIO`print(((\"Two tray items on sorter         : \" ^ String`NatToStr((r.twoTrayItemsOnSorter))) ^ \"\n\"));\nIO`print(((\"Number of tray steps             : \" ^ String`NatToStr((r.traySteps))) ^ \"\n\"));\nIO`print(((\"Number of inducted items         : \" ^ String`NatToStr((r.inductedItems))) ^ \"\n\"));\nIO`print(((\"Calculated throughput[items/hour]: \" ^ String`NatToStr((floor (r.calcThroughput)))) ^ \"\n\"))\n);\nIO`print(\"----------------------------------------------\n\");\nif ((((env.sc).allocator).IsSorterFull)() \u003d true)\nthen\nIO`print(\"      ****    Sorter is full   *****\n\")else\nIO`print(\"      ****  Sorter is not full  ****\n\");\nIO`print(\"----------------------------------------------\n\")\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nfor all test in set {1, ... ,(len testfiles)} do\n(\n\nenv :\u003d new SorterEnviroment();\nloader :\u003d new ItemLoader(testfiles(test));\nenv.AssignItemLoader(loader);\nIO`print(\"---------------------------------------------\n\");\nIO`print(((((\"Tray allocation model test #\" ^ String`NatToStr(test)) ^ \": \") ^ testfiles(test)) ^ \"\n\"));\nIO`print(\"---------------------------------------------\n\");\nfor all t in set {0, ... ,(loader.GetNumTimeSteps)()} do\nenv.TimeStep(t);\nPrintSimulationResult()\n)\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]