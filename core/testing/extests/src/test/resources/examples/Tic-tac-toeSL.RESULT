["Number_of_vacancies:nat1 \u003d 5","Cand_names:set of ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e)) \u003d {\u003cAdam\u003e, \u003cBill\u003e, \u003cCharlie\u003e, \u003cDonald\u003e, \u003cEdward\u003e, \u003cFrank\u003e, \u003cGeorge\u003e, \u003cHarry\u003e, \u003cIan\u003e, \u003cJohn\u003e}","rand_choice:seq1 of ((\u003cAdam\u003e | \u003cBill\u003e | \u003cFrank\u003e | \u003cJohn\u003e)) \u003d [\u003cBill\u003e, \u003cAdam\u003e, \u003cJohn\u003e, \u003cFrank\u003e]","Votes:map ((map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cFrank\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cGeorge\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cHarry\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cIan\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cJohn\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cDonald\u003e)) to (nat1) | map ((\u003cAdam\u003e | \u003cIan\u003e)) to (nat1) | map ((\u003cBill\u003e | \u003cFrank\u003e)) to (nat1) | map ((\u003cBill\u003e | \u003cHarry\u003e)) to (nat1) | map ((\u003cCharlie\u003e | \u003cGeorge\u003e)) to (nat1) | map ((\u003cCharlie\u003e | \u003cJohn\u003e)) to (nat1))) to (nat1) \u003d {{\u003cAdam\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cFrank\u003e |-\u003e 4} |-\u003e 100000, {\u003cBill\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cGeorge\u003e |-\u003e 4} |-\u003e 100000, {\u003cAdam\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cHarry\u003e |-\u003e 4} |-\u003e 100000, {\u003cBill\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cIan\u003e |-\u003e 4} |-\u003e 100000, {\u003cCharlie\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cJohn\u003e |-\u003e 4} |-\u003e 100000, {\u003cCharlie\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cDonald\u003e |-\u003e 4} |-\u003e 100000, {\u003cDonald\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000, {\u003cFrank\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000, {\u003cGeorge\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000, {\u003cHarry\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000, {\u003cIan\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000, {\u003cJohn\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000}","Candidate_names \u003d Candidate_names","Voting_paper \u003d Voting_paper\n\tinv v \u003d\u003d (exists1 name:Candidate_names \u0026 (v(name) \u003d 1))","Parcel \u003d Parcel","Score \u003d Score","Stage \u003d Stage\n\tinv s \u003d\u003d (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e ((s(i).name) \u003c\u003e (s(j).name)))))","Value \u003d Value\n\tinv v \u003d\u003d (v \u003e\u003d 0)","Sub_parcel \u003d Sub_parcel","Candidate \u003d Candidate\n\tinv candidate \u003d\u003d ((forall ov in set (dom (candidate.original_votes)) \u0026 (((ov :\u003e {1}) \u003d {(candidate.name) |-\u003e 1}) and (({(candidate.name)} \u003c: ov) \u003d {(candidate.name) |-\u003e 1}))) and (forall sub_parcel in set (elems (candidate.transferred_votes)) \u0026 (forall tv in set (dom (sub_parcel.votes)) \u0026 ((candidate.name) in set (dom tv)))))","Sub_parcel_bundle \u003d Sub_parcel_bundle","Record_entry \u003d Record_entry","Result \u003d Result","Result_sheet \u003d Result_sheet","Candset \u003d Candset","Candnset \u003d Candnset","state Stof\n[elected : set of (Candidate), excluded : set of (Candidate), continuing : set of (Candidate), stages : seq of (Stage), quota : real, record : seq of (Record_entry), next_choice : seq of (Candidate_names)]\n\tinv s \u003d\u003d (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name))))))\n\tinit s \u003d\u003d (s \u003d mk_St({mk_Candidate(nm, {|-\u003e}, []) | nm in set Cand_names}, {}, {}, [], 42, [], []))","private mult_p_sum: (set of ((nat * Parcel)) -\u003e nat)\n\tmult_p_sum(s) \u003d\u003d\n(if (s \u003d {})\nthen 0\nelse let mk_(m, pa) in set s in (((card (dom pa)) * m) + mult_p_sum((s \\ {mk_(m, pa)}))))","private size: (Parcel -\u003e nat)\n\tsize(p) \u003d\u003d\nlet mults:set of (nat1) \u003d (rng p) in let mult_p:set of ((nat1 * Parcel)) \u003d {mk_(m, (p :\u003e {m})) | m in set mults} in mult_p_sum(mult_p)","private disjoint: (set of (set of (Candidate)) -\u003e bool)\n\tdisjoint(ss) \u003d\u003d\n(forall s1 in set ss, s2 in set ss \u0026 ((s1 \u003c\u003e s2) \u003d\u003e ((s1 inter s2) \u003d {})))","private vote_res: (Parcel * set of (Voting_paper) -\u003e Parcel)\n\tvote_res(votes, domain) \u003d\u003d\n(domain \u003c: votes)","private sort_papers: (Parcel * set of (Candidate_names) -\u003e Candset)\n\tsort_papers(votes, names) \u003d\u003d\n{mk_Candidate(name, vote_res(votes, {v | v in set (dom votes) \u0026 ((v :\u003e {1}) \u003d {name |-\u003e 1})}), []) | name in set names}","private two_decimal_places: (real -\u003e real)\n\ttwo_decimal_places(r) \u003d\u003d\nlet s:real \u003d (r * 100) in (if ((floor s) \u003d s)\nthen r\nelse (((floor s) + 1) / 100))","private stage_bk: (seq of (Score) -\u003e Score)\n\tstage_bk(s) \u003d\u003d\ns((len s))\n\tpre (s \u003c\u003e [])","private defer_transfer_of_surplus: (real * Stage -\u003e bool)\n\tdefer_transfer_of_surplus(quota, stage) \u003d\u003d\nlet lowest_value:real \u003d (stage_bk(stage).count), second_lowest_value:real \u003d (stage(((len stage) - 1)).count) in (sum([((stage(i).count) - quota) | i in set (inds stage) \u0026 ((stage(i).count) \u003e quota)]) \u003c\u003d (second_lowest_value - lowest_value))\n\tpre ((len stage) \u003e 1)","private sum: (seq of (real) -\u003e real)\n\tsum(s) \u003d\u003d\n(if (s \u003d [])\nthen 0\nelse ((hd s) + sum((tl s))))","private sole_leader: (Stage * Candidate_names * set of (Candidate_names) -\u003e bool)\n\tsole_leader(stage, name, leaders) \u003d\u003d\nlet cand:Score \u003d (iota c in set (elems stage) \u0026 ((c.name) \u003d name)) in let leading_scores:set of (Score) \u003d ({sc | sc in set (elems stage) \u0026 ((sc.name) in set leaders)} \\ {cand}) in (forall sc in set leading_scores \u0026 ((cand.count) \u003e (sc.count)))","private greatest_value_at_earliest_stage: (Candidate_names * seq of (Stage) -\u003e bool)\n\tgreatest_value_at_earliest_stage(name, all_stages) \u003d\u003d\nlet leaders:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d ((hd (hd all_stages)).count))} in (exists i in set (inds all_stages) \u0026 (sole_leader(all_stages(i), name, leaders) and (forall j in set {(i + 1), ... ,(len all_stages)}, other_leader in set leaders \u0026 (not sole_leader(all_stages(j), other_leader, leaders)))))","private surplus_from_original_votes: (Candidate -\u003e bool)\n\tsurplus_from_original_votes(candidate) \u003d\u003d\n((candidate.transferred_votes) \u003d [])","private construct_sub_parcels: (Value * Parcel * Candidate * set of (Candidate) -\u003e Sub_parcel_bundle)\n\tconstruct_sub_parcels(val, parcel, discontinuing, continuing_candidates) \u003d\u003d\nlet names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in let non_empty_sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e sub_parcel_map(n) | n in set (dom sub_parcel_map) \u0026 ((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e})} in mk_Sub_parcel_bundle(non_empty_sub_parcel_map, mk_Sub_parcel(non_transferable_papers(parcel, (discontinuing.name), names), 1.0), 0)","private non_transferable_papers: (Parcel * Candidate_names * set of (Candidate_names) -\u003e Parcel)\n\tnon_transferable_papers(parcel, disc, cont) \u003d\u003d\n({v | v in set (dom parcel) \u0026 non_transferable_paper(v, disc, cont)} \u003c: parcel)","private next_preference: (Candidate_names * Voting_paper * set of (Candidate_names) -\u003e bool)\n\tnext_preference(name, vote, continuing) \u003d\u003d\n(if (name in set (dom vote))\nthen (exists i in set (rng vote) \u0026 ((vote(name) \u003d i) and (((dom (vote :\u003e {1, ... ,(i - 1)})) inter continuing) \u003d {})))\nelse false)","private construct_bundle_for_transfer: (real * Value * Parcel * Candidate * set of (Candidate) -\u003e Sub_parcel_bundle)\n\tconstruct_bundle_for_transfer(surplus, old_value, old_votes, disc, cont_cands) \u003d\u003d\nlet new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in let sub_parcels:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel(((new_sub_parcels.sub_parcels)(n).votes), transf_val) | n in set (dom (new_sub_parcels.sub_parcels))}, loss_of_value:real \u003d calc_loss_of_value(surplus, total_val_trans_votes, total_no_of_trans_votes, old_value), non_trans_val:Value \u003d calc_non_transf_value(surplus, total_val_trans_votes) in mk_Sub_parcel_bundle(sub_parcels, mk_Sub_parcel(((new_sub_parcels.non_transferable).votes), non_trans_val), loss_of_value)","private calc_transf_value: (real * Value * Value * nat -\u003e Value)\n\tcalc_transf_value(surplus, total_value, old_value, total_no) \u003d\u003d\n(if (surplus \u003c total_value)\nthen ((floor ((100 * surplus) / total_no)) / 100)\nelse old_value)","private calc_loss_of_value: (real * Value * nat * Value -\u003e real)\n\tcalc_loss_of_value(surplus, total_value, total_number, old_value) \u003d\u003d\n(if (surplus \u003c total_value)\nthen ((surplus / total_number) - ((floor (((100 * surplus) * old_value) / total_value)) / 100))\nelse 0)","private calc_non_transf_value: (real * Value -\u003e Value)\n\tcalc_non_transf_value(surplus, total_value) \u003d\u003d\n(if (surplus \u003e total_value)\nthen (surplus - total_value)\nelse 0)","private redistribute_parcels: (Candset * Sub_parcel_bundle -\u003e Candset)\n\tredistribute_parcels(previous_collection, bundle) \u003d\u003d\n({mu(candidate, transferred_votes |-\u003e ([(bundle.sub_parcels)(n)] ^ (candidate.transferred_votes))) | candidate in set previous_collection, n in set (dom (bundle.sub_parcels)) \u0026 ((candidate.name) \u003d n)} union {candidate | candidate in set previous_collection \u0026 ((candidate.name) not in set (dom (bundle.sub_parcels)))})\n\tpre ((dom (bundle.sub_parcels)) subset {(candidate.name) | candidate in set previous_collection})","private score_sort: (Stage -\u003e Stage)\n\tscore_sort(sta) \u003d\u003d\n(cases sta :\n[] -\u003e sta,\n[e] -\u003e sta\nothers let sta1 ^ sta2 in set {sta} be st ((abs ((len sta1) - (len sta2))) \u003c 2) in let sta_l:Stage \u003d score_sort(sta1), sta_r:Stage \u003d score_sort(sta2) in score_merge(sta_l, sta_r)\n end)","private score_merge: (Stage * Stage -\u003e Stage)\n\tscore_merge(sta1, sta2) \u003d\u003d\n(cases mk_(sta1, sta2) :\nmk_([], sta) -\u003e sta,\nmk_(sta, []) -\u003e sta\nothers (if (((hd sta1).count) \u003e\u003d ((hd sta2).count))\nthen ([(hd sta1)] ^ score_merge((tl sta1), sta2))\nelse ([(hd sta2)] ^ score_merge(sta1, (tl sta2))))\n end)","private set_seq: (set of (Score) -\u003e Stage)\n\tset_seq(s) \u003d\u003d\n(if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ set_seq((s \\ {e}))))","private build_first_stage: (set of (Candidate) -\u003e Stage)\n\tbuild_first_stage(candidates) \u003d\u003d\nscore_sort(set_seq({mk_Score((candidate.name), size((candidate.original_votes))) | candidate in set candidates}))","private construct_new_stage: (Stage * Candidate_names * Sub_parcel_bundle -\u003e Stage)\n\tconstruct_new_stage(old_stage, discontinuing, bundle) \u003d\u003d\nlet cands_with_more_votes:set of (Candidate_names) \u003d (dom (bundle.sub_parcels)) in let unsorted_scores:set of (Score) \u003d ({mk_Score(name, (old_count + (((bundle.sub_parcels)(name).value) * size(((bundle.sub_parcels)(name).votes))))) | mk_Score(name, old_count) in set (elems old_stage) \u0026 (name in set cands_with_more_votes)} union {sc | sc in set (elems old_stage) \u0026 ((sc.name) not in set cands_with_more_votes)}) in score_sort(set_seq(unsorted_scores))","private exists_non_deferable_surplus: (seq of (Stage) * real -\u003e bool)\n\texists_non_deferable_surplus(stages, quota) \u003d\u003d\n((((hd (hd stages)).count) \u003e\u003d quota) and (not defer_transfer_of_surplus(quota, (hd stages))))","private trailing_candidate: (Candidate_names * seq1 of (Stage) -\u003e bool)\n\ttrailing_candidate(name, all_stages) \u003d\u003d\nlet trailing_count:real \u003d (stage_bk((hd all_stages)).count) in let lowest:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d trailing_count)} in (exists i in set (inds all_stages) \u0026 (sole_trailer(all_stages(i), name, lowest) and (forall j in set {(i + 1), ... ,(len all_stages)}, other in set lowest \u0026 (not sole_trailer(all_stages(j), other, lowest)))))","private sole_trailer: (Stage * Candidate_names * set of (Candidate_names) -\u003e bool)\n\tsole_trailer(stage, name, lowest) \u003d\u003d\nlet cand:Score \u003d (iota c in set (elems stage) \u0026 ((c.name) \u003d name)) in let lowest_scores:set of (Score) \u003d ({sc | sc in set (elems stage) \u0026 ((sc.name) in set lowest)} \\ {cand}) in (forall sc in set lowest_scores \u0026 ((cand.count) \u003c (sc.count)))","private number_of_continuing_candidates: (set of (Candidate_names) -\u003e nat)\n\tnumber_of_continuing_candidates(cands) \u003d\u003d\n(card cands)","private number_of_remaining_vacancies: (set of (Candidate_names) -\u003e nat)\n\tnumber_of_remaining_vacancies(cands) \u003d\u003d\n(Number_of_vacancies - (card cands))","private total_value: (Sub_parcel -\u003e real)\n\ttotal_value(sub_parcel) \u003d\u003d\n(size((sub_parcel.votes)) * (sub_parcel.value))","private number_of_candidates_satisfying_quota: (set of (Candidate) * seq of (Stage) * real -\u003e nat)\n\tnumber_of_candidates_satisfying_quota(continuing, stages, quota) \u003d\u003d\nlet xs_quota_scs:set of (Candidate_names) \u003d {(sc.name) | sc in set (elems (hd stages)) \u0026 ((sc.count) \u003e\u003d quota)} in (card {cand | cand in set continuing \u0026 ((cand.name) in set xs_quota_scs)})","private non_transferable_paper: (Voting_paper * Candidate_names * set of (Candidate_names) -\u003e bool)\n\tnon_transferable_paper(paper, discontinuing, continuing_names) \u003d\u003d\n((((dom (paper :-\u003e {1})) inter continuing_names) \u003d {}) or let s:set of (nat1) \u003d (rng (paper :-\u003e {1, ... ,paper(discontinuing)})) in (if (s \u003d {})\nthen true\nelse let m:real \u003d min(s) in (((card (dom (paper :\u003e {m}))) \u003e 1) or ((m - 1) not in set (rng paper)))))","private min: (set of (real) -\u003e real)\n\tmin(s) \u003d\u003d\nlet m in set s in (if ((card s) \u003d 1)\nthen m\nelse let sm:real \u003d min((s \\ {m})) in (if (m \u003c sm)\nthen m\nelse sm))\n\tpre (s \u003c\u003e {})","private last_vacancy_fillable: (set of (Candidate) * seq of (Stage) * real -\u003e bool)\n\tlast_vacancy_fillable(continuing, stages, quota) \u003d\u003d\nlet continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (exists i in set (inds continuing_scores) \u0026 ((continuing_scores(i).count) \u003e (sum([(continuing_scores(j).count) | j in set ((inds continuing_scores) \\ {i})]) + sum([((surplus_scores(j).count) - quota) | j in set (inds surplus_scores)]))))","private make_result_sheet: (seq of (Stage) * real * seq of (Record_entry) * set of (Candidate_names) -\u003e Result_sheet)\n\tmake_result_sheet(stages, quota, record, elected) \u003d\u003d\nlet result: (nat1 -\u003e Result)\n\tresult(i) \u003d\u003d\n(if ((len stages((i + 1))) \u003e (len stages(i)))\nthen let excluded:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})) in mk_Result((record((i + 1)).scores), nil, excluded)\nelse let transferred:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})) in mk_Result((record((i + 1)).scores), transferred, nil)) in mk_Result_sheet([result(((len record) - j)) | j in set {1, ... ,((len record) - 1)}], elected)","private sp_set_seq: (set of (Sub_parcel) -\u003e seq of (Sub_parcel))\n\tsp_set_seq(s) \u003d\u003d\n(if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ sp_set_seq((s \\ {e}))))","private sub_parcels_sort: (seq of (Sub_parcel) -\u003e seq of (Sub_parcel))\n\tsub_parcels_sort(sps) \u003d\u003d\n(cases sps :\n[] -\u003e sps,\n[e] -\u003e sps\nothers let sps1 ^ sps2 in set {sps} be st ((abs ((len sps1) - (len sps2))) \u003c 2) in let sps_l:seq of (Sub_parcel) \u003d sub_parcels_sort(sps1), sps_r:seq of (Sub_parcel) \u003d sub_parcels_sort(sps2) in sub_parcels_merge(sps_l, sps_r)\n end)","private sub_parcels_merge: (seq of (Sub_parcel) * seq of (Sub_parcel) -\u003e seq of (Sub_parcel))\n\tsub_parcels_merge(sps1, sps2) \u003d\u003d\n(cases mk_(sps1, sps2) :\nmk_([], sps) -\u003e sps,\nmk_(sps, []) -\u003e sps\nothers (if (total_value((hd sps1)) \u003e\u003d total_value((hd sps2)))\nthen ([(hd sps1)] ^ sub_parcels_merge((tl sps1), sps2))\nelse ([(hd sps2)] ^ sub_parcels_merge(sps1, (tl sps2))))\n end)","CHOOSE_SURPLUS_TO_TRANSFER (() \u003d\u003d\u003e Candidate_names)\n\tCHOOSE_SURPLUS_TO_TRANSFER() \u003d\u003d\n(\nleaders:set of (Candidate_names) :\u003d {(score.name) | score in set (elems (hd stages)) \u0026 ((score.count) \u003d ((hd (hd stages)).count))}\n\nif ((card leaders) \u003d 1)\nthen\nlet {n}:set of (Candidate_names) \u003d leaders in return (n)else\nif (exists n in set leaders \u0026 greatest_value_at_earliest_stage(n, stages))\nthen\nreturn ((iota name in set leaders \u0026 greatest_value_at_earliest_stage(name, stages)))else\nreturn (RANDOM_ELEMENT(leaders))\n)\n\tpre (stages \u003c\u003e [])","CHOOSE_CANDIDATE_TO_EXCLUDE (() \u003d\u003d\u003e Candidate_names)\n\tCHOOSE_CANDIDATE_TO_EXCLUDE() \u003d\u003d\n(\nlowest:set of (Candidate_names) :\u003d {(score.name) | score in set (elems (hd stages)) \u0026 ((score.count) \u003d (stage_bk((hd stages)).count))}\n\nif ((card lowest) \u003d 1)\nthen\nlet {n}:set of (Candidate_names) \u003d lowest in return (n)else\nif (exists n in set lowest \u0026 trailing_candidate(n, stages))\nthen\nreturn ((iota name in set lowest \u0026 trailing_candidate(name, stages)))else\nreturn (RANDOM_ELEMENT(lowest))\n)\n\tpre (stages \u003c\u003e [])","RANDOM_ELEMENT (Candnset \u003d\u003d\u003e Candidate_names)\n\tRANDOM_ELEMENT(s) \u003d\u003d\n(\nc:Candidate_names :\u003d (hd next_choice)\n\nnext_choice :\u003d (tl next_choice);\nreturn (c)\n)","PREPARE_ELECTION (Parcel \u003d\u003d\u003e ())\n\tPREPARE_ELECTION(votes) \u003d\u003d\n(\ncurr_cont:Candset :\u003d sort_papers(votes, Cand_names)\n\nexcluded :\u003d {};\ncontinuing :\u003d curr_cont;\nnext_choice :\u003d rand_choice;\nelected :\u003d {};\nstages :\u003d [build_first_stage(curr_cont)];\nquota :\u003d two_decimal_places((size(votes) / (Number_of_vacancies + 1)));\nrecord :\u003d [mk_Record_entry((elems (hd stages)), 0, 0)];\nlet nc:nat \u003d number_of_candidates_satisfying_quota(curr_cont, stages, quota) in if ((0 \u003c nc) and (nc \u003c\u003d Number_of_vacancies))\nthen\nCHANGE_STATUS_OF_ELECTED_CANDIDATES()else\nskip\n)","ELECT_ALL_REMAINING_CANDIDATES (() \u003d\u003d\u003e ())\n\tELECT_ALL_REMAINING_CANDIDATES() \u003d\u003d\n(\n\nelected :\u003d (elected union continuing);\ncontinuing :\u003d {}\n)","PROCESS_SUB_PARCELS (Candidate * seq of (Sub_parcel) \u003d\u003d\u003e ())\n\tPROCESS_SUB_PARCELS(ex_cand, sub_parcels) \u003d\u003d\n(\ni:nat :\u003d 0\nnon_trans_value:real :\u003d 0\nbundle:Sub_parcel_bundle :\u003d mk_Sub_parcel_bundle({|-\u003e}, mk_Sub_parcel({|-\u003e}, 0.0), 0)\nnew_candidates:set of (Candidate) :\u003d (continuing \\ {ex_cand})\nnew_stage:Stage :\u003d (hd stages)\n\nwhile (i \u003c\u003e (len sub_parcels)) do (\n\ni :\u003d (i + 1);\nbundle :\u003d construct_sub_parcels((sub_parcels(i).value), (sub_parcels(i).votes), ex_cand, new_candidates);\nnon_trans_value :\u003d (non_trans_value + (size(((bundle.non_transferable).votes)) * (sub_parcels(i).value)));\nnew_candidates :\u003d redistribute_parcels(new_candidates, bundle);\nnew_stage :\u003d construct_new_stage(new_stage, (ex_cand.name), bundle);\n(\n\nlet no_cands:nat \u003d number_of_candidates_satisfying_quota(new_candidates, [new_stage], quota) in (\n\nif ((0 \u003c no_cands) and (no_cands \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))\nthen\nlet xs_quota_scs:set of (Candidate_names) \u003d {(sc.name) | sc in set (elems new_stage) \u0026 ((sc.count) \u003e\u003d quota)} in let new_elected:set of (Candidate) \u003d {cand | cand in set new_candidates \u0026 ((cand.name) in set xs_quota_scs)} in (\n\nelected :\u003d (elected union new_elected);\nnew_candidates :\u003d (new_candidates \\ new_elected)\n)else\nskip\n)\n)\n);\ncontinuing :\u003d new_candidates;\nexcluded :\u003d (excluded union {ex_cand});\nrecord :\u003d ([mk_Record_entry((((elems new_stage) union {score | score in set ((hd record).scores) \u0026 ((score.name) not in set {(sc.name) | sc in set (elems new_stage)})}) union {mk_Score((ex_cand.name), 0)}), non_trans_value, 0)] ^ record);\nstages :\u003d ([[new_stage(i) | i in set (inds new_stage) \u0026 ((new_stage(i).name) \u003c\u003e (ex_cand.name))]] ^ stages)\n)","ELECT_LAST_CANDIDATE (() \u003d\u003d\u003e ())\n\tELECT_LAST_CANDIDATE() \u003d\u003d\n(\nelected_candidate:Candidate :\u003d (iota leader in set continuing \u0026 ((leader.name) \u003d ((hd stages)(Number_of_vacancies).name)))\n\nelected :\u003d (elected union {elected_candidate});\ncontinuing :\u003d (continuing \\ {elected_candidate})\n)\n\tpre last_vacancy_fillable(continuing, stages, quota)","TRANSFER_SURPLUS (() \u003d\u003d\u003e ())\n\tTRANSFER_SURPLUS() \u003d\u003d\n(\nname:Candidate_names :\u003d CHOOSE_SURPLUS_TO_TRANSFER()\n\nlet candidate \u003d (iota c in set elected \u0026 ((c.name) \u003d name)) in let surplus \u003d (((hd (hd stages)).count) - quota), sub_parcel \u003d (if surplus_from_original_votes(candidate)\nthen mk_Sub_parcel((candidate.original_votes), 1.0)\nelse (hd (candidate.transferred_votes))) in let sub_parcel_bundle \u003d construct_bundle_for_transfer(surplus, (sub_parcel.value), (sub_parcel.votes), candidate, continuing) in let new_stage \u003d construct_new_stage(([mk_Score(name, quota)] ^ [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) \u003c\u003e name)]), (candidate.name), sub_parcel_bundle) in let curr_cont \u003d redistribute_parcels((continuing \\ {candidate}), sub_parcel_bundle) in (\n\nstages :\u003d ([new_stage] ^ stages);\nrecord :\u003d ([mk_Record_entry(((elems new_stage) union {score | score in set ((hd record).scores) \u0026 ((score.name) not in set {(sc.name) | sc in set (elems new_stage)})}), ((sub_parcel_bundle.non_transferable).value), (sub_parcel_bundle.loss_of_value))] ^ record);\ncontinuing :\u003d curr_cont;\nlet nc:nat \u003d number_of_candidates_satisfying_quota(curr_cont, stages, quota) in if ((0 \u003c nc) and (nc \u003c\u003d Number_of_vacancies))\nthen\n(\n\nCHANGE_STATUS_OF_ELECTED_CANDIDATES()\n)\n)\n)\n\tpre exists_non_deferable_surplus(stages, quota)","EXCLUDE_CANDIDATE (() \u003d\u003d\u003e ())\n\tEXCLUDE_CANDIDATE() \u003d\u003d\nlet name:Candidate_names \u003d CHOOSE_CANDIDATE_TO_EXCLUDE() in let excluded_candidate:Candidate \u003d (iota c in set continuing \u0026 ((c.name) \u003d name)) in let sorted_sub_parcels:seq of (Sub_parcel) \u003d sub_parcels_sort(sp_set_seq(((elems (excluded_candidate.transferred_votes)) union {mk_Sub_parcel((excluded_candidate.original_votes), 1.0)}))) in PROCESS_SUB_PARCELS(excluded_candidate, sorted_sub_parcels)","ELECT_CANDIDATES (() \u003d\u003d\u003e ())\n\tELECT_CANDIDATES() \u003d\u003d\nlet nc \u003d number_of_continuing_candidates({(c.name) | c in set continuing}), nv \u003d number_of_remaining_vacancies({(e.name) | e in set elected}), nq \u003d number_of_candidates_satisfying_quota(continuing, stages, quota) in if (nc \u003d nv)\nthen\nELECT_ALL_REMAINING_CANDIDATES()elseif ((0 \u003c nq) and (nq \u003c\u003d nv))\nthen\nCHANGE_STATUS_OF_ELECTED_CANDIDATES()elseif ((nv \u003d 1) and last_vacancy_fillable(continuing, stages, quota))\nthen\nELECT_LAST_CANDIDATE()elseif exists_non_deferable_surplus(stages, quota)\nthen\nTRANSFER_SURPLUS()else\nEXCLUDE_CANDIDATE()","CONDUCT_ELECTION (Parcel \u003d\u003d\u003e Result_sheet)\n\tCONDUCT_ELECTION(votes) \u003d\u003d\n(\n\nPREPARE_ELECTION(votes);\nwhile (((card elected) \u003c\u003e Number_of_vacancies) and ((card continuing) \u003e 0)) do ELECT_CANDIDATES();\nreturn (make_result_sheet(stages, quota, record, {(e.name) | e in set elected}))\n)","CHANGE_STATUS_OF_ELECTED_CANDIDATES (() \u003d\u003d\u003e ())\n\tCHANGE_STATUS_OF_ELECTED_CANDIDATES() \u003d\u003d\nlet xs_quota_scs:set of (Candidate_names) \u003d {(sc.name) | sc in set (elems (hd stages)) \u0026 ((sc.count) \u003e\u003d quota)} in let candidates_satisfying_quota \u003d {candidate | candidate in set continuing \u0026 ((candidate.name) in set xs_quota_scs)} in (\n\nelected :\u003d (candidates_satisfying_quota union elected);\ncontinuing :\u003d (continuing \\ candidates_satisfying_quota)\n)\n\tpre (number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected}))"]