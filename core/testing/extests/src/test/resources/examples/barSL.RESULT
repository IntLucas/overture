["SOURCE \u003d SOURCE","ERROR \u003d ERROR","LABEL \u003d LABEL","TREE \u003d TREE","PARSED \u003d PARSED","PARSER \u003d PARSER","UNEXPECTED_EOF:seq1 of (char) \u003d \"Unexpected EOF\"","UNEXPECTED:seq1 of (char) \u003d \"Unexpected \"","EXPECTED:seq1 of (char) \u003d \"Expected \"","any:(SOURCE -\u003e PARSED) \u003d (lambda [source:(unresolved VCParser`SOURCE)] \u0026 (cases source :\n[] -\u003e mk_PARSED(mk_ERROR(UNEXPECTED_EOF), source)\nothers mk_PARSED(mk_TREE(nil, [(hd source)]), (tl source))\n end))","digit:PARSER \u003d label(\"digit\", either([takeChar(\"0123456789\"(index)) | index in set {1, ... ,10}]))","lowerAlphabet:PARSER \u003d label(\"lowerAlphabet\", either([takeChar(\"abcdefghijklmnopqrstuvwxyz\"(index)) | index in set {1, ... ,26}]))","upperAlphabet:PARSER \u003d label(\"upperAlphabet\", either([takeChar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"(index)) | index in set {1, ... ,26}]))","alphabet:PARSER \u003d label(\"alphabet\", either([lowerAlphabet, upperAlphabet]))","natnum:PARSER \u003d label(\"nat\", concat(series([concat(series([pass(fail(takeChar(\u00270\u0027))), digit])), concat(star(digit))])))","integer:PARSER \u003d label(\"int\", concat(series([option(takeChar(\u0027-\u0027)), natnum])))","private takeChar: (char -\u003e PARSER)\n\ttakeChar(c) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 (cases source :\n[] -\u003e mk_PARSED(mk_ERROR(UNEXPECTED_EOF), source)\nothers (if ((hd source) \u003d c)\nthen mk_PARSED(mk_TREE(nil, [c]), (tl source))\nelse mk_PARSED(mk_ERROR((((EXPECTED ^ \"\u0027\") ^ [c]) ^ \"\u0027\")), source))\n end))","private takeString: (seq1 of (char) -\u003e PARSER)\n\ttakeString(string) \u003d\u003d\nconcat(series([takeChar(string(index)) | index in set (inds string)]))","private series: (seq1 of (PARSER) -\u003e PARSER)\n\tseries(parsers) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in (cases mk_(tree1, (tl parsers)) :\nmk_(mk_ERROR(msg), -) -\u003e mk_PARSED(tree1, source1),\nmk_(-, []) -\u003e mk_PARSED(mk_TREE(nil, [tree1]), source1),\nmk_(-, rest) -\u003e let mk_PARSED(tree2, source2):PARSED \u003d series(rest)(source1) in (cases tree2 :\nmk_TREE(-, trees2) -\u003e mk_PARSED(mk_TREE(nil, ([tree1] ^ trees2)), source2),\nmk_ERROR(message) -\u003e mk_PARSED(tree2, source2)\n end)\n end))","private either: (seq1 of (PARSER) -\u003e PARSER)\n\teither(parsers) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in (cases mk_(tree1, (tl parsers)) :\nmk_(mk_ERROR(msg), []) -\u003e mk_PARSED(tree1, source1),\nmk_(mk_ERROR(msg), -) -\u003e either((tl parsers))(source),\nmk_(tree, rest) -\u003e mk_PARSED(tree1, source1)\n end))","private star: (PARSER -\u003e PARSER)\n\tstar(parser) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 (cases parser(source) :\nmk_PARSED(mk_ERROR(-), -) -\u003e mk_PARSED(mk_TREE(nil, []), source),\nmk_PARSED(tree, rest) -\u003e let mk_PARSED(mk_TREE(-, trees), source2):PARSED \u003d star(parser)(rest) in mk_PARSED(mk_TREE(nil, ([tree] ^ trees)), source2)\n end))","private option: (PARSER -\u003e PARSER)\n\toption(parser) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 (cases parser(source) :\nmk_PARSED(mk_ERROR(-), -) -\u003e mk_PARSED(mk_TREE(nil, []), source),\nsuccess -\u003e success\n end))","private trimBlanks: (PARSER -\u003e PARSER)\n\ttrimBlanks(parser) \u003d\u003d\n((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_ERROR(-), -) -\u003e parsed,\nmk_PARSED(mk_TREE(-, contents), rest) -\u003e mk_PARSED(contents(2), rest)\n end)) comp series([star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)])), parser, star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)]))]))","private fail: (PARSER -\u003e PARSER)\n\tfail(parser) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 let mk_PARSED(tree1, source1):PARSED \u003d parser(source) in (cases tree1 :\nmk_ERROR(-) -\u003e mk_PARSED(mk_TREE(nil, []), source),\nmk_TREE(-, -) -\u003e mk_PARSED(mk_ERROR((UNEXPECTED ^ [source(index) | index in set {1, ... ,((len source) - (len source1))}])), source)\n end))","private concat: (PARSER -\u003e PARSER)\n\tconcat(parser) \u003d\u003d\n((lambda [p:(unresolved VCParser`PARSED)] \u0026 (cases p :\nmk_PARSED(mk_ERROR(message), rest) -\u003e p,\nmk_PARSED(mk_TREE(label, contents), rest) -\u003e (if (contents \u003d [])\nthen mk_PARSED(mk_TREE(nil, contents), rest)\nelseif is_(contents, seq of (char))\nthen mk_PARSED(mk_TREE(nil, contents), rest)\nelse mk_PARSED(mk_TREE(nil, (conc [let mk_TREE(-, subcontent):(TREE | char) \u003d contents(index) in subcontent | index in set (inds contents)])), rest))\n end)) comp parser)","private pass: (PARSER -\u003e PARSER)\n\tpass(parser) \u003d\u003d\n(lambda [source:(unresolved VCParser`SOURCE)] \u0026 (cases parser(source) :\nmk_PARSED(mk_TREE(label, contents), rest) -\u003e mk_PARSED(mk_TREE(label, []), rest),\nerr -\u003e err\n end))","private label: (LABEL * PARSER -\u003e PARSER)\n\tlabel(newLabel, parser) \u003d\u003d\n((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_TREE(-, contents), source) -\u003e mk_PARSED(mk_TREE(newLabel, contents), source)\nothers parsed\n end)) comp parser)","private trans: ((PARSED -\u003e PARSED) * PARSER -\u003e PARSER)\n\ttrans(modifier, parser) \u003d\u003d\n(modifier comp parser)","private transtree: ((TREE -\u003e TREE) * PARSER -\u003e PARSER)\n\ttranstree(modifier, parser) \u003d\u003d\ntrans((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_ERROR(message), rest) -\u003e parsed,\nmk_PARSED(tree, rest) -\u003e mk_PARSED(modifier(tree), rest)\n end)), parser)","private iferror: (seq of (char) * PARSER -\u003e PARSER)\n\tiferror(message, parser) \u003d\u003d\ntrans((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_ERROR(-), rest) -\u003e mk_PARSED(mk_ERROR(message), rest),\nmk_PARSED(mk_TREE(-, -), -) -\u003e parsed\n end)), parser)","TREE \u003d TREE","PARSED \u003d PARSED","concat:(PARSER -\u003e PARSER) \u003d VCParser`concat","series:(seq1 of (PARSER) -\u003e PARSER) \u003d VCParser`series","either:(seq1 of (PARSER) -\u003e PARSER) \u003d VCParser`either","star:(PARSER -\u003e PARSER) \u003d VCParser`star","trimBlanks:(PARSER -\u003e PARSER) \u003d VCParser`trimBlanks","integer:PARSER \u003d VCParser`integer","takeChar:(char -\u003e PARSER) \u003d VCParser`takeChar","label:(LABEL * PARSER -\u003e PARSER) \u003d VCParser`label","transtree:((TREE -\u003e TREE) * PARSER -\u003e PARSER) \u003d VCParser`transtree","parseInt:PARSER \u003d trimBlanks(integer)","parseMul:PARSER \u003d series([takeChar(\u0027*\u0027), parseInt])","parseDiv:PARSER \u003d series([takeChar(\u0027/\u0027), parseInt])","parseTerm:PARSER \u003d transtree(liftOperator, series([parseInt, star(either([parseMul, parseDiv]))]))","parseAdd:PARSER \u003d series([takeChar(\u0027+\u0027), parseTerm])","parseSub:PARSER \u003d series([takeChar(\u0027-\u0027), parseTerm])","parseExpression:PARSER \u003d transtree(liftOperator, series([parseTerm, star(either([parseAdd, parseSub]))]))","liftOperator:(TREE -\u003e (? | TREE | char)) \u003d (lambda [tree:(unresolved VCParser`TREE)] \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in (cases rights :\n[] -\u003e left,\n[mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest -\u003e liftOperator(mk_VCParser`TREE(nil, [mk_VCParser`TREE(operator, [left, operand]), mk_VCParser`TREE(nil, rest)]))\n end))","private evalInt: (seq of (char) -\u003e int)\n\tevalInt(string) \u003d\u003d\n(cases string :\n\"-\" ^ rest -\u003e (evalInt(rest) * -1),\n[] -\u003e 0\nothers ((evalInt([string(i) | i in set {1, ... ,((len string) - 1)}]) * 10) + {\u00270\u0027 |-\u003e 0, \u00271\u0027 |-\u003e 1, \u00272\u0027 |-\u003e 2, \u00273\u0027 |-\u003e 3, \u00274\u0027 |-\u003e 4, \u00275\u0027 |-\u003e 5, \u00276\u0027 |-\u003e 6, \u00277\u0027 |-\u003e 7, \u00278\u0027 |-\u003e 8, \u00279\u0027 |-\u003e 9}(string((len string))))\n end)","private evalTree: (TREE -\u003e int)\n\tevalTree(tree) \u003d\u003d\n(cases tree :\nmk_TREE(\"int\", contents) -\u003e evalInt(contents),\nmk_TREE(\"*\", [e1, e2]) -\u003e (evalTree(e1) * evalTree(e2)),\nmk_TREE(\"/\", [e1, e2]) -\u003e (evalTree(e1) / evalTree(e2)),\nmk_TREE(\"+\", [e1, e2]) -\u003e (evalTree(e1) + evalTree(e2)),\nmk_TREE(\"-\", [e1, e2]) -\u003e (evalTree(e1) - evalTree(e2))\n end)","private eval: (seq of (char) -\u003e [int])\n\teval(string) \u003d\u003d\n(cases parseExpression(string) :\nmk_PARSED(tree, []) -\u003e evalTree(tree)\nothers nil\n end)"]