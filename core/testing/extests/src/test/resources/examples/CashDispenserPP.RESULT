["class CM\npublic static  detector:MissileDetector :\u003d new MissileDetector()\npublic static  sensor0:Sensor :\u003d new Sensor(detector, 0)\npublic static  sensor1:Sensor :\u003d new Sensor(detector, 90)\npublic static  sensor2:Sensor :\u003d new Sensor(detector, 180)\npublic static  sensor3:Sensor :\u003d new Sensor(detector, 270)\npublic static  controller0:FlareController :\u003d new FlareController(0)\npublic static  controller1:FlareController :\u003d new FlareController(120)\npublic static  controller2:FlareController :\u003d new FlareController(240)\npublic static  dispenser0:FlareDispenser :\u003d new FlareDispenser(0)\npublic static  dispenser1:FlareDispenser :\u003d new FlareDispenser(30)\npublic static  dispenser2:FlareDispenser :\u003d new FlareDispenser(60)\npublic static  dispenser3:FlareDispenser :\u003d new FlareDispenser(90)\npublic static  dispenser4:FlareDispenser :\u003d new FlareDispenser(0)\npublic static  dispenser5:FlareDispenser :\u003d new FlareDispenser(30)\npublic static  dispenser6:FlareDispenser :\u003d new FlareDispenser(60)\npublic static  dispenser7:FlareDispenser :\u003d new FlareDispenser(90)\npublic static  dispenser8:FlareDispenser :\u003d new FlareDispenser(0)\npublic static  dispenser9:FlareDispenser :\u003d new FlareDispenser(30)\npublic static  dispenser10:FlareDispenser :\u003d new FlareDispenser(60)\npublic static  dispenser11:FlareDispenser :\u003d new FlareDispenser(90)\nend CM\n","class Environment is subclass of [GLOBAL]\npublic static  inline \u003d inline\npublic static  outline \u003d outline\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (outline) :\u003d []\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  sensors:map (nat) to (Sensor) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom sensors))\nprivate  evid:[EventId] :\u003d nil\nprivate  busy:bool :\u003d true\npublic  Environment(seq of (char)) (seq of (char) \u003d\u003d\u003e Environment)\n\tEnvironment(seq of (char))(fname) \u003d\u003d\nlet mk_(-, input) \u003d ((io.freadval))[seq of (inline)](fname) in inlines :\u003d input\npublic  addSensor(Sensor) (Sensor \u003d\u003d\u003e ())\n\taddSensor(Sensor)(psens) \u003d\u003d\n(\nid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {id |-\u003e (psens.getAperture)()}), sensors :\u003d (sensors munion {id |-\u003e psens}))\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nwhile (not (isFinished() and (CM`detector.isFinished)())) do (\n\nevid :\u003d createSignal();\nCM`detector.Step();\nWorld`timerRef.StepTime()\n);\nshowResult()\n)\nprivate  createSignal() (() \u003d\u003d\u003e [EventId])\n\tcreateSignal()() \u003d\u003d\n(\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d (World`timerRef.GetTime)()\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(eventid, pmt, pa, pt) \u003d (hd inlines) in if (pt \u003c\u003d curtime)\nthen\n(\n\nfor all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\nsensors(id).trip(eventid, pmt, pa);\ninlines :\u003d (tl inlines);\ndone :\u003d ((len inlines) \u003d 0);\nreturn (eventid)\n)else\n(\n\ndone :\u003d true;\nreturn (nil)\n)\n)else\n(\n\nbusy :\u003d false;\nreturn (nil)\n)\n)\npublic  handleEvent(EventId, FlareType, Angle, Time, Time) (EventId * FlareType * Angle * Time * Time \u003d\u003d\u003e ())\n\thandleEvent(EventId, FlareType, Angle, Time, Time)(newevid, pfltp, angle, pt1, pt2) \u003d\u003d\n(\n\noutlines :\u003d (outlines ^ [mk_(newevid, pfltp, angle, pt1, pt2)])\n)\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (outline)](outlines) in skip\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn (((inlines \u003d []) and (not busy)))\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(0, 0))\nend Environment\n","class FlareController is subclass of [GLOBAL]\nprivate  aperture:Angle :\u003d (undefined)\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  dispensers:map (nat) to (FlareDispenser) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom dispensers))\nprivate  threats:seq of ((EventId * MissileType * Angle * Time)) :\u003d []\nprivate  busy:bool :\u003d false\npublic  FlareController(Angle) (Angle \u003d\u003d\u003e FlareController)\n\tFlareController(Angle)(papp) \u003d\u003d\naperture :\u003d papp\npublic  addDispenser(FlareDispenser) (FlareDispenser \u003d\u003d\u003e ())\n\taddDispenser(FlareDispenser)(pfldisp) \u003d\u003d\nlet angle:nat \u003d (aperture + (pfldisp.GetAngle)()) in (\nid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {id |-\u003e mk_(angle, DISPENSER_APERTURE)}), dispensers :\u003d (dispensers munion {id |-\u003e pfldisp}))\n)\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (threats \u003c\u003e [])\nthen\nlet mk_(evid, pmt, pa, pt) \u003d getThreat() in for all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\ndispensers(id).addThreat(evid, pmt, pt);\nbusy :\u003d ((len threats) \u003e 0);\nfor all id in set (dom dispensers) do\ndispensers(id).Step()\n)\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(aperture, FLARE_APERTURE))\npublic  addThreat(EventId, MissileType, Angle, Time) (EventId * MissileType * Angle * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Angle, Time)(evid, pmt, pa, pt) \u003d\u003d\n(\n\nthreats :\u003d (threats ^ [mk_(evid, pmt, pa, pt)]);\nbusy :\u003d true\n)\nprivate  getThreat() (() \u003d\u003d\u003e (EventId * MissileType * Angle * Time))\n\tgetThreat()() \u003d\u003d\n(\nres:(EventId * MissileType * Angle * Time) :\u003d (hd threats)\n\nthreats :\u003d (tl threats);\nreturn (res)\n)\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn ((forall id in set (dom dispensers) \u0026 (dispensers(id).isFinished)()))\nend FlareController\n","class FlareDispenser is subclass of [GLOBAL]\nprivate static  responseDB:map (MissileType) to (Plan) \u003d {\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)], \u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)], \u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}\nprivate static  missilePriority:map (MissileType) to (nat) \u003d {\u003cNone\u003e |-\u003e 0, \u003cMissileA\u003e |-\u003e 1, \u003cMissileB\u003e |-\u003e 2, \u003cMissileC\u003e |-\u003e 3}\npublic static  Plan \u003d Plan\npublic static  PlanStep \u003d PlanStep\npublic  curplan:Plan :\u003d []\nprivate  curprio:nat :\u003d 0\nprivate  busy:bool :\u003d false\nprivate  aperture:Angle :\u003d (undefined)\nprivate  eventid:[EventId] :\u003d (undefined)\npublic  FlareDispenser(nat) (nat \u003d\u003d\u003e FlareDispenser)\n\tFlareDispenser(nat)(ang) \u003d\u003d\naperture :\u003d ang\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nif ((len curplan) \u003e 0)\nthen\n(\ncurtime:Time :\u003d (World`timerRef.GetTime)()\nfirst:PlanStep :\u003d (hd curplan)\nnext:Plan :\u003d (tl curplan)\n\nlet mk_(fltp, fltime):PlanStep \u003d first in (\n\nif (fltime \u003c\u003d curtime)\nthen\n(\n\nreleaseFlare(eventid, fltp, fltime, curtime);\ncurplan :\u003d next;\nif ((len next) \u003d 0)\nthen\n(\n\ncurprio :\u003d 0;\nbusy :\u003d false\n)\n)\n)\n)\npublic  GetAngle() (() \u003d\u003d\u003e nat)\n\tGetAngle()() \u003d\u003d\nreturn (aperture)\npublic  addThreat(EventId, MissileType, Time) (EventId * MissileType * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Time)(evid, pmt, ptime) \u003d\u003d\nif (missilePriority(pmt) \u003e curprio)\nthen\n(\nnewplan:Plan :\u003d []\nnewtime:Time :\u003d ptime\n\nfor in \u0027FlareDispenser\u0027 (flaredispenser.vdmpp) at line 70:13mk_(fltp, fltime)ADefPatternBind[fltp \u003d FlareType, fltime \u003d Time]ADefPatternBind in responseDB(pmt) do\n(\n\nnewplan :\u003d (newplan ^ [mk_(fltp, newtime)]);\nnewtime :\u003d (newtime + fltime)\n);\nlet mk_(fltp, fltime) \u003d (hd newplan), t \u003d (World`timerRef.GetTime)() in releaseFlare(evid, fltp, fltime, t);\ncurplan :\u003d (tl newplan);\neventid :\u003d evid;\ncurprio :\u003d missilePriority(pmt);\nbusy :\u003d true\n)\n\tpre ((pmt in set (dom missilePriority)) and (pmt in set (dom responseDB)))\nprivate  releaseFlare(EventId, FlareType, Time, Time) (EventId * FlareType * Time * Time \u003d\u003d\u003e ())\n\treleaseFlare(EventId, FlareType, Time, Time)(evid, pfltp, pt1, pt2) \u003d\u003d\nWorld`env.handleEvent(evid, pfltp, aperture, pt1, pt2)\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn ((not busy))\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(0, 0))\nend FlareDispenser\n","class GLOBAL\npublic static  SENSOR_APERTURE:nat1 \u003d 90\npublic static  FLARE_APERTURE:nat1 \u003d 120\npublic static  DISPENSER_APERTURE:nat1 \u003d 30\npublic static  MissileType \u003d MissileType\npublic static  FlareType \u003d FlareType\npublic static  Angle \u003d Angle\n\tinv num \u003d\u003d (num \u003c 360)\npublic static  EventId \u003d EventId\npublic static  Time \u003d Time\npublic  canObserve(Angle, Angle, Angle) (Angle * Angle * Angle \u003d\u003d\u003e bool)\n\tcanObserve(Angle, Angle, Angle)(pangle, pleft, psize) \u003d\u003d\nlet pright \u003d ((pleft + psize) mod 360) in if (pright \u003c pleft)\nthen\nreturn (((pangle \u003c pright) or (pangle \u003e\u003d pleft)))else\nreturn (((pangle \u003e\u003d pleft) and (pangle \u003c pright)))\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nis subclass responsibility\nend GLOBAL\n","class MissileDetector is subclass of [GLOBAL]\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  controllers:map (nat) to (FlareController) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom controllers))\nprivate  threats:seq of ((EventId * MissileType * Angle * Time)) :\u003d []\nprivate  busy:bool :\u003d false\npublic  addController(FlareController) (FlareController \u003d\u003d\u003e ())\n\taddController(FlareController)(pctrl) \u003d\u003d\n(\nnid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {nid |-\u003e (pctrl.getAperture)()}), controllers :\u003d (controllers munion {nid |-\u003e pctrl}))\n)\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (threats \u003c\u003e [])\nthen\nlet mk_(evid, pmt, pa, pt) \u003d getThreat() in for all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\ncontrollers(id).addThreat(evid, pmt, pa, pt);\nbusy :\u003d ((len threats) \u003e 0);\nfor all id in set (dom controllers) do\ncontrollers(id).Step()\n)\npublic  addThreat(EventId, MissileType, Angle, Time) (EventId * MissileType * Angle * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Angle, Time)(evid, pmt, pa, pt) \u003d\u003d\n(\n\nthreats :\u003d (threats ^ [mk_(evid, pmt, pa, pt)]);\nbusy :\u003d true\n)\nprivate  getThreat() (() \u003d\u003d\u003e (EventId * MissileType * Angle * Time))\n\tgetThreat()() \u003d\u003d\n(\nres:(EventId * MissileType * Angle * Time) :\u003d (hd threats)\n\nthreats :\u003d (tl threats);\nreturn (res)\n)\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn ((forall id in set (dom controllers) \u0026 (controllers(id).isFinished)()))\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(0, 0))\nend MissileDetector\n","class Sensor is subclass of [GLOBAL]\nprivate  detector:MissileDetector :\u003d (undefined)\nprivate  aperture:Angle :\u003d (undefined)\npublic  Sensor(MissileDetector, Angle) (MissileDetector * Angle \u003d\u003d\u003e Sensor)\n\tSensor(MissileDetector, Angle)(pmd, psa) \u003d\u003d\n(\n\ndetector :\u003d pmd;\naperture :\u003d psa\n)\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(aperture, SENSOR_APERTURE))\npublic  trip(EventId, MissileType, Angle) (EventId * MissileType * Angle \u003d\u003d\u003e ())\n\ttrip(EventId, MissileType, Angle)(evid, pmt, pa) \u003d\u003d\ndetector.addThreat(evid, pmt, pa, (World`timerRef.GetTime)())\n\tpre canObserve(pa, aperture, SENSOR_APERTURE)\nend Sensor\n","class Timer\nprivate  currentTime:nat :\u003d 0\nprivate static  timerInstance:Timer :\u003d new Timer()\nprivate static  stepLength:nat \u003d 10\nprivate  Timer() (() \u003d\u003d\u003e Timer)\n\tTimer()() \u003d\u003d\nskip\npublic static  GetInstance() (() \u003d\u003d\u003e Timer)\n\tGetInstance()() \u003d\u003d\nreturn (timerInstance)\npublic  StepTime() (() \u003d\u003d\u003e ())\n\tStepTime()() \u003d\u003d\ncurrentTime :\u003d (currentTime + stepLength)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nend Timer\n","class World\npublic static  env:[Environment] :\u003d nil\npublic static  timerRef:Timer :\u003d Timer`GetInstance()\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Environment(\"scenario.txt\");\nenv.addSensor(CM`sensor0);\nenv.addSensor(CM`sensor1);\nenv.addSensor(CM`sensor2);\nenv.addSensor(CM`sensor3);\nCM`controller0.addDispenser(CM`dispenser0);\nCM`controller0.addDispenser(CM`dispenser1);\nCM`controller0.addDispenser(CM`dispenser2);\nCM`controller0.addDispenser(CM`dispenser3);\nCM`detector.addController(CM`controller0);\nCM`controller1.addDispenser(CM`dispenser4);\nCM`controller1.addDispenser(CM`dispenser5);\nCM`controller1.addDispenser(CM`dispenser6);\nCM`controller1.addDispenser(CM`dispenser7);\nCM`detector.addController(CM`controller1);\nCM`controller2.addDispenser(CM`dispenser8);\nCM`controller2.addDispenser(CM`dispenser9);\nCM`controller2.addDispenser(CM`dispenser10);\nCM`controller2.addDispenser(CM`dispenser11);\nCM`detector.addController(CM`controller2)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\nenv.Run()\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]