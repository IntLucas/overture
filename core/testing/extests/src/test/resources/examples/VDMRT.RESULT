["class DataReader\npublic  DataReader() (() \u003d\u003d\u003e DataReader)\n\tDataReader()() \u003d\u003d\nreturn (self)\npublic  Read() (() \u003d\u003d\u003e ())\n\tRead()() \u003d\u003d\nskip\nend DataReader\n","class DataReaderTest is subclass of [TestCase]\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend DataReaderTest\n","class Enviroment\nprivate  file:Storage :\u003d (undefined)\npublic  completeGrid:Grid :\u003d (undefined)\nprivate  currentRobotPosition:Point :\u003d (undefined)\nprivate  busy:bool :\u003d true\npublic  Enviroment() (() \u003d\u003d\u003e Enviroment)\n\tEnviroment()() \u003d\u003d\n(\n\nfile :\u003d new Storage();\ncompleteGrid :\u003d new Grid(mk_Grid`Point(0, 0), mk_Grid`Point(100, 100))\n)\npublic  GetPointAvalibility(Point) (Point \u003d\u003d\u003e PointAvalibility)\n\tGetPointAvalibility(Point)(p) \u003d\u003d\nreturn ((completeGrid.GetPointAvalibility)((p.X), (p.Y)))\npublic  handleEvent(Grid, seq of (Route), Point, bool) (Grid * seq of (Route) * Point * bool \u003d\u003d\u003e ())\n\thandleEvent(Grid, seq of (Route), Point, bool)(g, routes, dest, b) \u003d\u003d\nfile.Save(g, routes, dest, b)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nRobot`steering.isFinished()\nprotected  thread (\n\ncompleteGrid :\u003d (file.Load)(\"testmap.map\");\nstart (Robot`nmc);\nstart (Robot`mobs1);\nstart (Robot`mobs2);\nstart (Robot`mobs3);\nstart (Robot`mobs4);\nstart (Robot`steering);\nRobot`steering.SetDiscoverInfo((file.startingPoint), (file.dest), (file.battery));\nbusy :\u003d false\n)\nprivate  per isFinished \u003d\u003e (not busy)\nend Enviroment\n","class EnviromentTest is subclass of [TestCase]\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend EnviromentTest\n","class Grid\npublic static  PointAvalibility \u003d PointAvalibility\npublic static  Point \u003d Point\npublic  points:map (Point) to (PointAvalibility) :\u003d {|-\u003e}\nprivate  maxPoint:Point :\u003d mk_Point(1.0E7, 1.0E7)\nprivate  inv(forall p in set (dom points) \u0026 IsValidGridPoint(p))\npublic  Grid(Point, Point) (Point * Point \u003d\u003d\u003e Grid)\n\tGrid(Point, Point)(startPoint, p) \u003d\u003d\n(\n\npoints :\u003d {startPoint |-\u003e \u003cFree\u003e};\nmaxPoint :\u003d p\n)\n\tpre (IsValidGridPoint(startPoint) and IsValidGridPoint(p))\npublic  GetPointAvalibility(int, int) (int * int \u003d\u003d\u003e PointAvalibility)\n\tGetPointAvalibility(int, int)(x, y) \u003d\u003d\nif (mk_Point(x, y) in set (dom points))\nthen\nreturn (points(mk_Point(x, y)))else\nreturn (\u003cUnknown\u003e)\n\tpre IsValidGridPoint(mk_Point(x, y))\npublic  SetPointMP(map (Point) to (PointAvalibility)) (map (Point) to (PointAvalibility) \u003d\u003d\u003e ())\n\tSetPointMP(map (Point) to (PointAvalibility))(mapping) \u003d\u003d\npoints :\u003d (points ++ mapping)\n\tpre (forall p in set (dom mapping) \u0026 IsValidGridPoint(p))\npublic  IsValidGridPoint(Point) (Point \u003d\u003d\u003e bool)\n\tIsValidGridPoint(Point)(p) \u003d\u003d\nreturn ((((maxPoint.X) \u003e\u003d (p.X)) and (((p.X) \u003e\u003d 0) and (((maxPoint.Y) \u003e\u003d (p.Y)) and ((p.Y) \u003e\u003d 0)))))\nend Grid\n","class GridTest is subclass of [TestCase]\nprivate static  sta:Point \u003d mk_Grid`Point(0, 0)\nprivate static  max:Point \u003d mk_Grid`Point(100, 100)\npublic  GridTest(seq of (char)) (seq of (char) \u003d\u003d\u003e GridTest)\n\tGridTest(seq of (char))(name) \u003d\u003d\nTestCase(name)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntc:Grid :\u003d new Grid(sta, max)\n\nAssertTrue(((tc.GetPointAvalibility)((sta.X), (sta.Y)) \u003d \u003cFree\u003e));\nAssertFalse((tc.IsValidGridPoint)(mk_Grid`Point(-999999, -999999)));\nAssertFalse((tc.IsValidGridPoint)(mk_Grid`Point(999999, 999999)));\nAssertTrue((tc.IsValidGridPoint)(mk_Grid`Point(4, 1)));\nAssertTrue((\u003cUnknown\u003e \u003d (tc.GetPointAvalibility)(4, 1)));\nAssertTrue((\u003cUnknown\u003e \u003d (tc.GetPointAvalibility)(4, 2)));\nAssertTrue((\u003cUnknown\u003e \u003d (tc.GetPointAvalibility)(4, 3)));\nAssertTrue((\u003cUnknown\u003e \u003d (tc.GetPointAvalibility)(5, 4)))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend GridTest\n","class MovingObstacle\npublic static  MoveDirection \u003d MoveDirection\nprivate  firstpos:Point :\u003d (undefined)\nprivate  pos:Point :\u003d (undefined)\nprivate  direction:MoveDirection :\u003d (undefined)\nprivate  steps:int :\u003d (undefined)\nprivate  busy:bool :\u003d true\npublic  MovingObstacle(Point, MoveDirection) (Point * MoveDirection \u003d\u003d\u003e MovingObstacle)\n\tMovingObstacle(Point, MoveDirection)(p, dir) \u003d\u003d\n(\n\nfirstpos :\u003d p;\npos :\u003d firstpos;\ndirection :\u003d dir;\nsteps :\u003d 0\n)\nprivate  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nduration (1000) (\n\nif (steps \u003d 10)\nthen\n(\n\nSetPos(firstpos, 0)\n)else\n(\n\nif (direction \u003d \u003cNorth\u003e)\nthen\nSetPos(mk_Grid`Point((pos.X), ((pos.Y) + 1)), (steps + 1));\nif (direction \u003d \u003cSouth\u003e)\nthen\nSetPos(mk_Grid`Point((pos.X), ((pos.Y) - 1)), (steps + 1));\nif (direction \u003d \u003cEast\u003e)\nthen\nSetPos(mk_Grid`Point(((pos.X) + 1), (pos.Y)), (steps + 1));\nif (direction \u003d \u003cWest\u003e)\nthen\nSetPos(mk_Grid`Point(((pos.X) - 1), (pos.Y)), (steps + 1))\n)\n)\nprivate  SetPos(Point, int) (Point * int \u003d\u003d\u003e ())\n\tSetPos(Point, int)(p, s) \u003d\u003d\n(\n\npos :\u003d p;\nsteps :\u003d s\n)\npublic  GetPos() (() \u003d\u003d\u003e Point)\n\tGetPos()() \u003d\u003d\nreturn (pos)\npublic  Stop() (() \u003d\u003d\u003e ())\n\tStop()() \u003d\u003d\nbusy :\u003d false\nprotected  thread periodic(1.0E9, 100, 100, 0)(Step())\nprivate  mutex(SetPos, GetPos)\nprivate  mutex(SetPos)\nend MovingObstacle\n","class MovingObstacleTest is subclass of [TestCase]\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend MovingObstacleTest\n","class NextMoveController\nprivate  obs:map (Point) to (PointAvalibility) :\u003d (undefined)\nprivate  mobs:set of (MovingObstacle) :\u003d {}\nprotected  thread periodic(2.5E9, 1, 0, 0)(LocateMovingObstacles())\nprivate  mutex(SetObs, IsPointBlocked)\nprivate  mutex(SetObs)\nprivate  mutex(WaitForAvalibility)\nprivate  mutex(LocateMovingObstacles)\nprivate  mutex(GetNextPoint)\nprivate  per GetNextPoint \u003d\u003e (#fin[LocateMovingObstacles] \u003e #fin[GetNextPoint])\nprivate  per IsPointBlocked \u003d\u003e (#fin[SetObs] \u003e #fin[IsPointBlocked])\npublic  NextMoveController() (() \u003d\u003d\u003e NextMoveController)\n\tNextMoveController()() \u003d\u003d\n(\n\nskip\n)\npublic  AddMovingObsticle(MovingObstacle) (MovingObstacle \u003d\u003d\u003e ())\n\tAddMovingObsticle(MovingObstacle)(mo) \u003d\u003d\nmobs :\u003d (mobs union {mo})\nprivate  LocateMovingObstacles() (() \u003d\u003d\u003e ())\n\tLocateMovingObstacles()() \u003d\u003d\nduration (100) (\n\nlet m:map (Point) to (\u003cOccupied\u003e) \u003d {(mo.GetPos)() |-\u003e \u003cOccupied\u003e | mo in set mobs} in SetObs(m)\n)\nprivate  SetObs(map (Point) to (PointAvalibility)) (map (Point) to (PointAvalibility) \u003d\u003d\u003e ())\n\tSetObs(map (Point) to (PointAvalibility))(mp) \u003d\u003d\n(\n\nobs :\u003d {|-\u003e};\nobs :\u003d (obs ++ mp)\n)\nprivate  WaitForAvalibility(Point) (Point \u003d\u003d\u003e ())\n\tWaitForAvalibility(Point)(p) \u003d\u003d\nwhile IsPointBlocked(p) do (\n\nUtil`PrintDebug(\"Waiting for obstacle on pos:\");\nUtil`PrintValue(p);\nUtil`PrintInt(time);\nskip\n)\nprivate  IsPointBlocked(Point) (Point \u003d\u003d\u003e bool)\n\tIsPointBlocked(Point)(p) \u003d\u003d\n(\n\nUtil`PrintDebug(\"Requesting Pos\");\nUtil`PrintValue(p);\nUtil`PrintDebug(\"Mobs\");\nfor all mo in set (dom obs) do\nUtil`PrintValue(mo);\nif (p in set (dom obs))\nthen\nUtil`PrintDebug(\"in\")else\nUtil`PrintDebug(\"not\");\nreturn ((p in set (dom obs)))\n)\npublic  GetNextPoint(set of (Point), Point) (set of (Point) * Point \u003d\u003d\u003e [Point])\n\tGetNextPoint(set of (Point), Point)(neighbours, dest) \u003d\u003d\nlet tmp:set of (Point) \u003d {p | p in set neighbours \u0026 (not (exists q in set neighbours \u0026 (Distance(p, dest) \u003e Distance(q, dest))))} in for all p in set tmp do\n(\n\nWaitForAvalibility(p);\nreturn (p)\n)\n\tpre ((card neighbours) \u003e 0)\nprivate  private Distance: (Point * Point -\u003e nat)\n\tDistance(p1, p2) \u003d\u003d\ndef a \u003d ((((p2.X) - (p1.X)) * ((p2.X) - (p1.X))) + (((p2.Y) - (p1.Y)) * ((p2.Y) - (p1.Y)))) in\n(if (0 \u003c\u003d a)\nthen (floor MATH`sqrt(a))\nelse 0)\nend NextMoveController\n","class NextMoveControllerTest is subclass of [TestCase]\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend NextMoveControllerTest\n","class ObstacleSensor\npublic static  SensorDirection \u003d SensorDirection\nprivate  sDirection:SensorDirection :\u003d (undefined)\npublic  ObstacleSensor(SensorDirection) (SensorDirection \u003d\u003d\u003e ObstacleSensor)\n\tObstacleSensor(SensorDirection)(direction) \u003d\u003d\nsDirection :\u003d direction\npublic  GetPointAvalibility(Point) (Point \u003d\u003d\u003e PointAvalibility)\n\tGetPointAvalibility(Point)(p) \u003d\u003d\nif ((World`env.GetPointAvalibility)(p) \u003d \u003cOccupied\u003e)\nthen\nreturn (\u003cOccupied\u003e)else\nreturn (\u003cFree\u003e)\n\tpre ((World`env.completeGrid).IsValidGridPoint)(p)\npublic  GetDirection() (() \u003d\u003d\u003e SensorDirection)\n\tGetDirection()() \u003d\u003d\nreturn (sDirection)\nend ObstacleSensor\n","class ObstacleSensorTest is subclass of [TestCase]\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntc:ObstacleSensor :\u003d new ObstacleSensor(\u003cNorth\u003e)\n\nAssertTrue(((tc.GetDirection)() \u003d \u003cNorth\u003e))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend ObstacleSensorTest\n","system Robot\nprivate  cpu1:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  cpu2:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  cpu3:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  cpu4:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  cpu5:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  bus1:BUS :\u003d new BUS(\u003cFCFS\u003e, 1.0E9, {cpu1})\nprivate  bus2:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu1, cpu2})\nprivate  bus3:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu5, cpu1})\nprivate  bus4:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu3, cpu2})\nprivate  bus5:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000000.0, {cpu4, cpu2})\nprivate  name:set of (char) :\u003d (undefined)\npublic static  obsSensorNorth:ObstacleSensor :\u003d new ObstacleSensor(\u003cNorth\u003e)\npublic static  obsSensorSouth:ObstacleSensor :\u003d new ObstacleSensor(\u003cSouth\u003e)\npublic static  obsSensorEast:ObstacleSensor :\u003d new ObstacleSensor(\u003cEast\u003e)\npublic static  obsSensorWest:ObstacleSensor :\u003d new ObstacleSensor(\u003cWest\u003e)\npublic static  dataReader:DataReader :\u003d new DataReader()\npublic static  steering:SteeringController :\u003d new SteeringController()\npublic static  mobs1:MovingObstacle :\u003d new MovingObstacle(mk_Grid`Point(5, 0), \u003cWest\u003e)\npublic static  mobs2:MovingObstacle :\u003d new MovingObstacle(mk_Grid`Point(7, 0), \u003cWest\u003e)\npublic static  mobs3:MovingObstacle :\u003d new MovingObstacle(mk_Grid`Point(20, 20), \u003cWest\u003e)\npublic static  mobs4:MovingObstacle :\u003d new MovingObstacle(mk_Grid`Point(10, 10), \u003cSouth\u003e)\npublic static  nmc:NextMoveController :\u003d new NextMoveController()\npublic  Robot() (() \u003d\u003d\u003e Robot)\n\tRobot()() \u003d\u003d\n(\n\ncpu1.deploy(obsSensorNorth);\ncpu1.deploy(obsSensorSouth);\ncpu1.deploy(obsSensorEast);\ncpu1.deploy(obsSensorWest);\ncpu5.deploy(dataReader);\ncpu1.deploy(steering);\ncpu1.setPriority(\"SteeringController`SetDiscoverInfo\", 80);\ncpu3.deploy(mobs1);\ncpu3.setPriority(\"MovingObstacle`Step\", 15);\ncpu3.deploy(mobs2);\ncpu3.setPriority(\"MovingObstacle`Step\", 15);\ncpu4.deploy(mobs3);\ncpu4.setPriority(\"MovingObstacle`Step\", 15);\ncpu4.deploy(mobs4);\ncpu4.setPriority(\"MovingObstacle`Step\", 15);\ncpu2.deploy(nmc);\ncpu2.setPriority(\"NextMoveController`LocateMovingObstacles\", 80)\n)\nend Robot\n","class RobotTest\npublic  Execute() (() \u003d\u003d\u003e ())\n\tExecute()() \u003d\u003d\n(\nts:TestSuite :\u003d new TestSuite()\n\nts.AddTest(new GridTest(\"Grid\"));\nts.AddTest(new StorageTest(\"Storage\"));\nts.Run()\n)\nend RobotTest\n","class SteeringController\nprivate static  MAX_POINT:Point \u003d mk_Grid`Point(100, 100)\npublic static  Route \u003d Route\nprivate  routes:seq of (Route) :\u003d []\npublic static  obsSensors:set of (ObstacleSensor) :\u003d {}\nprivate  batCap:int :\u003d 1\nprivate  dest:Point :\u003d (undefined)\nprivate  workingGrid:Grid :\u003d (undefined)\nprivate  busy:bool :\u003d true\npublic  SteeringController() (() \u003d\u003d\u003e SteeringController)\n\tSteeringController()() \u003d\u003d\n(\n\nskip\n)\nprivate  GetPointDirection(Point) (Point \u003d\u003d\u003e SensorDirection)\n\tGetPointDirection(Point)(p) \u003d\u003d\n(\n\nlet curPos:Point \u003d GetPos() in if ((curPos.X) \u003e (p.X))\nthen\nreturn (\u003cEast\u003e)else\nif ((curPos.X) \u003c (p.X))\nthen\nreturn (\u003cWest\u003e)else\nif ((curPos.Y) \u003e (p.Y))\nthen\nreturn (\u003cNorth\u003e)else\nreturn (\u003cSouth\u003e)\n)\nprivate  GetBatUsage() (() \u003d\u003d\u003e nat)\n\tGetBatUsage()() \u003d\u003d\nreturn ((len routes((len routes))))\n\tpre ((len routes) \u003e 0)\nprivate  GetPos() (() \u003d\u003d\u003e Point)\n\tGetPos()() \u003d\u003d\nlet r:Route \u003d routes((len routes)) in return (r((len r)))\nprivate  GetRoutes() (() \u003d\u003d\u003e seq of (Route))\n\tGetRoutes()() \u003d\u003d\nreturn (routes)\nprivate  GetNeighbourPoints() (() \u003d\u003d\u003e set of (Point))\n\tGetNeighbourPoints()() \u003d\u003d\nreturn (let cPos:Point \u003d GetPos() in (({mk_Grid`Point((cPos.X), y) | y in set {((cPos.Y) + 1), ((cPos.Y) - 1)} \u0026 (y \u003e\u003d 0)} union {mk_Grid`Point(x, (cPos.Y)) | x in set {((cPos.X) + 1), ((cPos.X) - 1)} \u0026 (x \u003e\u003d 0)}) \\ {cPos}))\n\tpost ((RESULT \u003d let cPos:Point \u003d GetPos() in (({mk_Grid`Point((cPos.X), y) | y in set {((cPos.Y) + 1), ((cPos.Y) - 1)} \u0026 (y \u003e\u003d 0)} union {mk_Grid`Point(x, (cPos.Y)) | x in set {((cPos.X) + 1), ((cPos.X) - 1)} \u0026 (x \u003e\u003d 0)}) \\ {cPos})) and (forall p in set RESULT \u0026 (workingGrid.IsValidGridPoint)(p)))\nprivate  GetNextMove(set of (Point)) (set of (Point) \u003d\u003d\u003e [Point])\n\tGetNextMove(set of (Point))(neighbourPoints) \u003d\u003d\n(\n\nlet freePts:set of (Point) \u003d {p | p in set neighbourPoints \u0026 (((workingGrid.GetPointAvalibility)((p.X), (p.Y)) \u003d \u003cFree\u003e) and (not IsInRoute(p)))} in if ((card freePts) \u003e 0)\nthen\nreturn ((Robot`nmc.GetNextPoint)(freePts, dest))else\nreturn (nil)\n)\nprivate  IsDestination(Point) (Point \u003d\u003d\u003e bool)\n\tIsDestination(Point)(p) \u003d\u003d\nreturn ((((p.X) \u003d (dest.X)) and ((p.Y) \u003d (dest.Y))))\nprivate  DoesRouteHaveMoreOptions() (() \u003d\u003d\u003e bool)\n\tDoesRouteHaveMoreOptions()() \u003d\u003d\n(\n\nreturn (((len routes((len routes))) \u003e 1))\n)\nprivate  IsInRoute(Point) (Point \u003d\u003d\u003e bool)\n\tIsInRoute(Point)(p) \u003d\u003d\n(\n\nlet r:seq of (Point) \u003d (conc routes) in if ((card {r(x) | x in set (inds r) \u0026 (r(x) \u003d p)}) \u003e 0)\nthen\nreturn (true)else\nreturn (false)\n)\nprivate  StartNewRoute() (() \u003d\u003d\u003e ())\n\tStartNewRoute()() \u003d\u003d\n(\n\nlet r:Route \u003d routes((len routes)) in if ((len r) \u003e 1)\nthen\n(\n\nroutes :\u003d (routes ^ [(r(1, ... ,((len routes((len routes))) - 1)))])\n)\n)\npublic  ReturnToBase() (() \u003d\u003d\u003e ())\n\tReturnToBase()() \u003d\u003d\nskip\nprivate  Move(Point) (Point \u003d\u003d\u003e ())\n\tMove(Point)(p) \u003d\u003d\nduration (1000) (\n\nlet r:Route \u003d routes((len routes)) in routes((len routes)) :\u003d (r ^ [p])\n)\n\tpre (((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y)))))\n\tpost (p \u003d routes((len routes))((len routes((len routes)))))\nprivate  RestartNewRoute() (() \u003d\u003d\u003e ())\n\tRestartNewRoute()() \u003d\u003d\n(\n\nReturnToBase();\nStartNewRoute()\n)\nprivate  FindRoute() (() \u003d\u003d\u003e (Grid * seq of (Route) * Point * bool))\n\tFindRoute()() \u003d\u003d\n(\n\nif FindRouteToDestination()\nthen\n(\n\nRobot`dataReader.Read();\nUtil`PrintDebug(\"Succes\")\n)else\n(\n\nUtil`PrintDebug(\"No route found, has reached dead end\")\n);\nReturnToBase();\nUtil`PrintDebug(\"The End\");\nreturn (mk_(workingGrid, routes, dest, IsDestination(GetPos())))\n)\n\tpre (workingGrid.IsValidGridPoint)(dest)\nprivate  FindRouteToDestination() (() \u003d\u003d\u003e bool)\n\tFindRouteToDestination()() \u003d\u003d\n(\n\nwhile ((not IsDestination(GetPos())) and ((GetBatUsage() * 2) \u003c\u003d batCap)) do (\n\nlet neighbourPoints:set of (Point) \u003d {n | n in set GetNeighbourPoints() \u0026 (workingGrid.IsValidGridPoint)(n)} in if ((card neighbourPoints) \u003e 0)\nthen\n(\n\nDiscoverUnknownNeighbourPoints(neighbourPoints);\nlet nextMove:[Point] \u003d GetNextMove(neighbourPoints) in if (nextMove \u003c\u003e nil)\nthen\n(\n\nMove(nextMove);\nUtil`PrintDebug(\"Moved to pos:\");\nUtil`PrintValue(GetPos())\n)else\n(\n\nif DoesRouteHaveMoreOptions()\nthen\nRestartNewRoute()else\nreturn (false)\n)\n)else\nRestartNewRoute()\n);\nreturn (true)\n)\nprivate  DiscoverUnknownNeighbourPoints(set of (Point)) (set of (Point) \u003d\u003d\u003e ())\n\tDiscoverUnknownNeighbourPoints(set of (Point))(neighbourPoints) \u003d\u003d\n(\n\nlet unknownPoints:set of (Point) \u003d {p | p in set neighbourPoints \u0026 ((workingGrid.GetPointAvalibility)((p.X), (p.Y)) \u003d \u003cUnknown\u003e)} in (\n\nlet knownMappings:map (Point) to (PointAvalibility) \u003d {p |-\u003e (obs.GetPointAvalibility)(p) | obs in set obsSensors, p in set unknownPoints \u0026 ((obs.GetDirection)() \u003d GetPointDirection(p))} in workingGrid.SetPointMP(knownMappings)\n)\n)\n\tpre (forall p in set neighbourPoints \u0026 (workingGrid.IsValidGridPoint)(p))\npublic  SetDiscoverInfo(Point, Point, int) (Point * Point * int \u003d\u003d\u003e ())\n\tSetDiscoverInfo(Point, Point, int)(startingPoint, destination, batCapacity) \u003d\u003d\n(\n\nworkingGrid :\u003d new Grid(startingPoint, MAX_POINT);\nworkingGrid.SetPointMP({startingPoint |-\u003e \u003cFree\u003e});\nbatCap :\u003d batCapacity;\ndest :\u003d destination;\nroutes :\u003d [[startingPoint]]\n)\n\tpre (ValidatePoint(MAX_POINT, destination) and (ValidatePoint(MAX_POINT, startingPoint) and (batCapacity \u003e\u003d 2)))\npublic  AddObstacleSensor(ObstacleSensor) (ObstacleSensor \u003d\u003d\u003e ())\n\tAddObstacleSensor(ObstacleSensor)(obs) \u003d\u003d\nobsSensors :\u003d (obsSensors union {obs})\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\nprivate  per isFinished \u003d\u003e (not busy)\nprotected  thread while busy do (\n\nlet res:(Grid * seq of (Route) * Point * bool) \u003d FindRoute() in World`env.handleEvent((res.#1), (res.#2), (res.#3), (res.#4));\nbusy :\u003d false\n)\nprivate  per FindRoute \u003d\u003e (#fin[SetDiscoverInfo] \u003e #fin[FindRoute])\nprivate  mutex(FindRoute)\nprivate  mutex(SetDiscoverInfo, FindRoute)\nprivate  mutex(SetDiscoverInfo)\nprivate  mutex(AddObstacleSensor)\nprivate  private ValidatePoint: (Point * Point -\u003e bool)\n\tValidatePoint(max, point) \u003d\u003d\n(((max.X) \u003e\u003d (point.X)) and (((max.Y) \u003e\u003d (point.Y)) and (((point.X) \u003e\u003d 0) and ((point.Y) \u003e\u003d 0))))\nend SteeringController\n","class SteeringControllerTest is subclass of [TestCase]\nprivate static  sta:Point \u003d mk_Grid`Point(0, 0)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nskip\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend SteeringControllerTest\n","class Storage\npublic static  inDataType \u003d inDataType\nprivate static  startIndex:nat \u003d 1\nprivate static  destIndex:nat \u003d 2\nprivate static  batCapIndex:nat \u003d 3\nprivate  file:IO :\u003d (undefined)\nprivate  inputFileName:seq of (char) :\u003d \"map.m\"\nprivate  inv(inputFileName \u003c\u003e [])\nprivate  outputFileName:seq of (char) :\u003d (undefined)\nprivate  inv(outputFileName \u003c\u003e [])\nprivate  inData:seq of (inDataType) :\u003d []\npublic  dest:Point :\u003d (undefined)\npublic  startingPoint:Point :\u003d (undefined)\npublic  battery:nat :\u003d (undefined)\nprivate  inv(battery \u003e\u003d 0)\nprivate  counter:nat :\u003d (undefined)\npublic  fields:nat :\u003d (undefined)\nprivate  inv((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))\npublic  Storage() (() \u003d\u003d\u003e Storage)\n\tStorage()() \u003d\u003d\n(\n\nbattery :\u003d 0;\nfile :\u003d new IO();\nstartingPoint :\u003d mk_Grid`Point(0, 0);\noutputFileName :\u003d \"TestRun.txt\";\nfields :\u003d 0\n)\npublic  Load(seq of (char)) (seq of (char) \u003d\u003d\u003e Grid)\n\tLoad(seq of (char))(newFileName) \u003d\u003d\n(\n\ninputFileName :\u003d newFileName;\nfile :\u003d new IO();\nlet mk_(-, input) \u003d ((file.freadval))[seq of (inDataType)](inputFileName) in inData :\u003d input;\nreturn (SetData(inData))\n)\n\tpre (newFileName \u003c\u003e [])\nprivate  SetData(seq of (inDataType)) (seq of (inDataType) \u003d\u003d\u003e Grid)\n\tSetData(seq of (inDataType))(data) \u003d\u003d\n(\n\nlet g \u003d new Grid(mk_Grid`Point(0, 0), mk_Grid`Point(100, 100)) in (\n\nstartingPoint :\u003d mk_Grid`Point((data(startIndex).#1), (data(startIndex).#2));\ndest :\u003d mk_Grid`Point((data(destIndex).#1), (data(destIndex).#2));\nbattery :\u003d (inData(batCapIndex).#1);\nfields :\u003d ((len data) - 2);\nlet obsticales:map (Grid`Point) to (\u003cOccupied\u003e) \u003d {mk_Grid`Point((data(i).#1), (inData(i).#2)) |-\u003e \u003cOccupied\u003e | i in set {4, ... ,(len data)}} in g.SetPointMP(obsticales);\nreturn (g)\n)\n)\n\tpre ((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data))))\npublic  Save(Grid, seq of (Route), Point, bool) (Grid * seq of (Route) * Point * bool \u003d\u003d\u003e ())\n\tSave(Grid, seq of (Route), Point, bool)(g, routes, dest, b) \u003d\u003d\n(\n\nPrintLine(\"#--START--#\");\nPrintLine(\"#--Start Successfull Destination--#\");\nlet - \u003d ((file.fwriteval))[(bool * Point)](outputFileName, mk_(b, dest), \u003cappend\u003e) in skip;\nPrintLine(\"#--End Successfull Destination--#\");\nPrintLine(\"#--Start Grid--#\");\nfor all x in set (dom (g.points)) do\n(\n\nWriteMap(x, (g.points)(x))\n);\nPrintLine(\"#--End Grid--#\");\nfor all x in set (inds routes) do\n(\n\nPrintLine(\"#--Start Route--#\");\nPrintInt(x);\nWriteRoute(routes(x));\nPrintLine(\"#--End Reoute Grid--#\")\n);\nPrintLine(\"#--END--#\")\n)\nprivate  WriteMap(Point, PointAvalibility) (Point * PointAvalibility \u003d\u003d\u003e ())\n\tWriteMap(Point, PointAvalibility)(g, p) \u003d\u003d\n(\n\nfile :\u003d new IO();\nlet - \u003d ((file.fwriteval))[(Point * PointAvalibility)](outputFileName, mk_(g, p), \u003cappend\u003e) in skip\n)\nprivate  WriteRoute(Route) (Route \u003d\u003d\u003e ())\n\tWriteRoute(Route)(r) \u003d\u003d\n(\n\nfile :\u003d new IO();\nfor all x in set (inds r) do\n(\n\nlet - \u003d ((file.fwriteval))[Point](outputFileName, r(x), \u003cappend\u003e) in skip\n)\n)\nprivate  PrintInt(nat) (nat \u003d\u003d\u003e ())\n\tPrintInt(nat)(i) \u003d\u003d\n(\n\nfile :\u003d new IO();\nlet - \u003d ((file.fwriteval))[nat](outputFileName, i, \u003cappend\u003e) in skip\n)\nprivate  PrintLine(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrintLine(seq of (char))(line) \u003d\u003d\n(\n\nfile :\u003d new IO();\nlet - \u003d ((file.fwriteval))[seq of (char)](outputFileName, line, \u003cappend\u003e) in skip\n)\nend Storage\n","class StorageTest is subclass of [TestCase]\nprivate  completeGrid:Grid :\u003d (undefined)\npublic  StorageTest(seq of (char)) (seq of (char) \u003d\u003d\u003e StorageTest)\n\tStorageTest(seq of (char))(name) \u003d\u003d\nTestCase(name)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntc:Storage :\u003d new Storage()\n\ncompleteGrid :\u003d (tc.Load)(\"testmap.txt\");\nAssertTrue(((tc.fields) \u003d (card (dom (completeGrid.points)))));\nAssertTrue(((tc.startingPoint) \u003d mk_Grid`Point(0, 0)));\nAssertTrue(((tc.dest) \u003d mk_Grid`Point(10, 10)));\nAssertTrue((\u003cOccupied\u003e \u003d (completeGrid.GetPointAvalibility)(1, 1)));\nAssertTrue((\u003cOccupied\u003e \u003d (completeGrid.GetPointAvalibility)(2, 2)));\nAssertTrue((\u003cOccupied\u003e \u003d (completeGrid.GetPointAvalibility)(3, 3)));\nAssertTrue((\u003cOccupied\u003e \u003d (completeGrid.GetPointAvalibility)(4, 4)))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend StorageTest\n","class Util\npublic static  PrintValue(Point) (Point \u003d\u003d\u003e ())\n\tPrintValue(Point)(p) \u003d\u003d\n(\n\nlet file \u003d new IO() in let - \u003d ((file.writeval))[(int * int)](mk_((p.X), (p.Y))) in skip\n)\npublic static  PrintDebug(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrintDebug(seq of (char))(debugData) \u003d\u003d\n(\n\nlet file \u003d new IO() in let - \u003d (file.echo)((debugData ^ \"\n\")) in skip\n)\npublic static  PrintInt(int) (int \u003d\u003d\u003e ())\n\tPrintInt(int)(i) \u003d\u003d\n(\n\nlet file \u003d new IO() in let - \u003d ((file.writeval))[int](i) in skip\n)\nend Util\n","class Test\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(-) \u003d\u003d\nis subclass responsibility\nend Test\n","class TestCase is subclass of [Test]\nprivate  name:seq of (char) :\u003d (undefined)\npublic  TestCase(seq of (char)) (seq of (char) \u003d\u003d\u003e TestCase)\n\tTestCase(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\npublic  GetName() (() \u003d\u003d\u003e seq of (char))\n\tGetName()() \u003d\u003d\nreturn (name)\nprotected  AssertTrue(bool) (bool \u003d\u003d\u003e ())\n\tAssertTrue(bool)(pb) \u003d\u003d\nif (not pb)\nthen\nexit (\u003cFAILURE\u003e)\nprotected  AssertFalse(bool) (bool \u003d\u003d\u003e ())\n\tAssertFalse(bool)(pb) \u003d\u003d\nif pb\nthen\nexit (\u003cFAILURE\u003e)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(ptr) \u003d\u003d\ntrap in \u0027TestCase\u0027 (VDMUnit Framework.vdmrt) at line 31:9\u003cFAILURE\u003eADefPatternBind[]ADefPatternBind with ptr.AddFailure(self) in (\n\nSetUp();\nRunTest();\nTearDown()\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nis subclass responsibility\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nis subclass responsibility\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nis subclass responsibility\nend TestCase\n","class TestSuite is subclass of [Test]\nprivate  tests:seq of (Test) :\u003d []\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\nntr:TestResult :\u003d new TestResult()\n\nRun(ntr);\nntr.Show()\n)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(result) \u003d\u003d\nfor in \u0027TestSuite\u0027 (VDMUnit Framework.vdmrt) at line 66:8testADefPatternBind[test \u003d Test]ADefPatternBind in tests do\ntest.Run(result)\npublic  AddTest(Test) (Test \u003d\u003d\u003e ())\n\tAddTest(Test)(test) \u003d\u003d\ntests :\u003d (tests ^ [test])\nend TestSuite\n","class TestResult\nprivate  failures:seq of (TestCase) :\u003d []\npublic  AddFailure(TestCase) (TestCase \u003d\u003d\u003e ())\n\tAddFailure(TestCase)(ptst) \u003d\u003d\nfailures :\u003d (failures ^ [ptst])\npublic  Print(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrint(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((pstr ^ \"\n\")) in skip\npublic  Show() (() \u003d\u003d\u003e ())\n\tShow()() \u003d\u003d\nif (failures \u003d [])\nthen\nPrint(\"No failures detected\")else\nfor in \u0027TestResult\u0027 (VDMUnit Framework.vdmrt) at line 96:10failureADefPatternBind[failure \u003d TestCase]ADefPatternBind in failures do\nPrint(((failure.GetName)() ^ \" failed\"))\nend TestResult\n","class World\npublic static  env:[Enviroment] :\u003d nil\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Enviroment();\nRobot`nmc.AddMovingObsticle(Robot`mobs1);\nRobot`nmc.AddMovingObsticle(Robot`mobs2);\nRobot`nmc.AddMovingObsticle(Robot`mobs3);\nRobot`nmc.AddMovingObsticle(Robot`mobs4);\nRobot`steering.AddObstacleSensor(Robot`obsSensorNorth);\nRobot`steering.AddObstacleSensor(Robot`obsSensorSouth);\nRobot`steering.AddObstacleSensor(Robot`obsSensorEast);\nRobot`steering.AddObstacleSensor(Robot`obsSensorWest)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nstart (env);\nenv.isFinished()\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n"]