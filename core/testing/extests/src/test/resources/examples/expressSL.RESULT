["LampId \u003d LampId","darklamps:set of (LampId) \u003d {}","stoplamps:set of (LampId) \u003d {\u003cL1\u003e, \u003cL2\u003e}","warninglamps:set of (LampId) \u003d {\u003cL1\u003e, \u003cL3\u003e}","drivelamps:set of (LampId) \u003d {\u003cL2\u003e, \u003cL3\u003e}","Signal \u003d Signal","LogCom \u003d LogCom","Message \u003d Message","Errors \u003d Errors","Control ([LogCom] * set of (LampId) \u003d\u003d\u003e (Message * Errors * Trace))\n\tControl(com, failures) \u003d\u003d\nlet newstate:Dwarf \u003d NormalTrans(com) in ErrorCorrection(com, newstate, failures)\n\tpre AllowedCommand(com, lampstate)","private static AllowedCommand: ([LogCom] * Signal +\u003e bool)\n\tAllowedCommand(com, signal) \u003d\u003d\n(((com \u003d \u003cdark\u003e) \u003d\u003e (signal in set {stoplamps, darklamps})) and ((com in set {\u003cwarning\u003e, \u003cdrive\u003e}) \u003d\u003e (signal \u003c\u003e darklamps)))","Trace \u003d Trace","state Dwarfof\n[trace : Trace, lampstate : Signal]\n\tinv mk_Dwarf(t, s) \u003d\u003d (MaxOneLampChange(t) and (StopToDriveOrWarning(t) and (ToAndFromDark(t) and AlwaysDefinedState(s))))\n\tinit s \u003d\u003d (s \u003d mk_Dwarf([stoplamps], stoplamps))","NormalTrans ([LogCom] \u003d\u003d\u003e Dwarf)\n\tNormalTrans(command) \u003d\u003d\ncases command :\n  nil -\u003e return (mk_Dwarf([], lampstate))  \u003cdark\u003e -\u003e let t:([] | seq1 of ((set of (\u003cL1\u003e) | set of (LampId)))) \u003d (if (lampstate \u003d stoplamps)\nthen [{\u003cL1\u003e}, darklamps]\nelse []) in return (mk_Dwarf(t, darklamps))  \u003cstop\u003e -\u003e let t:([] | seq1 of ((set of (\u003cL1\u003e) | set of (LampId))) | seq1 of ((set of (\u003cL2\u003e) | set of (LampId)))) \u003d (if (lampstate \u003d darklamps)\nthen [{\u003cL1\u003e}, stoplamps]\nelseif (lampstate \u003d warninglamps)\nthen [{\u003cL1\u003e}, stoplamps]\nelseif (lampstate \u003d drivelamps)\nthen [{\u003cL2\u003e}, stoplamps]\nelse []) in return (mk_Dwarf(t, stoplamps))  \u003cwarning\u003e -\u003e let t:([] | seq1 of ((set of (\u003cL1\u003e) | set of (LampId))) | seq1 of ((set of (\u003cL3\u003e) | set of (LampId)))) \u003d (if (lampstate \u003d drivelamps)\nthen [{\u003cL3\u003e}, warninglamps]\nelseif (lampstate \u003d stoplamps)\nthen [{\u003cL1\u003e}, warninglamps]\nelse []) in return (mk_Dwarf(t, warninglamps))  \u003cdrive\u003e -\u003e let t:([] | seq1 of ((set of (\u003cL2\u003e) | set of (LampId))) | seq1 of ((set of (\u003cL3\u003e) | set of (LampId)))) \u003d (if (lampstate \u003d warninglamps)\nthen [{\u003cL3\u003e}, drivelamps]\nelseif (lampstate \u003d stoplamps)\nthen [{\u003cL2\u003e}, drivelamps]\nelse []) in return (mk_Dwarf(t, drivelamps))  others -\u003e error end\n\tpre AllowedCommand(command, lampstate)","ErrorCorrection ([LogCom] * Dwarf * set of (LampId) \u003d\u003d\u003e (Message * Errors * Trace))\n\tErrorCorrection(com, dwarf, failures) \u003d\u003d\nif (failures \u003d {\u003cL2\u003e})\nthen\n(\n\ncases com :\n  nil -\u003e if (\u003cL2\u003e in set lampstate)\nthen\nlet errdwarf:Dwarf \u003d NormalTrans(\u003cwarning\u003e) in NoCorrection(com, errdwarf, failures)else\nNoCorrection(com, dwarf, failures)  \u003cdark\u003e -\u003e NoCorrection(com, dwarf, failures)  \u003cstop\u003e -\u003e let errdwarf:Dwarf \u003d NormalTrans(\u003cwarning\u003e) in NoCorrection(com, errdwarf, failures)  \u003cwarning\u003e -\u003e NoCorrection(com, dwarf, failures)  \u003cdrive\u003e -\u003e let errdwarf:Dwarf \u003d NormalTrans(\u003cwarning\u003e) in NoCorrection(com, errdwarf, failures)  others -\u003e error end\n)else\n(\n\nNoCorrection(com, dwarf, failures)\n)","NoCorrection ([LogCom] * Dwarf * set of (LampId) \u003d\u003d\u003e (Message * Errors * Trace))\n\tNoCorrection(com, mk_Dwarf(newtr, newsignals), failures) \u003d\u003d\n(\n\ntrace :\u003d (trace ^ newtr);\nlampstate :\u003d newsignals;\nlet m:(\u003cport_failure\u003e | \u003cunknown\u003e | [LogCom]) \u003d (if (failures \u003c\u003e {})\nthen \u003cport_failure\u003e\nelseif (com \u003d nil)\nthen \u003cunknown\u003e\nelse com) in return (mk_(m, {}, newtr))\n)","private static MaxOneLampChange: (Trace +\u003e bool)\n\tMaxOneLampChange(t) \u003d\u003d\n(forall i in set ((inds t) \\ {1}) \u0026 (((card (t((i - 1)) \\ t(i))) \u003c\u003d 1) and ((card (t(i) \\ t((i - 1)))) \u003c\u003d 1)))","private static StopToDriveOrWarning: (Trace +\u003e bool)\n\tStopToDriveOrWarning(t) \u003d\u003d\n(forall i, j in set (inds t) \u0026 (((i \u003c j) and ((t(i) \u003d stoplamps) and ((t(j) in set {drivelamps, warninglamps}) and (not (exists k in set {(i + 1), ... ,(j - 1)} \u0026 (t(k) in set {darklamps, warninglamps, drivelamps})))))) \u003d\u003e (forall k in set {(i + 1), ... ,(j - 1)} \u0026 (((card t(k)) \u003c 3) and ((card t(k)) \u003e 0)))))","private static ToAndFromDark: (Trace +\u003e bool)\n\tToAndFromDark(t) \u003d\u003d\n(forall i in set (inds t) \u0026 ((t(i) \u003d darklamps) \u003d\u003e ToOrFromStop(t, i)))","private static ToOrFromStop: (Trace * nat1 +\u003e bool)\n\tToOrFromStop(t, i) \u003d\u003d\n(((i \u003e 2) \u003d\u003e (t((i - 2)) \u003d stoplamps)) and (((i + 1) \u003c (len t)) \u003d\u003e (t((i + 2)) \u003d stoplamps)))","private static AlwaysDefinedState: (Signal +\u003e bool)\n\tAlwaysDefinedState(sig) \u003d\u003d\n(sig in set {darklamps, stoplamps, warninglamps, drivelamps})","[SeqTest][[([[com:LogComALetBeStBindingTraceDefinitionNormalTrans(com){1,1}def com:LogCom]]){5,5}]]"]