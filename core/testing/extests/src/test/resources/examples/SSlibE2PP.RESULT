["class SAFERSys\npublic static  SAFER \u003d SAFER\nprivate  private ControlCycle: (SwitchPositions * HandGripPosition * RotCommand * SAFER * AAH -\u003e (ThrusterSet * SAFER * AAH))\n\tControlCycle(mk_SwitchPositions(mode, aah), raw_grip, aah_cmd, saferstate, aahstate) \u003d\u003d\nlet mk_SAFER(clock):SAFER \u003d saferstate, grip_cmd:SixDofCommand \u003d GripCommand(raw_grip, mode), thrusters:ThrusterSet \u003d SelectedThrusters(grip_cmd, aah_cmd, (aahstate.active_axes), (aahstate.ignore_hcm)), aahstate\u0027:AAH \u003d Transition(aah, grip_cmd, clock, aahstate), saferstate\u0027:SAFER \u003d mu(saferstate, clock |-\u003e (clock + 1)) in mk_(thrusters, saferstate\u0027, aahstate\u0027)\n\tpost let mk_(thr, -, -):(ThrusterSet * SAFER * AAH) \u003d RESULT in (((card thr) \u003c\u003d 4) and ThrusterConsistency(thr))\nprivate  private ThrusterConsistency: (set of (ThrusterName) +\u003e bool)\n\tThrusterConsistency(thrusters) \u003d\u003d\n((not ({\u003cB1\u003e, \u003cF1\u003e} subset thrusters)) and ((not ({\u003cB2\u003e, \u003cF2\u003e} subset thrusters)) and ((not ({\u003cB3\u003e, \u003cF3\u003e} subset thrusters)) and ((not ({\u003cB4\u003e, \u003cF4\u003e} subset thrusters)) and ((not (((thrusters inter {\u003cL1R\u003e, \u003cL1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR2R\u003e, \u003cR2F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cL3R\u003e, \u003cL3F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR4R\u003e, \u003cR4F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cD1R\u003e, \u003cD1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU3R\u003e, \u003cU3F\u003e}) \u003c\u003e {}))) and (not (((thrusters inter {\u003cD2R\u003e, \u003cD2F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU4R\u003e, \u003cU4F\u003e}) \u003c\u003e {}))))))))))\nprivate static  axis_command_set:set of (AxisCommand) \u003d {\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e}\nprivate static  tran_axis_set:set of (TranAxis) \u003d {\u003cX\u003e, \u003cY\u003e, \u003cZ\u003e}\npublic static  rot_axis_set:set of (RotAxis) \u003d {\u003cRoll\u003e, \u003cPitch\u003e, \u003cYaw\u003e}\nprivate static  null_tran_command:TranCommand \u003d {a |-\u003e \u003cZero\u003e | a in set tran_axis_set}\nprivate static  null_rot_command:RotCommand \u003d {a |-\u003e \u003cZero\u003e | a in set rot_axis_set}\nprivate static  null_six_dof:SixDofCommand \u003d mk_SixDofCommand(null_tran_command, null_rot_command)\npublic static  AxisCommand \u003d AxisCommand\nprivate static  TranAxis \u003d TranAxis\npublic static  RotAxis \u003d RotAxis\nprivate static  TranCommand \u003d TranCommand\n\tinv cmd \u003d\u003d ((dom cmd) \u003d tran_axis_set)\npublic static  RotCommand \u003d RotCommand\n\tinv cmd \u003d\u003d ((dom cmd) \u003d rot_axis_set)\nprivate static  SixDofCommand \u003d SixDofCommand\npublic static  AAH \u003d AAH\npublic static  EngageState \u003d EngageState\nprivate static  click_timeout:nat \u003d 10\nprivate  private Transition: (ControlButton * SixDofCommand * nat * AAH -\u003e AAH)\n\tTransition(button_pos, hcm_cmd, clock, aahstate) \u003d\u003d\nlet mk_AAH(active_axes, ignore_hcm, toggle, timeout):AAH \u003d aahstate, engage:EngageState \u003d ButtonTransition(toggle, button_pos, active_axes, clock, timeout), starting:bool \u003d ((toggle \u003d \u003cAAH_off\u003e) and (engage \u003d \u003cAAH_started\u003e)), aahstate\u0027:AAH \u003d mu(aahstate, active_axes |-\u003e {a | a in set rot_axis_set \u0026 (starting or ((engage \u003c\u003e \u003cAAH_off\u003e) and ((a in set active_axes) and (((hcm_cmd.rot)(a) \u003d \u003cZero\u003e) or (a in set ignore_hcm)))))}, ignore_hcm |-\u003e {a | a in set rot_axis_set \u0026 ((starting and ((hcm_cmd.rot)(a) \u003c\u003e \u003cZero\u003e)) or ((not starting) and (a in set ignore_hcm)))}, timeout |-\u003e (if ((toggle \u003d \u003cAAH_on\u003e) and (engage \u003d \u003cpressed_once\u003e))\nthen (clock + click_timeout)\nelse timeout), toggle |-\u003e engage) in aahstate\u0027\nprivate  private AllAxesOff: (set of (RotAxis) +\u003e bool)\n\tAllAxesOff(active) \u003d\u003d\n(active \u003d {})\nprivate  private ButtonTransition: (EngageState * ControlButton * set of (RotAxis) * nat * nat +\u003e EngageState)\n\tButtonTransition(estate, button, active, clock, timeout) \u003d\u003d\n(cases mk_(estate, button) :\nmk_(\u003cAAH_off\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cAAH_off\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_started\u003e, \u003cUp\u003e) -\u003e \u003cAAH_on\u003e,\nmk_(\u003cAAH_started\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_on\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff(active)\nthen \u003cAAH_off\u003e\nelse \u003cAAH_on\u003e),\nmk_(\u003cAAH_on\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cpressed_once\u003e, \u003cUp\u003e) -\u003e \u003cAAH_closing\u003e,\nmk_(\u003cpressed_once\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cAAH_closing\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff(active)\nthen \u003cAAH_off\u003e\nelseif (clock \u003e timeout)\nthen \u003cAAH_on\u003e\nelse \u003cAAH_closing\u003e),\nmk_(\u003cAAH_closing\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e\n end)\npublic static  SwitchPositions \u003d SwitchPositions\npublic static  ControlModeSwitch \u003d ControlModeSwitch\npublic static  ControlButton \u003d ControlButton\npublic static  HandGripPosition \u003d HandGripPosition\nprivate  private GripCommand: (HandGripPosition * ControlModeSwitch +\u003e SixDofCommand)\n\tGripCommand(mk_HandGripPosition(vert, horiz, trans, twist), mode) \u003d\u003d\nlet tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen twist\nelse \u003cZero\u003e)} in mk_SixDofCommand(tran, rot)\npublic static  ThrusterName \u003d ThrusterName\npublic static  ThrusterSet \u003d ThrusterSet\nprivate  private RotCmdsPresent: (RotCommand +\u003e bool)\n\tRotCmdsPresent(cmd) \u003d\u003d\n(exists a in set (dom cmd) \u0026 (cmd(a) \u003c\u003e \u003cZero\u003e))\nprivate  private PrioritizedTranCmd: (TranCommand +\u003e TranCommand)\n\tPrioritizedTranCmd(tran) \u003d\u003d\n(if (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cX\u003e |-\u003e tran(\u003cX\u003e)})\nelseif (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cY\u003e |-\u003e tran(\u003cY\u003e)})\nelseif (tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cZ\u003e |-\u003e tran(\u003cZ\u003e)})\nelse null_tran_command)\nprivate  private CombinedRotCmds: (RotCommand * RotCommand * set of (RotAxis) +\u003e RotCommand)\n\tCombinedRotCmds(hcm_rot, aah, ignore_hcm) \u003d\u003d\nlet aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in ({a |-\u003e aah(a) | a in set aah_axes} munion {a |-\u003e hcm_rot(a) | a in set (rot_axis_set \\ aah_axes)})\nprivate  private IntegratedCommands: (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +\u003e SixDofCommand)\n\tIntegratedCommands(mk_SixDofCommand(tran, rot), aah, active_axes, ignore_hcm) \u003d\u003d\n(if AllAxesOff(active_axes)\nthen (if RotCmdsPresent(rot)\nthen mk_SixDofCommand(null_tran_command, rot)\nelse mk_SixDofCommand(PrioritizedTranCmd(tran), null_rot_command))\nelse (if RotCmdsPresent(rot)\nthen mk_SixDofCommand(null_tran_command, CombinedRotCmds(rot, aah, ignore_hcm))\nelse mk_SixDofCommand(PrioritizedTranCmd(tran), aah)))\nprivate  private BFThrusters: (AxisCommand * AxisCommand * AxisCommand +\u003e (ThrusterSet * ThrusterSet))\n\tBFThrusters(A, B, C) \u003d\u003d\n(cases mk_(A, B, C) :\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB3\u003e, \u003cB4\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e}, {\u003cB1\u003e, \u003cB4\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cB4\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB3\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e}, {\u003cB1\u003e, \u003cB4\u003e}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB2\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB4\u003e, \u003cF1\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB4\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cF1\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF1\u003e}, {\u003cF2\u003e, \u003cF3\u003e}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF1\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF2\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF1\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF2\u003e, \u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF2\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF3\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF4\u003e}, {\u003cF2\u003e, \u003cF3\u003e})\n end)\nprivate  private LRUDThrusters: (AxisCommand * AxisCommand * AxisCommand +\u003e (ThrusterSet * ThrusterSet))\n\tLRUDThrusters(A, B, C) \u003d\u003d\n(cases mk_(A, B, C) :\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cL1R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cL1R\u003e, \u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cU3R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cU3R\u003e, \u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cL1R\u003e, \u003cR4R\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cR2R\u003e, \u003cL3R\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cD1R\u003e, \u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cD1R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cR2R\u003e, \u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cR2R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({}, {})\n end)\nprivate  private SelectedThrusters: (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +\u003e ThrusterSet)\n\tSelectedThrusters(hcm, aah, active_axes, ignore_hcm) \u003d\u003d\nlet mk_SixDofCommand(tran, rot):SixDofCommand \u003d IntegratedCommands(hcm, aah, active_axes, ignore_hcm), mk_(bf_mandatory, bf_optional):(ThrusterSet * ThrusterSet) \u003d BFThrusters(tran(\u003cX\u003e), rot(\u003cPitch\u003e), rot(\u003cYaw\u003e)), mk_(lrud_mandatory, lrud_optional):(ThrusterSet * ThrusterSet) \u003d LRUDThrusters(tran(\u003cY\u003e), tran(\u003cZ\u003e), rot(\u003cRoll\u003e)), bf_thr:ThrusterSet \u003d (if (rot(\u003cRoll\u003e) \u003d \u003cZero\u003e)\nthen (bf_optional union bf_mandatory)\nelse bf_mandatory), lrud_thr:ThrusterSet \u003d (if ((rot(\u003cPitch\u003e) \u003d \u003cZero\u003e) and (rot(\u003cYaw\u003e) \u003d \u003cZero\u003e))\nthen (lrud_optional union lrud_mandatory)\nelse lrud_mandatory) in (bf_thr union lrud_thr)\npublic  BigTest() (() \u003d\u003d\u003e map ((SwitchPositions * HandGripPosition * RotCommand)) to ((ThrusterSet * SAFER * AAH)))\n\tBigTest()() \u003d\u003d\nlet switch_positions:set of (SwitchPositions) \u003d {mk_SwitchPositions(mode, aah) | mode in set {\u003cTran\u003e, \u003cRot\u003e}, aah in set {\u003cUp\u003e, \u003cDown\u003e}}, grip_positions:set of (HandGripPosition) \u003d {mk_HandGripPosition(vert, horiz, trans, twist) | vert, horiz, trans, twist in set axis_command_set \u0026 (((vert \u003d \u003cZero\u003e) and ((horiz \u003d \u003cZero\u003e) and (trans \u003d \u003cZero\u003e))) or (((vert \u003d \u003cZero\u003e) and ((horiz \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))) or (((vert \u003d \u003cZero\u003e) and ((trans \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))) or ((horiz \u003d \u003cZero\u003e) and ((trans \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))))))}, all_rot_commands:set of (RotCommand) \u003d {{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set axis_command_set}, safer:SAFER \u003d mk_SAFER(0), aah:AAH \u003d mk_AAH({}, {}, \u003cAAH_off\u003e, 0) in (\n\nreturn ({mk_(switch, grip, aah_law) |-\u003e ControlCycle(switch, grip, aah_law, safer, aah) | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands})\n)\npublic  HugeTest() (() \u003d\u003d\u003e map ((SwitchPositions * HandGripPosition * RotCommand)) to ((ThrusterSet * SAFER * AAH)))\n\tHugeTest()() \u003d\u003d\nlet switch_positions:set of (SwitchPositions) \u003d {mk_SwitchPositions(mode, aah) | mode in set {\u003cTran\u003e, \u003cRot\u003e}, aah in set {\u003cUp\u003e, \u003cDown\u003e}}, all_grip_positions:set of (HandGripPosition) \u003d {mk_HandGripPosition(vert, horiz, trans, twist) | vert, horiz, trans, twist in set axis_command_set}, all_rot_commands:set of (RotCommand) \u003d {{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set axis_command_set}, safer:SAFER \u003d mk_SAFER(0), aah:AAH \u003d mk_AAH({}, {}, \u003cAAH_off\u003e, 0) in (\n\nreturn ({mk_(switch, grip, aah_law) |-\u003e ControlCycle(switch, grip, aah_law, safer, aah) | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands})\n)\nend SAFERSys\n"]