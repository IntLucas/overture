["Key \u003d Key","Room \u003d Room","Guest \u003d Guest","Card \u003d Card","Desk \u003d Desk\n\tinv d \u003d\u003d ((rng (d.prev)) subset (d.issued))","state Hotelof\n[desk : Desk, locks : map (Room) to (Key), guests : map (Guest) to (set of (Card))]\n\tinv h \u003d\u003d (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))\n\tinit h \u003d\u003d ((((h.desk).issued) \u003d {}) and ((((h.desk).prev) \u003d (h.locks)) and ((rng (h.guests)) \u003d {{}})))","CheckIn([g]Guest, [r]Room)\n\text [wr[desk]Desk, wr[guests]map (Guest) to (set of (Card))]\n\tpre (r in set (dom (desk.prev)))\n\tpost (exists new_k:Key \u0026 ((new_k not in set (desk~.issued)) and let new_c:Card \u003d mk_Card((desk~.prev)(r), new_k) in (((desk.issued) \u003d ((desk~.issued) union {new_k})) and (((desk.prev) \u003d ((desk~.prev) ++ {r |-\u003e new_k})) and (if (g in set (dom guests~))\nthen (guests \u003d (guests~ ++ {g |-\u003e (guests~(g) union {new_c})}))\nelse (guests \u003d (guests~ munion {g |-\u003e {new_c}})))))))","Enter([r]Room, [g]Guest)\n\text [wr[locks]map (Room) to (Key), rd[guests]map (Guest) to (set of (Card))]\n\tpre ((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r))))))\n\tpost (exists c in set guests(g) \u0026 ((((c.fst) \u003d locks(r)) and (locks \u003d (locks~ ++ {r |-\u003e (c.snd)}))) or (((c.snd) \u003d locks(r)) and (locks \u003d locks~))))","CheckInExpl (Guest * Room \u003d\u003d\u003e ())\n\tCheckInExpl(g, r) \u003d\u003d\nlet new_k:Key be st (new_k not in set (desk.issued)) in let new_c:Card \u003d mk_Card((desk.prev)(r), new_k) in (\n\ndesk.issued :\u003d ((desk.issued) union {new_k});\ndesk.prev :\u003d ((desk.prev) ++ {r |-\u003e new_k});\nguests :\u003d (if (g in set (dom guests))\nthen (guests ++ {g |-\u003e (guests(g) union {new_c})})\nelse (guests munion {g |-\u003e {new_c}}))\n)\n\tpre (r in set (dom (desk.prev)))","EnterExpl (Room * Guest \u003d\u003d\u003e ())\n\tEnterExpl(r, g) \u003d\u003d\nlet c in set guests(g) be st (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r))) in if ((c.fst) \u003d locks(r))\nthen\nlocks :\u003d (locks ++ {r |-\u003e (c.snd)})\n\tpre ((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r))))))","IssueCard (() \u003d\u003d\u003e Key)\n\tIssueCard() \u003d\u003d\nlet k:Key be st (k not in set (desk.issued)) in (\n\ndesk.issued :\u003d ((desk.issued) union {k});\nreturn (k)\n)","AddRoom (Room * Key \u003d\u003d\u003e ())\n\tAddRoom(r, k) \u003d\u003d\n(\n\ndesk.prev :\u003d ((desk.prev) munion {r |-\u003e k});\nlocks :\u003d (locks munion {r |-\u003e k})\n)\n\tpre ((k in set (desk.issued)) and (r not in set (dom locks)))","AddGuest (Guest * set of (Card) \u003d\u003d\u003e ())\n\tAddGuest(g, cs) \u003d\u003d\nguests :\u003d (guests ++ {g |-\u003e (if (g in set (dom guests))\nthen (guests(g) union cs)\nelse cs)})\n\tpre (forall c in set cs \u0026 ({(c.fst), (c.snd)} subset (desk.issued)))"]