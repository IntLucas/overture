["class BaseRTThread\npublic static  ThreadDef \u003d ThreadDef\nprotected  period:nat1 :\u003d 1.0E9\nprotected  isPeriodic:bool :\u003d true\nprotected  jitter:nat :\u003d 0\nprotected  delay:nat :\u003d 0\nprotected  offset:nat :\u003d 0\nprotected  registeredSelf:BaseRTThread :\u003d (undefined)\nprotected  timeStamp:RTTimeStamp :\u003d RTTimeStamp`GetInstance()\nprotected  BaseRTThread(BaseRTThread) (BaseRTThread \u003d\u003d\u003e BaseRTThread)\n\tBaseRTThread(BaseRTThread)(t) \u003d\u003d\n(\n\nregisteredSelf :\u003d t;\ntimeStamp.RegisterThread(registeredSelf);\nif (not (timeStamp.IsInitialising)())\nthen\nstart (registeredSelf)\n)\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nis subclass responsibility\nprotected  thread periodic(period, jitter, delay, offset)(Step())\nend BaseRTThread\n","class CMTest\npublic  Execute() (() \u003d\u003d\u003e ())\n\tExecute()() \u003d\u003d\n(\nts:TestSuite :\u003d new TestSuite()\n\nts.AddTest(new CMTestCase2(\"Busy\"));\nts.Run()\n)\nend CMTest\n","class CMTestCase2 is subclass of [TestCase]\npublic  CMTestCase2(seq of (char)) (seq of (char) \u003d\u003d\u003e CMTestCase2)\n\tCMTestCase2(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ninlines:seq of (inline) :\u003d [mk_(1, \u003cMissileA\u003e, 45, 10000), mk_(2, \u003cMissileB\u003e, 270, 11000), mk_(3, \u003cMissileA\u003e, 276, 12000), mk_(4, \u003cMissileC\u003e, 266, 14000)]\n\nlet - \u003d ((new IO().fwriteval))[seq of (inline)](\"scenario.txt\", inlines, \u003cstart\u003e) in let world:World \u003d new World() in (\n\nworld.Run();\nlet reaction:seq of (outline) \u003d ((world.env).GetAndPurgeOutlines)() in for all i in set (inds inlines) do\nAssertTrue((exists j in set (inds reaction) \u0026 (((reaction(j).#1) \u003d i) and (((reaction(j).#4) + 1000) \u003e (reaction(j).#5)))))\n)\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend CMTestCase2\n","class RTTimeStamp\nprivate  registeredThreads:set of (BaseRTThread) :\u003d {}\nprivate  isInitialising:bool :\u003d true\nprivate static  rtTimeStamp:RTTimeStamp :\u003d new RTTimeStamp()\nprivate  RTTimeStamp() (() \u003d\u003d\u003e RTTimeStamp)\n\tRTTimeStamp()() \u003d\u003d\nskip\npublic static  GetInstance() (() \u003d\u003d\u003e RTTimeStamp)\n\tGetInstance()() \u003d\u003d\nreturn (rtTimeStamp)\npublic  RegisterThread(BaseRTThread) (BaseRTThread \u003d\u003d\u003e ())\n\tRegisterThread(BaseRTThread)(t) \u003d\u003d\n(\n\nregisteredThreads :\u003d (registeredThreads union {t})\n)\npublic  UnRegisterThread(BaseRTThread) (BaseRTThread \u003d\u003d\u003e ())\n\tUnRegisterThread(BaseRTThread)(t) \u003d\u003d\n(\n\nregisteredThreads :\u003d (registeredThreads \\ {t})\n)\npublic  IsInitialising() (() \u003d\u003d\u003e bool)\n\tIsInitialising()() \u003d\u003d\nreturn (isInitialising)\npublic  DoneInitialising() (() \u003d\u003d\u003e ())\n\tDoneInitialising()() \u003d\u003d\n(\n\nif isInitialising\nthen\n(\n\nisInitialising :\u003d false;\nfor all t in set registeredThreads do\nstart (t)\n)\n)\nprivate  mutex(RegisterThread)\nprivate  mutex(UnRegisterThread)\nprivate  mutex(RegisterThread, UnRegisterThread)\nprivate  mutex(IsInitialising)\nprivate  mutex(DoneInitialising)\nend RTTimeStamp\n","class Test\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(-) \u003d\u003d\nis subclass responsibility\nend Test\n","class TestCase is subclass of [Test]\nprotected  name:seq of (char) :\u003d (undefined)\npublic  TestCase(seq of (char)) (seq of (char) \u003d\u003d\u003e TestCase)\n\tTestCase(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\npublic  GetName() (() \u003d\u003d\u003e seq of (char))\n\tGetName()() \u003d\u003d\nreturn (name)\nprotected  AssertTrue(bool) (bool \u003d\u003d\u003e ())\n\tAssertTrue(bool)(pb) \u003d\u003d\nif (not pb)\nthen\nexit (\u003cFAILURE\u003e)\nprotected  AssertFalse(bool) (bool \u003d\u003d\u003e ())\n\tAssertFalse(bool)(pb) \u003d\u003d\nif pb\nthen\nexit (\u003cFAILURE\u003e)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(ptr) \u003d\u003d\ntrap in \u0027TestCase\u0027 (TestCase.vdmrt) at line 27:10\u003cFAILURE\u003eADefPatternBind[]ADefPatternBind with ptr.AddFailure(self) in (\n\nSetUp();\nRunTest();\nTearDown()\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nis subclass responsibility\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nis subclass responsibility\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nis subclass responsibility\nend TestCase\n","class TestResult\nprivate  failures:seq of (TestCase) :\u003d []\npublic  AddFailure(TestCase) (TestCase \u003d\u003d\u003e ())\n\tAddFailure(TestCase)(ptst) \u003d\u003d\nfailures :\u003d (failures ^ [ptst])\npublic  Print(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrint(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((pstr ^ \"\n\")) in skip\npublic  Show() (() \u003d\u003d\u003e ())\n\tShow()() \u003d\u003d\nif (failures \u003d [])\nthen\nPrint(\"No failures detected\")else\nfor in \u0027TestResult\u0027 (TestResult.vdmrt) at line 38:11failureADefPatternBind[failure \u003d TestCase]ADefPatternBind in failures do\nPrint(((failure.GetName)() ^ \" failed\"))\nend TestResult\n","class TestSuite is subclass of [Test]\nprivate  tests:seq of (Test) :\u003d []\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\nntr:TestResult :\u003d new TestResult()\n\nRun(ntr);\nntr.Show()\n)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(result) \u003d\u003d\nfor in \u0027TestSuite\u0027 (TestSuite.vdmrt) at line 19:9testADefPatternBind[test \u003d Test]ADefPatternBind in tests do\ntest.Run(result)\npublic  AddTest(Test) (Test \u003d\u003d\u003e ())\n\tAddTest(Test)(test) \u003d\u003d\ntests :\u003d (tests ^ [test])\nend TestSuite\n","class Environment is subclass of [GLOBAL, BaseRTThread]\npublic static  inline \u003d inline\npublic static  outline \u003d outline\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (outline) :\u003d []\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  sensors:map (nat) to (Sensor) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom sensors))\nprivate  busy:bool :\u003d true\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nis not yet specified\npublic  Environment(seq of (char), [ThreadDef]) (seq of (char) * [ThreadDef] \u003d\u003d\u003e Environment)\n\tEnvironment(seq of (char), [ThreadDef])(fname, tDef) \u003d\u003d\n(\n\nlet mk_(-, input) \u003d ((io.freadval))[seq of (inline)](fname) in inlines :\u003d input;\nif (tDef \u003c\u003e nil)\nthen\n(\n\nperiod :\u003d (tDef.p);\njitter :\u003d (tDef.j);\ndelay :\u003d (tDef.d);\noffset :\u003d (tDef.o)\n);\nBaseRTThread(self)\n)\npublic  addSensor(Sensor) (Sensor \u003d\u003d\u003e ())\n\taddSensor(Sensor)(psens) \u003d\u003d\nduration (0) (\nid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {id |-\u003e (psens.getAperture)()}), sensors :\u003d (sensors munion {id |-\u003e psens}))\n)\nprivate  createSignal() (() \u003d\u003d\u003e ())\n\tcreateSignal()() \u003d\u003d\nduration (0) (\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d time\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(eventid, pmt, pa, pt) \u003d (hd inlines) in if (pt \u003c\u003d curtime)\nthen\n(\n\nfor all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\nsensors(id).trip(eventid, pmt, pa);\ninlines :\u003d (tl inlines);\ndone :\u003d ((len inlines) \u003d 0)\n)else\ndone :\u003d true\n)else\nbusy :\u003d false\n)\npublic  handleEvent(EventId, FlareType, Angle, Time, Time) (EventId * FlareType * Angle * Time * Time \u003d\u003d\u003e ())\n\thandleEvent(EventId, FlareType, Angle, Time, Time)(evid, pfltp, angle, pt1, pt2) \u003d\u003d\nduration (0) (\n\noutlines :\u003d (outlines ^ [mk_(evid, pfltp, angle, pt1, pt2)])\n)\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (outline)](outlines) in skip\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  GetAndPurgeOutlines() (() \u003d\u003d\u003e seq of (outline))\n\tGetAndPurgeOutlines()() \u003d\u003d\nlet res:seq of (outline) \u003d outlines in (\n\noutlines :\u003d [];\nreturn (res)\n)\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\ncreateSignal()\n)\nprivate  mutex(handleEvent)\nprivate  mutex(createSignal)\nprivate  per isFinished \u003d\u003e (not busy)\nend Environment\n","system CM\nprivate  cpu1:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\nprivate  cpu2:CPU :\u003d new CPU(\u003cFCFS\u003e, 1000000.0)\nprivate  cpu3:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E9)\nprivate  cpu4:CPU :\u003d new CPU(\u003cFCFS\u003e, 1.0E8)\nprivate  cpu5:CPU :\u003d new CPU(\u003cFCFS\u003e, 1.0E8)\nprivate  cpu6:CPU :\u003d new CPU(\u003cFCFS\u003e, 1.0E8)\nprivate  bus1:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000.0, {cpu1, cpu3})\nprivate  bus2:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000.0, {cpu2, cpu3})\nprivate  bus3:BUS :\u003d new BUS(\u003cFCFS\u003e, 1000.0, {cpu3, cpu4, cpu5, cpu6})\npublic static  detector:MissileDetector :\u003d new MissileDetector(nil)\npublic static  sensor0:Sensor :\u003d new Sensor(detector, 0)\npublic static  sensor1:Sensor :\u003d new Sensor(detector, 90)\npublic static  sensor2:Sensor :\u003d new Sensor(detector, 180)\npublic static  sensor3:Sensor :\u003d new Sensor(detector, 270)\npublic static  controller0:FlareController :\u003d new FlareController(0, nil)\npublic static  controller1:FlareController :\u003d new FlareController(120, nil)\npublic static  controller2:FlareController :\u003d new FlareController(240, nil)\npublic static  dispenser0:FlareDispenser :\u003d new FlareDispenser(0, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser1:FlareDispenser :\u003d new FlareDispenser(30, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser2:FlareDispenser :\u003d new FlareDispenser(60, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser3:FlareDispenser :\u003d new FlareDispenser(90, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser4:FlareDispenser :\u003d new FlareDispenser(0, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser5:FlareDispenser :\u003d new FlareDispenser(30, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser6:FlareDispenser :\u003d new FlareDispenser(60, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser7:FlareDispenser :\u003d new FlareDispenser(90, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser8:FlareDispenser :\u003d new FlareDispenser(0, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser9:FlareDispenser :\u003d new FlareDispenser(30, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser10:FlareDispenser :\u003d new FlareDispenser(60, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic static  dispenser11:FlareDispenser :\u003d new FlareDispenser(90, mk_BaseRTThread`ThreadDef(1.0E9, true, 0, 0, 0))\npublic  CM() (() \u003d\u003d\u003e CM)\n\tCM()() \u003d\u003d\n(\n\ncpu3.deploy(detector);\ncpu1.deploy(sensor0);\ncpu1.deploy(sensor1);\ncpu2.deploy(sensor2);\ncpu2.deploy(sensor3);\ncpu3.deploy(controller0);\ncpu4.deploy(dispenser0);\ncpu4.deploy(dispenser1);\ncpu4.deploy(dispenser2);\ncpu4.deploy(dispenser3);\ncpu3.deploy(controller1);\ncpu5.deploy(dispenser4);\ncpu5.deploy(dispenser5);\ncpu5.deploy(dispenser6);\ncpu5.deploy(dispenser7);\ncpu3.deploy(controller2);\ncpu6.deploy(dispenser8);\ncpu6.deploy(dispenser9);\ncpu6.deploy(dispenser10);\ncpu6.deploy(dispenser11)\n)\nend CM\n","class FlareController is subclass of [GLOBAL, BaseRTThread]\nprivate  aperture:Angle :\u003d (undefined)\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  dispensers:map (nat) to (FlareDispenser) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom dispensers))\nprivate  threats:seq of ((EventId * MissileType * Angle * Time)) :\u003d []\nprivate  busy:bool :\u003d false\npublic  FlareController(Angle, [ThreadDef]) (Angle * [ThreadDef] \u003d\u003d\u003e FlareController)\n\tFlareController(Angle, [ThreadDef])(papp, tDef) \u003d\u003d\n(\n\naperture :\u003d papp;\nif (tDef \u003c\u003e nil)\nthen\n(\n\nperiod :\u003d (tDef.p);\njitter :\u003d (tDef.j);\ndelay :\u003d (tDef.d);\noffset :\u003d (tDef.o)\n);\nBaseRTThread(self)\n)\npublic  addDispenser(FlareDispenser) (FlareDispenser \u003d\u003d\u003e ())\n\taddDispenser(FlareDispenser)(pfldisp) \u003d\u003d\nlet angle:nat \u003d (aperture + (pfldisp.GetAngle)()) in (\nid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {id |-\u003e mk_(angle, DISPENSER_APERTURE)}), dispensers :\u003d (dispensers munion {id |-\u003e pfldisp}));\nstart (pfldisp)\n)\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(aperture, FLARE_APERTURE))\npublic async  addThreat(EventId, MissileType, Angle, Time) (EventId * MissileType * Angle * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Angle, Time)(evid, pmt, pa, pt) \u003d\u003d\n(\n\nthreats :\u003d (threats ^ [mk_(evid, pmt, pa, pt)]);\nbusy :\u003d true\n)\nprivate  getThreat() (() \u003d\u003d\u003e (EventId * MissileType * Angle * Time))\n\tgetThreat()() \u003d\u003d\n(\nres:(EventId * MissileType * Angle * Time) :\u003d (hd threats)\n\nthreats :\u003d (tl threats);\nreturn (res)\n)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nfor all id in set (dom dispensers) do\ndispensers(id).isFinished()\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (threats \u003c\u003e [])\nthen\n(\n\nlet mk_(evid, pmt, pa, pt) \u003d getThreat() in for all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\ndispensers(id).addThreat(evid, pmt, pt);\nbusy :\u003d ((len threats) \u003e 0)\n)\n)\nprivate  mutex(addThreat, getThreat)\nprivate  per getThreat \u003d\u003e ((len threats) \u003e 0)\nprivate  per isFinished \u003d\u003e (not busy)\nend FlareController\n","class FlareDispenser is subclass of [GLOBAL, BaseRTThread]\nprivate static  responseDB:map (MissileType) to (Plan) \u003d {\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)], \u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)], \u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}\nprivate static  missilePriority:map (MissileType) to (nat) \u003d {\u003cMissileA\u003e |-\u003e 1, \u003cMissileB\u003e |-\u003e 2, \u003cMissileC\u003e |-\u003e 3}\npublic static  Plan \u003d Plan\npublic static  PlanStep \u003d PlanStep\npublic  curplan:Plan :\u003d []\nprivate  curprio:nat :\u003d 0\nprivate  busy:bool :\u003d false\nprivate  aparature:Angle :\u003d (undefined)\nprivate  eventid:[EventId] :\u003d (undefined)\npublic  FlareDispenser(Angle, [ThreadDef]) (Angle * [ThreadDef] \u003d\u003d\u003e FlareDispenser)\n\tFlareDispenser(Angle, [ThreadDef])(ang, tDef) \u003d\u003d\n(\n\naparature :\u003d ang;\nif (tDef \u003c\u003e nil)\nthen\n(\n\nperiod :\u003d (tDef.p);\njitter :\u003d (tDef.j);\ndelay :\u003d (tDef.d);\noffset :\u003d (tDef.o)\n);\nBaseRTThread(self)\n)\npublic  GetAngle() (() \u003d\u003d\u003e nat)\n\tGetAngle()() \u003d\u003d\nreturn (aparature)\npublic async  addThreat(EventId, MissileType, Time) (EventId * MissileType * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Time)(evid, pmt, ptime) \u003d\u003d\nif (missilePriority(pmt) \u003e curprio)\nthen\n(\nnewplan:Plan :\u003d []\nnewtime:Time :\u003d ptime\n\nfor in \u0027FlareDispenser\u0027 (flaredispenser.vdmrt) at line 62:13mk_(fltp, fltime)ADefPatternBind[fltime \u003d Time, fltp \u003d FlareType]ADefPatternBind in responseDB(pmt) do\n(\n\nnewplan :\u003d (newplan ^ [mk_(fltp, newtime)]);\nnewtime :\u003d (newtime + fltime)\n);\nlet mk_(fltp, fltime) \u003d (hd newplan) in releaseFlare(evid, fltp, fltime, time);\ncurplan :\u003d (tl newplan);\neventid :\u003d evid;\ncurprio :\u003d missilePriority(pmt);\nbusy :\u003d true\n)\n\tpre ((pmt in set (dom missilePriority)) and (pmt in set (dom responseDB)))\nprotected async  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\ncycles (100000.0) (\n\nif ((len curplan) \u003e 0)\nthen\n(\ncurtime:Time :\u003d time\ndone:bool :\u003d false\n\nwhile (not done) do (\nfirst:PlanStep :\u003d (hd curplan)\nnext:Plan :\u003d (tl curplan)\n\nlet mk_(fltp, fltime):PlanStep \u003d first in if (fltime \u003c\u003d curtime)\nthen\n(\n\nreleaseFlare(eventid, fltp, fltime, curtime);\ncurplan :\u003d next;\nif ((len next) \u003d 0)\nthen\n(\n\ncurprio :\u003d 0;\ndone :\u003d true;\nbusy :\u003d false\n)\n)else\ndone :\u003d true\n)\n)\n)\nprivate  releaseFlare(EventId, FlareType, Time, Time) (EventId * FlareType * Time * Time \u003d\u003d\u003e ())\n\treleaseFlare(EventId, FlareType, Time, Time)(evid, pfltp, pt1, pt2) \u003d\u003d\nWorld`env.handleEvent(evid, pfltp, aparature, pt1, pt2)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nis not yet specified\nprivate  mutex(addThreat, Step)\nprivate  per isFinished \u003d\u003e (not busy)\nend FlareDispenser\n","class GLOBAL\npublic static  SENSOR_APERTURE:nat1 \u003d 90\npublic static  FLARE_APERTURE:nat1 \u003d 120\npublic static  DISPENSER_APERTURE:nat1 \u003d 30\npublic static  MissileType \u003d MissileType\npublic static  FlareType \u003d FlareType\npublic static  Angle \u003d Angle\n\tinv num \u003d\u003d (num \u003c 360)\npublic static  EventId \u003d EventId\npublic static  Time \u003d Time\npublic  canObserve(Angle, Angle, Angle) (Angle * Angle * Angle \u003d\u003d\u003e bool)\n\tcanObserve(Angle, Angle, Angle)(pangle, pleft, psize) \u003d\u003d\nlet pright \u003d ((pleft + psize) mod 360) in if (pright \u003c pleft)\nthen\nreturn (((pangle \u003c pright) or (pangle \u003e\u003d pleft)))else\nreturn (((pangle \u003e\u003d pleft) and (pangle \u003c pright)))\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nis subclass responsibility\nend GLOBAL\n","class MissileDetector is subclass of [GLOBAL, BaseRTThread]\nprivate  ranges:map (nat) to ((Angle * Angle)) :\u003d {|-\u003e}\nprivate  controllers:map (nat) to (FlareController) :\u003d {|-\u003e}\nprivate  inv((dom ranges) \u003d (dom controllers))\nprivate  threats:seq of ((EventId * MissileType * Angle * Time)) :\u003d []\nprivate  busy:bool :\u003d false\npublic  MissileDetector([ThreadDef]) ([ThreadDef] \u003d\u003d\u003e MissileDetector)\n\tMissileDetector([ThreadDef])(tDef) \u003d\u003d\n(\n\nif (tDef \u003c\u003e nil)\nthen\n(\n\nperiod :\u003d (tDef.p);\njitter :\u003d (tDef.j);\ndelay :\u003d (tDef.d);\noffset :\u003d (tDef.o)\n);\nBaseRTThread(self)\n)\npublic  addController(FlareController) (FlareController \u003d\u003d\u003e ())\n\taddController(FlareController)(pctrl) \u003d\u003d\n(\nnid:nat :\u003d ((card (dom ranges)) + 1)\n\natomic (ranges :\u003d (ranges munion {nid |-\u003e (pctrl.getAperture)()}), controllers :\u003d (controllers munion {nid |-\u003e pctrl}))\n)\npublic async  addThreat(EventId, MissileType, Angle, Time) (EventId * MissileType * Angle * Time \u003d\u003d\u003e ())\n\taddThreat(EventId, MissileType, Angle, Time)(evid, pmt, pa, pt) \u003d\u003d\n(\n\nthreats :\u003d (threats ^ [mk_(evid, pmt, pa, pt)]);\nbusy :\u003d true\n)\nprivate  getThreat() (() \u003d\u003d\u003e (EventId * MissileType * Angle * Time))\n\tgetThreat()() \u003d\u003d\n(\nres:(EventId * MissileType * Angle * Time) :\u003d (hd threats)\n\nthreats :\u003d (tl threats);\nreturn (res)\n)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nfor all id in set (dom controllers) do\ncontrollers(id).isFinished()\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (threats \u003c\u003e [])\nthen\n(\n\nlet mk_(evid, pmt, pa, pt) \u003d getThreat() in for all id in set (dom ranges) do\nlet mk_(papplhs, pappsize) \u003d ranges(id) in if canObserve(pa, papplhs, pappsize)\nthen\ncontrollers(id).addThreat(evid, pmt, pa, pt);\nbusy :\u003d ((len threats) \u003e 0)\n)\n)\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nis not yet specified\nprivate  mutex(addThreat, getThreat)\nprivate  per getThreat \u003d\u003e ((len threats) \u003e 0)\nprivate  per isFinished \u003d\u003e (not busy)\nend MissileDetector\n","class Sensor is subclass of [GLOBAL]\nprivate  detector:MissileDetector :\u003d (undefined)\nprivate  aperture:Angle :\u003d (undefined)\npublic  Sensor(MissileDetector, Angle) (MissileDetector * Angle \u003d\u003d\u003e Sensor)\n\tSensor(MissileDetector, Angle)(pmd, psa) \u003d\u003d\n(\n\ndetector :\u003d pmd;\naperture :\u003d psa\n)\npublic  getAperture() (() \u003d\u003d\u003e (Angle * Angle))\n\tgetAperture()() \u003d\u003d\nreturn (mk_(aperture, SENSOR_APERTURE))\npublic async  trip(EventId, MissileType, Angle) (EventId * MissileType * Angle \u003d\u003d\u003e ())\n\ttrip(EventId, MissileType, Angle)(evid, pmt, pa) \u003d\u003d\ndetector.addThreat(evid, pmt, pa, time)\n\tpre canObserve(pa, aperture, SENSOR_APERTURE)\nend Sensor\n","class World\npublic static  timerRef:RTTimeStamp :\u003d RTTimeStamp`GetInstance()\npublic static  env:[Environment] :\u003d nil\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Environment(\"scenario.txt\", mk_BaseRTThread`ThreadDef(1.0E9, true, 10, 900, 0));\nenv.addSensor(CM`sensor0);\nenv.addSensor(CM`sensor1);\nenv.addSensor(CM`sensor2);\nenv.addSensor(CM`sensor3);\nCM`controller0.addDispenser(CM`dispenser0);\nCM`controller0.addDispenser(CM`dispenser1);\nCM`controller0.addDispenser(CM`dispenser2);\nCM`controller0.addDispenser(CM`dispenser3);\nCM`detector.addController(CM`controller0);\nCM`controller1.addDispenser(CM`dispenser4);\nCM`controller1.addDispenser(CM`dispenser5);\nCM`controller1.addDispenser(CM`dispenser6);\nCM`controller1.addDispenser(CM`dispenser7);\nCM`detector.addController(CM`controller1);\nCM`controller2.addDispenser(CM`dispenser8);\nCM`controller2.addDispenser(CM`dispenser9);\nCM`controller2.addDispenser(CM`dispenser10);\nCM`controller2.addDispenser(CM`dispenser11);\nCM`detector.addController(CM`controller2)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\ntimerRef.DoneInitialising();\nenv.isFinished();\nCM`detector.isFinished();\nenv.showResult()\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]