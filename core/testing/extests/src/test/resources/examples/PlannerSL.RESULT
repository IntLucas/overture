["Eid \u003d Eid","Value \u003d Value","Esetnm \u003d Esetnm","Rnm \u003d Rnm","Maptp \u003d Maptp","Tuple \u003d Tuple","Rinf \u003d Rinf","Rkey \u003d Rkey","private checkinv: (map (Esetnm) to (set of (Eid)) * map (Eid) to ([Value]) * map (Rkey) to (Rinf) -\u003e bool)\n\tcheckinv(esm, em, rm) \u003d\u003d\n(((dom em) \u003d (dunion (rng esm))) and (forall rk in set (dom rm) \u0026 let mk_Rkey(-, fs, ts):Rkey \u003d rk in let mk_Rinf(tp, r):Rinf \u003d rm(rk) in (({fs, ts} subset (dom esm)) and (((tp \u003d \u003cONETOMANY\u003e) \u003d\u003e (forall t1, t2 in set r \u0026 (((t1.tv) \u003d (t2.tv)) \u003d\u003e ((t1.fv) \u003d (t2.fv))))) and (((tp \u003d \u003cMANYTOONE\u003e) \u003d\u003e (forall t1, t2 in set r \u0026 (((t1.fv) \u003d (t2.fv)) \u003d\u003e ((t1.tv) \u003d (t2.tv))))) and (((tp \u003d \u003cONETOONE\u003e) \u003d\u003e (forall t1, t2 in set r \u0026 (((t1.fv) \u003d (t2.fv)) \u003c\u003d\u003e ((t1.tv) \u003d (t2.tv))))) and (forall mk_Tuple(fv, tv) in set r \u0026 ((fv in set esm(fs)) and (tv in set esm(ts))))))))))","state Ndbof\n[esm : map (Esetnm) to (set of (Eid)), em : map (Eid) to ([Value]), rm : map (Rkey) to (Rinf)]\n\tinv mk_Ndb(esm, em, rm) \u003d\u003d checkinv(esm, em, rm)\n\tinit ndb \u003d\u003d (ndb \u003d mk_Ndb({|-\u003e}, {|-\u003e}, {|-\u003e}))","ADDES([es]Esetnm)\n\text [wr[esm]map (Esetnm) to (set of (Eid))]\n\tpre (es not in set (dom esm))\n\tpost (esm \u003d (esm~ munion {es |-\u003e {}}))","DELES([es]Esetnm)\n\text [wr[esm]map (Esetnm) to (set of (Eid)), rd[rm]map (Rkey) to (Rinf)]\n\tpre ((es in set (dom esm)) and ((esm(es) \u003d {}) and (es not in set ({(rk.fs) | rk in set (dom rm)} union {(rk.ts) | rk in set (dom rm)}))))\n\tpost (esm \u003d ({es} \u003c-: esm~))","ADDENT([memb]set of (Esetnm), [val][Value]) eid:Eid\n\text [wr[esm]map (Esetnm) to (set of (Eid)), wr[em]map (Eid) to ([Value])]\n\tpre (memb subset (dom esm))\n\tpost ((eid not in set (dom em~)) and ((em \u003d (em~ munion {eid |-\u003e val})) and (esm \u003d (esm~ ++ {es |-\u003e (esm~(es) union {eid}) | es in set memb}))))","DELENT([eid]Eid)\n\text [wr[esm]map (Esetnm) to (set of (Eid)), wr[em]map (Eid) to ([Value]), rd[rm]map (Rkey) to (Rinf)]\n\tpre ((eid in set (dom em)) and (forall t in set (dunion {(ri.r) | ri in set (rng rm)}) \u0026 (((t.fv) \u003c\u003e eid) and ((t.tv) \u003c\u003e eid))))\n\tpost ((esm \u003d {es |-\u003e (esm~(es) \\ {eid}) | es in set (dom esm~)}) and (em \u003d ({eid} \u003c-: em~)))","ADDREL([rk]Rkey, [tp]Maptp)\n\text [rd[esm]map (Esetnm) to (set of (Eid)), wr[rm]map (Rkey) to (Rinf)]\n\tpre (({(rk.fs), (rk.ts)} subset (dom esm)) and (rk not in set (dom rm)))\n\tpost (rm \u003d (rm~ munion {rk |-\u003e mk_Rinf(tp, {})}))","DELREL([rk]Rkey)\n\text [wr[rm]map (Rkey) to (Rinf)]\n\tpre ((rk in set (dom rm)) and ((rm(rk).r) \u003d {}))\n\tpost (rm \u003d ({rk} \u003c-: rm~))","ADDTUP([fval, tval]Eid, [rk]Rkey)\n\text [wr[rm]map (Rkey) to (Rinf), rd[esm]map (Esetnm) to (set of (Eid)), rd[em]map (Eid) to ([Value])]\n\tpre ((rk in set (dom rm)) and let ri:Rinf \u003d mu(rm(rk), r |-\u003e ((rm(rk).r) union {mk_Tuple(fval, tval)})) in checkinv(esm, em, (rm ++ {rk |-\u003e ri})))\n\tpost let ri:Rinf \u003d mu(rm~(rk), r |-\u003e ((rm~(rk).r) union {mk_Tuple(fval, tval)})) in (rm \u003d (rm~ ++ {rk |-\u003e ri}))","DELTUP([fval, tval]Eid, [rk]Rkey)\n\text [wr[rm]map (Rkey) to (Rinf)]\n\tpre (rk in set (dom rm))\n\tpost let ri:Rinf \u003d mu(rm~(rk), r |-\u003e ((rm~(rk).r) \\ {mk_Tuple(fval, tval)})) in (rm \u003d (rm~ ++ {rk |-\u003e ri}))"]