["binexpr:Expr \u003d mk_AST`BinaryExpr(mk_AST`IntVal(4), \u003cAdd\u003e, mk_AST`IntVal(5))","private RunTypeCheck: (() -\u003e (bool * [Type]))\n\tRunTypeCheck() \u003d\u003d\nSTATSEM`wf_Expr(binexpr, {|-\u003e})","private RunEval: (() -\u003e Value)\n\tRunEval() \u003d\u003d\nDYNSEM`EvalExpr(binexpr, {|-\u003e})","Program \u003d Program","Declaration \u003d Declaration","Identifier \u003d Identifier","Type \u003d Type","Value \u003d Value","BoolVal \u003d BoolVal","IntVal \u003d IntVal","Stmt \u003d Stmt","BlockStmt \u003d BlockStmt","AssignStmt \u003d AssignStmt","Variable \u003d Variable","Expr \u003d Expr","BinaryExpr \u003d BinaryExpr","Operator \u003d Operator","CondStmt \u003d CondStmt","ForStmt \u003d ForStmt","RepeatStmt \u003d RepeatStmt","DynEnv \u003d DynEnv","private EvalProgram: (Program -\u003e DynEnv)\n\tEvalProgram(mk_Program(decls, stmt)) \u003d\u003d\nEvalStmt(stmt, EvalDeclarations(decls))\n\tpre (STATSEM`wf_Program(mk_AST`Program(decls, stmt)) and pre_EvalStmt(stmt, EvalDeclarations(decls)))","private EvalDeclarations: (seq of (Declaration) -\u003e DynEnv)\n\tEvalDeclarations(decls) \u003d\u003d\n{id |-\u003e (if (val \u003c\u003e nil)\nthen val\nelseif (tp \u003d \u003cBoolType\u003e)\nthen mk_AST`BoolVal(false)\nelse mk_AST`IntVal(0)) | mk_Declaration(id, tp, val) in set (elems decls)}","private EvalStmt: (Stmt * DynEnv -\u003e DynEnv)\n\tEvalStmt(stmt, denv) \u003d\u003d\n(cases true :\n(is_(stmt, AST`BlockStmt)) -\u003e EvalBlockStmt(stmt, denv),\n(is_(stmt, AST`AssignStmt)) -\u003e EvalAssignStmt(stmt, denv),\n(is_(stmt, AST`CondStmt)) -\u003e EvalCondStmt(stmt, denv),\n(is_(stmt, AST`ForStmt)) -\u003e EvalForStmt(stmt, denv),\n(is_(stmt, AST`RepeatStmt)) -\u003e EvalRepeatStmt(stmt, denv)\n end)\n\tpre ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv))))))","private EvalBlockStmt: (BlockStmt * DynEnv -\u003e DynEnv)\n\tEvalBlockStmt(mk_BlockStmt(decls, stmts), denv) \u003d\u003d\nlet ldenv:DynEnv \u003d EvalDeclarations(decls) in let denv\u0027:DynEnv \u003d EvalStmts(stmts, (denv ++ ldenv)) in (denv ++ ((dom ldenv) \u003c-: denv\u0027))\n\tpre let ldenv:DynEnv \u003d EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv))","private EvalStmts: (seq of (Stmt) * DynEnv -\u003e DynEnv)\n\tEvalStmts(stmts, denv) \u003d\u003d\n(cases stmts :\n[] -\u003e denv\nothers EvalStmts((tl stmts), EvalStmt((hd stmts), denv))\n end)\n\tpre ((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv))","private LenStmt: (seq of (Stmt) * DynEnv -\u003e nat)\n\tLenStmt(l, -) \u003d\u003d\n(len l)","private EvalAssignStmt: (AssignStmt * DynEnv -\u003e DynEnv)\n\tEvalAssignStmt(mk_AssignStmt(lhs, rhs), denv) \u003d\u003d\n(denv ++ {(lhs.id) |-\u003e EvalExpr(rhs, denv)})\n\tpre pre_EvalExpr(rhs, denv)","private EvalCondStmt: (CondStmt * DynEnv -\u003e DynEnv)\n\tEvalCondStmt(mk_CondStmt(guard, thenst, elsest), denv) \u003d\u003d\n(if (EvalExpr(guard, denv).val)\nthen EvalStmt(thenst, denv)\nelse EvalStmt(elsest, denv))\n\tpre (pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv)))","private EvalRepeatStmt: (RepeatStmt * DynEnv -\u003e DynEnv)\n\tEvalRepeatStmt(mk_RepeatStmt(repeat, until), denv) \u003d\u003d\nlet denv\u0027:DynEnv \u003d EvalStmt(repeat, denv) in (if (EvalExpr(until, denv\u0027).val)\nthen denv\u0027\nelse EvalRepeatStmt(mk_AST`RepeatStmt(repeat, until), denv\u0027))\n\tpre (pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv)))","private EvalForStmt: (ForStmt * DynEnv -\u003e DynEnv)\n\tEvalForStmt(mk_ForStmt(start, stop, stmt), denv) \u003d\u003d\nlet denv\u0027:DynEnv \u003d EvalAssignStmt(start, denv) in EvalForLoop((start.lhs), EvalExpr(stop, denv\u0027), stmt, denv\u0027)\n\tpre (pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv)))","private EvalForLoop: (Variable * Value * Stmt * DynEnv -\u003e DynEnv)\n\tEvalForLoop(mk_Variable(id), val, stmt, denv) \u003d\u003d\n(if ((denv(id).val) \u003c\u003d (val.val))\nthen let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in EvalForLoop(mk_AST`Variable(id), val, stmt, (denv\u0027 ++ {id |-\u003e mk_AST`IntVal(((denv\u0027(id).val) + 1))}))\nelse denv)\n\tpre pre_EvalStmt(stmt, denv)","private LoopParInc: (Variable * Value * Stmt * DynEnv -\u003e nat)\n\tLoopParInc(mk_Variable(id), val, -, denv) \u003d\u003d\n((val.val) - (denv(id).val))","private EvalExpr: (Expr * DynEnv -\u003e Value)\n\tEvalExpr(ex, denv) \u003d\u003d\n(cases ex :\nmk_BoolVal(-) -\u003e ex,\nmk_IntVal(-) -\u003e ex,\nmk_Variable(id) -\u003e denv(id),\nmk_BinaryExpr(-, -, -) -\u003e EvalBinaryExpr(ex, denv)\n end)\n\tpre (is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv))","private EvalBinaryExpr: (BinaryExpr * DynEnv -\u003e Value)\n\tEvalBinaryExpr(mk_BinaryExpr(lhs, op, rhs), denv) \u003d\u003d\nlet v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in (cases op :\n\u003cAdd\u003e -\u003e mk_AST`IntVal((v1 + v2)),\n\u003cSub\u003e -\u003e mk_AST`IntVal((v1 - v2)),\n\u003cDiv\u003e -\u003e mk_AST`IntVal((v1 div v2)),\n\u003cMul\u003e -\u003e mk_AST`IntVal((v1 * v2)),\n\u003cLt\u003e -\u003e mk_AST`BoolVal((v1 \u003c v2)),\n\u003cGt\u003e -\u003e mk_AST`BoolVal((v1 \u003e v2)),\n\u003cEq\u003e -\u003e mk_AST`BoolVal((v1 \u003d v2)),\n\u003cAnd\u003e -\u003e mk_AST`BoolVal((v1 and v2)),\n\u003cOr\u003e -\u003e mk_AST`BoolVal((v1 or v2))\n end)\n\tpre ((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0))","StatEnv \u003d StatEnv","private wf_Program: (Program -\u003e bool)\n\twf_Program(mk_Program(decls, stmt)) \u003d\u003d\n(wf_Declarations(decls) and wf_Stmt(stmt, get_Declarations(decls)))","private wf_Declarations: (seq of (Declaration) -\u003e bool)\n\twf_Declarations(decls) \u003d\u003d\n((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) and (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e ((is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) \u003d \u003cBoolType\u003e)) or (is_((decls(i).val), AST`IntVal) and ((decls(i).tp) \u003d \u003cIntType\u003e))))))","private get_Declarations: (seq of (Declaration) -\u003e StatEnv)\n\tget_Declarations(decls) \u003d\u003d\n{id |-\u003e tp | mk_Declaration(id, tp, -) in set (elems decls)}","private wf_Stmt: (Stmt * StatEnv -\u003e bool)\n\twf_Stmt(stmt, senv) \u003d\u003d\n(cases true :\n(is_(stmt, AST`BlockStmt)) -\u003e wf_BlockStmt(stmt, senv),\n(is_(stmt, AST`AssignStmt)) -\u003e let mk_(wf_ass, -):(bool * [Type]) \u003d wf_AssignStmt(stmt, senv) in wf_ass,\n(is_(stmt, AST`CondStmt)) -\u003e wf_CondStmt(stmt, senv),\n(is_(stmt, AST`ForStmt)) -\u003e wf_ForStmt(stmt, senv),\n(is_(stmt, AST`RepeatStmt)) -\u003e wf_RepeatStmt(stmt, senv)\nothers false\n end)","private wf_BlockStmt: (BlockStmt * StatEnv -\u003e bool)\n\twf_BlockStmt(mk_BlockStmt(decls, stmts), senv) \u003d\u003d\n(wf_Declarations(decls) and wf_Stmts(stmts, (senv ++ get_Declarations(decls))))","private wf_Stmts: (seq of (Stmt) * StatEnv -\u003e bool)\n\twf_Stmts(stmts, senv) \u003d\u003d\n(forall stmt in set (elems stmts) \u0026 wf_Stmt(stmt, senv))","private wf_AssignStmt: (AssignStmt * StatEnv -\u003e (bool * [Type]))\n\twf_AssignStmt(mk_AssignStmt(lhs, rhs), senv) \u003d\u003d\nlet mk_(wf_var, tp_var):(bool * [Type]) \u003d wf_Variable(lhs, senv), mk_(wf_ex, tp_ex):(bool * [Type]) \u003d wf_Expr(rhs, senv) in mk_((wf_ex and (wf_var and (tp_var \u003d tp_ex))), tp_var)","private wf_CondStmt: (CondStmt * StatEnv -\u003e bool)\n\twf_CondStmt(mk_CondStmt(guard, thenst, elsest), senv) \u003d\u003d\nlet mk_(wf_ex, tp_ex):(bool * [Type]) \u003d wf_Expr(guard, senv) in (wf_ex and ((tp_ex \u003d \u003cBoolType\u003e) and (wf_Stmt(thenst, senv) and wf_Stmt(elsest, senv))))","private wf_RepeatStmt: (RepeatStmt * StatEnv -\u003e bool)\n\twf_RepeatStmt(mk_RepeatStmt(repeat, until), senv) \u003d\u003d\nlet mk_(wf_ex, tp_ex):(bool * [Type]) \u003d wf_Expr(until, senv) in (wf_ex and ((tp_ex \u003d \u003cBoolType\u003e) and wf_Stmt(repeat, senv)))","private wf_ForStmt: (ForStmt * StatEnv -\u003e bool)\n\twf_ForStmt(mk_ForStmt(start, stop, stmt), senv) \u003d\u003d\nlet mk_(wf_ass, tp_ass):(bool * [Type]) \u003d wf_AssignStmt(start, senv), mk_(wf_ex, tp_ex):(bool * [Type]) \u003d wf_Expr(stop, senv) in (wf_ass and (wf_ex and ((tp_ass \u003d \u003cIntType\u003e) and ((tp_ex \u003d \u003cIntType\u003e) and wf_Stmt(stmt, senv)))))","private wf_Expr: (Expr * StatEnv -\u003e (bool * [Type]))\n\twf_Expr(ex, senv) \u003d\u003d\n(cases true :\n(is_(ex, AST`BoolVal)) -\u003e mk_(true, \u003cBoolType\u003e),\n(is_(ex, AST`IntVal)) -\u003e mk_(true, \u003cIntType\u003e),\n(is_(ex, AST`Variable)) -\u003e wf_Variable(ex, senv),\n(is_(ex, AST`BinaryExpr)) -\u003e wf_BinaryExpr(ex, senv)\nothers mk_(false, \u003cIntType\u003e)\n end)","private wf_Variable: (Variable * StatEnv -\u003e (bool * [Type]))\n\twf_Variable(mk_Variable(id), senv) \u003d\u003d\n(if (id in set (dom senv))\nthen mk_(true, senv(id))\nelse mk_(false, nil))","private wf_BinaryExpr: (BinaryExpr * StatEnv -\u003e (bool * [Type]))\n\twf_BinaryExpr(mk_BinaryExpr(lhs, op, rhs), senv) \u003d\u003d\nlet mk_(wf_lhs, tp_lhs):(bool * [Type]) \u003d wf_Expr(lhs, senv), mk_(wf_rhs, tp_rhs):(bool * [Type]) \u003d wf_Expr(rhs, senv) in (cases op :\n\u003cAdd\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cIntType\u003e),\n\u003cSub\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cIntType\u003e),\n\u003cDiv\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cIntType\u003e),\n\u003cMul\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cIntType\u003e),\n\u003cLt\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cBoolType\u003e),\n\u003cGt\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cBoolType\u003e),\n\u003cEq\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cIntType\u003e) and (tp_rhs \u003d \u003cIntType\u003e)))), \u003cBoolType\u003e),\n\u003cAnd\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cBoolType\u003e) and (tp_rhs \u003d \u003cBoolType\u003e)))), \u003cBoolType\u003e),\n\u003cOr\u003e -\u003e mk_((wf_lhs and (wf_rhs and ((tp_lhs \u003d \u003cBoolType\u003e) and (tp_rhs \u003d \u003cBoolType\u003e)))), \u003cBoolType\u003e)\nothers mk_(false, nil)\n end)"]