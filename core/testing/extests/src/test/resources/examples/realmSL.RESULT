["Tracks \u003d Tracks","Track_id \u003d Track_id","private NoReflexive: (Tracks +\u003e bool)\n\tNoReflexive(tracks) \u003d\u003d\n(forall mk_(t1, t2) in set tracks \u0026 (t1 \u003c\u003e t2))","private Symmetric: (Tracks +\u003e bool)\n\tSymmetric(tracks) \u003d\u003d\n(forall mk_(t1, t2) in set tracks \u0026 (mk_(t2, t1) in set tracks))","private Is_wf_Tracks: (Tracks +\u003e bool)\n\tIs_wf_Tracks(tracks) \u003d\u003d\n(NoReflexive(tracks) and Symmetric(tracks))","Points \u003d Points","Point_control \u003d Point_control","Crossings \u003d Crossings","private PointsInTracks: (Tracks * Points +\u003e bool)\n\tPointsInTracks(tracks, points) \u003d\u003d\n((dom points) subset tracks)","private Inverses: (Points +\u003e bool)\n\tInverses(points) \u003d\u003d\n(forall mk_(t1, t2) in set (dom points) \u0026 ((mk_(t2, t1) in set (dom points)) and (points(mk_(t1, t2)) \u003d points(mk_(t2, t1)))))","private OkDomRng: (Points +\u003e bool)\n\tOkDomRng(points) \u003d\u003d\n(forall mk_(t1, t2) in set (dom points) \u0026 ((points(mk_(t1, t2)) \u003c\u003e {|-\u003e}) and ((dom points(mk_(t1, t2))) subset {t1, t2})))","private RelateToTracks: (Tracks * Points +\u003e bool)\n\tRelateToTracks(tracks, points) \u003d\u003d\n((forall tpair in set (dom points) \u0026 (forall pid in set (dom points(tpair)) \u0026 ((card {t | mk_(t, t\u0027) in set tracks \u0026 (t\u0027 \u003d pid)}) \u003d 3))) and (forall mk_(t1, -) in set tracks \u0026 ((not (exists tpair in set (dom points) \u0026 (t1 in set (dom points(tpair))))) \u003d\u003e ((card {t | mk_(t, t\u0027) in set tracks \u0026 (t\u0027 \u003d t1)}) \u003c\u003d 2))))","private Control2Dir: (Points +\u003e bool)\n\tControl2Dir(points) \u003d\u003d\n(forall mk_(t1, t2) in set (dom points) \u0026 (((({t1} \u003c: points(mk_(t1, t2))) \u003d {t1 |-\u003e \u003cleft\u003e}) \u003d\u003e (exists mk_(t, t\u0027) in set (dom points) \u0026 ((t \u003d t1) and (({t1} \u003c: points(mk_(t1, t\u0027))) \u003d {t1 |-\u003e \u003cright\u003e})))) and ((({t1} \u003c: points(mk_(t1, t2))) \u003d {t1 |-\u003e \u003cright\u003e}) \u003d\u003e (exists mk_(t, t\u0027) in set (dom points) \u0026 ((t \u003d t1) and (({t1} \u003c: points(mk_(t1, t\u0027))) \u003d {t1 |-\u003e \u003cleft\u003e}))))))","private Is_wf_Points: (Tracks * Points +\u003e bool)\n\tIs_wf_Points(tracks, points) \u003d\u003d\n(PointsInTracks(tracks, points) and (Inverses(points) and (OkDomRng(points) and (RelateToTracks(tracks, points) and Control2Dir(points)))))","private SeperateBranches: (Tracks * Crossings +\u003e bool)\n\tSeperateBranches(tracks, crossings) \u003d\u003d\n((crossings inter tracks) \u003d {})","private CrossInTracks: (Tracks * Crossings +\u003e bool)\n\tCrossInTracks(tracks, crossings) \u003d\u003d\n(forall mk_(t1, t2) in set crossings \u0026 ((exists mk_(t3, -) in set tracks \u0026 (t1 \u003d t3)) and (exists mk_(t4, -) in set tracks \u0026 (t2 \u003d t4))))","private UniqueCross: (Crossings +\u003e bool)\n\tUniqueCross(crossings) \u003d\u003d\n(forall mk_(t1, t2) in set crossings \u0026 ((t1 \u003c\u003e t2) and (forall mk_(t3, t4) in set (crossings \\ {mk_(t1, t2)}) \u0026 ((t1 \u003c\u003e t3) and ((t1 \u003c\u003e t4) and ((t2 \u003c\u003e t3) and (t2 \u003c\u003e t4)))))))","private DiffPointsCrossings: (Points * Crossings +\u003e bool)\n\tDiffPointsCrossings(points, crossings) \u003d\u003d\n(forall mk_(t1, t2) in set crossings \u0026 (forall pointcontrol in set (rng points) \u0026 ((t1 not in set (dom pointcontrol)) and (t2 not in set (dom pointcontrol)))))","private Is_wf_Crossings: (Tracks * Points * Crossings +\u003e bool)\n\tIs_wf_Crossings(tracks, points, crossings) \u003d\u003d\n(SeperateBranches(tracks, crossings) and (CrossInTracks(tracks, crossings) and (UniqueCross(crossings) and DiffPointsCrossings(points, crossings))))","Signals \u003d Signals","Signal_id \u003d Signal_id","private UniqueSignals: (Signals +\u003e bool)\n\tUniqueSignals(signals) \u003d\u003d\n((card (rng signals)) \u003d (card (dom signals)))","private SigInTracks: (Tracks * Signals +\u003e bool)\n\tSigInTracks(tracks, signals) \u003d\u003d\n(forall mk_(t1, t2) in set (dom signals) \u0026 (((t1 \u003d \"ol\") \u003d\u003e ((card {t | mk_(t, t\u0027) in set tracks \u0026 (t\u0027 \u003d t2)}) \u003d 1)) and (((t2 \u003d \"ol\") \u003d\u003e ((card {t | mk_(t, t\u0027) in set tracks \u0026 (t\u0027 \u003d t1)}) \u003d 1)) and (((t1 \u003c\u003e \"ol\") and (t2 \u003c\u003e \"ol\")) \u003d\u003e (mk_(t1, t2) in set tracks)))))","private Is_wf_Signals: (Tracks * Signals +\u003e bool)\n\tIs_wf_Signals(tracks, signals) \u003d\u003d\n(UniqueSignals(signals) and SigInTracks(tracks, signals))","Station_topo \u003d Station_topo","private Is_wf_Station_topo: (Station_topo +\u003e bool)\n\tIs_wf_Station_topo(stationtopo) \u003d\u003d\n(Is_wf_Tracks((stationtopo.tracks)) and (Is_wf_Points((stationtopo.tracks), (stationtopo.points)) and (Is_wf_Crossings((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings)) and Is_wf_Signals((stationtopo.tracks), (stationtopo.signals)))))","Station_state \u003d Station_state","Track_states \u003d Track_states","Point_states \u003d Point_states","Signal_states \u003d Signal_states","Track_state \u003d Track_state","Train_id \u003d Train_id","Train_type \u003d Train_type","Point_state \u003d Point_state","Operation \u003d Operation","Signal_state \u003d Signal_state","private ConformTracks: (Tracks * Track_states +\u003e bool)\n\tConformTracks(tracks, trackstates) \u003d\u003d\n(TracksStateInTopo(tracks, trackstates) and TracksTopoInState(tracks, trackstates))","private TracksStateInTopo: (Tracks * Track_states +\u003e bool)\n\tTracksStateInTopo(tracks, trackstates) \u003d\u003d\n(forall t in set (dom trackstates) \u0026 (exists mk_(t1, t2) in set tracks \u0026 ((t \u003d t1) or (t \u003d t2))))","private TracksTopoInState: (Tracks * Track_states +\u003e bool)\n\tTracksTopoInState(tracks, trackstates) \u003d\u003d\n(forall mk_(t1, t2) in set tracks \u0026 ((t1 in set (dom trackstates)) and (t2 in set (dom trackstates))))","private ConformPoints: (Points * Point_states +\u003e bool)\n\tConformPoints(points, pointstates) \u003d\u003d\n(PointsStateInTopo(points, pointstates) and PointsTopoInState(points, pointstates))","private PointsStateInTopo: (Points * Point_states +\u003e bool)\n\tPointsStateInTopo(points, pointstates) \u003d\u003d\n(forall t in set (dom pointstates) \u0026 (exists mk_(t1, t2) in set (dom points) \u0026 (t in set (dom points(mk_(t1, t2))))))","private PointsTopoInState: (Points * Point_states +\u003e bool)\n\tPointsTopoInState(points, pointstates) \u003d\u003d\n(forall mk_(t1, t2) in set (dom points) \u0026 (((t1 in set (dom points(mk_(t1, t2)))) \u003d\u003e (t1 in set (dom pointstates))) and ((t2 in set (dom points(mk_(t1, t2)))) \u003d\u003e (t2 in set (dom pointstates)))))","private ConformSignals: (Signals * Signal_states +\u003e bool)\n\tConformSignals(signals, signalstates) \u003d\u003d\n((rng signals) \u003d (dom signalstates))","private Is_wf_Trains: (Tracks * Points * Crossings * Track_states +\u003e bool)\n\tIs_wf_Trains(tracks, points, crossings, trackstates) \u003d\u003d\n(UniqueTrain(trackstates) and let trains:map (Train_id) to (set of (Track_id)) \u003d Trains(trackstates, {|-\u003e}) in (Connected(trains, tracks) and (OkPointTrains(trains, points) and OkCrossTrains(trains, crossings))))","private UniqueTrain: (Track_states +\u003e bool)\n\tUniqueTrain(trackstates) \u003d\u003d\n(forall trackid in set (dom trackstates) \u0026 (forall trainid in set (dom trackstates(trackid)) \u0026 (((trackstates(trackid)(trainid) \u003d \u003cfixedroute\u003e) \u003d\u003e (forall trackid\u0027 in set (dom trackstates) \u0026 ((trainid in set (dom trackstates(trackid\u0027))) \u003d\u003e (trackstates(trackid\u0027)(trainid) \u003d \u003cfixedroute\u003e)))) and ((trackstates(trackid)(trainid) \u003d \u003cautonomous\u003e) \u003d\u003e (forall trackid\u0027 in set (dom trackstates) \u0026 ((trainid in set (dom trackstates(trackid\u0027))) \u003d\u003e (trackstates(trackid\u0027)(trainid) \u003d \u003cautonomous\u003e)))))))","private Trains: (Track_states * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tTrains(trackstates, sorted) \u003d\u003d\n(if (trackstates \u003d {|-\u003e})\nthen sorted\nelse let t in set (dom trackstates) in (if (trackstates(t) \u003d {|-\u003e})\nthen Trains(({t} \u003c-: trackstates), sorted)\nelse Trains(({t} \u003c-: trackstates), Update(mk_(t, trackstates(t)), sorted))))","private Update: ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tUpdate(mk_(t, trackstate), sorted) \u003d\u003d\n(if (trackstate \u003d {|-\u003e})\nthen sorted\nelse let tid in set (dom trackstate) in (if (tid in set (dom sorted))\nthen Update(mk_(t, ({tid} \u003c-: trackstate)), (sorted ++ {tid |-\u003e ({t} union sorted(tid))}))\nelse Update(mk_(t, ({tid} \u003c-: trackstate)), (sorted munion {tid |-\u003e {t}}))))","private Connected: (map (Train_id) to (set of (Track_id)) * Tracks +\u003e bool)\n\tConnected(trains, tracks) \u003d\u003d\n(forall trackset in set (rng trains) \u0026 ExistsPath(trackset, tracks))","private ExistsPath: (set of (Track_id) * Tracks +\u003e bool)\n\tExistsPath(trackset, tracks) \u003d\u003d\n(exists t in set trackset \u0026 Path((trackset \\ {t}), [t], tracks, {}))","private Path: (set of (Track_id) * seq of (Track_id) * Tracks * set of (Track_id) +\u003e bool)\n\tPath(trackset, connected, tracks, tried) \u003d\u003d\n(if (trackset \u003d {})\nthen (tried \u003d {})\nelse let t in set trackset in (if (mk_(t, (hd connected)) in set tracks)\nthen Path(((trackset \\ {t}) union tried), ([t] ^ connected), tracks, {})\nelse (if (mk_(connected((len connected)), t) in set tracks)\nthen Path(((trackset \\ {t}) union tried), (connected ^ [t]), tracks, {})\nelse Path((trackset \\ {t}), connected, tracks, (tried union {t})))))","private OkPointTrains: (map (Train_id) to (set of (Track_id)) * Points +\u003e bool)\n\tOkPointTrains(trains, points) \u003d\u003d\n(forall trackset in set (rng trains) \u0026 (forall t1, t2 in set trackset \u0026 (((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2))))) \u003d\u003e (forall t3 in set trackset \u0026 (((mk_(t1, t3) in set (dom points)) and (t1 in set (dom points(mk_(t1, t3))))) \u003d\u003e (points(mk_(t1, t2))(t1) \u003d points(mk_(t1, t3))(t1)))))))","private OkCrossTrains: (map (Track_id) to (set of (Track_id)) * Crossings +\u003e bool)\n\tOkCrossTrains(trains, crossings) \u003d\u003d\n(forall trackidset in set (rng trains) \u0026 (forall t1, t2 in set trackidset \u0026 (mk_(t1, t2) not in set crossings)))","private Is_wf_Station_state: (Station_topo * Station_state +\u003e bool)\n\tIs_wf_Station_state(stationtopo, stationstate) \u003d\u003d\n(ConformTracks((stationtopo.tracks), (stationstate.trackstates)) and (ConformPoints((stationtopo.points), (stationstate.pointstates)) and (ConformSignals((stationtopo.signals), (stationstate.signalstates)) and Is_wf_Trains((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings), (stationstate.trackstates)))))","private SafeReq: (Station_topo * Station_state +\u003e bool)\n\tSafeReq(stationtopo, stationstate) \u003d\u003d\n(NoCollision(stationtopo, stationstate) and NoDerail(stationtopo, stationstate))\n\tpre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))","private NoCollision: (Station_topo * Station_state +\u003e bool)\n\tNoCollision(stationtopo, stationstate) \u003d\u003d\n(forall tid in set (dom (stationstate.trackstates)) \u0026 (((card (dom (stationstate.trackstates)(tid))) \u003c\u003d 1) and OneTrainAtCross((stationtopo.crossings), (stationstate.trackstates))))","private OneTrainAtCross: (Crossings * Track_states +\u003e bool)\n\tOneTrainAtCross(crossings, trackstates) \u003d\u003d\n(forall mk_(tid1, tid2) in set crossings \u0026 (((card (dom trackstates(tid1))) + (card (dom trackstates(tid2)))) \u003c\u003d 1))","private NoDerail: (Station_topo * Station_state +\u003e bool)\n\tNoDerail(stationtopo, stationstate) \u003d\u003d\nlet trains:map (Train_id) to (set of (Track_id)) \u003d Trains((stationstate.trackstates), {|-\u003e}) in (forall t in set (dom trains) \u0026 (forall t1, t2 in set trains(t) \u0026 ((mk_(t1, t2) in set (dom (stationtopo.points))) \u003d\u003e Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))","private Trains: (Track_states * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tTrains(trackstates, sorted) \u003d\u003d\n(if (trackstates \u003d {|-\u003e})\nthen sorted\nelse let t in set (dom trackstates) in (if (trackstates(t) \u003d {|-\u003e})\nthen Trains(({t} \u003c-: trackstates), sorted)\nelse Trains(({t} \u003c-: trackstates), Update(mk_(t, trackstates(t)), sorted))))","private Update: ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tUpdate(mk_(t, trainids), sorted) \u003d\u003d\n(if (trainids \u003d {|-\u003e})\nthen sorted\nelse let tid in set (dom trainids) in (if (tid in set (dom sorted))\nthen Update(mk_(t, ({tid} \u003c-: trainids)), (sorted ++ {tid |-\u003e ({t} union sorted(tid))}))\nelse Update(mk_(t, ({tid} \u003c-: trainids)), (sorted ++ {tid |-\u003e {t}}))))","private Ok_Point_states: ((Track_id * Track_id) * Points * Point_states +\u003e bool)\n\tOk_Point_states(mk_(t1, t2), points, pointstates) \u003d\u003d\n(if ({t1, t2} \u003d (dom points(mk_(t1, t2))))\nthen (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))\nelse (if ({t1} \u003d (dom points(mk_(t1, t2))))\nthen Point_state_ok(mk_(t1, t2), t1, points, pointstates)\nelse Point_state_ok(mk_(t1, t2), t2, points, pointstates)))\n\tpre (mk_(t1, t2) in set (dom points))","private Point_state_ok: ((Track_id * Track_id) * Track_id * Points * Point_states +\u003e bool)\n\tPoint_state_ok(tpair, t, points, pointstates) \u003d\u003d\nlet mk_(pcnt, -):Point_state \u003d pointstates(t) in (points(tpair)(t) \u003d pcnt)\n\tpre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))","Areas \u003d Areas","Area \u003d Area","private Impl: (Station_topo * Station_state +\u003e bool)\n\tImpl(stationtopo, stationstate) \u003d\u003d\nlet areas:Areas \u003d FindAreas(stationtopo, stationstate) in (NoCollision(areas, (stationtopo.crossings)) and NoDerail(areas, stationtopo, stationstate))\n\tpre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))","private NoCollision: (Areas * Crossings +\u003e bool)\n\tNoCollision(areas, crossings) \u003d\u003d\n(forall train1, train2 in set (dom areas) \u0026 ((train1 \u003c\u003e train2) \u003d\u003e (((areas(train1) inter areas(train2)) \u003d {}) and (forall t1 in set areas(train1) \u0026 (forall t2 in set areas(train2) \u0026 (mk_(t1, t2) not in set crossings))))))","private NoDerail: (Areas * Station_topo * Station_state +\u003e bool)\n\tNoDerail(areas, stationtopo, stationstate) \u003d\u003d\n(NoDerailUnderTrains(stationtopo, stationstate) and NoDerailPossible(areas, stationtopo, stationstate))","private NoDerailUnderTrains: (Station_topo * Station_state +\u003e bool)\n\tNoDerailUnderTrains(stationtopo, stationstate) \u003d\u003d\nlet trains:map (Train_id) to (set of (Track_id)) \u003d Trains((stationstate.trackstates), {|-\u003e}) in (forall t in set (dom trains) \u0026 (forall t1, t2 in set trains(t) \u0026 ((mk_(t1, t2) in set (dom (stationtopo.points))) \u003d\u003e Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))","private NoDerailPossible: (Areas * Station_topo * Station_state +\u003e bool)\n\tNoDerailPossible(areas, stationtopo, stationstate) \u003d\u003d\n(forall area in set (rng areas) \u0026 let traintype:Train_type \u003d TrainType(area, stationstate) in (if (traintype \u003d \u003cfixedroute\u003e)\nthen NoDerailFixed(area, stationtopo, stationstate)\nelse NoDerailAutonomous(area, stationtopo, stationstate)))","private Trains: (Track_states * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tTrains(trackstates, sorted) \u003d\u003d\n(if (trackstates \u003d {|-\u003e})\nthen sorted\nelse let t in set (dom trackstates) in (if (trackstates(t) \u003d {|-\u003e})\nthen Trains(({t} \u003c-: trackstates), sorted)\nelse Trains(({t} \u003c-: trackstates), Update(mk_(t, trackstates(t)), sorted))))","private Update: ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tUpdate(mk_(t, trainids), sorted) \u003d\u003d\n(if (trainids \u003d {|-\u003e})\nthen sorted\nelse let tid in set (dom trainids) in (if (tid in set (dom sorted))\nthen Update(mk_(t, ({tid} \u003c-: trainids)), (sorted ++ {tid |-\u003e ({t} union sorted(tid))}))\nelse Update(mk_(t, ({tid} \u003c-: trainids)), (sorted ++ {tid |-\u003e {t}}))))","private TrainType: (Area * Station_state +\u003e Train_type)\n\tTrainType(area, stationstate) \u003d\u003d\nlet t in set area be st ((stationstate.trackstates)(t) \u003c\u003e {|-\u003e}) in let tt in set (dom (stationstate.trackstates)(t)) in (stationstate.trackstates)(t)(tt)\n\tpre (forall t in set area \u0026 (t in set (dom (stationstate.trackstates))))","private NoDerailFixed: (Area * Station_topo * Station_state +\u003e bool)\n\tNoDerailFixed(area, stationtopo, stationstate) \u003d\u003d\n(forall t1, t2 in set area \u0026 ((mk_(t1, t2) in set (dom (stationtopo.points))) \u003d\u003e (Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)) and InterlockPoints(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))","private Ok_Point_states: ((Track_id * Track_id) * Points * Point_states +\u003e bool)\n\tOk_Point_states(mk_(t1, t2), points, pointstates) \u003d\u003d\n(if ({t1, t2} \u003d (dom points(mk_(t1, t2))))\nthen (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))\nelse (if ({t1} \u003d (dom points(mk_(t1, t2))))\nthen Point_state_ok(mk_(t1, t2), t1, points, pointstates)\nelse Point_state_ok(mk_(t1, t2), t2, points, pointstates)))\n\tpre (mk_(t1, t2) in set (dom points))","private Point_state_ok: ((Track_id * Track_id) * Track_id * Points * Point_states +\u003e bool)\n\tPoint_state_ok(tpair, t, points, pointstates) \u003d\u003d\nlet mk_(pcnt, -):Point_state \u003d pointstates(t) in (points(tpair)(t) \u003d pcnt)\n\tpre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))","private InterlockPoints: ((Track_id * Track_id) * Points * Point_states +\u003e bool)\n\tInterlockPoints(mk_(t1, t2), points, pointstates) \u003d\u003d\n(if (IsPoint(t1, points) and IsPoint(t2, points))\nthen (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))\nelse (if IsPoint(t1, points)\nthen IsInterlockPoint(t1, points, pointstates)\nelse IsInterlockPoint(t2, points, pointstates)))\n\tpre (IsPoint(t1, points) or IsPoint(t2, points))","private IsPoint: (Track_id * Points +\u003e bool)\n\tIsPoint(t, points) \u003d\u003d\n(exists mk_(t1, t2) in set (dom points) \u0026 (t in set (dom points(mk_(t1, t2)))))","private IsInterlockPoint: (Track_id * Points * Point_states +\u003e bool)\n\tIsInterlockPoint(t, points, pointstates) \u003d\u003d\n(if IsPoint(t, points)\nthen let mk_(-, operation):Point_state \u003d pointstates(t) in (operation \u003d \u003cinterlock\u003e)\nelse false)","private NoDerailAutonomous: (Area * Station_topo * Station_state +\u003e bool)\n\tNoDerailAutonomous(area, stationtopo, stationstate) \u003d\u003d\n(forall t1, t2 in set area \u0026 ((mk_(t1, t2) in set (dom (stationtopo.points))) \u003d\u003e OkAutonomPoint_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates))))","private OkAutonomPoint_states: ((Track_id * Track_id) * Points * Point_states +\u003e bool)\n\tOkAutonomPoint_states(mk_(t1, t2), points, pointstates) \u003d\u003d\n(if (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))\nthen (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))\nelse (if IsInterlockPoint(t1, points, pointstates)\nthen Point_state_ok(mk_(t1, t2), t1, points, pointstates)\nelse (if IsInterlockPoint(t2, points, pointstates)\nthen Point_state_ok(mk_(t1, t2), t2, points, pointstates)\nelse true)))","private FindAreas: (Station_topo * Station_state +\u003e Areas)\n\tFindAreas(stationtopo, stationstate) \u003d\u003d\nlet occupied:map (Train_id) to (set of (Track_id)) \u003d Occupied((stationstate.trackstates), {|-\u003e}) in DeduceAreas(occupied, stationtopo, stationstate)","private Occupied: (Track_states * map (Train_id) to (set of (Track_id)) +\u003e map (Train_id) to (set of (Track_id)))\n\tOccupied(trackstates, occupied) \u003d\u003d\n(if (forall s in set (rng trackstates) \u0026 (s \u003d {|-\u003e}))\nthen occupied\nelse let trains in set (rng trackstates) be st (trains \u003c\u003e {|-\u003e}) in let train in set (dom trains) in Occupied(RemoveTrain(train, trackstates), (occupied munion {train |-\u003e {tid | tid in set (dom trackstates) \u0026 (train in set (dom trackstates(tid)))}})))\n\tpre (forall trackstate in set (rng trackstates) \u0026 (((dom trackstate) inter (dom occupied)) \u003d {}))","private RemoveTrain: (Train_id * Track_states +\u003e Track_states)\n\tRemoveTrain(train, trackstates) \u003d\u003d\n(if (trackstates \u003d {|-\u003e})\nthen {|-\u003e}\nelse let tid in set (dom trackstates) in (if (train in set (dom trackstates(tid)))\nthen RemoveTrain(train, (trackstates ++ {tid |-\u003e ({train} \u003c-: trackstates(tid))}))\nelse ({tid |-\u003e trackstates(tid)} munion RemoveTrain(train, ({tid} \u003c-: trackstates)))))","private DeduceAreas: (map (Train_id) to (set of (Track_id)) * Station_topo * Station_state +\u003e Areas)\n\tDeduceAreas(occupied, stationtopo, stationstate) \u003d\u003d\n(if (occupied \u003d {|-\u003e})\nthen {|-\u003e}\nelse let train in set (dom occupied) in let area:Area \u003d FindArea(occupied(train), {}, stationtopo, stationstate) in ({train |-\u003e area} munion DeduceAreas(({train} \u003c-: occupied), stationtopo, stationstate)))","private FindArea: (set of (Track_id) * Area * Station_topo * Station_state +\u003e Area)\n\tFindArea(tracks, area, stationtopo, stationstate) \u003d\u003d\n(if (tracks \u003d {})\nthen area\nelse let t in set tracks in let neighbours:set of (Track_id) \u003d Neighbours(t, area, stationtopo, stationstate) in FindArea(((tracks \\ {t}) union neighbours), (area union {t}), stationtopo, stationstate))","private Neighbours: (Track_id * set of (Track_id) * Station_topo * Station_state +\u003e set of (Track_id))\n\tNeighbours(t, area, stationtopo, stationstate) \u003d\u003d\nlet neighcand:set of (Track_id) \u003d NeighbourCandidates(t, area, (stationtopo.tracks)) in {t\u0027 | t\u0027 in set neighcand \u0026 OkEdge(mk_(t, t\u0027), stationtopo, stationstate)}","private NeighbourCandidates: (Track_id * set of (Track_id) * Tracks +\u003e set of (Track_id))\n\tNeighbourCandidates(t, area, tracks) \u003d\u003d\n{t\u0027 | mk_(t1, t\u0027) in set tracks \u0026 ((t \u003d t1) and (t\u0027 not in set area))}","private OkEdge: ((Track_id * Track_id) * Station_topo * Station_state +\u003e bool)\n\tOkEdge(tpair, stationtopo, stationstate) \u003d\u003d\n(OkPoints(tpair, (stationtopo.points), (stationstate.pointstates)) and (not StopSignal(tpair, (stationtopo.signals), (stationstate.signalstates))))","private OkPoints: ((Track_id * Track_id) * Points * Point_states +\u003e bool)\n\tOkPoints(mk_(t, t\u0027), points, pointstates) \u003d\u003d\n((IsInterlockPoint(t, points, pointstates) and Branch(mk_(t, t\u0027), points)) \u003d\u003e Point_state_ok(mk_(t, t\u0027), t, points, pointstates))","private StopSignal: ((Track_id * Track_id) * Signals * Signal_states +\u003e bool)\n\tStopSignal(tpair, signals, signalstates) \u003d\u003d\n(if (tpair in set (dom signals))\nthen let sigid:Signal_id \u003d signals(tpair) in (signalstates(sigid) \u003d \u003cstop\u003e)\nelse false)","private Branch: ((Track_id * Track_id) * Points +\u003e bool)\n\tBranch(mk_(t1, t2), points) \u003d\u003d\n((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2)))))","tracksv:set of ((seq1 of (char) * seq1 of (char))) \u003d {mk_(\"K12\", \"26\"), mk_(\"26\", \"K12\"), mk_(\"25\", \"26\"), mk_(\"26\", \"25\"), mk_(\"25\", \"24\"), mk_(\"25\", \"17s\"), mk_(\"24\", \"25\"), mk_(\"24\", \"23\"), mk_(\"24\", \"15\"), mk_(\"23\", \"24\"), mk_(\"23\", \"22\"), mk_(\"22\", \"23\"), mk_(\"22\", \"21\"), mk_(\"21\", \"22\"), mk_(\"21\", \"A12\"), mk_(\"A12\", \"21\"), mk_(\"M12\", \"18\"), mk_(\"18\", \"M12\"), mk_(\"18\", \"17b\"), mk_(\"17b\", \"18\"), mk_(\"17s\", \"25\"), mk_(\"17b\", \"16\"), mk_(\"17s\", \"27\"), mk_(\"16\", \"17b\"), mk_(\"16\", \"19\"), mk_(\"16\", \"15\"), mk_(\"15\", \"24\"), mk_(\"15\", \"16\"), mk_(\"15\", \"14\"), mk_(\"14\", \"15\"), mk_(\"14\", \"13\"), mk_(\"13\", \"14\"), mk_(\"13\", \"11\"), mk_(\"11\", \"13\"), mk_(\"11\", \"C12\"), mk_(\"C12\", \"11\"), mk_(\"27\", \"17s\"), mk_(\"27\", \"O12\"), mk_(\"O12\", \"27\"), mk_(\"19\", \"16\"), mk_(\"19\", \"Q12\"), mk_(\"Q12\", \"19\")}","pointsv:map ((seq1 of (char) * seq1 of (char))) to ((map (seq1 of (char)) to (\u003cleft\u003e) | map (seq1 of (char)) to (\u003cright\u003e))) \u003d {mk_(\"25\", \"26\") |-\u003e {\"25\" |-\u003e \u003cright\u003e}, mk_(\"26\", \"25\") |-\u003e {\"25\" |-\u003e \u003cright\u003e}, mk_(\"25\", \"17s\") |-\u003e {\"25\" |-\u003e \u003cleft\u003e}, mk_(\"17s\", \"25\") |-\u003e {\"25\" |-\u003e \u003cleft\u003e}, mk_(\"24\", \"23\") |-\u003e {\"24\" |-\u003e \u003cleft\u003e}, mk_(\"23\", \"24\") |-\u003e {\"24\" |-\u003e \u003cleft\u003e}, mk_(\"24\", \"15\") |-\u003e {\"24\" |-\u003e \u003cright\u003e, \"15\" |-\u003e \u003cright\u003e}, mk_(\"15\", \"24\") |-\u003e {\"24\" |-\u003e \u003cright\u003e, \"15\" |-\u003e \u003cright\u003e}, mk_(\"16\", \"17b\") |-\u003e {\"16\" |-\u003e \u003cright\u003e}, mk_(\"17b\", \"16\") |-\u003e {\"16\" |-\u003e \u003cright\u003e}, mk_(\"16\", \"19\") |-\u003e {\"16\" |-\u003e \u003cleft\u003e}, mk_(\"19\", \"16\") |-\u003e {\"16\" |-\u003e \u003cleft\u003e}, mk_(\"16\", \"15\") |-\u003e {\"15\" |-\u003e \u003cleft\u003e}, mk_(\"15\", \"16\") |-\u003e {\"15\" |-\u003e \u003cleft\u003e}}","crossingsv:set of ((seq1 of (char) * seq1 of (char))) \u003d {mk_(\"17s\", \"17b\")}","signalsv:map ((seq1 of (char) * seq1 of (char))) to (seq1 of (char)) \u003d {mk_(\"ol\", \"K12\") |-\u003e \"N\", mk_(\"26\", \"K12\") |-\u003e \"K\", mk_(\"22\", \"23\") |-\u003e \"E2\", mk_(\"21\", \"A12\") |-\u003e \"D\", mk_(\"ol\", \"A12\") |-\u003e \"A\", mk_(\"ol\", \"M12\") |-\u003e \"M\", mk_(\"18\", \"M12\") |-\u003e \"L\", mk_(\"13\", \"14\") |-\u003e \"E1\", mk_(\"11\", \"C12\") |-\u003e \"C\", mk_(\"ol\", \"C12\") |-\u003e \"B\", mk_(\"27\", \"O12\") |-\u003e \"O\", mk_(\"ol\", \"O12\") |-\u003e \"R\", mk_(\"ol\", \"Q12\") |-\u003e \"Q\", mk_(\"19\", \"Q12\") |-\u003e \"P\"}","trackstatev:map (seq1 of (char)) to ((map (?) to (?) | map (seq1 of (char)) to (\u003cfixedroute\u003e))) \u003d {\"K12\" |-\u003e {|-\u003e}, \"26\" |-\u003e {|-\u003e}, \"25\" |-\u003e {|-\u003e}, \"24\" |-\u003e {|-\u003e}, \"23\" |-\u003e {|-\u003e}, \"22\" |-\u003e {|-\u003e}, \"21\" |-\u003e {|-\u003e}, \"A12\" |-\u003e {|-\u003e}, \"M12\" |-\u003e {|-\u003e}, \"18\" |-\u003e {\"t2\" |-\u003e \u003cfixedroute\u003e}, \"17s\" |-\u003e {|-\u003e}, \"17b\" |-\u003e {|-\u003e}, \"16\" |-\u003e {|-\u003e}, \"15\" |-\u003e {|-\u003e}, \"14\" |-\u003e {|-\u003e}, \"13\" |-\u003e {|-\u003e}, \"11\" |-\u003e {|-\u003e}, \"C12\" |-\u003e {|-\u003e}, \"O12\" |-\u003e {|-\u003e}, \"Q12\" |-\u003e {|-\u003e}, \"19\" |-\u003e {|-\u003e}, \"27\" |-\u003e {|-\u003e}}","pointstatev:map (seq1 of (char)) to (((\u003cleft\u003e * \u003cinterlock\u003e) | (\u003cright\u003e * \u003cinterlock\u003e))) \u003d {\"25\" |-\u003e mk_(\u003cleft\u003e, \u003cinterlock\u003e), \"24\" |-\u003e mk_(\u003cright\u003e, \u003cinterlock\u003e), \"15\" |-\u003e mk_(\u003cleft\u003e, \u003cinterlock\u003e), \"16\" |-\u003e mk_(\u003cright\u003e, \u003cinterlock\u003e)}","signalstatev:map (seq1 of (char)) to ((\u003cdriveaspect\u003e | \u003cstop\u003e)) \u003d {\"N\" |-\u003e \u003cstop\u003e, \"K\" |-\u003e \u003cstop\u003e, \"E2\" |-\u003e \u003cstop\u003e, \"D\" |-\u003e \u003cstop\u003e, \"A\" |-\u003e \u003cstop\u003e, \"M\" |-\u003e \u003cstop\u003e, \"L\" |-\u003e \u003cstop\u003e, \"E1\" |-\u003e \u003cstop\u003e, \"C\" |-\u003e \u003cstop\u003e, \"B\" |-\u003e \u003cstop\u003e, \"O\" |-\u003e \u003cstop\u003e, \"R\" |-\u003e \u003cstop\u003e, \"P\" |-\u003e \u003cdriveaspect\u003e, \"Q\" |-\u003e \u003cstop\u003e}"]