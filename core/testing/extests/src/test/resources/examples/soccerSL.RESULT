["PortType \u003d PortType\n\tinv mk_PortType(label, cardinality, portlist) \u003d\u003d (cardinality \u003d (card (elems portlist)))","Event \u003d Event\n\tinv mk_Event(label, type, porttype) \u003d\u003d (((type \u003d \u003cINTERNAL\u003e) and ((porttype.label) \u003d \"NULLPORT\")) or (((type \u003d \u003cINPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\")) or ((type \u003d \u003cOUTPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\"))))","State \u003d State\n\tinv mk_State(label, type, isinitial, substates) \u003d\u003d let exists_entry_state: (set of (State) +\u003e bool)\n\texists_entry_state(substates) \u003d\u003d\n((exists1 s in set substates \u0026 ((s.isinitial) \u003d true)) and (forall s in set substates \u0026 ((((s.type) \u003d \u003cSIMPLE\u003e) and ((s.substates) \u003d {})) or (((s.type) \u003d \u003cCOMPLEX\u003e) and exists_entry_state((s.substates)))))) in (((type \u003d \u003cSIMPLE\u003e) and (substates \u003d {})) or ((type \u003d \u003cCOMPLEX\u003e) and exists_entry_state(substates)))","Attribute \u003d Attribute","LSLTrait \u003d LSLTrait","AttrFunction \u003d AttrFunction","TransitionSpec \u003d TransitionSpec","TimeConstraint \u003d TimeConstraint\n\tinv mk_TimeConstraint(label, transition, cevent, tbounds, dstates, rwindows) \u003d\u003d ((((cevent.type) \u003d \u003cINTERNAL\u003e) or ((cevent.type) \u003d \u003cOUTPUT\u003e)) and (forall rw in set rwindows \u0026 (((rw.uppertimebound) - (rw.lowertimebound)) \u003d ((tbounds.uppertimebound) - (tbounds.lowertimebound)))))","EventType \u003d EventType","StateType \u003d StateType","ReactionWindow \u003d ReactionWindow\n\tinv mk_ReactionWindow(lowertimebound, uppertimebound) \u003d\u003d (lowertimebound \u003c\u003d uppertimebound)","Port \u003d Port","PortLink \u003d PortLink\n\tinv mk_PortLink(tromporttuple1, tromporttuple2) \u003d\u003d ((tromporttuple1.tromlabel) \u003c\u003e (tromporttuple2.tromlabel))","TromPortTuple \u003d TromPortTuple","SimulationEvent \u003d SimulationEvent","EventHistory \u003d EventHistory","ReactionHistory \u003d ReactionHistory","Reaction \u003d Reaction","LSLTraitDefinition \u003d LSLTraitDefinition","String \u003d String","Trom \u003d Trom\n\tinv mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector) \u003d\u003d ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) and ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) and ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) and ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) and ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) and ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) and ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) and ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) and ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) and ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) and ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) and ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) and ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) and ((forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states \u0026 ((d \u003d (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events \u0026 (e \u003d (ts.triggerevent)))))) and (forall tc in set timeconstraints \u0026 ((exists1 ts in set transitionspecs \u0026 (ts \u003d (tc.transition))) and ((exists1 e in set events \u0026 ((e \u003d (tc.constrainedevent)) and (((e.type) \u003d \u003cINTERNAL\u003e) or ((e.type) \u003d \u003cOUTPUT\u003e)))) and (forall ds in set (tc.disablingstates) \u0026 (exists1 s in set states \u0026 ((s \u003d ds) or substate_of(ds, s))))))))))))))))))))))","Subsystem \u003d Subsystem\n\tinv mk_Subsystem(label, includes, troms, portlinks) \u003d\u003d ((forall s1, s2 in set includes \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and (let included_subsystem: (String * set of (Subsystem) +\u003e bool)\n\tincluded_subsystem(subsystemlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((s.label) \u003d subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) and ((forall trom1, trom2 in set troms \u0026 (((trom1.label) \u003d (trom2.label)) \u003d\u003e (trom1 \u003d trom2))) and (let included_trom: (String * set of (Subsystem) +\u003e bool)\n\tincluded_trom(tromlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 ((exists1 trom in set (s.troms) \u0026 ((trom.label) \u003d tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms \u0026 (not included_trom((trom.label), includes))) and let linked_trom: (TromPortTuple * set of (Trom) +\u003e bool)\n\tlinked_trom(tptuple, troms) \u003d\u003d\n(exists1 trom in set troms \u0026 (((trom.label) \u003d (tptuple.tromlabel)) and (exists1 pt in set (trom.porttypes) \u0026 (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (tptuple.portlabel)))))), linked_subsystem: (TromPortTuple * set of (Subsystem) +\u003e bool)\n\tlinked_subsystem(tptuple, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set subsystems) and (su \u003c\u003e s))} \u0026 ((not linked_trom(tptuple, (s2.troms))) and (not linked_subsystem(tptuple, (s2.includes))))))) in (forall pl in set portlinks \u0026 (((linked_trom((pl.tromporttuple1), troms) and (not linked_subsystem((pl.tromporttuple1), includes))) or ((not linked_trom((pl.tromporttuple1), troms)) and linked_subsystem((pl.tromporttuple1), includes))) and ((linked_trom((pl.tromporttuple2), troms) and (not linked_subsystem((pl.tromporttuple2), includes))) or ((not linked_trom((pl.tromporttuple2), troms)) and linked_subsystem((pl.tromporttuple2), includes)))))))))","state Systemof\n[SUBSYSTEM : Subsystem, SIMULATIONEVENTLIST : seq of (SimulationEvent), LSLLIBRARY : set of (LSLTraitDefinition), CLOCK : nat]\n\tinv mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d\u003d (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem))))))\n\tinit mk_System(subsys, simeventlist, lsllib, clock) \u003d\u003d ((simeventlist \u003c\u003e []) and (clock \u003d 0))","private  get_trom_object((tromlabel:String), (subsystem:Subsystem))trom:[Trom]\n\tpost (((trom in set (subsystem.troms)) and ((trom.label) \u003d tromlabel)) or ((exists1 s in set (subsystem.includes) \u0026 (trom \u003d get_trom_object(tromlabel, s))) or (trom \u003d nil)))","private  get_transition_spec((trom:Trom), (se:SimulationEvent))ts:[TransitionSpec]\n\tpre ((trom.label) \u003d (se.tromlabel))\n\tpost (((ts in set (trom.transitionspecs)) and (((((trom.currentstate).label) \u003d ((ts.sourcestate).label)) or substate_of((trom.currentstate), (ts.sourcestate))) and ((((ts.triggerevent).label) \u003d (se.eventlabel)) and (((ts.portcondition) \u003d true) and ((ts.enabcondition) \u003d true))))) or (ts \u003d nil))","private substate_of: (State * State +\u003e bool)\n\tsubstate_of(substate, complexstate) \u003d\u003d\n((substate in set (complexstate.substates)) or (exists1 s in set (complexstate.substates) \u0026 (((s.type) \u003d \u003cCOMPLEX\u003e) and substate_of(substate, s))))\n\tpre ((complexstate.type) \u003d \u003cCOMPLEX\u003e)","private  get_entry_state((complexstate:State))entry:State\n\tpre ((complexstate.type) \u003d \u003cCOMPLEX\u003e)\n\tpost (exists1 s in set (complexstate.substates) \u0026 (((s.isinitial) \u003d true) and ((((s.type) \u003d \u003cSIMPLE\u003e) and (entry \u003d s)) or (((s.type) \u003d \u003cCOMPLEX\u003e) and (entry \u003d get_entry_state(s))))))","private  get_initial_state((trom:Trom))initial:State\n\tpre ((trom.states) \u003c\u003e {})\n\tpost (exists1 s in set (trom.states) \u0026 (((s.isinitial) \u003d true) and ((((s.type) \u003d \u003cSIMPLE\u003e) and (initial \u003d s)) or (((s.type) \u003d \u003cCOMPLEX\u003e) and (initial \u003d get_entry_state(s))))))","private  get_linked_tromport_tuple((tupleA:TromPortTuple), (subsystem:Subsystem))tupleB:[TromPortTuple]\n\tpost ((exists1 pl in set (subsystem.portlinks) \u0026 ((((pl.tromporttuple1) \u003d tupleA) and ((pl.tromporttuple2) \u003d tupleB)) or (((pl.tromporttuple2) \u003d tupleA) and ((pl.tromporttuple1) \u003d tupleB)))) or ((exists1 s in set (subsystem.includes) \u0026 (tupleB \u003d get_linked_tromport_tuple(tupleA, s))) or (tupleB \u003d nil)))","private exists_in_subsystem: (Trom * Subsystem +\u003e bool)\n\texists_in_subsystem(trom, subsys) \u003d\u003d\n((trom in set (subsys.troms)) or (exists1 subsystem in set (subsys.includes) \u0026 exists_in_subsystem(trom, subsystem)))\n\tpre (((subsys.troms) \u003c\u003e {}) or ((subsys.includes) \u003c\u003e {}))","private  get_unconstrained_internal_event((trom:Trom))event:[Event]\n\tpost ((exists ts in set (trom.transitionspecs) \u0026 (((ts.sourcestate) \u003d (trom.currentstate)) and ((((ts.triggerevent).type) \u003d \u003cINTERNAL\u003e) and ((not constrained_event(trom, (ts.triggerevent))) and (event \u003d (ts.triggerevent)))))) or (event \u003d nil))","private constrained_event: (Trom * Event +\u003e bool)\n\tconstrained_event(trom, event) \u003d\u003d\n(exists tc in set (trom.timeconstraints) \u0026 ((tc.constrainedevent) \u003d event))\n\tpre (event in set (trom.events))","private  get_simevent_index((se:SimulationEvent), (se_list:seq of (SimulationEvent)))index:nat1\n\tpre (se in set (elems se_list))\n\tpost (se_list(index) \u003d se)","private  get_random_time_within_rw((rw:ReactionWindow))time:nat\n\tpost ((time \u003e\u003d (rw.lowertimebound)) and (time \u003c\u003d (rw.uppertimebound)))","private  get_lru_port((portlist:seq of (Port)))port:Port\n\tpre (portlist \u003c\u003e [])\n\tpost (port in set (elems portlist))","simulator (() \u003d\u003d\u003e ())\n\tsimulator() \u003d\u003d\n(\ni:nat1 :\u003d 1\n\ninitialize_simulation_clock();\nschedule_unconstrained_internal_events_from_initial_state();\nwhile (i \u003c\u003d (len SIMULATIONEVENTLIST)) do (\n\nwhile (CLOCK \u003c (SIMULATIONEVENTLIST(i).occurtime)) do (\n\nupdate_simulation_clock()\n);\nwhile ((i \u003c\u003d (len SIMULATIONEVENTLIST)) and (CLOCK \u003d (SIMULATIONEVENTLIST(i).occurtime))) do (\n\nhandle_event(SIMULATIONEVENTLIST(i));\ni :\u003d (i + 1)\n)\n)\n)\n\tpre ((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {}))))))\n\tpost ((SIMULATIONEVENTLIST \u003c\u003e []) and (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {}))))))","handle_event (SimulationEvent \u003d\u003d\u003e ())\n\thandle_event(se) \u003d\u003d\n(\ntrom:[Trom] :\u003d (undefined)\nts:[TransitionSpec] :\u003d (undefined)\n\ntrom :\u003d get_trom_object((se.tromlabel), SUBSYSTEM);\nif (trom \u003d nil)\nthen\nreturnelse\nskip;\nts :\u003d get_transition_spec(trom, se);\nif (ts \u003d nil)\nthen\n(\n\nupdate_history_notransition(trom, se, ts)\n)else\n(\n\nupdate_history_assignment_vector(trom, se, ts);\nif ((ts.postcondition) \u003d false)\nthen\n(\n\nupdate_history_notransition(trom, se, ts)\n)else\n(\n\nupdate_history_transition(trom, se, ts);\nupdate_trom_current_state(trom, se, ts);\nhandle_transition(trom, se, ts);\nschedule_unconstrained_internal_event(trom, se)\n)\n)\n)\n\tpre ((se.occurtime) \u003d CLOCK)\n\tpost (CLOCK \u003d CLOCK~)","handle_transition (Trom * SimulationEvent * TransitionSpec \u003d\u003d\u003e ())\n\thandle_transition(trom, se, ts) \u003d\u003d\n(\n\nfor all tc in set (trom.timeconstraints) do\n(\n\nif (((tc.constrainedevent).label) \u003d (se.eventlabel))\nthen\n(\n\nfor all rw in set (tc.reactionwindows) do\n(\n\nif (((se.occurtime) \u003e\u003d (rw.lowertimebound)) and ((se.occurtime) \u003c\u003d (rw.uppertimebound)))\nthen\n(\n\nupdate_history_fire_reaction(trom, se, tc, rw);\nfire_reaction(trom, se, tc, rw)\n)\n)\n);\nif ((trom.currentstate) in set (tc.disablingstates))\nthen\n(\n\nfor all rw in set (tc.reactionwindows) do\n(\n\nupdate_history_disable_reaction(trom, se, tc, rw);\ndisable_reaction(trom, se, tc, rw)\n)\n);\nif ((ts.label) \u003d ((tc.transition).label))\nthen\n(\n\nupdate_history_enable_reaction(trom, se, tc, ts);\nenable_reaction(trom, se, tc, ts)\n)\n)\n)\n\tpre ((se.occurtime) \u003d CLOCK)\n\tpost (CLOCK \u003d CLOCK~)","update_trom_current_state([trom]Trom, [se]SimulationEvent, [ts]TransitionSpec)\n\tpre ((ts.postcondition) \u003d true)\n\tpost (((((ts.destinstate).type) \u003d \u003cSIMPLE\u003e) and ((trom.currentstate) \u003d (ts.destinstate))) or ((((ts.destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((trom.currentstate) \u003d get_entry_state((ts.destinstate)))))","update_history_assignment_vector([trom]Trom, [se]SimulationEvent, [ts][TransitionSpec])\n\tpre (ts \u003c\u003e nil)\n\tpost (((se.eventhistory).assignmentvector) \u003d (trom.assignmentvector))","update_history_notransition([trom]Trom, [se]SimulationEvent, [ts][TransitionSpec])\n\tpre ((ts \u003d nil) or ((ts.postcondition) \u003d false))\n\tpost ((((se.eventhistory).triggeredtransition) \u003d false) and ((((se.eventhistory).tromcurrentstate) \u003d nil) and ((((se.eventhistory).assignmentvector) \u003d nil) and (((se.eventhistory).reactionshistory) \u003d {}))))","update_history_transition([trom]Trom, [se]SimulationEvent, [ts]TransitionSpec)\n\tpre ((ts.postcondition) \u003d true)\n\tpost ((((se.eventhistory).triggeredtransition) \u003d true) and ((((se.eventhistory).tromcurrentstate) \u003d (trom.currentstate)) and ((((se.eventhistory).assignmentvector) \u003d (trom.assignmentvector)) and (((se.eventhistory).reactionshistory) \u003d {}))))","update_history_fire_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [rw]ReactionWindow)\n\tpre ((((tc.constrainedevent).label) \u003d (se.eventlabel)) and ((rw in set (tc.reactionwindows)) and (((se.occurtime) \u003e\u003d (rw.lowertimebound)) and ((se.occurtime) \u003c\u003d (rw.uppertimebound)))))\n\tpost (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cFIRED\u003e))))","update_history_disable_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [rw]ReactionWindow)\n\tpre (((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows)))\n\tpost (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cDISABLED\u003e))))","update_history_enable_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [ts]TransitionSpec)\n\text [rd[CLOCK]nat]\n\tpre ((ts.label) \u003d ((tc.transition).label))\n\tpost let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cENABLED\u003e))))","fire_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [rw]ReactionWindow)\n\tpre ((((tc.constrainedevent).label) \u003d (se.eventlabel)) and ((rw in set (tc.reactionwindows)) and (((se.occurtime) \u003e\u003d (rw.lowertimebound)) and ((se.occurtime) \u003c\u003d (rw.uppertimebound)))))\n\tpost (rw not in set (tc.reactionwindows))","disable_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [rw]ReactionWindow)\n\text [rd[SUBSYSTEM]Subsystem, wr[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpre (((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows)))\n\tpost ((rw not in set (tc.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))]))))","enable_reaction([trom]Trom, [se]SimulationEvent, [tc]TimeConstraint, [ts]TransitionSpec)\n\text [rd[CLOCK]nat, rd[SUBSYSTEM]Subsystem, wr[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpre ((ts.label) \u003d ((tc.transition).label))\n\tpost let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in let port:Port be st (port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) in let occurtime:nat be st (occurtime \u003d get_random_time_within_rw(rw)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) in ((rw in set (tc.reactionwindows)) and ((se2 in set (elems SIMULATIONEVENTLIST)) and (((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in (((tromporttuple \u003c\u003e nil) and let se3:SimulationEvent be st (se3 \u003d mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil)) in (se3 in set (elems SIMULATIONEVENTLIST))) or (tromporttuple \u003d nil))) or (((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e))))","get_enabled_simevent([trom]Trom, [tc]TimeConstraint) se:SimulationEvent\n\text [rd[CLOCK]nat, rd[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpre (tc in set (trom.timeconstraints))\n\tpost ((se in set (elems SIMULATIONEVENTLIST)) and (((se.eventlabel) \u003d ((tc.constrainedevent).label)) and (((se.tromlabel) \u003d (trom.label)) and (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil)))))","get_enabled_simevent_synch([tromporttuple]TromPortTuple, [tc]TimeConstraint) se:SimulationEvent\n\text [rd[CLOCK]nat, rd[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpost ((se in set (elems SIMULATIONEVENTLIST)) and (((se.eventlabel) \u003d ((tc.constrainedevent).label)) and (((se.tromlabel) \u003d (tromporttuple.tromlabel)) and (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil)))))","schedule_unconstrained_internal_events_from_initial_state()\n\text [rd[CLOCK]nat, rd[SUBSYSTEM]Subsystem, wr[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpre (CLOCK \u003d 0)\n\tpost ((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil))))","schedule_unconstrained_internal_event([trom]Trom, [se]SimulationEvent)\n\text [rd[CLOCK]nat, wr[SIMULATIONEVENTLIST]seq of (SimulationEvent)]\n\tpre ((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label)))\n\tpost let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let j:nat1 be st (j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in (SIMULATIONEVENTLIST \u003d (([SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003c\u003d j)] ^ [se2]) ^ [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003e j)]))) or (event \u003d nil))","initialize_simulation_clock()\n\text [wr[CLOCK]nat]\n\tpost (CLOCK \u003d 0)","update_simulation_clock()\n\text [wr[CLOCK]nat]\n\tpost (CLOCK \u003d (CLOCK~ + 1))"]