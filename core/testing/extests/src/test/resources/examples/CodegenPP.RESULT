["class Account\nprivate  cards:map (CardId) to (Cardholder) :\u003d (undefined)\nprivate  balance:nat :\u003d (undefined)\nprivate  transactions:seq of (Transaction) :\u003d []\nprivate  invTransactionsInvariant(transactions)\nprivate static  dailyLimit:nat \u003d 2000\npublic static  AccountId \u003d AccountId\npublic static  Transaction \u003d Transaction\npublic  Account(map (CardId) to (Cardholder), nat) (map (CardId) to (Cardholder) * nat \u003d\u003d\u003e Account)\n\tAccount(map (CardId) to (Cardholder), nat)(cs, b) \u003d\u003d\n(\n\ncards :\u003d cs;\nbalance :\u003d b\n)\npublic  GetBalance() (() \u003d\u003d\u003e nat)\n\tGetBalance()() \u003d\u003d\nreturn (balance)\npublic  Withdrawal(CardId, nat, Date) (CardId * nat * Date \u003d\u003d\u003e bool)\n\tWithdrawal(CardId, nat, Date)(cardId, amount, date) \u003d\u003d\nlet transaction:Transaction \u003d mk_Transaction(date, cardId, amount) in if (((balance - amount) \u003e\u003d 0) and (DateTotal(date, (transactions ^ [transaction])) \u003c\u003d dailyLimit))\nthen\n(\n\nbalance :\u003d (balance - amount);\ntransactions :\u003d (transactions ^ [transaction]);\nreturn (true)\n)else\nreturn (false)\n\tpre (cardId in set (dom cards))\npublic  MakeStatement(CardId, Date) (CardId * Date \u003d\u003d\u003e Letter)\n\tMakeStatement(CardId, Date)(cardId, date) \u003d\u003d\nlet nm:Name \u003d (cards(cardId).GetName)(), addr:Address \u003d (cards(cardId).GetAddress)() in return (new Letter(nm, addr, date, transactions, balance))\n\tpre (cardId in set (dom cards))\npublic  GetCardIds() (() \u003d\u003d\u003e set of (CardId))\n\tGetCardIds()() \u003d\u003d\nreturn ((dom cards))\nprivate  AddCard(CardId, Cardholder) (CardId * Cardholder \u003d\u003d\u003e ())\n\tAddCard(CardId, Cardholder)(cId, ch) \u003d\u003d\ncards :\u003d (cards munion {cId |-\u003e ch})\n\tpre (cId not in set (dom cards))\nprivate  private TransactionsInvariant: (seq of (Transaction) +\u003e bool)\n\tTransactionsInvariant(ts) \u003d\u003d\n(forall date in set {(ts(i).date) | i in set (inds ts)} \u0026 (DateTotal(date, ts) \u003c\u003d dailyLimit))\nprivate  private DateTotal: (Date * seq of (Transaction) +\u003e nat)\n\tDateTotal(date, ts) \u003d\u003d\nSum([(ts(i).amount) | i in set (inds ts) \u0026 ((ts(i).date) \u003d date)])\nprivate  private Sum: (seq of (real) +\u003e real)\n\tSum(rs) \u003d\u003d\n(if (rs \u003d [])\nthen 0\nelse ((hd rs) + Sum((tl rs))))\nend Account\n","class Card\npublic static  CardId \u003d CardId\npublic static  Code \u003d Code\npublic static  PinCode \u003d PinCode\nprivate  code:Code :\u003d (undefined)\nprivate  cardId:CardId :\u003d (undefined)\nprivate  accountId:AccountId :\u003d (undefined)\npublic  Card(Code, CardId, AccountId) (Code * CardId * AccountId \u003d\u003d\u003e Card)\n\tCard(Code, CardId, AccountId)(c, cid, a) \u003d\u003d\n(\n\ncode :\u003d c;\ncardId :\u003d cid;\naccountId :\u003d a\n)\npublic  GetCode() (() \u003d\u003d\u003e Code)\n\tGetCode()() \u003d\u003d\nreturn (code)\npublic  GetAccountId() (() \u003d\u003d\u003e AccountId)\n\tGetAccountId()() \u003d\u003d\nreturn (accountId)\npublic  GetCardId() (() \u003d\u003d\u003e CardId)\n\tGetCardId()() \u003d\u003d\nreturn (cardId)\nend Card\n","class Cardholder\npublic static  Address \u003d Address\npublic static  Name \u003d Name\nprivate  name:Name :\u003d (undefined)\nprivate  address:Address :\u003d (undefined)\npublic  Cardholder(Name, Address) (Name * Address \u003d\u003d\u003e Cardholder)\n\tCardholder(Name, Address)(nm, addr) \u003d\u003d\n(\n\nname :\u003d nm;\naddress :\u003d addr\n)\npublic  GetName() (() \u003d\u003d\u003e Name)\n\tGetName()() \u003d\u003d\nreturn (name)\npublic  GetAddress() (() \u003d\u003d\u003e Address)\n\tGetAddress()() \u003d\u003d\nreturn (address)\nend Cardholder\n","class CentralResource\nprivate  accounts:map (AccountId) to (Account) :\u003d {|-\u003e}\nprivate  numberOfTries:map (CardId) to (nat) :\u003d {|-\u003e}\nprivate  illegalCards:set of (CardId) :\u003d {}\nprivate  letterbox:Letterbox :\u003d (undefined)\nprivate  clock:Clock :\u003d (undefined)\nprivate  inv(forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))\nprivate static  maxNumberOfTries:nat \u003d 3\npublic  CentralResource(Clock, Letterbox) (Clock * Letterbox \u003d\u003d\u003e CentralResource)\n\tCentralResource(Clock, Letterbox)(c, l) \u003d\u003d\n(\n\nclock :\u003d c;\nletterbox :\u003d l\n)\npublic  GetBalance(AccountId) (AccountId \u003d\u003d\u003e [nat])\n\tGetBalance(AccountId)(accountId) \u003d\u003d\nif (accountId in set (dom accounts))\nthen\naccounts(accountId).GetBalance()else\nreturn (nil)\npublic  Withdrawal(AccountId, CardId, nat) (AccountId * CardId * nat \u003d\u003d\u003e bool)\n\tWithdrawal(AccountId, CardId, nat)(accountId, cardId, amount) \u003d\u003d\nif IsLegalCard(accountId, cardId)\nthen\naccounts(accountId).Withdrawal(cardId, amount, (clock.GetDate)())else\nreturn (false)\npublic  PostStatement(AccountId, CardId) (AccountId * CardId \u003d\u003d\u003e bool)\n\tPostStatement(AccountId, CardId)(accountId, cardId) \u003d\u003d\nif IsLegalCard(accountId, cardId)\nthen\n(\n\nletterbox.PostStatement((accounts(accountId).MakeStatement)(cardId, (clock.GetDate)()));\nreturn (true)\n)else\nreturn (false)\npublic  IsLegalCard(AccountId, CardId) (AccountId * CardId \u003d\u003d\u003e bool)\n\tIsLegalCard(AccountId, CardId)(accountId, cardId) \u003d\u003d\nreturn (((cardId not in set illegalCards) and ((accountId in set (dom accounts)) and (cardId in set (accounts(accountId).GetCardIds)()))))\npublic  NumberOfTriesExceeded(CardId) (CardId \u003d\u003d\u003e bool)\n\tNumberOfTriesExceeded(CardId)(cardId) \u003d\u003d\nreturn ((numberOfTries(cardId) \u003e\u003d maxNumberOfTries))\npublic  ResetNumberOfTries(CardId) (CardId \u003d\u003d\u003e ())\n\tResetNumberOfTries(CardId)(cardId) \u003d\u003d\nnumberOfTries(cardId) :\u003d 0\npublic  IncrNumberOfTries(CardId) (CardId \u003d\u003d\u003e ())\n\tIncrNumberOfTries(CardId)(cardId) \u003d\u003d\nnumberOfTries(cardId) :\u003d (numberOfTries(cardId) + 1)\npublic  AddAccount(AccountId, Account) (AccountId * Account \u003d\u003d\u003e ())\n\tAddAccount(AccountId, Account)(accId, acc) \u003d\u003d\n(\n\nnumberOfTries :\u003d (numberOfTries ++ {cId |-\u003e 0 | cId in set (acc.GetCardIds)()});\naccounts :\u003d (accounts ++ {accId |-\u003e acc})\n)\n\tpre (accId not in set (dom accounts))\npublic  AddIllegalCard(CardId) (CardId \u003d\u003d\u003e ())\n\tAddIllegalCard(CardId)(cId) \u003d\u003d\nillegalCards :\u003d (illegalCards union {cId})\nend CentralResource\n","class Channel\nprivate  req:[Request] :\u003d nil\nprivate  resp:[Response] :\u003d nil\nprivate  timer:Timer :\u003d new Timer()\nprivate  curTime:nat :\u003d 0\nprivate static  timeout:nat1 \u003d 1500\npublic static  Request \u003d Request\npublic static  Command \u003d Command\npublic static  ReqData \u003d ReqData\npublic static  CardId \u003d CardId\npublic static  AccountId \u003d AccountId\npublic static  Amount \u003d Amount\npublic static  Response \u003d Response\npublic static  RespData \u003d RespData\npublic  SendRequest(Request) (Request \u003d\u003d\u003e ())\n\tSendRequest(Request)(r) \u003d\u003d\n(\n\nreq :\u003d r;\ntimer.Start()\n)\n\tpre (req \u003d nil)\npublic  ReceiveRequest() (() \u003d\u003d\u003e Request)\n\tReceiveRequest()() \u003d\u003d\nlet r:[Request] \u003d req in (\n\nreq :\u003d nil;\nreturn (r)\n)\npublic  SendResponse(Response) (Response \u003d\u003d\u003e ())\n\tSendResponse(Response)(r) \u003d\u003d\n(\n\nresp :\u003d r;\ntimer.Stop()\n)\n\tpre (resp \u003d nil)\npublic  ReceiveResponse() (() \u003d\u003d\u003e [Response])\n\tReceiveResponse()() \u003d\u003d\nlet r:[Response] \u003d resp in (\n\nresp :\u003d nil;\nreturn (r)\n)\npublic  Wait() (() \u003d\u003d\u003e ())\n\tWait()() \u003d\u003d\nskip\nprivate  CheckTime() (() \u003d\u003d\u003e ())\n\tCheckTime()() \u003d\u003d\ncurTime :\u003d (timer.GetTime)()\nprivate  private AllReceived: (nat * nat * nat * nat -\u003e bool)\n\tAllReceived(act_send, fin_send, act_rec, fin_rec) \u003d\u003d\n((act_send \u003d fin_send) and ((act_rec \u003d fin_rec) and ((act_send + fin_send) \u003d (act_send + fin_send))))\nprivate  per SendResponse \u003d\u003e (AllReceived(#act[SendRequest], #fin[SendRequest], #act[ReceiveRequest], #fin[ReceiveRequest]) and (AllReceived(#act[SendResponse], #fin[SendResponse], #act[ReceiveResponse], #fin[ReceiveResponse]) and ((#act[SendRequest] - #fin[SendResponse]) \u003d 1)))\nprivate  per ReceiveRequest \u003d\u003e (req \u003c\u003e nil)\nprivate  per Wait \u003d\u003e ((curTime \u003e timeout) or (resp \u003c\u003e nil))\nend Channel\n","class Clock\npublic static  Date \u003d Date\nprivate  date:Date :\u003d []\npublic  SetDate(Date) (Date \u003d\u003d\u003e ())\n\tSetDate(Date)(d) \u003d\u003d\ndate :\u003d d\npublic  GetDate() (() \u003d\u003d\u003e Date)\n\tGetDate()() \u003d\u003d\nreturn (date)\nend Clock\n","class Letter\nprivate  name:Name :\u003d (undefined)\nprivate  address:Address :\u003d (undefined)\nprivate  date:Date :\u003d (undefined)\nprivate  transactions:seq of (Transaction) :\u003d (undefined)\nprivate  balance:nat :\u003d (undefined)\npublic  Letter(Name, Address, Date, seq of (Transaction), nat) (Name * Address * Date * seq of (Transaction) * nat \u003d\u003d\u003e Letter)\n\tLetter(Name, Address, Date, seq of (Transaction), nat)(nm, addr, d, ts, b) \u003d\u003d\n(\n\nname :\u003d nm;\naddress :\u003d addr;\ndate :\u003d d;\ntransactions :\u003d ts;\nbalance :\u003d b\n)\nend Letter\n","class Letterbox\nprivate  statements:seq of (Letter) :\u003d []\npublic  PostStatement(Letter) (Letter \u003d\u003d\u003e ())\n\tPostStatement(Letter)(letter) \u003d\u003d\nstatements :\u003d (statements ^ [letter])\nprivate  GetLastStatement() (() \u003d\u003d\u003e Letter)\n\tGetLastStatement()() \u003d\u003d\nreturn (statements((len statements)))\n\tpre (statements \u003c\u003e [])\nend Letterbox\n","class LocalResource\nprivate  c:Channel :\u003d new Channel()\npublic  LocalResource(Channel) (Channel \u003d\u003d\u003e LocalResource)\n\tLocalResource(Channel)(nc) \u003d\u003d\nc :\u003d nc\npublic  GetBalance(AccountId) (AccountId \u003d\u003d\u003e (\u003cFail\u003e | [nat]))\n\tGetBalance(AccountId)(accountId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cGetBalance\u003e, {mk_Channel`AccountId(accountId)}) in (\n\nc.SendRequest(req);\nWait(\u003cGetBalance\u003e)\n)\nprivate  Wait(Command) (Command \u003d\u003d\u003e (\u003cFail\u003e | RespData))\n\tWait(Command)(comm) \u003d\u003d\n(\n\nc.Wait();\nlet resp:[Response] \u003d (c.ReceiveResponse)() in if (resp \u003d nil)\nthen\nreturn (\u003cFail\u003e)elseif ((resp.command) \u003c\u003e comm)\nthen\nreturn (\u003cFail\u003e)else\nreturn ((resp.data))\n)\npublic  Withdrawal(AccountId, CardId, nat) (AccountId * CardId * nat \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tWithdrawal(AccountId, CardId, nat)(accountId, cardId, amount) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cWithdrawal\u003e, {mk_Channel`AccountId(accountId), mk_Channel`CardId(cardId), mk_Channel`Amount(amount)}) in (\n\nc.SendRequest(req);\nWait(\u003cWithdrawal\u003e)\n)\npublic  PostStatement(AccountId, CardId) (AccountId * CardId \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tPostStatement(AccountId, CardId)(accountId, cardId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cPostStmt\u003e, {mk_Channel`AccountId(accountId), mk_Channel`CardId(cardId)}) in (\n\nc.SendRequest(req);\nWait(\u003cPostStmt\u003e)\n)\npublic  IsLegalCard(AccountId, CardId) (AccountId * CardId \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tIsLegalCard(AccountId, CardId)(accountId, cardId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cIsLegalCard\u003e, {mk_Channel`AccountId(accountId), mk_Channel`CardId(cardId)}) in (\n\nc.SendRequest(req);\nWait(\u003cIsLegalCard\u003e)\n)\npublic  NumberOfTriesExceeded(CardId) (CardId \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tNumberOfTriesExceeded(CardId)(cardId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cTriesExceeded\u003e, {mk_Channel`CardId(cardId)}) in (\n\nc.SendRequest(req);\nWait(\u003cTriesExceeded\u003e)\n)\npublic  ResetNumberOfTries(CardId) (CardId \u003d\u003d\u003e [\u003cFail\u003e])\n\tResetNumberOfTries(CardId)(cardId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cResetTries\u003e, {mk_Channel`CardId(cardId)}) in (\n\nc.SendRequest(req);\nWait(\u003cResetTries\u003e)\n)\npublic  IncrNumberOfTries(CardId) (CardId \u003d\u003d\u003e [\u003cFail\u003e])\n\tIncrNumberOfTries(CardId)(cardId) \u003d\u003d\nlet req:Channel`Request \u003d mk_Channel`Request(\u003cIncTries\u003e, {mk_Channel`CardId(cardId)}) in (\n\nc.SendRequest(req);\nWait(\u003cIncTries\u003e)\n)\nend LocalResource\n","class LocalTill\nprivate  c:Channel :\u003d (undefined)\nprivate  resource:CentralResource :\u003d (undefined)\nprivate  enabled:bool :\u003d true\nprotected  thread while enabled do let req:Request \u003d (c.ReceiveRequest)() in if enabled\nthen\nProcessRequest(req)\nprivate  ProcessRequest(Request) (Request \u003d\u003d\u003e ())\n\tProcessRequest(Request)(req) \u003d\u003d\n(\nrespdata:RespData :\u003d (undefined)\n\ncases req :\n  mk_Request(\u003cWithdrawal\u003e, {mk_AccountId(accId), mk_CardId(cardId), mk_Amount(amt)}) -\u003e respdata :\u003d (resource.Withdrawal)(accId, cardId, amt)  mk_Request(\u003cPostStmt\u003e, {mk_AccountId(accId), mk_CardId(cardId)}) -\u003e respdata :\u003d (resource.PostStatement)(accId, cardId)  mk_Request(\u003cIsLegalCard\u003e, {mk_AccountId(accId), mk_CardId(cardId)}) -\u003e respdata :\u003d (resource.IsLegalCard)(accId, cardId)  mk_Request(\u003cGetBalance\u003e, {mk_AccountId(accId)}) -\u003e respdata :\u003d (resource.GetBalance)(accId)  mk_Request(\u003cTriesExceeded\u003e, {mk_CardId(cardId)}) -\u003e respdata :\u003d (resource.NumberOfTriesExceeded)(cardId)  mk_Request(\u003cResetTries\u003e, {mk_CardId(cardId)}) -\u003e (\n\nresource.ResetNumberOfTries(cardId);\nrespdata :\u003d nil\n)  mk_Request(\u003cIncTries\u003e, {mk_CardId(cardId)}) -\u003e (\n\nresource.IncrNumberOfTries(cardId);\nrespdata :\u003d nil\n) end;\nc.SendResponse(mk_Channel`Response((req.command), respdata))\n)\npublic  LocalTill(Channel, CentralResource) (Channel * CentralResource \u003d\u003d\u003e LocalTill)\n\tLocalTill(Channel, CentralResource)(nc, nr) \u003d\u003d\n(\n\nc :\u003d nc;\nresource :\u003d nr\n)\npublic  Fail() (() \u003d\u003d\u003e ())\n\tFail()() \u003d\u003d\nenabled :\u003d false\npublic  Repair(Channel) (Channel \u003d\u003d\u003e ())\n\tRepair(Channel)(nc) \u003d\u003d\n(\n\nc :\u003d nc;\nenabled :\u003d true\n)\nend LocalTill\n","class Till\nprivate  curCard:[Card] :\u003d nil\nprivate  cardOk:bool :\u003d false\nprivate  retainedCards:set of (Card) :\u003d {}\nprivate  resource:LocalResource :\u003d (undefined)\nprivate  inv((curCard \u003d nil) \u003d\u003e (not cardOk))\npublic  Till(LocalResource) (LocalResource \u003d\u003d\u003e Till)\n\tTill(LocalResource)(res) \u003d\u003d\nresource :\u003d res\npublic  Set(LocalResource) (LocalResource \u003d\u003d\u003e Till)\n\tSet(LocalResource)(res) \u003d\u003d\n(\n\nresource :\u003d res;\nreturn (self)\n)\npublic  InsertCard(Card) (Card \u003d\u003d\u003e ())\n\tInsertCard(Card)(c) \u003d\u003d\ncurCard :\u003d c\n\tpre (not CardInside())\npublic  Validate(PinCode) (PinCode \u003d\u003d\u003e (\u003cFail\u003e | \u003cPinNotOk\u003e | \u003cPinOk\u003e | \u003cRetained\u003e))\n\tValidate(PinCode)(pin) \u003d\u003d\nlet cardId:CardId \u003d (curCard.GetCardId)(), codeOk:bool \u003d ((curCard.GetCode)() \u003d Encode(pin)), cardLegal:(\u003cFail\u003e | bool) \u003d IsLegalCard() in if (cardLegal \u003d \u003cFail\u003e)\nthen\nreturn (\u003cFail\u003e)else\n(\n\ncardOk :\u003d (codeOk and cardLegal);\nif (not cardLegal)\nthen\n(\n\nretainedCards :\u003d (retainedCards union {curCard});\ncurCard :\u003d nil;\nreturn (\u003cRetained\u003e)\n)elseif codeOk\nthen\nif ((resource.ResetNumberOfTries)(cardId) \u003d \u003cFail\u003e)\nthen\nreturn (\u003cFail\u003e)else\nreturn (\u003cPinOk\u003e)else\n(\n\nlet incTries:[\u003cFail\u003e] \u003d (resource.IncrNumberOfTries)(cardId), numTriesExceeded:(\u003cFail\u003e | bool) \u003d (resource.NumberOfTriesExceeded)(cardId) in if (\u003cFail\u003e in set {incTries, numTriesExceeded})\nthen\nreturn (\u003cFail\u003e)elseif numTriesExceeded\nthen\n(\n\nretainedCards :\u003d (retainedCards union {curCard});\ncardOk :\u003d false;\ncurCard :\u003d nil;\nreturn (\u003cRetained\u003e)\n)else\nreturn (\u003cPinNotOk\u003e)\n)\n)\n\tpre (CardInside() and (not cardOk))\npublic  ReturnCard() (() \u003d\u003d\u003e ())\n\tReturnCard()() \u003d\u003d\n(\n\ncardOk :\u003d false;\ncurCard :\u003d nil\n)\n\tpre CardInside()\npublic  GetBalance() (() \u003d\u003d\u003e (\u003cFail\u003e | [nat]))\n\tGetBalance()() \u003d\u003d\nresource.GetBalance((curCard.GetAccountId)())\n\tpre CardValidated()\npublic  MakeWithdrawal(nat) (nat \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tMakeWithdrawal(nat)(amount) \u003d\u003d\nresource.Withdrawal((curCard.GetAccountId)(), (curCard.GetCardId)(), amount)\n\tpre CardValidated()\npublic  RequestStatement() (() \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tRequestStatement()() \u003d\u003d\nresource.PostStatement((curCard.GetAccountId)(), (curCard.GetCardId)())\n\tpre CardValidated()\npublic  IsLegalCard() (() \u003d\u003d\u003e (\u003cFail\u003e | bool))\n\tIsLegalCard()() \u003d\u003d\nreturn ((resource.IsLegalCard)((curCard.GetAccountId)(), (curCard.GetCardId)()))\n\tpre CardInside()\npublic  CardValidated() (() \u003d\u003d\u003e bool)\n\tCardValidated()() \u003d\u003d\nreturn (((curCard \u003c\u003e nil) and cardOk))\npublic  CardInside() (() \u003d\u003d\u003e bool)\n\tCardInside()() \u003d\u003d\nreturn ((curCard \u003c\u003e nil))\nprivate  private Encode: (PinCode +\u003e Code)\n\tEncode(pin) \u003d\u003d\npin\nend Till\n","class Timer\nprivate  curTime:nat :\u003d 0\nprivate  active:bool :\u003d false\npublic  Start() (() \u003d\u003d\u003e ())\n\tStart()() \u003d\u003d\n(\n\nactive :\u003d true;\ncurTime :\u003d 0\n)\npublic  Stop() (() \u003d\u003d\u003e ())\n\tStop()() \u003d\u003d\nactive :\u003d false\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (curTime)\nprivate  IncTime() (() \u003d\u003d\u003e ())\n\tIncTime()() \u003d\u003d\nif active\nthen\ncurTime :\u003d (curTime + 100)\nend Timer\n","class Main\nprivate  ltills:map (TillId) to (LocalTill) :\u003d {|-\u003e}\nprivate  tills:map (TillId) to (Till) :\u003d {|-\u003e}\nprivate  cards:seq of (Card) :\u003d []\nprivate  resource:CentralResource :\u003d (undefined)\nprivate  clock:Clock :\u003d new Clock()\nprivate  letterbox:Letterbox :\u003d new Letterbox()\nprivate  mb:MessageBuffer :\u003d new MessageBuffer()\npublic static  TillId \u003d TillId\nprivate static  nat2char:map (nat) to (char) \u003d {0 |-\u003e \u00270\u0027, 1 |-\u003e \u00271\u0027, 2 |-\u003e \u00272\u0027, 3 |-\u003e \u00273\u0027, 4 |-\u003e \u00274\u0027, 5 |-\u003e \u00275\u0027, 6 |-\u003e \u00276\u0027, 7 |-\u003e \u00277\u0027, 8 |-\u003e \u00278\u0027, 9 |-\u003e \u00279\u0027}\nprivate  private tStr: (nat -\u003e seq of (char))\n\ttStr(n) \u003d\u003d\n((\"Till \" ^ nat2string(n)) ^ \":\t\")\nprivate  private nat2chars: (nat -\u003e seq of (char))\n\tnat2chars(n) \u003d\u003d\n(if (n \u003d 0)\nthen []\nelseif (n \u003c 10)\nthen [nat2char(n)]\nelse (nat2chars((n div 10)) ^ [nat2char((n mod 10))]))\nprivate  private nat2string: (nat -\u003e seq of (char))\n\tnat2string(n) \u003d\u003d\n(if (n \u003d 0)\nthen \"0\"\nelse nat2chars(n))\npublic  GetTill(TillId) (TillId \u003d\u003d\u003e Till)\n\tGetTill(TillId)(tid) \u003d\u003d\nreturn (tills(tid))\npublic  Main() (() \u003d\u003d\u003e Main)\n\tMain()() \u003d\u003d\n(\n\nclock.SetDate(\"150999\");\nlet c1:Card \u003d new Card(123456, 1, 1), c2:Card \u003d new Card(123457, 2, 2), c3:Card \u003d new Card(123458, 3, 3), c4:Card \u003d new Card(123459, 4, 4), c5:Card \u003d new Card(123460, 5, 5), c6:Card \u003d new Card(123461, 6, 5), c7:Card \u003d new Card(123462, 7, 5) in let peter:Cardholder \u003d new Cardholder(\"Peter Gorm Larsen\", \"Granvej 24\"), paul:Cardholder \u003d new Cardholder(\"Paul Mukherjee\", \"Rugaardsvej 47\"), sten:Cardholder \u003d new Cardholder(\"Sten Agerholm\", \"Teisensvej ??\"), kim:Cardholder \u003d new Cardholder(\"Kim Sunesen\", \"??\"), CSK:Cardholder \u003d new Cardholder(\"CSK\", \"Forskerparken 10A\") in let pglacc1:Account \u003d new Account({1 |-\u003e peter}, 5000), saacc1:Account \u003d new Account({2 |-\u003e sten}, 0), ksacc1:Account \u003d new Account({3 |-\u003e kim}, 9000), pmacc1:Account \u003d new Account({4 |-\u003e paul}, 6000), ifacc1:Account \u003d new Account({5 |-\u003e peter, 6 |-\u003e sten, 7 |-\u003e CSK}, 3000), pglid1:nat1 \u003d 1, said1:nat1 \u003d 2, ksid1:nat1 \u003d 3, pmid1:nat1 \u003d 4, ifid1:nat1 \u003d 5 in (\n\nresource :\u003d new CentralResource(clock, new Letterbox());\nresource.AddAccount(pglid1, pglacc1);\nresource.AddAccount(said1, saacc1);\nresource.AddAccount(ksid1, ksacc1);\nresource.AddAccount(pmid1, pmacc1);\nresource.AddAccount(ifid1, ifacc1);\ntills :\u003d {1 |-\u003e SetupTill(1, new Till()), 2 |-\u003e SetupTill(2, new Till()), 3 |-\u003e SetupTill(3, new Till()), 4 |-\u003e SetupTill(4, new Till())};\ncards :\u003d [c1, c2, c3, c4, c5, c6, c7]\n)\n)\nprivate  SetupTill(nat, Till) (nat * Till \u003d\u003d\u003e Till)\n\tSetupTill(nat, Till)(i, t) \u003d\u003d\nlet c:Channel \u003d new Channel(), lt:LocalTill \u003d new LocalTill(c, resource), lr:LocalResource \u003d new LocalResource(c) in (\n\nstart (lt);\nltills :\u003d (ltills ++ {i |-\u003e lt});\nt.Set(lr)\n)\npublic  RepairTill(nat) (nat \u003d\u003d\u003e ())\n\tRepairTill(nat)(tillNum) \u003d\u003d\ntills(tillNum) :\u003d SetupTill(tillNum, tills(tillNum))\npublic  EnterCardAtTill(nat, nat, nat) (nat * nat * nat \u003d\u003d\u003e ())\n\tEnterCardAtTill(nat, nat, nat)(tillNum, cardNum, pin) \u003d\u003d\n(\n\ntills(tillNum).InsertCard(cards(cardNum));\nlet validRes1:(\u003cFail\u003e | \u003cPinNotOk\u003e | \u003cPinOk\u003e | \u003cRetained\u003e) \u003d (tills(tillNum).Validate)(pin) in let msg:seq1 of (char) \u003d (cases validRes1 :\n\u003cFail\u003e -\u003e (tStr(tillNum) ^ \"Validate card failed\"),\n\u003cRetained\u003e -\u003e (tStr(tillNum) ^ \"Card Retained\"),\n\u003cPinNotOk\u003e -\u003e \"Validate Unsuccessful\",\n\u003cPinOk\u003e -\u003e (tStr(tillNum) ^ \"Validate Successful\")\nothers (tStr(tillNum) ^ \"Unknown Message\")\n end) in mb.put(msg);\nif (tillNum \u003d 1)\nthen\nFail(tillNum)\n)\n\tpre (tillNum in set (dom tills))\npublic  WithdrawalAtTill(nat, nat) (nat * nat \u003d\u003d\u003e ())\n\tWithdrawalAtTill(nat, nat)(tillNum, amount) \u003d\u003d\nlet wd1:(\u003cFail\u003e | bool) \u003d (tills(tillNum).MakeWithdrawal)(amount) in let msghdr:seq1 of (char) \u003d (((tStr(tillNum) ^ \"Withdrawal (\") ^ nat2string(amount)) ^ \")\") in if (\u003cFail\u003e \u003d wd1)\nthen\nmb.put((msghdr ^ \" Failed\"))elseif (not wd1)\nthen\nmb.put((msghdr ^ \" Unsuccessful\"))else\nmb.put((msghdr ^ \" Successful\"))\npublic  GetBalanceAtTill(nat) (nat \u003d\u003d\u003e ())\n\tGetBalanceAtTill(nat)(tillNum) \u003d\u003d\nlet bal1:(\u003cFail\u003e | [nat]) \u003d (tills(tillNum).GetBalance)() in if (nil \u003d bal1)\nthen\nmb.put((tStr(tillNum) ^ \"Balance not known for this account\"))elseif (\u003cFail\u003e \u003d bal1)\nthen\nmb.put((tStr(tillNum) ^ \"Balance Failed\"))else\nmb.put(((tStr(tillNum) ^ \"Balance is \") ^ nat2string(bal1)))\npublic  Fail(nat) (nat \u003d\u003d\u003e ())\n\tFail(nat)(tillNum) \u003d\u003d\n(\n\nltills(tillNum).Fail();\nmb.put((tStr(tillNum) ^ \"LocalTill Fail\"))\n)\npublic  ReturnCard(nat) (nat \u003d\u003d\u003e ())\n\tReturnCard(nat)(tillNum) \u003d\u003d\n(\n\ntills(tillNum).ReturnCard();\nmb.put((tStr(tillNum) ^ \"Card Returned\"))\n)\nprivate  Wait() (() \u003d\u003d\u003e ())\n\tWait()() \u003d\u003d\nskip\npublic  Run() (() \u003d\u003d\u003e seq of (char))\n\tRun()() \u003d\u003d\n(\nuser1:User :\u003d new User(1, 1, 123456, self)\nuser2:User :\u003d new User(2, 5, 123460, self)\nuser3:User :\u003d new User(3, 6, 123461, self)\nuser4:User :\u003d new User(4, 7, 123462, self)\n\nstart (user1);\nstart (user2);\nstart (user3);\nstart (user4);\nWait();\nreturn ((mb.get)())\n)\nprivate  mutex(SetupTill)\nprivate  mutex(ReturnCard)\nprivate  per Wait \u003d\u003e (#fin[ReturnCard] \u003e\u003d 3)\nend Main\n","class MessageBuffer\nprivate  data:seq of (char) :\u003d []\npublic  put(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tput(seq of (char))(msg) \u003d\u003d\ndata :\u003d ((data ^ \"\n\") ^ msg)\npublic  get() (() \u003d\u003d\u003e seq of (char))\n\tget()() \u003d\u003d\nreturn (data)\nprivate  mutex(put(seq of (char)), get())\nend MessageBuffer\n","class User\nprivate  tillNum:nat :\u003d (undefined)\nprivate  cardNum:nat :\u003d (undefined)\nprivate  pin:nat :\u003d (undefined)\nprivate  m:Main :\u003d (undefined)\npublic  User(nat, nat, nat, Main) (nat * nat * nat * Main \u003d\u003d\u003e User)\n\tUser(nat, nat, nat, Main)(nt, nc, np, nm) \u003d\u003d\n(\n\ntillNum :\u003d nt;\ncardNum :\u003d nc;\npin :\u003d np;\nm :\u003d nm\n)\nprivate  Test1() (() \u003d\u003d\u003e ())\n\tTest1()() \u003d\u003d\n(\n\nm.EnterCardAtTill(tillNum, cardNum, pin);\nm.GetBalanceAtTill(tillNum);\nm.WithdrawalAtTill(tillNum, 100);\nm.GetBalanceAtTill(tillNum);\nm.ReturnCard(tillNum)\n)\nprotected  thread Test1()\nend User\n"]