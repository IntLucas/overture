["class DoSort is subclass of [Sorter]\npublic  Sort(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tSort(seq of (int))(l) \u003d\u003d\nreturn (DoSorting(l))\nprivate static  private static DoSorting: (seq of (int) -\u003e seq of (int))\n\tDoSorting(l) \u003d\u003d\n(if (l \u003d [])\nthen []\nelse let sorted:seq of (int) \u003d DoSorting((tl l)) in InsertSorted((hd l), sorted))\nprivate static  private static InsertSorted: (int * seq of (int) -\u003e seq of (int))\n\tInsertSorted(i, l) \u003d\u003d\n(cases true :\n((l \u003d [])) -\u003e [i],\n((i \u003c\u003d (hd l))) -\u003e ([i] ^ l)\nothers ([(hd l)] ^ InsertSorted(i, (tl l)))\n end)\nprivate static  private static Len: (seq of (int) -\u003e nat)\n\tLen(list) \u003d\u003d\n(len list)\nprivate static  private static Len: (int * seq of (int) -\u003e nat)\n\tLen(-, list) \u003d\u003d\n(len list)\nend DoSort\n","class ExplSort is subclass of [Sorter]\npublic  Sort(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tSort(seq of (int))(l) \u003d\u003d\nlet r in set Permutations(l) be st IsOrdered(r) in return (r)\nprivate static  private static Permutations: (seq of (int) -\u003e set of (seq of (int)))\n\tPermutations(l) \u003d\u003d\n(cases l :\n[] -\u003e {l},\n[-] -\u003e {l}\nothers (dunion {{([l(i)] ^ j) | j in set Permutations(RestSeq(l, i))} | i in set (inds l)})\n end)\nprivate static  private static RestSeq: (seq of (int) * nat -\u003e seq of (int))\n\tRestSeq(l, i) \u003d\u003d\n[l(j) | j in set ((inds l) \\ {i})]\n\tpre (i in set (inds l))\n\tpost (((elems RESULT) subset (elems l)) and ((len RESULT) \u003d ((len l) - 1)))\nprivate static  private static IsOrdered: (seq of (int) -\u003e bool)\n\tIsOrdered(l) \u003d\u003d\n(forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (l(i) \u003e\u003d l(j))))\nprivate static  private static Len: (seq of (int) -\u003e nat)\n\tLen(list) \u003d\u003d\n(len list)\nend ExplSort\n","class ImplSort is subclass of [Sorter]\npublic  Sort(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tSort(seq of (int))(l) \u003d\u003d\nreturn (ImplSorter(l))\npublic static  public static  ImplSorter((l:seq of (int)))r:seq of (int)\n\tpost (IsPermutation(r, l) and IsOrdered(r))\nprivate static  private static IsPermutation: (seq of (int) * seq of (int) -\u003e bool)\n\tIsPermutation(l1, l2) \u003d\u003d\n(forall e in set ((elems l1) union (elems l2)) \u0026 ((card {i | i in set (inds l1) \u0026 (l1(i) \u003d e)}) \u003d (card {i | i in set (inds l2) \u0026 (l2(i) \u003d e)})))\nprivate static  private static IsOrdered: (seq of (int) -\u003e bool)\n\tIsOrdered(l) \u003d\u003d\n(forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (l(i) \u003e\u003d l(j))))\nend ImplSort\n","class MergeSort is subclass of [Sorter]\npublic  Sort(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tSort(seq of (int))(l) \u003d\u003d\nreturn (MergeSorter(l))\nprivate static  private static MergeSorter: (seq of (real) -\u003e seq of (real))\n\tMergeSorter(l) \u003d\u003d\n(cases l :\n[] -\u003e l,\n[e] -\u003e l\nothers let l1 ^ l2 in set {l} be st ((abs ((len l1) - (len l2))) \u003c 2) in let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in Merge(l_l, l_r)\n end)\nprivate static  private static Len: (seq of (real) -\u003e nat)\n\tLen(list) \u003d\u003d\n(len list)\nprivate static  private static Merge: (seq of (int) * seq of (int) -\u003e seq of (int))\n\tMerge(l1, l2) \u003d\u003d\n(cases mk_(l1, l2) :\nmk_([], l) -\u003e l,\nmk_(l, []) -\u003e l\nothers (if ((hd l1) \u003c\u003d (hd l2))\nthen ([(hd l1)] ^ Merge((tl l1), l2))\nelse ([(hd l2)] ^ Merge(l1, (tl l2))))\n end)\n\tpre (forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0))))\nprivate static  private static Len: (seq of (int) * seq of (int) -\u003e nat)\n\tLen(list1, list2) \u003d\u003d\n((len list1) + (len list2))\nend MergeSort\n","class Sorter\npublic  Sort(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tSort(seq of (int))(arg) \u003d\u003d\nis subclass responsibility\nend Sorter\n","class SortMachine\nprivate  srt:Sorter :\u003d new MergeSort()\npublic  SetSort(Sorter) (Sorter \u003d\u003d\u003e ())\n\tSetSort(Sorter)(s) \u003d\u003d\nsrt :\u003d s\npublic  GoSorting(seq of (int)) (seq of (int) \u003d\u003d\u003e seq of (int))\n\tGoSorting(seq of (int))(arr) \u003d\u003d\nreturn ((srt.Sort)(arr))\npublic  SetAndSort(Sorter, seq of (int)) (Sorter * seq of (int) \u003d\u003d\u003e seq of (int))\n\tSetAndSort(Sorter, seq of (int))(s, arr) \u003d\u003d\n(\n\nsrt :\u003d s;\nreturn ((srt.Sort)(arr))\n)\npublic  [DiffSorting][[srt in set {new DoSort(), new ExplSort(), new ImplSort(), new MergeSort()}ALetBeStBindingTraceDefinitionSetAndSort(srt, [3, 1, 66, 11, 5, 3, 99]){1,1}def srt in set {new DoSort(), new ExplSort(), new ImplSort(), new MergeSort()}]]\nend SortMachine\n"]