["class Accelerometer is subclass of [GLOBAL]\npublic  stimulate(ActivityData) (ActivityData \u003d\u003d\u003e ())\n\tstimulate(ActivityData)(a) \u003d\u003d\nPacemaker`rateController.stimulate(a)\nend Accelerometer\n","class BaseThread\nprotected  period:nat1 :\u003d 1\nprotected  isPeriodic:bool :\u003d true\nprotected  BaseThread() (() \u003d\u003d\u003e BaseThread)\n\tBaseThread()() \u003d\u003d\n(\n\nWorld`timerRef.RegisterThread(self);\nif (not (World`timerRef.IsInitialising)())\nthen\nstart (self)\n)\npublic  SetPeriod(nat1) (nat1 \u003d\u003d\u003e ())\n\tSetPeriod(nat1)(p) \u003d\u003d\nperiod :\u003d p\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nis subclass responsibility\nprotected  thread (\n\nif isPeriodic\nthen\n(\n\nwhile true do (\n\nStep();\nWorld`timerRef.WaitRelative(period)\n)\n)else\n(\n\nStep();\nWorld`timerRef.WaitRelative(0);\nWorld`timerRef.UnRegisterThread()\n)\n)\nend BaseThread\n","class Environment is subclass of [GLOBAL, BaseThread]\npublic static  InputTP \u003d InputTP\n\tinv inp \u003d\u003d (forall line in set (elems (inp.#2)) \u0026 ((inp.#1) \u003e\u003d (line.#4)))\npublic static  Inpline \u003d Inpline\npublic static  Outline \u003d Outline\nprivate  io:IO :\u003d new IO()\nprivate  inplines:seq of (Inpline) :\u003d []\nprivate  outlines:seq of (Outline) :\u003d []\nprivate  busy:bool :\u003d true\nprivate  simtime:Time :\u003d (undefined)\nprivate  leads:map (Chamber) to (Lead) :\u003d {|-\u003e}\nprivate  accelerometer:Accelerometer :\u003d (undefined)\npublic  Environment(seq of (char), nat1, bool) (seq of (char) * nat1 * bool \u003d\u003d\u003e Environment)\n\tEnvironment(seq of (char), nat1, bool)(fname, p, isP) \u003d\u003d\nlet mk_(-, mk_(timeval, input)) \u003d ((io.freadval))[InputTP](fname) in (\n\ninplines :\u003d input;\nsimtime :\u003d timeval;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  addLeadSensor(Lead) (Lead \u003d\u003d\u003e ())\n\taddLeadSensor(Lead)(lsens) \u003d\u003d\nleads :\u003d (leads ++ {(lsens.getChamber)() |-\u003e lsens})\npublic  addAccelerometer(Accelerometer) (Accelerometer \u003d\u003d\u003e ())\n\taddAccelerometer(Accelerometer)(acc) \u003d\u003d\naccelerometer :\u003d acc\nprivate  createSignal() (() \u003d\u003d\u003e ())\n\tcreateSignal()() \u003d\u003d\n(\n\nif ((len inplines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d (World`timerRef.GetTime)()\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(sensed, chamber, accinfo, stime):Inpline \u003d (hd inplines) in if (stime \u003c\u003d curtime)\nthen\n(\n\nleads(chamber).stimulate(sensed);\naccelerometer.stimulate(accinfo);\ninplines :\u003d (tl inplines);\ndone :\u003d ((len inplines) \u003d 0)\n)else\ndone :\u003d true\n);\nif ((len inplines) \u003d 0)\nthen\nbusy :\u003d false\n)\npublic  handleEvent(Pulse, Chamber, Time) (Pulse * Chamber * Time \u003d\u003d\u003e ())\n\thandleEvent(Pulse, Chamber, Time)(p, c, t) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(p, c, t)])\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (Outline)](outlines) in skip\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif busy\nthen\ncreateSignal();\nif ((World`timerRef.GetTime)() \u003e\u003d simtime)\nthen\n(\n\nPacemaker`heartController.finish();\nPacemaker`rateController.finish()\n)\n)\nprivate  mutex(handleEvent, showResult)\nprivate  per isFinished \u003d\u003e (not busy)\nend Environment\n","class GLOBAL\npublic static  Sense \u003d Sense\npublic static  Chamber \u003d Chamber\npublic static  ActivityData \u003d ActivityData\n\tinv a \u003d\u003d (a \u003c\u003d 7)\npublic static  Pulse \u003d Pulse\npublic static  Mode \u003d Mode\npublic static  PPM \u003d PPM\n\tinv ppm \u003d\u003d ((ppm \u003e\u003d 30) and (ppm \u003c\u003d 175))\npublic static  Time \u003d Time\nend GLOBAL\n","class HeartController is subclass of [GLOBAL, BaseThread]\nprivate  leads:map (Chamber) to (Lead) :\u003d (undefined)\nprivate  sensed:map (Chamber) to (Sense) :\u003d (undefined)\nprivate  mode:Mode :\u003d (undefined)\nprivate  finished:bool :\u003d (undefined)\nprivate  FixedAV:Time :\u003d (undefined)\nprivate  lastpulse:Time :\u003d (undefined)\nprivate  ARP:Time :\u003d (undefined)\nprivate  interval:Time :\u003d (undefined)\npublic  HeartController(nat1, bool) (nat1 * bool \u003d\u003d\u003e HeartController)\n\tHeartController(nat1, bool)(p, isP) \u003d\u003d\n(\n\nleads :\u003d {|-\u003e};\nsensed :\u003d {|-\u003e};\nmode :\u003d \u003cDOO\u003e;\nfinished :\u003d false;\nFixedAV :\u003d 150;\nlastpulse :\u003d 0;\nARP :\u003d 250;\ninterval :\u003d (Pacemaker`rateController.getInterval)();\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  addLeadPacer(Lead) (Lead \u003d\u003d\u003e ())\n\taddLeadPacer(Lead)(lead) \u003d\u003d\nleads :\u003d (leads ++ {(lead.getChamber)() |-\u003e lead})\npublic  pace() (() \u003d\u003d\u003e ())\n\tpace()() \u003d\u003d\n(\n\ncases mode :\n  \u003cAOO\u003e -\u003e PaceAOO()  \u003cAAT\u003e -\u003e PaceAAT()  \u003cDOO\u003e -\u003e PaceDOO()  \u003cOFF\u003e -\u003e skip  others -\u003e error end;\nsensed :\u003d {|-\u003e}\n)\nprivate  PaceAOO() (() \u003d\u003d\u003e ())\n\tPaceAOO()() \u003d\u003d\nlet curTime:Time \u003d (World`timerRef.GetTime)() in if ((interval + lastpulse) \u003c\u003d curTime)\nthen\n(\n\nlastpulse :\u003d curTime;\nleads(\u003cATRIA\u003e).addLeadPace(\u003cPULSE\u003e, curTime)\n)else\nskip\nprivate  PaceAAT() (() \u003d\u003d\u003e ())\n\tPaceAAT()() \u003d\u003d\nlet curTime:Time \u003d (World`timerRef.GetTime)() in if ((\u003cATRIA\u003e in set (dom sensed)) and (sensed(\u003cATRIA\u003e) \u003d \u003cPULSE\u003e))\nthen\nif ((curTime - lastpulse) \u003c\u003d ARP)\nthen\nskipelse\n(\n\nlastpulse :\u003d curTime;\nleads(\u003cATRIA\u003e).addLeadPace(\u003cTRI_PULSE\u003e, curTime)\n)elseif ((interval + lastpulse) \u003c\u003d curTime)\nthen\n(\n\nlastpulse :\u003d curTime;\nleads(\u003cATRIA\u003e).addLeadPace(\u003cPULSE\u003e, curTime)\n)else\nskip\nprivate  PaceDOO() (() \u003d\u003d\u003e ())\n\tPaceDOO()() \u003d\u003d\nlet curTime:Time \u003d (World`timerRef.GetTime)() in (\n\nif ((interval + lastpulse) \u003c\u003d curTime)\nthen\n(\n\nlastpulse :\u003d curTime;\nleads(\u003cATRIA\u003e).addLeadPace(\u003cPULSE\u003e, curTime);\nleads(\u003cVENTRICLE\u003e).addLeadPace(\u003cPULSE\u003e, (FixedAV + curTime))\n)else\nskip\n)\npublic  finish() (() \u003d\u003d\u003e ())\n\tfinish()() \u003d\u003d\nfinished :\u003d true\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nfor all lead in set (rng leads) do\nlead.isFinished()\npublic  sensorNotify(Sense, Chamber) (Sense * Chamber \u003d\u003d\u003e ())\n\tsensorNotify(Sense, Chamber)(s, c) \u003d\u003d\n(\n\nsensed :\u003d (sensed ++ {c |-\u003e s})\n)\npublic  setInterval(Time) (Time \u003d\u003d\u003e ())\n\tsetInterval(Time)(t) \u003d\u003d\ninterval :\u003d t\npublic  setMode(Mode) (Mode \u003d\u003d\u003e ())\n\tsetMode(Mode)(m) \u003d\u003d\n(\n\nmode :\u003d m\n)\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\npace()\nprivate  per isFinished \u003d\u003e ((sensed \u003d {|-\u003e}) and finished)\nprivate  mutex(sensorNotify, pace)\nend HeartController\n","class Lead is subclass of [GLOBAL, BaseThread]\nprivate  chamber:Chamber :\u003d (undefined)\nprivate  scheduledPulse:[(Time * Pulse)] :\u003d (undefined)\npublic  Lead(Chamber, nat1, bool) (Chamber * nat1 * bool \u003d\u003d\u003e Lead)\n\tLead(Chamber, nat1, bool)(chm, p, isP) \u003d\u003d\n(\n\nchamber :\u003d chm;\nscheduledPulse :\u003d nil;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  getChamber() (() \u003d\u003d\u003e Chamber)\n\tgetChamber()() \u003d\u003d\nreturn (chamber)\npublic  stimulate(Sense) (Sense \u003d\u003d\u003e ())\n\tstimulate(Sense)(s) \u003d\u003d\nPacemaker`heartController.sensorNotify(s, chamber)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  addLeadPace(Pulse, Time) (Pulse * Time \u003d\u003d\u003e ())\n\taddLeadPace(Pulse, Time)(p, t) \u003d\u003d\nif (t \u003c\u003d (World`timerRef.GetTime)())\nthen\ndischargePulse(p)else\n(\n\nscheduledPulse :\u003d mk_(t, p);\nreturn\n)\nprivate  followPlan() (() \u003d\u003d\u003e ())\n\tfollowPlan()() \u003d\u003d\n(\ncurTime:Time :\u003d (World`timerRef.GetTime)()\n\nif (scheduledPulse \u003c\u003e nil)\nthen\nif (curTime \u003e\u003d (scheduledPulse.#1))\nthen\n(\n\ndischargePulse((scheduledPulse.#2));\nscheduledPulse :\u003d nil\n)\n)\nprivate  dischargePulse(Pulse) (Pulse \u003d\u003d\u003e ())\n\tdischargePulse(Pulse)(p) \u003d\u003d\nWorld`env.handleEvent(p, chamber, (World`timerRef.GetTime)())\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (scheduledPulse \u003c\u003e nil)\nthen\nfollowPlan()\n)\nprivate  per isFinished \u003d\u003e (scheduledPulse \u003d nil)\nprivate  mutex(Step)\nprivate  mutex(addLeadPace)\nprivate  mutex(dischargePulse)\nend Lead\n","class Pacemaker\npublic static  atriaLead:Lead :\u003d new Lead(\u003cATRIA\u003e, 5, true)\npublic static  ventricleLead:Lead :\u003d new Lead(\u003cVENTRICLE\u003e, 5, true)\npublic static  accelerometer:Accelerometer :\u003d new Accelerometer()\npublic static  rateController:RateController :\u003d new RateController(1, true)\npublic static  heartController:HeartController :\u003d new HeartController(1000, true)\nend Pacemaker\n","class RateController is subclass of [GLOBAL, BaseThread]\nprivate  rateplan:map (Time) to (Time) :\u003d (undefined)\nprivate  sensed:[ActivityData] :\u003d (undefined)\nprivate  interval:Time :\u003d (undefined)\nprivate  finished:bool :\u003d (undefined)\nprivate  LRL:PPM :\u003d (undefined)\nprivate  MSR:PPM :\u003d (undefined)\nprivate  threshold:nat1 :\u003d (undefined)\nprivate  reactionT:Time :\u003d (undefined)\nprivate  recoveryT:Time :\u003d (undefined)\nprivate  responseF:nat1 :\u003d (undefined)\nprivate  inv((threshold \u003c 8) and ((reactionT in set {10, ... ,50}) and ((recoveryT in set {2, ... ,16}) and (responseF \u003c\u003d 16))))\npublic  RateController(nat1, bool) (nat1 * bool \u003d\u003d\u003e RateController)\n\tRateController(nat1, bool)(p, isP) \u003d\u003d\n(\n\nLRL :\u003d 60;\nMSR :\u003d 120;\nthreshold :\u003d MED;\nreactionT :\u003d 10;\nrecoveryT :\u003d 2;\nresponseF :\u003d 8;\nsensed :\u003d nil;\ninterval :\u003d (1 / ((LRL / 60) / 1000));\nfinished :\u003d false;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  getInterval() (() \u003d\u003d\u003e Time)\n\tgetInterval()() \u003d\u003d\nreturn (interval)\nprivate  controlRate() (() \u003d\u003d\u003e ())\n\tcontrolRate()() \u003d\u003d\n(\n\nif (sensed \u003e threshold)\nthen\nincreaseRate()elseif (sensed \u003c threshold)\nthen\ndecreaseRate()else\nskip;\nsensed :\u003d nil\n)\npublic  stimulate(ActivityData) (ActivityData \u003d\u003d\u003e ())\n\tstimulate(ActivityData)(ad) \u003d\u003d\nsensed :\u003d ad\nprivate  increaseRate() (() \u003d\u003d\u003e ())\n\tincreaseRate()() \u003d\u003d\n(\n\ninterval :\u003d (1 / ((MSR / 60) / 1000));\nPacemaker`heartController.SetPeriod(interval)\n)\nprivate  decreaseRate() (() \u003d\u003d\u003e ())\n\tdecreaseRate()() \u003d\u003d\n(\n\ninterval :\u003d (1 / ((LRL / 60) / 1000));\nPacemaker`heartController.setInterval(interval)\n)\npublic  finish() (() \u003d\u003d\u003e ())\n\tfinish()() \u003d\u003d\nfinished :\u003d true\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nif (sensed \u003c\u003e nil)\nthen\ncontrolRate()\nprivate  mutex(stimulate)\nprivate  mutex(increaseRate, decreaseRate, getInterval)\nprivate  per isFinished \u003d\u003e finished\nprivate  mutex(Step)\nprivate static  MED:ActivityData \u003d 4\nend RateController\n","class TimeStamp\npublic static  stepLength:nat \u003d 1\nprivate  currentTime:nat :\u003d 0\nprivate  wakeUpMap:map (nat) to ([nat]) :\u003d {|-\u003e}\nprivate  barrierCount:nat :\u003d 0\nprivate  registeredThreads:set of (BaseThread) :\u003d {}\nprivate  isInitialising:bool :\u003d true\npublic  TimeStamp(nat) (nat \u003d\u003d\u003e TimeStamp)\n\tTimeStamp(nat)(count) \u003d\u003d\nbarrierCount :\u003d count\npublic  RegisterThread(BaseThread) (BaseThread \u003d\u003d\u003e ())\n\tRegisterThread(BaseThread)(t) \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount + 1);\nregisteredThreads :\u003d (registeredThreads union {t})\n)\npublic  UnRegisterThread() (() \u003d\u003d\u003e ())\n\tUnRegisterThread()() \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount - 1)\n)\npublic  IsInitialising() (() \u003d\u003d\u003e bool)\n\tIsInitialising()() \u003d\u003d\nreturn (isInitialising)\npublic  DoneInitialising() (() \u003d\u003d\u003e ())\n\tDoneInitialising()() \u003d\u003d\n(\n\nif isInitialising\nthen\n(\n\nisInitialising :\u003d false;\nfor all t in set registeredThreads do\nstart (t)\n)\n)\npublic  WaitRelative(nat) (nat \u003d\u003d\u003e ())\n\tWaitRelative(nat)(val) \u003d\u003d\n(\n\nWaitAbsolute((currentTime + val))\n)\npublic  WaitAbsolute(nat) (nat \u003d\u003d\u003e ())\n\tWaitAbsolute(nat)(val) \u003d\u003d\n(\n\nAddToWakeUpMap(threadid, val);\nBarrierReached();\nAwake()\n)\nprivate  BarrierReached() (() \u003d\u003d\u003e ())\n\tBarrierReached()() \u003d\u003d\n(\n\nwhile ((card (dom wakeUpMap)) \u003d barrierCount) do (\n\ncurrentTime :\u003d (currentTime + stepLength);\nlet threadSet:set of (nat) \u003d {th | th in set (dom wakeUpMap) \u0026 ((wakeUpMap(th) \u003c\u003e nil) and (wakeUpMap(th) \u003c\u003d currentTime))} in for all t in set threadSet do\nwakeUpMap :\u003d ({t} \u003c-: wakeUpMap)\n)\n)\n\tpost (forall x in set (rng wakeUpMap) \u0026 ((x \u003d nil) or (x \u003e\u003d currentTime)))\nprivate  AddToWakeUpMap(nat, [nat]) (nat * [nat] \u003d\u003d\u003e ())\n\tAddToWakeUpMap(nat, [nat])(tId, val) \u003d\u003d\nwakeUpMap :\u003d (wakeUpMap ++ {tId |-\u003e val})\npublic  NotifyThread(nat) (nat \u003d\u003d\u003e ())\n\tNotifyThread(nat)(tId) \u003d\u003d\nwakeUpMap :\u003d ({tId} \u003c-: wakeUpMap)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nprivate  Awake() (() \u003d\u003d\u003e ())\n\tAwake()() \u003d\u003d\nskip\npublic  ThreadDone() (() \u003d\u003d\u003e ())\n\tThreadDone()() \u003d\u003d\nAddToWakeUpMap(threadid, nil)\nprivate  per Awake \u003d\u003e (threadid not in set (dom wakeUpMap))\nprivate  mutex(IsInitialising)\nprivate  mutex(DoneInitialising)\nprivate  mutex(AddToWakeUpMap)\nprivate  mutex(NotifyThread)\nprivate  mutex(BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread)\nprivate  mutex(AddToWakeUpMap, BarrierReached)\nprivate  mutex(NotifyThread, BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread, BarrierReached)\nend TimeStamp\n","class World is subclass of [GLOBAL]\npublic static  env:[Environment] :\u003d nil\npublic static  timerRef:TimeStamp :\u003d new TimeStamp(0)\npublic  World(seq of (char), Mode) (seq of (char) * Mode \u003d\u003d\u003e World)\n\tWorld(seq of (char), Mode)(filename, mode) \u003d\u003d\n(\n\nenv :\u003d new Environment(filename, 1, true);\nenv.addLeadSensor(Pacemaker`atriaLead);\nenv.addLeadSensor(Pacemaker`ventricleLead);\nenv.addAccelerometer(Pacemaker`accelerometer);\nPacemaker`heartController.addLeadPacer(Pacemaker`atriaLead);\nPacemaker`heartController.addLeadPacer(Pacemaker`ventricleLead);\nPacemaker`heartController.setMode(mode)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\ntimerRef.DoneInitialising();\nenv.isFinished();\nPacemaker`heartController.isFinished();\nenv.showResult()\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]