["GENERATE:nat1 \u003d 3","SURVIVE:set of (nat1) \u003d {2, 3}","Point \u003d Point","Population \u003d Population","private static around: (Point -\u003e set of (Point))\n\taround(p) \u003d\u003d\n{mk_Point(((p.x) + x), ((p.y) + y)) | x, y in set {-1, 0, (+ 1)} \u0026 ((x \u003c\u003e 0) or (y \u003c\u003e 0))}\n\tpost ((card RESULT) \u003c 9)","private static neighbourCount: (Population * Point -\u003e nat)\n\tneighbourCount(pop, p) \u003d\u003d\n(card {q | q in set around(p) \u0026 (q in set pop)})\n\tpost (RESULT \u003c 9)","private static newCells: (Population -\u003e set of (Point))\n\tnewCells(pop) \u003d\u003d\n(dunion {{q | q in set around(p) \u0026 ((q not in set pop) and (neighbourCount(pop, q) \u003d GENERATE))} | p in set pop})\n\tpost ((RESULT inter pop) \u003d {})","private static deadCells: (Population -\u003e set of (Point))\n\tdeadCells(pop) \u003d\u003d\n{p | p in set pop \u0026 (neighbourCount(pop, p) not in set SURVIVE)}\n\tpost ((RESULT inter pop) \u003d RESULT)","private static generation: (Population -\u003e Population)\n\tgeneration(pop) \u003d\u003d\n((pop \\ deadCells(pop)) union newCells(pop))","private static generations: (nat1 * Population -\u003e seq of (Population))\n\tgenerations(n, pop) \u003d\u003d\nlet new_p:Population \u003d generation(pop) in (if (n \u003d 1)\nthen [new_p]\nelse ([new_p] ^ generations((n - 1), new_p)))","private static measureGenerations: (nat1 * Population -\u003e nat)\n\tmeasureGenerations(n, -) \u003d\u003d\nn","private static offset: (Population * int * int -\u003e Population)\n\toffset(pop, dx, dy) \u003d\u003d\n{mk_Point((x + dx), (y + dy)) | mk_Point(x, y) in set pop}","private static isOffset: (Population * Population * nat1 -\u003e bool)\n\tisOffset(pop1, pop2, max) \u003d\u003d\n(exists dx, dy in set {-max, ... ,max} \u0026 (((dx \u003c\u003e 0) or (dy \u003c\u003e 0)) and (offset(pop1, dx, dy) \u003d pop2)))","private static periodN: (Population * nat1 -\u003e bool)\n\tperiodN(pop, n) \u003d\u003d\n((generation ** n)(pop) \u003d pop)","private static disappearN: (Population * nat1 -\u003e bool)\n\tdisappearN(pop, n) \u003d\u003d\n((generation ** n)(pop) \u003d {})","private static gliderN: (Population * nat1 * nat1 -\u003e bool)\n\tgliderN(pop, n, max) \u003d\u003d\nisOffset(pop, (generation ** n)(pop), max)","private static periodNP: (Population * nat1 -\u003e bool)\n\tperiodNP(pop, n) \u003d\u003d\n({a | a in set {1, ... ,n} \u0026 periodN(pop, a)} \u003d {n})","private static disappearNP: (Population * nat1 -\u003e bool)\n\tdisappearNP(pop, n) \u003d\u003d\n({a | a in set {1, ... ,n} \u0026 disappearN(pop, a)} \u003d {n})","private static gliderNP: (Population * nat1 * nat1 -\u003e bool)\n\tgliderNP(pop, n, max) \u003d\u003d\n({a | a in set {1, ... ,n} \u0026 gliderN(pop, a, max)} \u003d {n})","BLOCK:set of (Point) \u003d {mk_Point(0, 0), mk_Point(-1, 0), mk_Point(0, -1), mk_Point(-1, -1)}","BLINKER:set of (Point) \u003d {mk_Point(-1, 0), mk_Point(0, 0), mk_Point(1, 0)}","TOAD:set of (Point) \u003d (BLINKER union {mk_Point(0, -1), mk_Point(-1, -1), mk_Point(-2, -1)})","BEACON:set of (Point) \u003d {mk_Point(-2, 0), mk_Point(-2, 1), mk_Point(-1, 1), mk_Point(0, -2), mk_Point(1, -2), mk_Point(1, -1)}","PULSAR:set of (Point) \u003d let quadrant:set of (Point) \u003d {mk_Point(2, 1), mk_Point(3, 1), mk_Point(3, 2), mk_Point(1, 2), mk_Point(1, 3), mk_Point(2, 3), mk_Point(5, 2), mk_Point(5, 3), mk_Point(6, 3), mk_Point(7, 3), mk_Point(2, 5), mk_Point(3, 5), mk_Point(3, 6), mk_Point(3, 7)} in (((quadrant union {mk_Point(-x, y) | mk_Point(x, y) in set quadrant}) union {mk_Point(x, -y) | mk_Point(x, y) in set quadrant}) union {mk_Point(-x, -y) | mk_Point(x, y) in set quadrant})","DIEHARD:set of (Point) \u003d {mk_Point(0, 1), mk_Point(1, 1), mk_Point(1, 0), mk_Point(0, 5), mk_Point(0, 6), mk_Point(0, 7), mk_Point(2, 6)}","GLIDER:set of (Point) \u003d {mk_Point(1, 0), mk_Point(2, 0), mk_Point(3, 0), mk_Point(3, 1), mk_Point(2, 2)}","GOSPER_GLIDER_GUN:set of (Point) \u003d {mk_Point(2, 0), mk_Point(2, 1), mk_Point(2, 2), mk_Point(3, 0), mk_Point(3, 1), mk_Point(3, 2), mk_Point(4, -1), mk_Point(4, 3), mk_Point(6, -2), mk_Point(6, -1), mk_Point(6, 3), mk_Point(6, 4), mk_Point(16, 1), mk_Point(16, 2), mk_Point(17, 1), mk_Point(17, 2), mk_Point(-1, -1), mk_Point(-2, -2), mk_Point(-2, -1), mk_Point(-2, 0), mk_Point(-3, -3), mk_Point(-3, 1), mk_Point(-4, -1), mk_Point(-5, -4), mk_Point(-5, 2), mk_Point(-6, -4), mk_Point(-6, 2), mk_Point(-7, -3), mk_Point(-7, 1), mk_Point(-8, -2), mk_Point(-8, -1), mk_Point(-8, 0), mk_Point(-17, -1), mk_Point(-17, 0), mk_Point(-18, -1), mk_Point(-18, 0)}","private static tests: (() -\u003e seq of (bool))\n\ttests() \u003d\u003d\n[periodNP(BLOCK, 1), periodNP(BLINKER, 2), periodNP(TOAD, 2), periodNP(BEACON, 2), periodNP(PULSAR, 3), gliderNP(GLIDER, 4, 1), disappearNP(DIEHARD, 130)]","Configuration \u003d Configuration","private static generations_animate: (nat1 * Configuration -\u003e seq of (Population))\n\tgenerations_animate(n, conf) \u003d\u003d\nlet -:int \u003d initialise((conf.gridSide), (conf.sleepTime)) in let patterns:seq of (Population) \u003d Conway`generations(n, (conf.pop)) in animate_step(patterns)","private static animate_step: (seq of (Population) -\u003e seq of (Population))\n\tanimate_step(pop) \u003d\u003d\n(if (pop \u003d [])\nthen []\nelse let -:set of (int) \u003d {newLivingCell((cell.x), (cell.y)) | cell in set (hd pop)} in let -:int \u003d newRound() in animate_step((tl pop)))","private static measure_animate_step: (seq of (Population) -\u003e nat)\n\tmeasure_animate_step(list) \u003d\u003d\n(len list)","private static initialise: (nat1 * nat1 -\u003e int)\n\tinitialise(gridSideCount, sleepTime) \u003d\u003d\nis not yet specified","private static newLivingCell: (int * int -\u003e int)\n\tnewLivingCell(x, y) \u003d\u003d\nis not yet specified","private static newRound: (() -\u003e int)\n\tnewRound() \u003d\u003d\nis not yet specified","BLOCK:Configuration \u003d mk_Configuration(4, 500, Conway`BLOCK)","BLINKER:Configuration \u003d mk_Configuration(5, 500, Conway`BLINKER)","TOAD:Configuration \u003d mk_Configuration(6, 500, Conway`TOAD)","BEACON:Configuration \u003d mk_Configuration(8, 500, Conway`BEACON)","PULSAR:Configuration \u003d mk_Configuration(17, 1000, Conway`PULSAR)","DIEHARD:Configuration \u003d mk_Configuration(33, 300, Conway`DIEHARD)","GLIDER:Configuration \u003d mk_Configuration(40, 100, Conway`GLIDER)","GOSPER_GLIDER_GUN:Configuration \u003d mk_Configuration(40, 50, Conway`GOSPER_GLIDER_GUN)"]