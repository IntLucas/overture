["ADDRESS \u003d ADDRESS","NIL:ADDRESS \u003d 0","Nodes_Data \u003d Nodes_Data","Nodes_SingleLink \u003d Nodes_SingleLink","Nodes_DoubleLink \u003d Nodes_DoubleLink","Nodes_BinaryTree \u003d Nodes_BinaryTree","Nodes_Node \u003d Nodes_Node","Nodes_NodePtr \u003d Nodes_NodePtr","private Nodes_MkSingleLink: (Nodes_Data * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_MkSingleLink(data, ptr) \u003d\u003d\nmk_Nodes_SingleLink(data, ptr)","private Nodes_MkDoubleLink: (Nodes_Data * Nodes_NodePtr * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_MkDoubleLink(data, next, prev) \u003d\u003d\nmk_Nodes_DoubleLink(data, next, prev)","private Nodes_MkBinaryTree: (Nodes_Data * Nodes_NodePtr * Nodes_NodePtr * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_MkBinaryTree(data, right, left, parent) \u003d\u003d\nmk_Nodes_BinaryTree(data, right, left, parent)","private Nodes_GetData: (Nodes_Node -\u003e Nodes_Data)\n\tNodes_GetData(node) \u003d\u003d\n(if is_(node, Nodes_SingleLink)\nthen let mk_Nodes_SingleLink(data, -):Nodes_SingleLink \u003d node in data\nelseif is_(node, Nodes_DoubleLink)\nthen let mk_Nodes_DoubleLink(data, -, -):Nodes_DoubleLink \u003d node in data\nelse let mk_Nodes_BinaryTree(data, -, -, -):Nodes_Node \u003d node in data)\n\tpre (is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree)))","private Nodes_SetData: (Nodes_Node * Nodes_Data -\u003e Nodes_Node)\n\tNodes_SetData(node, data) \u003d\u003d\n(if is_(node, Nodes_SingleLink)\nthen let mk_Nodes_SingleLink(-, next):Nodes_SingleLink \u003d node in mk_Nodes_SingleLink(data, next)\nelseif is_(node, Nodes_DoubleLink)\nthen let mk_Nodes_DoubleLink(-, next, prev):Nodes_DoubleLink \u003d node in mk_Nodes_DoubleLink(data, next, prev)\nelse let mk_Nodes_BinaryTree(-, right, left, parent):Nodes_Node \u003d node in mk_Nodes_BinaryTree(data, right, left, parent))\n\tpre (is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree)))","private Nodes_GetNext: (Nodes_Node -\u003e Nodes_NodePtr)\n\tNodes_GetNext(node) \u003d\u003d\n(if is_(node, Nodes_SingleLink)\nthen let mk_Nodes_SingleLink(-, next):Nodes_SingleLink \u003d node in next\nelse let mk_Nodes_DoubleLink(-, next, -):Nodes_Node \u003d node in next)\n\tpre (is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink))","private Nodes_SetNext: (Nodes_Node * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_SetNext(node, next) \u003d\u003d\n(if is_(node, Nodes_SingleLink)\nthen let mk_Nodes_SingleLink(data, -):Nodes_SingleLink \u003d node in mk_Nodes_SingleLink(data, next)\nelse let mk_Nodes_DoubleLink(data, -, prev):Nodes_Node \u003d node in mk_Nodes_DoubleLink(data, next, prev))\n\tpre (is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink))","private Nodes_GetPrev: (Nodes_Node -\u003e Nodes_NodePtr)\n\tNodes_GetPrev(node) \u003d\u003d\nlet mk_Nodes_DoubleLink(-, -, prev):Nodes_DoubleLink \u003d node in prev\n\tpre is_(node, Nodes_DoubleLink)","private Nodes_SetPrev: (Nodes_Node * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_SetPrev(node, prev) \u003d\u003d\nlet mk_Nodes_DoubleLink(data, next, -):Nodes_DoubleLink \u003d node in mk_Nodes_DoubleLink(data, next, prev)\n\tpre is_(node, Nodes_DoubleLink)","private Nodes_GetRight: (Nodes_Node -\u003e Nodes_NodePtr)\n\tNodes_GetRight(node) \u003d\u003d\nlet mk_Nodes_BinaryTree(-, right, -, -):Nodes_BinaryTree \u003d node in right\n\tpre is_(node, Nodes_BinaryTree)","private Nodes_SetRight: (Nodes_Node * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_SetRight(node, right) \u003d\u003d\nlet mk_Nodes_BinaryTree(data, -, left, parent):Nodes_BinaryTree \u003d node in mk_Nodes_BinaryTree(data, right, left, parent)\n\tpre is_(node, Nodes_BinaryTree)","private Nodes_GetLeft: (Nodes_Node -\u003e Nodes_NodePtr)\n\tNodes_GetLeft(node) \u003d\u003d\nlet mk_Nodes_BinaryTree(-, -, left, -):Nodes_BinaryTree \u003d node in left\n\tpre is_(node, Nodes_BinaryTree)","private Nodes_SetLeft: (Nodes_Node * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_SetLeft(node, left) \u003d\u003d\nlet mk_Nodes_BinaryTree(data, right, -, parent):Nodes_BinaryTree \u003d node in mk_Nodes_BinaryTree(data, right, left, parent)\n\tpre is_(node, Nodes_BinaryTree)","private Nodes_GetParent: (Nodes_Node -\u003e Nodes_NodePtr)\n\tNodes_GetParent(node) \u003d\u003d\nlet mk_Nodes_BinaryTree(-, -, -, parent):Nodes_BinaryTree \u003d node in parent\n\tpre is_(node, Nodes_BinaryTree)","private Nodes_SetParent: (Nodes_Node * Nodes_NodePtr -\u003e Nodes_Node)\n\tNodes_SetParent(node, parent) \u003d\u003d\nlet mk_Nodes_BinaryTree(data, right, left, -):Nodes_BinaryTree \u003d node in mk_Nodes_BinaryTree(data, right, left, parent)\n\tpre is_(node, Nodes_BinaryTree)","Heaps_Data \u003d Heaps_Data","Heaps_Size:nat1 \u003d 20","Heaps_Location \u003d Heaps_Location\n\tinv mk_Heaps_Location(d, a) \u003d\u003d ((a \u003d true) \u003c\u003d\u003e (d \u003c\u003e nil))","Heaps_Heap \u003d Heaps_Heap\n\tinv mk_Heaps_Heap(s) \u003d\u003d ((len s) \u003d Heaps_Size)","private Heaps_InitSequence: (nat1 -\u003e seq of (Heaps_Location))\n\tHeaps_InitSequence(length) \u003d\u003d\n(if (length \u003e 1)\nthen ([mk_Heaps_Location(nil, false)] ^ Heaps_InitSequence((length - 1)))\nelse [mk_Heaps_Location(nil, false)])","private Heaps_Init: (() -\u003e Heaps_Heap)\n\tHeaps_Init() \u003d\u003d\nmk_Heaps_Heap(Heaps_InitSequence(Heaps_Size))","private Heaps_AmountUsed: (Heaps_Heap -\u003e nat)\n\tHeaps_AmountUsed(heap) \u003d\u003d\nlet store:seq of (Heaps_Location) \u003d (heap.storage) in (len [store(i) | i in set (inds store) \u0026 ((store(i).allocated) \u003d true)])","private Heaps_Available: (Heaps_Heap -\u003e bool)\n\tHeaps_Available(heap) \u003d\u003d\n(Heaps_AmountUsed(heap) \u003c (len (heap.storage)))","private Heaps_ModifyLoc: (Heaps_Heap * ADDRESS * Heaps_Location -\u003e Heaps_Heap)\n\tHeaps_ModifyLoc(heap, address, location) \u003d\u003d\nmk_Heaps_Heap(((heap.storage) ++ {address |-\u003e location}))\n\tpre (address in set (inds (heap.storage)))","private Heaps_Modify: (Heaps_Heap * ADDRESS * Heaps_Data -\u003e Heaps_Heap)\n\tHeaps_Modify(heap, address, data) \u003d\u003d\nHeaps_ModifyLoc(heap, address, mk_Heaps_Location(data, true))\n\tpre let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) \u003d true))","private Heaps_Retrieve: (Heaps_Heap * ADDRESS -\u003e [Heaps_Data])\n\tHeaps_Retrieve(heap, address) \u003d\u003d\n((heap.storage)(address).data)\n\tpre let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) \u003d true))","private Heaps_UnallocatedAddresses: (Heaps_Heap -\u003e set of (ADDRESS))\n\tHeaps_UnallocatedAddresses(heap) \u003d\u003d\nlet store:seq of (Heaps_Location) \u003d (heap.storage) in {i | i in set (inds store) \u0026 ((store(i).allocated) \u003d false)}","private Heaps_UnallocatedAddress: (Heaps_Heap -\u003e ADDRESS)\n\tHeaps_UnallocatedAddress(heap) \u003d\u003d\n(iota new in set Heaps_UnallocatedAddresses(heap) \u0026 (forall i in set Heaps_UnallocatedAddresses(heap) \u0026 (new \u003c\u003d i)))\n\tpre Heaps_Available(heap)","NEW (Heaps_Data \u003d\u003d\u003e ADDRESS)\n\tNEW(data) \u003d\u003d\n(\n\nlet newAddress \u003d Heaps_UnallocatedAddress(heap) in let newLoc \u003d mk_Heaps_Location(data, true) in (\n\nheap :\u003d Heaps_ModifyLoc(heap, newAddress, newLoc);\nreturn (newAddress)\n)\n)\n\tpre Heaps_Available(heap)","DISPOSE (ADDRESS \u003d\u003d\u003e ())\n\tDISPOSE(address) \u003d\u003d\nheap :\u003d Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))\n\tpre pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))","SET_DATA (ADDRESS * Data \u003d\u003d\u003e ())\n\tSET_DATA(ptr, data) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetData(Heaps_Retrieve(heap, ptr), data))","SET_NEXT (ADDRESS * ADDRESS \u003d\u003d\u003e ())\n\tSET_NEXT(ptr, next) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetNext(Heaps_Retrieve(heap, ptr), next))","SET_LEFT (ADDRESS * ADDRESS \u003d\u003d\u003e ())\n\tSET_LEFT(ptr, left) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetLeft(Heaps_Retrieve(heap, ptr), left))","SET_RIGHT (ADDRESS * ADDRESS \u003d\u003d\u003e ())\n\tSET_RIGHT(ptr, right) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetRight(Heaps_Retrieve(heap, ptr), right))","SET_PREV (ADDRESS * ADDRESS \u003d\u003d\u003e ())\n\tSET_PREV(ptr, prev) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetPrev(Heaps_Retrieve(heap, ptr), prev))","SET_PARENT (ADDRESS * ADDRESS \u003d\u003d\u003e ())\n\tSET_PARENT(ptr, parent) \u003d\u003d\nheap :\u003d Heaps_Modify(heap, ptr, Nodes_SetParent(Heaps_Retrieve(heap, ptr), parent))","DATA (ADDRESS \u003d\u003d\u003e Data)\n\tDATA(ptr) \u003d\u003d\nreturn (Nodes_GetData(Heaps_Retrieve(heap, ptr)))","NEXT (ADDRESS \u003d\u003d\u003e ADDRESS)\n\tNEXT(ptr) \u003d\u003d\nreturn (Nodes_GetNext(Heaps_Retrieve(heap, ptr)))","LEFT (ADDRESS \u003d\u003d\u003e ADDRESS)\n\tLEFT(ptr) \u003d\u003d\nreturn (Nodes_GetLeft(Heaps_Retrieve(heap, ptr)))","RIGHT (ADDRESS \u003d\u003d\u003e ADDRESS)\n\tRIGHT(ptr) \u003d\u003d\nreturn (Nodes_GetRight(Heaps_Retrieve(heap, ptr)))","PARENT (ADDRESS \u003d\u003d\u003e ADDRESS)\n\tPARENT(ptr) \u003d\u003d\nreturn (Nodes_GetParent(Heaps_Retrieve(heap, ptr)))","SList_Data \u003d SList_Data","SList_List \u003d SList_List","private SList_IsEmpty: (SList_List -\u003e bool)\n\tSList_IsEmpty(list) \u003d\u003d\n(list \u003d NIL)","private SList_Seq: (Heaps_Heap * SList_List -\u003e seq of (SList_Data))\n\tSList_Seq(heap, list) \u003d\u003d\n(if (not SList_IsEmpty(list))\nthen let node:[Heaps_Data] \u003d Heaps_Retrieve(heap, list) in let data:Nodes_Data \u003d Nodes_GetData(node) in let tail:Nodes_NodePtr \u003d Nodes_GetNext(node) in ([data] ^ SList_Seq(heap, tail))\nelse [])","private SList_Lengthf: (Heaps_Heap * SList_List -\u003e nat)\n\tSList_Lengthf(heap, list) \u003d\u003d\n(if (not SList_IsEmpty(list))\nthen let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (1 + SList_Lengthf(heap, tail))\nelse 0)\n\tpost (RESULT \u003d (len SList_Seq(heap, list)))","private SList_PtrToNode: (Heaps_Heap * SList_List * nat1 -\u003e Nodes_NodePtr)\n\tSList_PtrToNode(heap, list, position) \u003d\u003d\nlet tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list)\n\tpre (position \u003c\u003d SList_Lengthf(heap, list))\n\tpost let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, RESULT)), listSeq:seq of (SList_Data) \u003d SList_Seq(heap, list) in (data \u003d listSeq(position))","private SList_Init: (() -\u003e SList_List)\n\tSList_Init() \u003d\u003d\nNIL","SList_InsertAtBeginning (SList_List * SList_Data \u003d\u003d\u003e SList_List)\n\tSList_InsertAtBeginning(list, data) \u003d\u003d\nreturn (NEW(Nodes_MkSingleLink(data, list)))\n\tpost (([data] ^ SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))","SList_InsertAfter (SList_List * Nodes_NodePtr * SList_Data \u003d\u003d\u003e SList_List)\n\tSList_InsertAfter(list, ptr, data) \u003d\u003d\n(\nnew:Nodes_NodePtr :\u003d NEW(Nodes_MkSingleLink(data, NEXT(ptr)))\n\nSET_NEXT(ptr, new);\nreturn (list)\n)\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) \u003d SList_Seq(heap, ptr))","SList_Insert (SList_List * SList_Data * nat1 \u003d\u003d\u003e SList_List)\n\tSList_Insert(list, data, position) \u003d\u003d\nif (position \u003d 1)\nthen\nreturn (SList_InsertAtBeginning(list, data))else\nreturn (SList_InsertAfter(list, SList_PtrToNode(heap, list, (position - 1)), data))\n\tpre ((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap))\n\tpost let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) and ((new(position) \u003d data) and ((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap))))","SList_Append (SList_List * SList_Data \u003d\u003d\u003e SList_List)\n\tSList_Append(list, data) \u003d\u003d\n(\nptr:Nodes_NodePtr :\u003d list\n\nif (ptr \u003d NIL)\nthen\nreturn (SList_InsertAtBeginning(list, data))else\n(\n\nwhile (NEXT(ptr) \u003c\u003e NIL) do ptr :\u003d NEXT(ptr);\nreturn (SList_InsertAfter(list, ptr, data))\n)\n)\n\tpre Heaps_Available(heap)\n\tpost (((SList_Seq(heap~, list) ^ [data]) \u003d SList_Seq(heap, RESULT)) and ((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)))","SList_Update (SList_List * SList_Data * nat1 \u003d\u003d\u003e SList_List)\n\tSList_Update(list, data, position) \u003d\u003d\n(\nptr:Nodes_NodePtr :\u003d SList_PtrToNode(heap, list, position)\n\nSET_DATA(ptr, data);\nreturn (list)\n)\n\tpre (position \u003c\u003d SList_Lengthf(heap, list))\n\tpost (((SList_Seq(heap~, list) ++ {position |-\u003e data}) \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d Heaps_AmountUsed(heap)))","SList_DeleteAtBeginning (SList_List \u003d\u003d\u003e SList_List)\n\tSList_DeleteAtBeginning(list) \u003d\u003d\n(\ntemp:Nodes_NodePtr :\u003d list\nnewlist:SList_List :\u003d NEXT(list)\n\nDISPOSE(temp);\nreturn (newlist)\n)\n\tpost ((tl SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))","SList_DeleteAfter (SList_List * Nodes_NodePtr \u003d\u003d\u003e SList_List)\n\tSList_DeleteAfter(list, ptr) \u003d\u003d\n(\ntemp:Nodes_NodePtr :\u003d (undefined)\n\ntemp :\u003d NEXT(ptr);\nSET_NEXT(ptr, NEXT(temp));\nDISPOSE(temp);\nreturn (list)\n)\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) \u003d SList_Seq(heap, ptr))","SList_Delete (SList_List * nat1 \u003d\u003d\u003e SList_List)\n\tSList_Delete(list, position) \u003d\u003d\n(\n\nif (position \u003d 1)\nthen\nreturn (SList_DeleteAtBeginning(list))else\nreturn (SList_DeleteAfter(list, SList_PtrToNode(heap, list, (position - 1))))\n)\n\tpre (position \u003c\u003d SList_Lengthf(heap, list))\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (([old(i) | i in set (inds old) \u0026 (i \u003c\u003e position)] \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1)))","SList_Traverse (SList_List * (SList_Data -\u003e SList_Data) \u003d\u003d\u003e SList_List)\n\tSList_Traverse(list, traversal) \u003d\u003d\n(\nptr:Nodes_NodePtr :\u003d list\n\nwhile (ptr \u003c\u003e NIL) do (\n\nSET_DATA(ptr, traversal(DATA(ptr)));\nptr :\u003d NEXT(ptr)\n);\nreturn (list)\n)\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in ((old \u003c\u003e []) \u003d\u003e ([traversal(old(i)) | i in set (inds old)] \u003d SList_Seq(heap, RESULT)))","SList_Length (SList_List \u003d\u003d\u003e nat)\n\tSList_Length(list) \u003d\u003d\nreturn (SList_Lengthf(heap, list))","SList_Empty (SList_List \u003d\u003d\u003e bool)\n\tSList_Empty(list) \u003d\u003d\nreturn (SList_IsEmpty(list))","SList_Element (SList_List * nat1 \u003d\u003d\u003e SList_Data)\n\tSList_Element(list, position) \u003d\u003d\nDATA(SList_PtrToNode(heap, list, position))","DList_Data \u003d DList_Data","DList_List \u003d DList_List","private DList_LastNode: (Heaps_Heap * DList_List -\u003e Nodes_NodePtr)\n\tDList_LastNode(heap, list) \u003d\u003d\nlet next:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (next \u003c\u003e NIL)\nthen DList_LastNode(heap, next)\nelse list)","private DList_Forward: (Heaps_Heap * DList_List -\u003e seq of (DList_Data))\n\tDList_Forward(heap, list) \u003d\u003d\nSList_Seq(heap, list)","private DList_Backward: (Heaps_Heap * DList_List -\u003e seq of (DList_Data))\n\tDList_Backward(heap, list) \u003d\u003d\n(if (list \u003c\u003e NIL)\nthen let prev:Nodes_NodePtr \u003d Nodes_GetPrev(Heaps_Retrieve(heap, list)) in let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, list)) in (DList_Backward(heap, prev) ^ [data])\nelse [])","private DList_IsList: (Heaps_Heap * DList_List -\u003e bool)\n\tDList_IsList(heap, list) \u003d\u003d\n(if (list \u003c\u003e NIL)\nthen (DList_Forward(heap, list) \u003d DList_Backward(heap, DList_LastNode(heap, list)))\nelse true)","private DList_Init: (() -\u003e DList_List)\n\tDList_Init() \u003d\u003d\nNIL","DList_InsertAtBeginning (DList_List * DList_Data \u003d\u003d\u003e DList_List)\n\tDList_InsertAtBeginning(list, data) \u003d\u003d\n(\nnew:Nodes_NodePtr :\u003d NEW(Nodes_MkDoubleLink(data, list, NIL))\n\nif (list \u003c\u003e NIL)\nthen\nSET_PREV(list, new);\nreturn (new)\n)\n\tpost (([data] ^ SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))","DList_InsertAfter (DList_List * Nodes_NodePtr * DList_Data \u003d\u003d\u003e DList_List)\n\tDList_InsertAfter(list, ptr, data) \u003d\u003d\n(\nnew:Nodes_NodePtr :\u003d NEW(Nodes_MkDoubleLink(data, NEXT(ptr), ptr))\n\nif (NEXT(ptr) \u003c\u003e NIL)\nthen\nSET_PREV(NEXT(ptr), new);\nSET_NEXT(ptr, new);\nreturn (list)\n)\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) \u003d SList_Seq(heap, ptr))","DList_Insert (DList_List * DList_Data * nat1 \u003d\u003d\u003e DList_List)\n\tDList_Insert(list, data, position) \u003d\u003d\nif (position \u003d 1)\nthen\nreturn (DList_InsertAtBeginning(list, data))else\nreturn (DList_InsertAfter(list, SList_PtrToNode(heap, list, (position - 1)), data))\n\tpre ((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list)))\n\tpost (DList_IsList(heap, RESULT) and let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) and (new(position) \u003d data)))","DList_DeleteAtBeginning (DList_List \u003d\u003d\u003e DList_List)\n\tDList_DeleteAtBeginning(list) \u003d\u003d\n(\ntemp:Nodes_NodePtr :\u003d list\nnewlist:DList_List :\u003d NEXT(list)\n\nif (newlist \u003c\u003e NIL)\nthen\nSET_PREV(newlist, NIL);\nDISPOSE(temp);\nreturn (newlist)\n)\n\tpost ((tl SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))","DList_DeleteAfter (DList_List * Nodes_NodePtr \u003d\u003d\u003e DList_List)\n\tDList_DeleteAfter(list, ptr) \u003d\u003d\n(\ntemp:Nodes_NodePtr :\u003d (undefined)\nnextPtr:Nodes_NodePtr :\u003d (undefined)\n\ntemp :\u003d NEXT(ptr);\nnextPtr :\u003d NEXT(temp);\nSET_NEXT(ptr, nextPtr);\nif (nextPtr \u003c\u003e NIL)\nthen\nSET_PREV(nextPtr, ptr);\nDISPOSE(temp);\nreturn (list)\n)\n\tpost let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) \u003d SList_Seq(heap, ptr))","DList_Delete (DList_List * nat1 \u003d\u003d\u003e DList_List)\n\tDList_Delete(list, position) \u003d\u003d\n(\n\nif (position \u003d 1)\nthen\nreturn (DList_DeleteAtBeginning(list))else\nreturn (DList_DeleteAfter(list, SList_PtrToNode(heap, list, (position - 1))))\n)\n\tpre ((position \u003c\u003d SList_Lengthf(heap, list)) and DList_IsList(heap, list))\n\tpost (DList_IsList(heap, RESULT) and let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (([old(i) | i in set (inds old) \u0026 (i \u003c\u003e position)] \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1))))","DList_Append (DList_List * DList_Data \u003d\u003d\u003e DList_List)\n\tDList_Append(list, data) \u003d\u003d\n(\nptr:Nodes_NodePtr :\u003d list\n\nif (ptr \u003d NIL)\nthen\nreturn (DList_InsertAtBeginning(list, data))else\n(\n\nwhile (NEXT(ptr) \u003c\u003e NIL) do ptr :\u003d NEXT(ptr);\nreturn (DList_InsertAfter(list, ptr, data))\n)\n)\n\tpre (Heaps_Available(heap) and DList_IsList(heap, list))\n\tpost (((SList_Seq(heap~, list) ^ [data]) \u003d SList_Seq(heap, RESULT)) and (((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)) and DList_IsList(heap, RESULT)))","DList_Empty (DList_List \u003d\u003d\u003e bool)\n\tDList_Empty(list) \u003d\u003d\nSList_Empty(list)","DList_Element (DList_List * nat1 \u003d\u003d\u003e DList_Data)\n\tDList_Element(list, position) \u003d\u003d\nSList_Element(list, position)","DList_Length (DList_List \u003d\u003d\u003e nat)\n\tDList_Length(list) \u003d\u003d\nSList_Length(list)","DList_Traverse (DList_List * (DList_Data -\u003e DList_Data) \u003d\u003d\u003e DList_List)\n\tDList_Traverse(list, traversal) \u003d\u003d\nSList_Traverse(list, traversal)","DList_Update (DList_List * DList_Data * nat1 \u003d\u003d\u003e DList_List)\n\tDList_Update(list, data, position) \u003d\u003d\nSList_Update(list, data, position)","Queues_Data \u003d Queues_Data","Queues_Queue \u003d Queues_Queue","private Queues_Init: (() -\u003e Queues_Queue)\n\tQueues_Init() \u003d\u003d\nSList_Init()","Queues_Enqueue (Queues_Queue * Queues_Data \u003d\u003d\u003e Queues_Queue)\n\tQueues_Enqueue(queue, data) \u003d\u003d\nreturn (SList_Append(queue, data))","Queues_Dequeue (Queues_Queue \u003d\u003d\u003e (Queues_Queue * Queues_Data))\n\tQueues_Dequeue(queue) \u003d\u003d\n(\n\nif (not SList_Empty(queue))\nthen\n(\ndata:Queues_Data :\u003d Queues_Head(queue)\n\nreturn (mk_(SList_Delete(queue, 1), data))\n)else\nerror\n)","Queues_Head (Queues_Queue \u003d\u003d\u003e Queues_Data)\n\tQueues_Head(queue) \u003d\u003d\nif (not SList_Empty(queue))\nthen\nSList_Element(queue, 1)else\nerror","Stacks_Data \u003d Stacks_Data","Stacks_Stack \u003d Stacks_Stack","private Stacks_Init: (() -\u003e Stacks_Stack)\n\tStacks_Init() \u003d\u003d\nSList_Init()","Stacks_Push (Stacks_Stack * Stacks_Data \u003d\u003d\u003e Stacks_Stack)\n\tStacks_Push(stack, data) \u003d\u003d\nreturn (SList_Insert(stack, data, 1))","Stacks_Top (Stacks_Stack \u003d\u003d\u003e Stacks_Data)\n\tStacks_Top(stack) \u003d\u003d\nif (not SList_Empty(stack))\nthen\nSList_Element(stack, 1)else\nerror","Stacks_Pop (Stacks_Stack \u003d\u003d\u003e (Stacks_Stack * Stacks_Data))\n\tStacks_Pop(stack) \u003d\u003d\n(\n\nif (not SList_Empty(stack))\nthen\n(\ndata:Stacks_Data :\u003d Stacks_Top(stack)\n\nreturn (mk_(SList_Delete(stack, 1), data))\n)else\nerror\n)","STrees_Data \u003d STrees_Data","STrees_Direction \u003d STrees_Direction","STrees_Node \u003d STrees_Node","STrees_Tree \u003d STrees_Tree\n\tinv tree \u003d\u003d ((forall node in set tree \u0026 ((not STrees_IsRoot(tree, node)) \u003c\u003d\u003e (STrees_IsChild(tree, node) and STrees_IsUnique(tree, node)))) and ((tree \u003c\u003e {}) \u003c\u003d\u003e (exists1 node in set tree \u0026 STrees_IsRoot(tree, node))))","STrees_Info \u003d STrees_Info\n\tinv mk_STrees_Info(t, c) \u003d\u003d (((c \u003d nil) \u003c\u003d\u003e (t \u003d {})) and ((c \u003c\u003e nil) \u003c\u003d\u003e ((c in set t) and let r:STrees_Node \u003d STrees_Root(t) in ((r.position) \u003d 1))))","private STrees_GetTree: (STrees_Info -\u003e STrees_Tree)\n\tSTrees_GetTree(mk_STrees_Info(tree, -)) \u003d\u003d\ntree","private STrees_MkNode: (STrees_Data * nat1 -\u003e STrees_Node)\n\tSTrees_MkNode(data, position) \u003d\u003d\nmk_STrees_Node(data, position)","private STrees_MkTree: (set of (STrees_Node) -\u003e STrees_Tree)\n\tSTrees_MkTree(tree) \u003d\u003d\ntree\n\tpre inv_STrees_Tree(tree)","private STrees_MkInfo: (STrees_Tree * STrees_Node -\u003e STrees_Info)\n\tSTrees_MkInfo(tree, current) \u003d\u003d\nmk_STrees_Info(tree, current)\n\tpre inv_STrees_Info(mk_STrees_Info(tree, current))","private STrees_Init: (() -\u003e STrees_Info)\n\tSTrees_Init() \u003d\u003d\nmk_STrees_Info({}, nil)","private STrees_IsRoot: (set of (STrees_Node) * STrees_Node -\u003e bool)\n\tSTrees_IsRoot(tree, mk_STrees_Node(dr, pr)) \u003d\u003d\n(not STrees_IsChild(tree, mk_STrees_Node(dr, pr)))\n\tpre (mk_STrees_Node(dr, pr) in set tree)","private STrees_IsParent: (STrees_Tree * STrees_Node -\u003e bool)\n\tSTrees_IsParent(tree, node) \u003d\u003d\n(exists child in set tree \u0026 STrees_IsParentOf(tree, node, child))\n\tpre (node in set tree)","private STrees_IsChild: (set of (STrees_Node) * STrees_Node -\u003e bool)\n\tSTrees_IsChild(tree, node) \u003d\u003d\n((exists parent in set tree \u0026 STrees_IsParentOf(tree, parent, node)) and (exists1 parent in set tree \u0026 STrees_IsParentOf(tree, parent, node)))\n\tpre (node in set tree)","private STrees_IsUnique: (set of (STrees_Node) * STrees_Node -\u003e bool)\n\tSTrees_IsUnique(tree, mk_STrees_Node(data, position)) \u003d\u003d\n((mk_STrees_Node(data, position) in set tree) and (exists1 node in set tree \u0026 ((node.position) \u003d position)))","private STrees_IsParentOf: (set of (STrees_Node) * STrees_Node * STrees_Node -\u003e bool)\n\tSTrees_IsParentOf(tree, node1, node2) \u003d\u003d\n(STrees_IsRightChildOf(tree, node2, node1) or STrees_IsLeftChildOf(tree, node2, node1))\n\tpre ((node1 in set tree) and (node2 in set tree))","private STrees_IsRightChildOf: (set of (STrees_Node) * STrees_Node * STrees_Node -\u003e bool)\n\tSTrees_IsRightChildOf(tree, node1, node2) \u003d\u003d\nlet mk_STrees_Node(-, position1):STrees_Node \u003d node1 in let mk_STrees_Node(-, position2):STrees_Node \u003d node2 in (position1 \u003d ((2 * position2) + 1))\n\tpre ((node1 in set tree) and (node2 in set tree))","private STrees_IsLeftChildOf: (set of (STrees_Node) * STrees_Node * STrees_Node -\u003e bool)\n\tSTrees_IsLeftChildOf(tree, node1, node2) \u003d\u003d\nlet mk_STrees_Node(-, position1):STrees_Node \u003d node1 in let mk_STrees_Node(-, position2):STrees_Node \u003d node2 in (position1 \u003d (2 * position2))\n\tpre ((node1 in set tree) and (node2 in set tree))","private STrees_Insert: (STrees_Info * STrees_Data * STrees_Direction -\u003e STrees_Info)\n\tSTrees_Insert(mk_STrees_Info(tree, current), data, direction) \u003d\u003d\n(cases mk_(current, direction) :\nmk_(nil, \u003cToRoot\u003e) -\u003e STrees_InsertRoot(data),\nmk_(-, \u003cToLeft\u003e) -\u003e STrees_InsertLeft(tree, current, data),\nmk_(-, \u003cToRight\u003e) -\u003e STrees_InsertRight(tree, current, data)\n end)\n\tpre (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current)))))\n\tpost inv_STrees_Info(RESULT)","private STrees_InsertRoot: (STrees_Data -\u003e STrees_Info)\n\tSTrees_InsertRoot(data) \u003d\u003d\nlet root:STrees_Node \u003d mk_STrees_Node(data, 1) in mk_STrees_Info({root}, root)","private STrees_InsertLeft: (STrees_Tree * STrees_Node * STrees_Data -\u003e STrees_Info)\n\tSTrees_InsertLeft(tree, current, data) \u003d\u003d\nlet mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, (2 * position)) in mk_STrees_Info((tree union {new}), new)\n\tpre (not STrees_HasLeftChild(tree, current))","private STrees_InsertRight: (STrees_Tree * STrees_Node * STrees_Data -\u003e STrees_Info)\n\tSTrees_InsertRight(tree, current, data) \u003d\u003d\nlet mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, ((2 * position) + 1)) in mk_STrees_Info((tree union {new}), new)\n\tpre (not STrees_HasRightChild(tree, current))","private STrees_Traverse: (STrees_Info * (STrees_Data -\u003e STrees_Data) -\u003e STrees_Info)\n\tSTrees_Traverse(treeinfo, traversal) \u003d\u003d\nlet mk_STrees_Info(tree, current):STrees_Info \u003d treeinfo in (if (current \u003c\u003e nil)\nthen let mk_STrees_Node(data, position):[STrees_Node] \u003d current in let newtree:set of (STrees_Node) \u003d {mk_STrees_Node(traversal(data), position) | mk_STrees_Node(data, position) in set tree} in mk_STrees_Info(newtree, mk_STrees_Node(traversal(data), position))\nelse treeinfo)","private STrees_MoveInDir: (STrees_Info * STrees_Direction -\u003e STrees_Info)\n\tSTrees_MoveInDir(mk_STrees_Info(tree, current), direction) \u003d\u003d\n(cases direction :\n\u003cToRoot\u003e -\u003e mk_STrees_Info(tree, STrees_Root(tree)),\n\u003cToLeft\u003e -\u003e mk_STrees_Info(tree, STrees_LeftChild(tree, current)),\n\u003cToRight\u003e -\u003e mk_STrees_Info(tree, STrees_RightChild(tree, current))\n end)\n\tpre STrees_ExistsDirection(mk_STrees_Info(tree, current), direction)","private STrees_MoveToNode: (STrees_Info * nat1 -\u003e STrees_Info)\n\tSTrees_MoveToNode(mk_STrees_Info(tree, current), position) \u003d\u003d\nmk_STrees_Info(tree, STrees_GetNode(tree, position))\n\tpre STrees_ExistsNode(mk_STrees_Info(tree, current), position)","private STrees_MoveToParent: (STrees_Info -\u003e STrees_Info)\n\tSTrees_MoveToParent(mk_STrees_Info(tree, current)) \u003d\u003d\nmk_STrees_Info(tree, STrees_Parent(tree, current))\n\tpre (not STrees_IsRoot(tree, current))","private STrees_MoveToAnscestor: (STrees_Info * nat1 -\u003e STrees_Info)\n\tSTrees_MoveToAnscestor(treeinfo, pathlength) \u003d\u003d\n(if (pathlength \u003e 1)\nthen STrees_MoveToAnscestor(STrees_MoveToParent(treeinfo), (pathlength - 1))\nelse STrees_MoveToParent(treeinfo))\n\tpre pre_STrees_MoveToParent(treeinfo)","private STrees_Root: (STrees_Tree -\u003e STrees_Node)\n\tSTrees_Root(tree) \u003d\u003d\n(iota root in set tree \u0026 STrees_IsRoot(tree, root))\n\tpre (tree \u003c\u003e {})","private STrees_Parent: (STrees_Tree * STrees_Node -\u003e STrees_Node)\n\tSTrees_Parent(tree, node) \u003d\u003d\n(iota parent in set tree \u0026 STrees_IsParentOf(tree, parent, node))\n\tpre ((node in set tree) and (not STrees_IsRoot(tree, node)))","private STrees_LeftChild: (STrees_Tree * STrees_Node -\u003e STrees_Node)\n\tSTrees_LeftChild(tree, parent) \u003d\u003d\n(iota leftchild in set tree \u0026 STrees_IsLeftChildOf(tree, leftchild, parent))\n\tpre ((parent in set tree) and STrees_HasLeftChild(tree, parent))","private STrees_RightChild: (STrees_Tree * STrees_Node -\u003e STrees_Node)\n\tSTrees_RightChild(tree, parent) \u003d\u003d\n(iota rightchild in set tree \u0026 STrees_IsRightChildOf(tree, rightchild, parent))\n\tpre ((parent in set tree) and STrees_HasRightChild(tree, parent))","private STrees_GetNode: (STrees_Tree * nat1 -\u003e STrees_Node)\n\tSTrees_GetNode(tree, position) \u003d\u003d\n(iota node in set tree \u0026 ((node.position) \u003d position))\n\tpre (exists node in set tree \u0026 ((node.position) \u003d position))","private STrees_GetData: (STrees_Info * nat1 -\u003e STrees_Data)\n\tSTrees_GetData(mk_STrees_Info(tree, current), position) \u003d\u003d\nlet mk_STrees_Node(data, -):STrees_Node \u003d STrees_GetNode(tree, position) in data\n\tpre STrees_ExistsNode(mk_STrees_Info(tree, current), position)","private STrees_StoreCurrentData: (STrees_Info * STrees_Data -\u003e STrees_Info)\n\tSTrees_StoreCurrentData(mk_STrees_Info(tree, current), data) \u003d\u003d\nlet mk_STrees_Node(-, position):[STrees_Node] \u003d current in let newcurrent:STrees_Node \u003d mk_STrees_Node(data, position) in mk_STrees_Info(((tree \\ {current}) union {newcurrent}), newcurrent)\n\tpre (current \u003c\u003e nil)","private STrees_GetCurrentData: (STrees_Info -\u003e STrees_Data)\n\tSTrees_GetCurrentData(mk_STrees_Info(tree, mk_STrees_Node(data, -))) \u003d\u003d\ndata\n\tpre (tree \u003c\u003e {})","private STrees_Size: (STrees_Info -\u003e nat)\n\tSTrees_Size(mk_STrees_Info(tree, -)) \u003d\u003d\n(card tree)","private STrees_GetCurrentNode: (STrees_Info -\u003e STrees_Node)\n\tSTrees_GetCurrentNode(mk_STrees_Info(-, current)) \u003d\u003d\ncurrent","private STrees_SetCurrentNode: (STrees_Info * STrees_Node -\u003e STrees_Info)\n\tSTrees_SetCurrentNode(mk_STrees_Info(tree, -), newcurrent) \u003d\u003d\nmk_STrees_Info(tree, newcurrent)\n\tpre (newcurrent in set tree)","private STrees_HasLeftChild: (STrees_Tree * STrees_Node -\u003e bool)\n\tSTrees_HasLeftChild(tree, parent) \u003d\u003d\n(exists1 child in set tree \u0026 STrees_IsLeftChildOf(tree, child, parent))\n\tpre (parent in set tree)","private STrees_HasRightChild: (STrees_Tree * STrees_Node -\u003e bool)\n\tSTrees_HasRightChild(tree, parent) \u003d\u003d\n(exists1 child in set tree \u0026 STrees_IsRightChildOf(tree, child, parent))\n\tpre (parent in set tree)","private STrees_InOrderPredecessor: (STrees_Tree * STrees_Node -\u003e STrees_Node)\n\tSTrees_InOrderPredecessor(tree, node) \u003d\u003d\nlet leftchild:STrees_Node \u003d STrees_LeftChild(tree, node) in let left:STrees_Tree \u003d STrees_Subtree(tree, leftchild) in let rightpath:set of (STrees_Node) \u003d {n | n in set left \u0026 (exists p in set {0, ... ,(card left)} \u0026 ((n.position) \u003d ((((leftchild.position) + 1) * (2 ** p)) - 1)))} in (iota pred in set rightpath \u0026 (forall n in set rightpath \u0026 ((n.position) \u003c\u003d (pred.position))))\n\tpre ((node in set tree) and STrees_HasLeftChild(tree, node))","private STrees_Delete: (STrees_Info -\u003e STrees_Info)\n\tSTrees_Delete(mk_STrees_Info(tree, current)) \u003d\u003d\nlet old:STrees_Tree \u003d STrees_Subtree(tree, current) in (if (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))\nthen let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), rightchild:STrees_Node \u003d STrees_RightChild(tree, current), left:STrees_Tree \u003d STrees_Subtree(old, leftchild), mk_STrees_Node(-, position):STrees_Node \u003d STrees_InOrderPredecessor(old, current), newright:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)), newleft:STrees_Tree \u003d (left union newright), new:STrees_Tree \u003d STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelseif STrees_HasLeftChild(tree, current)\nthen let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, leftchild, (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelseif STrees_HasRightChild(tree, current)\nthen let rightchild:STrees_Node \u003d STrees_RightChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelse mk_STrees_Info((tree \\ {current}), STrees_Parent(tree, current)))\n\tpre (current \u003c\u003e nil)\n\tpost inv_STrees_Info(RESULT)","private STrees_Subtree: (STrees_Tree * STrees_Node -\u003e STrees_Tree)\n\tSTrees_Subtree(tree, mk_STrees_Node(rootdata, rootpos)) \u003d\u003d\n{mk_STrees_Node(d, p) | mk_STrees_Node(d, p) in set tree \u0026 (exists1 n in set {0, ... ,(card tree)} \u0026 ((p \u003e\u003d (rootpos * (2 ** n))) and (p \u003c ((rootpos + 1) * (2 ** n)))))}\n\tpre (mk_STrees_Node(rootdata, rootpos) in set tree)","private STrees_MoveSubtree: (STrees_Tree * STrees_Node * nat1 -\u003e STrees_Tree)\n\tSTrees_MoveSubtree(tree, subtreeRoot, newRootPos) \u003d\u003d\nlet subtree:STrees_Tree \u003d STrees_Subtree(tree, subtreeRoot), mk_STrees_Node(-, oldRootPos):STrees_Node \u003d subtreeRoot in {STrees_MoveNode(tree, node, oldRootPos, newRootPos) | node in set subtree}\n\tpre (subtreeRoot in set tree)","private STrees_MoveNode: (STrees_Tree * STrees_Node * nat1 * nat1 -\u003e STrees_Node)\n\tSTrees_MoveNode(tree, mk_STrees_Node(d, p), oldRootPos, newRootPos) \u003d\u003d\nlet n:int \u003d (iota n in set {0, ... ,(card tree)} \u0026 ((p \u003e\u003d (oldRootPos * (2 ** n))) and (p \u003c ((oldRootPos + 1) * (2 ** n))))) in mk_STrees_Node(d, (((newRootPos * (2 ** n)) + p) - (oldRootPos * (2 ** n))))","private STrees_ExistsData: (STrees_Info * STrees_Data -\u003e bool)\n\tSTrees_ExistsData(mk_STrees_Info(tree, -), data) \u003d\u003d\n(exists node in set tree \u0026 ((node.data) \u003d data))","private STrees_ExistsNode: (STrees_Info * nat1 -\u003e bool)\n\tSTrees_ExistsNode(mk_STrees_Info(tree, -), position) \u003d\u003d\n(exists node in set tree \u0026 ((node.position) \u003d position))","private STrees_ExistsDirection: (STrees_Info * STrees_Direction -\u003e bool)\n\tSTrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003d\n(cases direction :\n\u003cToRoot\u003e -\u003e (tree \u003c\u003e {}),\n\u003cToLeft\u003e -\u003e (if (current \u003c\u003e nil)\nthen STrees_HasLeftChild(tree, current)\nelse false),\n\u003cToRight\u003e -\u003e (if (current \u003c\u003e nil)\nthen STrees_HasRightChild(tree, current)\nelse false)\n end)","Trees_Data \u003d Trees_Data","Trees_Direction \u003d Trees_Direction","Trees_Tree \u003d Trees_Tree","private Trees_Position: (Heaps_Heap * Nodes_NodePtr -\u003e nat1)\n\tTrees_Position(heap, child) \u003d\u003d\nlet parent:Nodes_NodePtr \u003d Nodes_GetParent(Heaps_Retrieve(heap, child)) in (if (parent \u003d NIL)\nthen 1\nelseif Trees_IsRightChildOf(heap, child, parent)\nthen ((2 * Trees_Position(heap, parent)) + 1)\nelse (2 * Trees_Position(heap, parent)))\n\tpre (child \u003c\u003e NIL)","private Trees_Set: (Heaps_Heap * Trees_Tree -\u003e STrees_Info)\n\tTrees_Set(heap, mk_Trees_Tree(treePtr, current)) \u003d\u003d\n(if (treePtr \u003c\u003e NIL)\nthen let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, current)) in let position:nat1 \u003d Trees_Position(heap, current) in let currentnode:STrees_Node \u003d STrees_MkNode(data, position) in STrees_MkInfo(treeset, currentnode)\nelse STrees_Init())","private Trees_SubtreeToSet: (Heaps_Heap * Nodes_NodePtr * nat1 -\u003e set of (STrees_Node))\n\tTrees_SubtreeToSet(heap, subtree, position) \u003d\u003d\n(if (subtree \u003c\u003e NIL)\nthen (({STrees_MkNode(Nodes_GetData(Heaps_Retrieve(heap, subtree)), position)} union Trees_SubtreeToSet(heap, Nodes_GetLeft(Heaps_Retrieve(heap, subtree)), (2 * position))) union Trees_SubtreeToSet(heap, Nodes_GetRight(Heaps_Retrieve(heap, subtree)), ((2 * position) + 1)))\nelse {})","private Trees_HasLeftChild: (Heaps_Heap * Nodes_NodePtr -\u003e bool)\n\tTrees_HasLeftChild(heap, ptr) \u003d\u003d\n(if (ptr \u003c\u003e NIL)\nthen (Nodes_GetLeft(Heaps_Retrieve(heap, ptr)) \u003c\u003e NIL)\nelse false)\n\tpre ((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr))","private Trees_HasRightChild: (Heaps_Heap * Nodes_NodePtr -\u003e bool)\n\tTrees_HasRightChild(heap, ptr) \u003d\u003d\n(if (ptr \u003c\u003e NIL)\nthen (Nodes_GetRight(Heaps_Retrieve(heap, ptr)) \u003c\u003e NIL)\nelse false)\n\tpre ((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr))","private Trees_IsRightChildOf: (Heaps_Heap * Nodes_NodePtr * Nodes_NodePtr -\u003e bool)\n\tTrees_IsRightChildOf(heap, child, parent) \u003d\u003d\n((child \u003d Nodes_GetRight(Heaps_Retrieve(heap, parent))) and (parent \u003d Nodes_GetParent(Heaps_Retrieve(heap, child))))\n\tpre (pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child))","private Trees_IsLeftChildOf: (Heaps_Heap * Nodes_NodePtr * Nodes_NodePtr -\u003e bool)\n\tTrees_IsLeftChildOf(heap, child, parent) \u003d\u003d\n((child \u003d Nodes_GetLeft(Heaps_Retrieve(heap, parent))) and (parent \u003d Nodes_GetParent(Heaps_Retrieve(heap, child))))\n\tpre (pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child))","private Trees_IsRoot: (Heaps_Heap * Nodes_NodePtr -\u003e bool)\n\tTrees_IsRoot(heap, ptr) \u003d\u003d\n(Nodes_GetParent(Heaps_Retrieve(heap, ptr)) \u003d NIL)\n\tpre (ptr \u003c\u003e NIL)","private Trees_Init: (() -\u003e Trees_Tree)\n\tTrees_Init() \u003d\u003d\nmk_Trees_Tree(NIL, NIL)","Trees_Insert (Trees_Tree * Trees_Data * Trees_Direction \u003d\u003d\u003e Trees_Tree)\n\tTrees_Insert(tree, data, direction) \u003d\u003d\ncases direction :\n  \u003cToRoot\u003e -\u003e return (Trees_InsertRoot(data))  \u003cToLeft\u003e -\u003e return (Trees_InsertLeft(tree, data))  \u003cToRight\u003e -\u003e return (Trees_InsertRight(tree, data))  others -\u003e error end\n\tpre (Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) and (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) and ((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not Trees_HasLeftChild(heap, current))))))\n\tpost (((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)) and let old:STrees_Info \u003d Trees_Set(heap~, tree) in (STrees_Insert(old, data, direction) \u003d Trees_Set(heap, RESULT)))","Trees_InsertRoot (Trees_Data \u003d\u003d\u003e Trees_Tree)\n\tTrees_InsertRoot(data) \u003d\u003d\n(\nnewTreePtr:Nodes_NodePtr :\u003d NEW(Nodes_MkBinaryTree(data, NIL, NIL, NIL))\n\nreturn (mk_Trees_Tree(newTreePtr, newTreePtr))\n)","Trees_InsertLeft (Trees_Tree * Trees_Data \u003d\u003d\u003e Trees_Tree)\n\tTrees_InsertLeft(mk_Trees_Tree(treePtr, current), data) \u003d\u003d\n(\nnew:Nodes_NodePtr :\u003d NEW(Nodes_MkBinaryTree(data, NIL, NIL, current))\n\nSET_LEFT(current, new);\nreturn (mk_Trees_Tree(treePtr, new))\n)","Trees_InsertRight (Trees_Tree * Trees_Data \u003d\u003d\u003e Trees_Tree)\n\tTrees_InsertRight(mk_Trees_Tree(treePtr, current), data) \u003d\u003d\n(\nnew:Nodes_NodePtr :\u003d NEW(Nodes_MkBinaryTree(data, NIL, NIL, current))\n\nSET_RIGHT(current, new);\nreturn (mk_Trees_Tree(treePtr, new))\n)","Trees_InOrderPredecessor (Nodes_NodePtr \u003d\u003d\u003e Nodes_NodePtr)\n\tTrees_InOrderPredecessor(ptr) \u003d\u003d\n(\npred:Nodes_NodePtr :\u003d LEFT(ptr)\n\nwhile Trees_HasRightChild(heap, pred) do pred :\u003d RIGHT(pred);\nreturn (pred)\n)\n\tpre Trees_HasLeftChild(heap, ptr)","Trees_Delete (Trees_Tree \u003d\u003d\u003e Trees_Tree)\n\tTrees_Delete(mk_Trees_Tree(treePtr, current)) \u003d\u003d\n(\nhasLeftChild:bool :\u003d Trees_HasLeftChild(heap, current)\nhasRightChild:bool :\u003d Trees_HasRightChild(heap, current)\nnewcurrent:Nodes_NodePtr :\u003d (undefined)\nnewtree:Nodes_NodePtr :\u003d treePtr\nparent:Nodes_NodePtr :\u003d PARENT(current)\nnewchild:Nodes_NodePtr :\u003d (undefined)\n\nif (hasLeftChild or hasRightChild)\nthen\n(\n\nif hasLeftChild\nthen\n(\n\nnewcurrent :\u003d LEFT(current);\nif hasRightChild\nthen\n(\nright:Nodes_NodePtr :\u003d RIGHT(current)\npred:Nodes_NodePtr :\u003d Trees_InOrderPredecessor(current)\n\nSET_PARENT(right, pred);\nSET_RIGHT(pred, right)\n)\n)else\nnewcurrent :\u003d RIGHT(current);\nnewchild :\u003d newcurrent;\nSET_PARENT(newcurrent, parent)\n)else\n(\n\nnewcurrent :\u003d parent;\nnewchild :\u003d NIL\n);\nif Trees_IsRoot(heap, current)\nthen\nnewtree :\u003d newchildelseif Trees_IsRightChildOf(heap, current, parent)\nthen\nSET_RIGHT(parent, newchild)else\nSET_LEFT(parent, newchild);\nDISPOSE(current);\nreturn (mk_Trees_Tree(newtree, newcurrent))\n)\n\tpre (treePtr \u003c\u003e NIL)\n\tpost ((Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1)) and let old:STrees_Info \u003d Trees_Set(heap~, mk_Trees_Tree(treePtr, current)) in (STrees_Delete(old) \u003d Trees_Set(heap, RESULT)))","Trees_SearchSubtree (Nodes_NodePtr * Trees_Data \u003d\u003d\u003e bool)\n\tTrees_SearchSubtree(subtree, dataToFind) \u003d\u003d\n(\n\nif (subtree \u003c\u003e NIL)\nthen\n(\n\nlet data \u003d DATA(subtree) in if (data \u003d dataToFind)\nthen\nreturn (true)else\nreturn ((Trees_SearchSubtree(RIGHT(subtree), dataToFind) or Trees_SearchSubtree(LEFT(subtree), dataToFind)))\n)else\nreturn (false)\n)","Trees_ExistsData (Trees_Tree * Trees_Data \u003d\u003d\u003e bool)\n\tTrees_ExistsData(tree, data) \u003d\u003d\nTrees_SearchSubtree((tree.treePtr), data)\n\tpost (STrees_ExistsData(Trees_Set(heap, tree), data) \u003d RESULT)","Trees_ExistsDirection (Trees_Tree * Trees_Direction \u003d\u003d\u003e bool)\n\tTrees_ExistsDirection(tree, direction) \u003d\u003d\ncases direction :\n  \u003cToRoot\u003e -\u003e return (((tree.treePtr) \u003c\u003e NIL))  \u003cToLeft\u003e -\u003e return ((((tree.current) \u003c\u003e NIL) and Trees_HasLeftChild(heap, (tree.current))))  \u003cToRight\u003e -\u003e return ((((tree.current) \u003c\u003e NIL) and Trees_HasRightChild(heap, (tree.current))))  others -\u003e error end\n\tpost (STrees_ExistsDirection(Trees_Set(heap, tree), direction) \u003d RESULT)","Trees_GetCurrentData (Trees_Tree \u003d\u003d\u003e Trees_Data)\n\tTrees_GetCurrentData(tree) \u003d\u003d\nDATA((tree.current))\n\tpre ((tree.treePtr) \u003c\u003e NIL)\n\tpost (STrees_GetCurrentData(Trees_Set(heap, tree)) \u003d RESULT)","Trees_StoreCurrentData (Trees_Tree * Trees_Data \u003d\u003d\u003e Trees_Tree)\n\tTrees_StoreCurrentData(tree, data) \u003d\u003d\n(\n\nSET_DATA((tree.current), data);\nreturn (tree)\n)\n\tpre ((tree.treePtr) \u003c\u003e NIL)\n\tpost (STrees_StoreCurrentData(Trees_Set(heap~, tree), data) \u003d Trees_Set(heap, RESULT))","Trees_MoveInDir (Trees_Tree * Trees_Direction \u003d\u003d\u003e Trees_Tree)\n\tTrees_MoveInDir(tree, direction) \u003d\u003d\ncases direction :\n  \u003cToRoot\u003e -\u003e return (mk_Trees_Tree((tree.treePtr), (tree.treePtr)))  \u003cToLeft\u003e -\u003e return (mk_Trees_Tree((tree.treePtr), LEFT((tree.current))))  \u003cToRight\u003e -\u003e return (mk_Trees_Tree((tree.treePtr), RIGHT((tree.current))))  others -\u003e error end\n\tpre (((tree.treePtr) \u003c\u003e NIL) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e Trees_HasRightChild(heap, (tree.current)))))\n\tpost (STrees_MoveInDir(Trees_Set(heap~, tree), direction) \u003d Trees_Set(heap, RESULT))","Trees_MoveToParent (Trees_Tree \u003d\u003d\u003e Trees_Tree)\n\tTrees_MoveToParent(tree) \u003d\u003d\nreturn (mk_Trees_Tree((tree.treePtr), PARENT((tree.current))))\n\tpre (not Trees_IsRoot(heap, (tree.current)))\n\tpost (STrees_MoveToParent(Trees_Set(heap~, tree)) \u003d Trees_Set(heap, RESULT))","Trees_Size (Trees_Tree \u003d\u003d\u003e nat)\n\tTrees_Size(tree) \u003d\u003d\nTrees_SubtreeSize((tree.treePtr))\n\tpost (STrees_Size(Trees_Set(heap~, tree)) \u003d RESULT)","Trees_SubtreeSize (Nodes_NodePtr \u003d\u003d\u003e nat)\n\tTrees_SubtreeSize(subtree) \u003d\u003d\nif (subtree \u003c\u003e NIL)\nthen\nreturn (((1 + Trees_SubtreeSize(RIGHT(subtree))) + Trees_SubtreeSize(LEFT(subtree))))else\nreturn (0)","Trees_Traverse (Trees_Tree * (Trees_Data -\u003e Trees_Data) \u003d\u003d\u003e Trees_Tree)\n\tTrees_Traverse(tree, traversal) \u003d\u003d\n(\n\nTrees_TraverseSubtree((tree.treePtr), traversal);\nreturn (tree)\n)\n\tpost (STrees_Traverse(Trees_Set(heap~, tree), traversal) \u003d Trees_Set(heap, RESULT))","Trees_TraverseSubtree (Nodes_NodePtr * (Trees_Data -\u003e Trees_Data) \u003d\u003d\u003e ())\n\tTrees_TraverseSubtree(subtree, traversal) \u003d\u003d\nif (subtree \u003c\u003e NIL)\nthen\n(\n\nSET_DATA(subtree, traversal(DATA(subtree)));\nTrees_TraverseSubtree(LEFT(subtree), traversal);\nTrees_TraverseSubtree(RIGHT(subtree), traversal)\n)","state SystemStateof\n[heap : Heaps_Heap, slist : SList_List, charQueue : Queues_Queue, charStack : Stacks_Stack, dlist : DList_List, charTree : Trees_Tree, stree : STrees_Info]\n\tinit s \u003d\u003d (s \u003d mk_SystemState(Heaps_Init(), SList_Init(), Queues_Init(), Stacks_Init(), DList_Init(), Trees_Init(), STrees_Init()))","Data \u003d Data","TestSList (() \u003d\u003d\u003e bool)\n\tTestSList() \u003d\u003d\n(\n\nslist :\u003d SList_Insert(slist, \u0027b\u0027, 1);\nslist :\u003d SList_Update(slist, \u0027a\u0027, 1);\nslist :\u003d SList_Delete(slist, 1);\nslist :\u003d SList_Insert(slist, \u0027a\u0027, 1);\nslist :\u003d SList_Insert(slist, \u0027b\u0027, 2);\nslist :\u003d SList_Update(slist, \u0027c\u0027, 2);\nslist :\u003d SList_Delete(slist, 2);\nslist :\u003d SList_Insert(slist, \u0027b\u0027, 2);\nslist :\u003d SList_Insert(slist, \u0027c\u0027, 3);\nslist :\u003d SList_Update(slist, \u0027d\u0027, 2);\nslist :\u003d SList_Update(slist, \u0027b\u0027, 3);\nslist :\u003d SList_Delete(slist, 2);\nslist :\u003d SList_Append(slist, \u0027c\u0027);\nslist :\u003d SList_Delete(slist, 1);\nslist :\u003d SList_Insert(slist, \u0027a\u0027, 1);\nslist :\u003d SList_Insert(slist, \u0027f\u0027, 4);\nslist :\u003d SList_Insert(slist, \u0027d\u0027, 4);\nslist :\u003d SList_Append(slist, \u0027g\u0027);\nslist :\u003d SList_Insert(slist, \u0027e\u0027, 5);\nslist :\u003d SList_Append(slist, \u0027h\u0027);\nslist :\u003d SList_Append(slist, \u0027i\u0027);\nslist :\u003d SList_Append(slist, \u0027j\u0027);\nslist :\u003d SList_Delete(slist, 10);\nreturn (([SList_Element(slist, i) | i in set {1, ... ,9}] \u003d \"abcdefghi\"))\n)","TestDList (() \u003d\u003d\u003e bool)\n\tTestDList() \u003d\u003d\n(\n\ndlist :\u003d DList_Insert(dlist, \u0027b\u0027, 1);\ndlist :\u003d DList_Update(dlist, \u0027a\u0027, 1);\ndlist :\u003d DList_Delete(dlist, 1);\ndlist :\u003d DList_Insert(dlist, \u0027a\u0027, 1);\ndlist :\u003d DList_Insert(dlist, \u0027b\u0027, 2);\ndlist :\u003d DList_Update(dlist, \u0027c\u0027, 2);\ndlist :\u003d DList_Delete(dlist, 2);\ndlist :\u003d DList_Insert(dlist, \u0027b\u0027, 2);\ndlist :\u003d DList_Insert(dlist, \u0027c\u0027, 3);\ndlist :\u003d DList_Update(dlist, \u0027d\u0027, 2);\ndlist :\u003d DList_Update(dlist, \u0027b\u0027, 3);\ndlist :\u003d DList_Delete(dlist, 2);\ndlist :\u003d DList_Append(dlist, \u0027c\u0027);\ndlist :\u003d DList_Delete(dlist, 1);\ndlist :\u003d DList_Insert(dlist, \u0027a\u0027, 1);\ndlist :\u003d DList_Insert(dlist, \u0027f\u0027, 4);\ndlist :\u003d DList_Insert(dlist, \u0027d\u0027, 4);\ndlist :\u003d DList_Append(dlist, \u0027g\u0027);\ndlist :\u003d DList_Insert(dlist, \u0027e\u0027, 5);\ndlist :\u003d DList_Append(dlist, \u0027h\u0027);\ndlist :\u003d DList_Append(dlist, \u0027i\u0027);\ndlist :\u003d DList_Append(dlist, \u0027j\u0027);\ndlist :\u003d DList_Delete(dlist, 10);\nreturn (([DList_Element(dlist, i) | i in set {1, ... ,9}] \u003d \"abcdefghi\"))\n)","InsertResult:STrees_Tree \u003d STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027b\u0027, 2), STrees_MkNode(\u0027c\u0027, 3), STrees_MkNode(\u0027d\u0027, 4), STrees_MkNode(\u0027e\u0027, 5), STrees_MkNode(\u0027f\u0027, 6), STrees_MkNode(\u0027g\u0027, 7), STrees_MkNode(\u0027h\u0027, 8), STrees_MkNode(\u0027i\u0027, 9), STrees_MkNode(\u0027j\u0027, 10), STrees_MkNode(\u0027k\u0027, 11), STrees_MkNode(\u0027l\u0027, 12), STrees_MkNode(\u0027m\u0027, 13), STrees_MkNode(\u0027n\u0027, 14), STrees_MkNode(\u0027o\u0027, 15), STrees_MkNode(\u0027p\u0027, 16), STrees_MkNode(\u0027q\u0027, 17), STrees_MkNode(\u0027r\u0027, 18), STrees_MkNode(\u0027s\u0027, 19), STrees_MkNode(\u0027t\u0027, 20), STrees_MkNode(\u0027u\u0027, 21), STrees_MkNode(\u0027v\u0027, 22), STrees_MkNode(\u0027w\u0027, 23), STrees_MkNode(\u0027x\u0027, 24), STrees_MkNode(\u0027y\u0027, 25), STrees_MkNode(\u0027z\u0027, 26)})","DeleteResult:STrees_Tree \u003d STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027d\u0027, 2), STrees_MkNode(\u0027c\u0027, 3), STrees_MkNode(\u0027h\u0027, 4), STrees_MkNode(\u0027i\u0027, 5), STrees_MkNode(\u0027f\u0027, 6), STrees_MkNode(\u0027o\u0027, 7), STrees_MkNode(\u0027p\u0027, 8), STrees_MkNode(\u0027r\u0027, 10), STrees_MkNode(\u0027s\u0027, 11), STrees_MkNode(\u0027l\u0027, 12), STrees_MkNode(\u0027z\u0027, 13), STrees_MkNode(\u0027j\u0027, 23), STrees_MkNode(\u0027x\u0027, 24), STrees_MkNode(\u0027y\u0027, 25), STrees_MkNode(\u0027t\u0027, 46), STrees_MkNode(\u0027u\u0027, 47), STrees_MkNode(\u0027k\u0027, 95), STrees_MkNode(\u0027v\u0027, 190), STrees_MkNode(\u0027w\u0027, 191)})","TraverseResult:STrees_Tree \u003d STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027a\u0027, 2), STrees_MkNode(\u0027a\u0027, 3), STrees_MkNode(\u0027a\u0027, 4), STrees_MkNode(\u0027a\u0027, 5), STrees_MkNode(\u0027a\u0027, 6), STrees_MkNode(\u0027b\u0027, 7), STrees_MkNode(\u0027b\u0027, 8), STrees_MkNode(\u0027b\u0027, 10), STrees_MkNode(\u0027b\u0027, 11), STrees_MkNode(\u0027b\u0027, 12), STrees_MkNode(\u0027b\u0027, 13), STrees_MkNode(\u0027a\u0027, 23), STrees_MkNode(\u0027b\u0027, 24), STrees_MkNode(\u0027b\u0027, 25), STrees_MkNode(\u0027b\u0027, 46), STrees_MkNode(\u0027b\u0027, 47), STrees_MkNode(\u0027b\u0027, 95), STrees_MkNode(\u0027b\u0027, 190), STrees_MkNode(\u0027b\u0027, 191)})","AlphabetSubset:set of (char) \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027, \u0027g\u0027, \u0027h\u0027, \u0027i\u0027, \u0027j\u0027}","private Traversal: (char -\u003e char)\n\tTraversal(ch) \u003d\u003d\n(if (ch in set AlphabetSubset)\nthen \u0027a\u0027\nelse \u0027b\u0027)","TestSTreesInsert (() \u003d\u003d\u003e bool)\n\tTestSTreesInsert() \u003d\u003d\n(\n\nstree :\u003d STrees_Insert(stree, \u0027a\u0027, \u003cToRoot\u003e);\nstree :\u003d STrees_Insert(stree, \u0027b\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027c\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027d\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027e\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRoot\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027f\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027g\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRoot\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027h\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027i\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 2);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027j\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027k\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRoot\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027l\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027m\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 2);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027n\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027o\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRoot\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027p\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027q\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 2);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027r\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027s\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 3);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027t\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027u\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 2);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027v\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027w\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRoot\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveInDir(stree, \u003cToLeft\u003e);\nstree :\u003d STrees_Insert(stree, \u0027x\u0027, \u003cToLeft\u003e);\nstree :\u003d STrees_MoveToParent(stree);\nstree :\u003d STrees_Insert(stree, \u0027y\u0027, \u003cToRight\u003e);\nstree :\u003d STrees_MoveToAnscestor(stree, 2);\nstree :\u003d STrees_MoveInDir(stree, \u003cToRight\u003e);\nstree :\u003d STrees_Insert(stree, \u0027z\u0027, \u003cToLeft\u003e);\nreturn ((STrees_GetTree(stree) \u003d InsertResult))\n)","TestSTreesDelete (() \u003d\u003d\u003e bool)\n\tTestSTreesDelete() \u003d\u003d\n(\n\nstree :\u003d STrees_MoveToNode(stree, 14);\nstree :\u003d STrees_Delete(stree);\nstree :\u003d STrees_MoveToNode(stree, 17);\nstree :\u003d STrees_Delete(stree);\nstree :\u003d STrees_MoveToNode(stree, 13);\nstree :\u003d STrees_Delete(stree);\nstree :\u003d STrees_MoveToNode(stree, 7);\nstree :\u003d STrees_Delete(stree);\nstree :\u003d STrees_MoveToNode(stree, 5);\nstree :\u003d STrees_Delete(stree);\nstree :\u003d STrees_MoveToNode(stree, 2);\nstree :\u003d STrees_Delete(stree);\nreturn ((STrees_GetTree(stree) \u003d DeleteResult))\n)","TestSTrees (() \u003d\u003d\u003e bool)\n\tTestSTrees() \u003d\u003d\n(\n\nif STrees_ExistsDirection(stree, \u003cToLeft\u003e)\nthen\nreturn (false);\nif STrees_ExistsDirection(stree, \u003cToRight\u003e)\nthen\nreturn (false);\nif (not TestSTreesInsert())\nthen\nreturn (false);\nif (not TestSTreesDelete())\nthen\nreturn (false);\nif (not STrees_ExistsData(stree, \u0027c\u0027))\nthen\nreturn (false);\nif (not STrees_ExistsNode(stree, 3))\nthen\nreturn (false);\nstree :\u003d STrees_MoveToNode(stree, 3);\nif (not STrees_ExistsDirection(stree, \u003cToLeft\u003e))\nthen\nreturn (false);\nif (not STrees_ExistsDirection(stree, \u003cToRight\u003e))\nthen\nreturn (false);\nif (not STrees_ExistsDirection(stree, \u003cToRoot\u003e))\nthen\nreturn (false);\nif (\u0027z\u0027 \u003c\u003e STrees_GetData(stree, 13))\nthen\nreturn (false);\nstree :\u003d STrees_SetCurrentNode(stree, STrees_MkNode(\u0027z\u0027, 13));\nif (STrees_MkNode(\u0027z\u0027, 13) \u003c\u003e STrees_GetCurrentNode(stree))\nthen\nreturn (false);\nstree :\u003d STrees_StoreCurrentData(stree, \u0027Z\u0027);\nif (\u0027Z\u0027 \u003c\u003e STrees_GetCurrentData(stree))\nthen\nreturn (false);\nif (STrees_Size(stree) \u003c\u003e 20)\nthen\nreturn (false);\nstree :\u003d STrees_Traverse(stree, Traversal);\nreturn ((STrees_GetTree(stree) \u003d TraverseResult))\n)","TestTreesInsert (() \u003d\u003d\u003e ())\n\tTestTreesInsert() \u003d\u003d\n(\n\ncharTree :\u003d Trees_Insert(charTree, \u0027a\u0027, \u003cToRoot\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027b\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027c\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027d\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027e\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027f\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027g\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027h\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027i\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027j\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027k\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027l\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027m\u0027, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_Insert(charTree, \u0027n\u0027, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveToParent(charTree);\ncharTree :\u003d Trees_Insert(charTree, \u0027o\u0027, \u003cToRight\u003e)\n)","TestTreesDelete (() \u003d\u003d\u003e ())\n\tTestTreesDelete() \u003d\u003d\n(\n\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToLeft\u003e);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRight\u003e);\ncharTree :\u003d Trees_Delete(charTree);\ncharTree :\u003d Trees_MoveInDir(charTree, \u003cToRoot\u003e);\ncharTree :\u003d Trees_Delete(charTree)\n)","TestTrees (() \u003d\u003d\u003e bool)\n\tTestTrees() \u003d\u003d\n(\n\nif Trees_ExistsDirection(charTree, \u003cToLeft\u003e)\nthen\nreturn (false);\nif Trees_ExistsDirection(charTree, \u003cToRight\u003e)\nthen\nreturn (false);\nTestTreesInsert();\nTestTreesDelete();\nif (not Trees_ExistsData(charTree, \u0027i\u0027))\nthen\nreturn (false);\nif Trees_ExistsDirection(charTree, \u003cToLeft\u003e)\nthen\nreturn (false);\nif (not Trees_ExistsDirection(charTree, \u003cToRight\u003e))\nthen\nreturn (false);\nif (not Trees_ExistsDirection(charTree, \u003cToRoot\u003e))\nthen\nreturn (false);\ncharTree :\u003d Trees_StoreCurrentData(charTree, \u0027Z\u0027);\nif (\u0027Z\u0027 \u003c\u003e Trees_GetCurrentData(charTree))\nthen\nreturn (false);\nif (Trees_Size(charTree) \u003c\u003e 8)\nthen\nreturn (false);\ncharTree :\u003d Trees_Traverse(charTree, Traversal);\nreturn (true)\n)"]