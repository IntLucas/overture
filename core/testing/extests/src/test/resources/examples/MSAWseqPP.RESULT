["class AirSpace is subclass of [GLOBAL]\nprivate  airspace:map (FOId) to (FO) :\u003d {|-\u003e}\nprivate  inv(forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)())))\npublic  addFO(FO) (FO \u003d\u003d\u003e ())\n\taddFO(FO)(fo) \u003d\u003d\n(\n\nairspace :\u003d (airspace munion {(fo.getId)() |-\u003e fo});\nMSAW`atc.UpdatesPresent()\n)\n\tpre ((fo.getId)() not in set (dom airspace))\npublic  removeFO(FOId) (FOId \u003d\u003d\u003e ())\n\tremoveFO(FOId)(id) \u003d\u003d\n(\n\nairspace :\u003d ({id} \u003c-: airspace);\nMSAW`atc.UpdatesPresent()\n)\npublic  getFO(FOId) (FOId \u003d\u003d\u003e FO)\n\tgetFO(FOId)(id) \u003d\u003d\nreturn (airspace(id))\n\tpre (id in set (dom airspace))\npublic  getAirspace() (() \u003d\u003d\u003e set of (FO))\n\tgetAirspace()() \u003d\u003d\nreturn ((rng airspace))\npublic  updateFO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e ())\n\tupdateFO(FOId, Coordinates, Altitude)(id, coord, alt) \u003d\u003d\n(\n\nif (id in set (dom airspace))\nthen\nlet fo:FO \u003d airspace(id) in (\n\nfo.setCoordinates(coord);\nfo.setAltitude(alt)\n)else\n(\n\nlet newfo:FO \u003d new FO(id, coord, alt) in airspace :\u003d (airspace munion {id |-\u003e newfo})\n);\nMSAW`atc.UpdatesPresent()\n)\nend AirSpace\n","class BaseThread\nprotected  period:nat1 :\u003d 1\nprotected  isPeriodic:bool :\u003d true\nprotected  BaseThread() (() \u003d\u003d\u003e BaseThread)\n\tBaseThread()() \u003d\u003d\n(\n\nWorld`timerRef.RegisterThread(self);\nif (not (World`timerRef.IsInitialising)())\nthen\nstart (self)\n)\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nis subclass responsibility\nprotected  thread (\n\nif isPeriodic\nthen\n(\n\nwhile true do (\n\nStep();\nWorld`timerRef.WaitRelative(period)\n)\n)else\n(\n\nStep();\nWorld`timerRef.WaitRelative(0);\nWorld`timerRef.UnRegisterThread()\n)\n)\nend BaseThread\n","class FO is subclass of [GLOBAL]\nprivate  id:FOId :\u003d (undefined)\nprivate  coord:Coordinates :\u003d (undefined)\nprivate  alt:Altitude :\u003d (undefined)\npublic  FO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e FO)\n\tFO(FOId, Coordinates, Altitude)(idarg, coordarg, altarg) \u003d\u003d\n(\n\nid :\u003d idarg;\ncoord :\u003d coordarg;\nalt :\u003d altarg\n)\npublic  getId() (() \u003d\u003d\u003e FOId)\n\tgetId()() \u003d\u003d\nreturn (id)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (coord)\npublic  setCoordinates(Coordinates) (Coordinates \u003d\u003d\u003e ())\n\tsetCoordinates(Coordinates)(coordarg) \u003d\u003d\ncoord :\u003d coordarg\npublic  getAltitude() (() \u003d\u003d\u003e Altitude)\n\tgetAltitude()() \u003d\u003d\nreturn (alt)\npublic  setAltitude(Altitude) (Altitude \u003d\u003d\u003e ())\n\tsetAltitude(Altitude)(altarg) \u003d\u003d\nalt :\u003d altarg\npublic  getPosition() (() \u003d\u003d\u003e Position)\n\tgetPosition()() \u003d\u003d\nreturn (mk_Position(coord, alt))\nend FO\n","class GLOBAL\npublic static  Altitude \u003d Altitude\npublic static  FOId \u003d FOId\npublic static  RadarId \u003d RadarId\npublic static  Coordinates \u003d Coordinates\npublic static  Time \u003d Time\npublic static  String \u003d String\npublic static  ObstacleType \u003d ObstacleType\npublic static  FOWarning \u003d FOWarning\npublic static  RadarWarning \u003d RadarWarning\npublic static  MinimumSafetyAltitude \u003d MinimumSafetyAltitude\npublic static  Position \u003d Position\npublic static  History \u003d History\npublic static  Vector \u003d Vector\nprotected  protected isPointInRange: (Coordinates * nat1 * Coordinates -\u003e bool)\n\tisPointInRange(center, range, point) \u003d\u003d\n(((((center.X) - (point.X)) ** 2) + (((center.Y) - (point.Y)) ** 2)) \u003c\u003d (range ** 2))\nprotected  protected vectorSum: (Vector * Vector -\u003e Vector)\n\tvectorSum(v1, v2) \u003d\u003d\nmk_Vector(((v1.X) + (v2.X)), ((v1.Y) + (v2.Y)))\nprotected  protected vectorDiv: (Vector * int -\u003e Vector)\n\tvectorDiv(v, n) \u003d\u003d\nmk_Vector(((v.X) / n), ((v.Y) / n))\n\tpre (n \u003c\u003e 0)\nprotected  protected addVectorToPoint: (Vector * Position -\u003e Coordinates)\n\taddVectorToPoint(v, p) \u003d\u003d\nmk_Coordinates((((p.coord).X) + (v.X)), (((p.coord).Y) + (v.Y)))\nprotected  protected vectorLength: (Vector -\u003e real)\n\tvectorLength(v) \u003d\u003d\nMATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))\nprotected  protected unitVector: (Vector -\u003e Vector)\n\tunitVector(v) \u003d\u003d\nlet l:real \u003d vectorLength(v) in mk_Vector(((v.X) / l), ((v.Y) / l))\nprotected  protected dotProduct: (Vector * Vector -\u003e real)\n\tdotProduct(v1, v2) \u003d\u003d\n(((v1.X) * (v2.X)) + ((v1.Y) * (v2.Y)))\nprotected  protected angleBetweenVectors: (Vector * Vector -\u003e real)\n\tangleBetweenVectors(v1, v2) \u003d\u003d\nlet uv1:Vector \u003d unitVector(v1), uv2:Vector \u003d unitVector(v2), dvs:real \u003d dotProduct(uv1, uv2), angle:real \u003d MATH`acos(dvs) in radians2degree(angle)\nprotected  protected radians2degree: (real -\u003e real)\n\tradians2degree(r) \u003d\u003d\n(r * (180 / MATH`pi))\nprotected  protected atan2: (real * real -\u003e real)\n\tatan2(y, x) \u003d\u003d\n(2 * MATH`atan((y / (MATH`sqrt(((x ** 2) + (y ** 2))) + x))))\n\tpre (not ((x \u003d 0) and (y \u003d 0)))\nprotected  protected signedVectorAngle: (Vector * Vector -\u003e real)\n\tsignedVectorAngle(v1, v2) \u003d\u003d\n(atan2((v2.Y), (v2.X)) - atan2((v1.Y), (v1.X)))\nprotected  protected vectorAngle: (Vector -\u003e (real * real))\n\tvectorAngle(v) \u003d\u003d\nmk_(radians2degree(MATH`acos(((v.X) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))), radians2degree(MATH`asin(((v.Y) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))))\nprotected  protected vectorRotate: (Vector * real -\u003e Vector)\n\tvectorRotate(v, a) \u003d\u003d\nlet x\u0027:real \u003d ((MATH`cos(a) * (v.X)) - (MATH`sin(a) * (v.Y))), y\u0027:real \u003d ((MATH`cos(a) * (v.Y)) + (MATH`sin(a) * (v.X))) in mk_Vector(round(x\u0027), round(y\u0027))\nprotected  protected round: (real -\u003e real)\n\tround(r) \u003d\u003d\nlet fr:int \u003d (floor r), dif:real \u003d (abs (r - fr)) in (if (dif \u003c (10 ** -10))\nthen fr\nelse r)\npublic  test(real, real, real, real) (real * real * real * real \u003d\u003d\u003e (Vector * Vector * real * real * Vector * real * real))\n\ttest(real, real, real, real)(x1, y1, x2, y2) \u003d\u003d\nlet v1:Vector \u003d mk_Vector(x1, y1), v2:Vector \u003d mk_Vector(x2, y2) in return (mk_(unitVector(v1), unitVector(v2), dotProduct(unitVector(v1), unitVector(v2)), atan2(1.0E-6, 0.0), vectorRotate(v2, signedVectorAngle(v1, v2)), radians2degree(signedVectorAngle(v1, v2)), angleBetweenVectors(v1, v2)))\nend GLOBAL\n","class MSAW is subclass of [GLOBAL]\npublic static  atc:AirTrafficController :\u003d new AirTrafficController(1, true)\npublic static  airspace:AirSpace :\u003d new AirSpace()\npublic static  militaryZone:Obstacle :\u003d new Obstacle(\u003cNotAllowed\u003e, mk_Coordinates(25, 0), 5, 5, \u003cMilitary_Area\u003e)\npublic static  radar1:Radar :\u003d new Radar(6, 11, 20, 1, true)\npublic static  radar2:Radar :\u003d new Radar(30, 30, 5, 1, true)\nend MSAW\n","class Radar is subclass of [GLOBAL, BaseThread]\nprivate  busy:bool :\u003d true\nprivate  location:Coordinates :\u003d (undefined)\nprivate  range:nat1 :\u003d (undefined)\nprivate  detected:map (FOId) to (FO) :\u003d (undefined)\nprivate  priority:seq of (FO) :\u003d []\nprivate  inv(forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid))\npublic  Radar(int, int, nat1, nat1, bool) (int * int * nat1 * nat1 * bool \u003d\u003d\u003e Radar)\n\tRadar(int, int, nat1, nat1, bool)(x, y, r, p, isP) \u003d\u003d\n(\n\nlocation :\u003d mk_Coordinates(x, y);\nrange :\u003d r;\ndetected :\u003d {|-\u003e};\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  Scan(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tScan(AirSpace)(as) \u003d\u003d\n(\n\ndetected :\u003d {(x.getId)() |-\u003e x | x in set (as.getAirspace)() \u0026 InRange(x)};\nUpdatePriorityList()\n)\nprivate  InRange(FO) (FO \u003d\u003d\u003e bool)\n\tInRange(FO)(fo) \u003d\u003d\nlet foLocation:Coordinates \u003d (fo.getCoordinates)() in return (isPointInRange(location, range, foLocation))\npublic  getDetected() (() \u003d\u003d\u003e set of (FO))\n\tgetDetected()() \u003d\u003d\nreturn ((rng detected))\npublic  getDetectedMap() (() \u003d\u003d\u003e map (FOId) to (FO))\n\tgetDetectedMap()() \u003d\u003d\nreturn (detected)\npublic  saturatedRadar() (() \u003d\u003d\u003e bool)\n\tsaturatedRadar()() \u003d\u003d\nreturn (((card (dom detected)) \u003e (range / 4)))\npublic  getSaturatingFOs() (() \u003d\u003d\u003e set of (FOId))\n\tgetSaturatingFOs()() \u003d\u003d\nreturn ({(priority(i).getId)() | i in set (inds priority) \u0026 (i \u003e (floor (range / 4)))})\npublic  getLocation() (() \u003d\u003d\u003e Coordinates)\n\tgetLocation()() \u003d\u003d\nreturn (location)\npublic  getRange() (() \u003d\u003d\u003e nat1)\n\tgetRange()() \u003d\u003d\nreturn (range)\nprivate  UpdatePriorityList() (() \u003d\u003d\u003e ())\n\tUpdatePriorityList()() \u003d\u003d\nlet notDetect:set of (FO) \u003d ((elems priority) \\ (rng detected)), newlyDet:map (FOId) to (FO) \u003d (detected :-\u003e (elems priority)) in (\n\nremoveNotDetected(notDetect);\naddNewlyDetected(newlyDet);\nbusy :\u003d false\n)\nprivate  removeNotDetected(set of (FO)) (set of (FO) \u003d\u003d\u003e ())\n\tremoveNotDetected(set of (FO))(fos) \u003d\u003d\npriority :\u003d [priority(i) | i in set (inds priority) \u0026 (priority(i) in set fos)]\nprivate  addNewlyDetected(map (FOId) to (FO)) (map (FOId) to (FO) \u003d\u003d\u003e ())\n\taddNewlyDetected(map (FOId) to (FO))(newlyDetect) \u003d\u003d\npriority :\u003d (priority ^ set2seqFO((rng newlyDetect)))\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nlet as:AirSpace \u003d MSAW`airspace in (\n\ndetected :\u003d {(x.getId)() |-\u003e x | x in set (as.getAirspace)() \u0026 InRange(x)};\nUpdatePriorityList()\n)\nprivate  private set2seqFO: (set of (FO) -\u003e seq of (FO))\n\tset2seqFO(fos) \u003d\u003d\n(if (fos \u003d {})\nthen []\nelse let fo in set fos in ([fo] ^ set2seqFO((fos \\ {fo}))))\nprivate  private set2seqFOm: (set of (FO) -\u003e nat)\n\tset2seqFOm(fos) \u003d\u003d\n(card fos)\nprivate  mutex(Step)\nprivate  mutex(InRange)\nprivate  mutex(UpdatePriorityList)\nprivate  per isFinished \u003d\u003e (not busy)\nprivate  mutex(removeNotDetected)\nprivate  mutex(addNewlyDetected)\nprivate  mutex(UpdatePriorityList)\nend Radar\n","class TimeStamp\npublic static  stepLength:nat \u003d 1\nprivate  currentTime:nat :\u003d 0\nprivate  wakeUpMap:map (nat) to ([nat]) :\u003d {|-\u003e}\nprivate  barrierCount:nat :\u003d 0\nprivate  registeredThreads:set of (BaseThread) :\u003d {}\nprivate  isInitialising:bool :\u003d true\npublic  TimeStamp(nat) (nat \u003d\u003d\u003e TimeStamp)\n\tTimeStamp(nat)(count) \u003d\u003d\nbarrierCount :\u003d count\npublic  RegisterThread(BaseThread) (BaseThread \u003d\u003d\u003e ())\n\tRegisterThread(BaseThread)(t) \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount + 1);\nregisteredThreads :\u003d (registeredThreads union {t})\n)\npublic  UnRegisterThread() (() \u003d\u003d\u003e ())\n\tUnRegisterThread()() \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount - 1)\n)\npublic  IsInitialising() (() \u003d\u003d\u003e bool)\n\tIsInitialising()() \u003d\u003d\nreturn (isInitialising)\npublic  DoneInitialising() (() \u003d\u003d\u003e ())\n\tDoneInitialising()() \u003d\u003d\n(\n\nif isInitialising\nthen\n(\n\nisInitialising :\u003d false;\nfor all t in set registeredThreads do\nstart (t)\n)\n)\npublic  WaitRelative(nat) (nat \u003d\u003d\u003e ())\n\tWaitRelative(nat)(val) \u003d\u003d\n(\n\nWaitAbsolute((currentTime + val))\n)\npublic  WaitAbsolute(nat) (nat \u003d\u003d\u003e ())\n\tWaitAbsolute(nat)(val) \u003d\u003d\n(\n\nAddToWakeUpMap(threadid, val);\nBarrierReached();\nAwake()\n)\nprivate  BarrierReached() (() \u003d\u003d\u003e ())\n\tBarrierReached()() \u003d\u003d\n(\n\nwhile ((card (dom wakeUpMap)) \u003d barrierCount) do (\n\ncurrentTime :\u003d (currentTime + stepLength);\nlet threadSet:set of (nat) \u003d {th | th in set (dom wakeUpMap) \u0026 ((wakeUpMap(th) \u003c\u003e nil) and (wakeUpMap(th) \u003c\u003d currentTime))} in for all t in set threadSet do\nwakeUpMap :\u003d ({t} \u003c-: wakeUpMap)\n)\n)\n\tpost (forall x in set (rng wakeUpMap) \u0026 ((x \u003d nil) or (x \u003e\u003d currentTime)))\nprivate  AddToWakeUpMap(nat, [nat]) (nat * [nat] \u003d\u003d\u003e ())\n\tAddToWakeUpMap(nat, [nat])(tId, val) \u003d\u003d\nwakeUpMap :\u003d (wakeUpMap ++ {tId |-\u003e val})\npublic  NotifyThread(nat) (nat \u003d\u003d\u003e ())\n\tNotifyThread(nat)(tId) \u003d\u003d\nwakeUpMap :\u003d ({tId} \u003c-: wakeUpMap)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nprivate  Awake() (() \u003d\u003d\u003e ())\n\tAwake()() \u003d\u003d\nskip\npublic  ThreadDone() (() \u003d\u003d\u003e ())\n\tThreadDone()() \u003d\u003d\nAddToWakeUpMap(threadid, nil)\nprivate  per Awake \u003d\u003e (threadid not in set (dom wakeUpMap))\nprivate  mutex(IsInitialising)\nprivate  mutex(DoneInitialising)\nprivate  mutex(AddToWakeUpMap)\nprivate  mutex(NotifyThread)\nprivate  mutex(BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread)\nprivate  mutex(AddToWakeUpMap, BarrierReached)\nprivate  mutex(NotifyThread, BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread, BarrierReached)\nend TimeStamp\n","class AirTrafficController is subclass of [GLOBAL, BaseThread]\nprivate  busy:bool :\u003d false\nprivate  radars:set of (Radar) :\u003d {}\nprivate  obstacles:set of (Obstacle) :\u003d {}\nprivate  history:map (FOId) to (seq of (Position)) :\u003d {|-\u003e}\npublic  AirTrafficController(nat1, bool) (nat1 * bool \u003d\u003d\u003e AirTrafficController)\n\tAirTrafficController(nat1, bool)(p, isP) \u003d\u003d\n(\n\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\nprivate  OverviewAllRadars() (() \u003d\u003d\u003e map (FOId) to (FO))\n\tOverviewAllRadars()() \u003d\u003d\nreturn ((merge {(r.getDetectedMap)() | r in set radars}))\nprivate  getDirectionVectors(FOId) (FOId \u003d\u003d\u003e seq of (Vector))\n\tgetDirectionVectors(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), p1:Position \u003d hist(3), p2:Position \u003d hist(2), p3:Position \u003d hist(1) in return ([mk_Vector((((p1.coord).X) - ((p2.coord).X)), (((p1.coord).Y) - ((p2.coord).Y))), mk_Vector((((p2.coord).X) - ((p3.coord).X)), (((p2.coord).Y) - ((p3.coord).Y)))])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  getAltitudeHistory(FOId) (FOId \u003d\u003d\u003e seq of (nat))\n\tgetAltitudeHistory(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), lastHist:seq of (Position) \u003d (hist(1, ... ,2)) in return ([(lastHist(i).altitude) | i in set (inds lastHist)])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  updateHistory() (() \u003d\u003d\u003e ())\n\tupdateHistory()() \u003d\u003d\n(\n\ncleanUpHistory();\nfor all r in set radars do\n(\n\nfor all fo in set (r.getDetected)() do\nregisterHistory(fo)\n)\n)\nprivate  registerHistory(FO) (FO \u003d\u003d\u003e ())\n\tregisterHistory(FO)(fo) \u003d\u003d\n(\n\nlet id:FOId \u003d (fo.getId)() in if (id in set (dom history))\nthen\nhistory :\u003d (history ++ {id |-\u003e addHistory(history(id), (fo.getCoordinates)(), (fo.getAltitude)())})else\nhistory :\u003d (history munion {id |-\u003e addHistory([], (fo.getCoordinates)(), (fo.getAltitude)())})\n)\nprivate  cleanUpHistory() (() \u003d\u003d\u003e ())\n\tcleanUpHistory()() \u003d\u003d\n(\n\nlet alldetected:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}), allids:set of (FOId) \u003d {(fo.getId)() | fo in set alldetected} in history :\u003d (allids \u003c: history)\n)\nprivate  private addHistory: (History * Coordinates * Altitude -\u003e History)\n\taddHistory(hist, coord, alt) \u003d\u003d\n(if ((len hist) \u003e 0)\nthen let lastValue:Position \u003d last(hist) in (if (lastValue \u003d mk_Position(coord, alt))\nthen hist\nelse (if ((len hist) \u003c 3)\nthen (hist ^ [mk_Position(coord, alt)])\nelse ((tl hist) ^ [mk_Position(coord, alt)])))\nelse (hist ^ [mk_Position(coord, alt)]))\nprivate  private last: (History -\u003e Position)\n\tlast(hist) \u003d\u003d\nhist((len hist))\n\tpre ((len hist) \u003e 0)\npublic  addRadar(Radar) (Radar \u003d\u003d\u003e ())\n\taddRadar(Radar)(r) \u003d\u003d\nradars :\u003d ({r} union radars)\npublic  addObstacle(Obstacle) (Obstacle \u003d\u003d\u003e ())\n\taddObstacle(Obstacle)(ob) \u003d\u003d\nobstacles :\u003d ({ob} union obstacles)\npublic  findThreats() (() \u003d\u003d\u003e ())\n\tfindThreats()() \u003d\u003d\nlet allFOs:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}) in (\n\nfor all fo in set allFOs do\nfor all ob in set obstacles do\nif (not isFOSafe(ob, (fo.getPosition)()))\nthen\nwriteObjectWarning(ob, fo)else\nif ((len history((fo.getId)())) \u003d 3)\nthen\nwillFObeSafe(ob, fo);\nfor all r in set radars do\nif (r.saturatedRadar)()\nthen\nwriteRadarWarning(r)\n)\npublic  UpdatesPresent() (() \u003d\u003d\u003e ())\n\tUpdatesPresent()() \u003d\u003d\nbusy :\u003d true\npublic  detectedByTwoRadars(set of (Radar)) (set of (Radar) \u003d\u003d\u003e set of (FO))\n\tdetectedByTwoRadars(set of (Radar))(radars) \u003d\u003d\nreturn ((dunion {((a.getDetected)() inter (b.getDetected)()) | a, b in set radars \u0026 (a \u003c\u003e b)}))\npublic  detectedByAllRadars(set of (Radar)) (set of (Radar) \u003d\u003d\u003e set of (FO))\n\tdetectedByAllRadars(set of (Radar))(radars) \u003d\u003d\nreturn ((dinter {(r.getDetected)() | r in set radars}))\nprivate  isFOSafe(Obstacle, Position) (Obstacle * Position \u003d\u003d\u003e bool)\n\tisFOSafe(Obstacle, Position)(obs, pos) \u003d\u003d\nlet obsloc:Coordinates \u003d (obs.getCoordinates)(), secureRange:nat1 \u003d (obs.getSecureRange)(), foloc:Coordinates \u003d (pos.coord) in return ((isPointInRange(obsloc, secureRange, foloc) \u003d\u003e isFOatSafeAltitude((obs.getMSA)(), pos)))\nprivate  isFOatSafeAltitude(MinimumSafetyAltitude, Position) (MinimumSafetyAltitude * Position \u003d\u003d\u003e bool)\n\tisFOatSafeAltitude(MinimumSafetyAltitude, Position)(msa, pos) \u003d\u003d\nreturn (((msa \u003c\u003e \u003cNotAllowed\u003e) and (msa \u003c (pos.altitude))))\nprivate  willFObeSafe(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twillFObeSafe(Obstacle, FO)(obs, fo) \u003d\u003d\nlet pred:[set of (Position)] \u003d isPredictPossible(fo) in for all p in set pred do\nif (not isFOSafe(obs, p))\nthen\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:\u003cEstimationWarning\u003e \u003d \u003cEstimationWarning\u003e, msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d (World`timerRef.GetTime)() in (\n\nWorld`env.handleFOWarningEvent(id, cs, alt, type, msa, t);\nreturn\n)\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  writeObjectWarning(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twriteObjectWarning(Obstacle, FO)(obs, fo) \u003d\u003d\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:ObstacleType \u003d (obs.getType)(), msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d (World`timerRef.GetTime)() in World`env.handleFOWarningEvent(id, cs, alt, type, msa, t)\nprivate  writeRadarWarning(Radar) (Radar \u003d\u003d\u003e ())\n\twriteRadarWarning(Radar)(r) \u003d\u003d\nlet coord:Coordinates \u003d (r.getLocation)(), range:nat1 \u003d (r.getRange)(), radWarn:\u003cSaturated\u003e \u003d \u003cSaturated\u003e, num:nat \u003d (card (r.getDetected)()), t:nat \u003d (World`timerRef.GetTime)() in World`env.handleRadarWarningEvent(coord, range, radWarn, num, t)\nprivate  isPredictPossible(FO) (FO \u003d\u003d\u003e [set of (Position)])\n\tisPredictPossible(FO)(fo) \u003d\u003d\nlet hist:seq of (Position) \u003d history((fo.getId)()) in if ((len hist) \u003c 3)\nthen\nreturn (nil)else\nreturn (predictPosition(fo))\n\tpre ((fo.getId)() in set (dom history))\nprivate  predictPosition(FO) (FO \u003d\u003d\u003e set of (Position))\n\tpredictPosition(FO)(fo) \u003d\u003d\nlet foid:FOId \u003d (fo.getId)(), vs:seq of (Vector) \u003d getDirectionVectors(foid), estVec:Vector \u003d vectorRotate(vs(1), signedVectorAngle(vs(2), vs(1))), estAlt:nat \u003d predictAltitude(getAltitudeHistory(foid)), estCoo:Coordinates \u003d addVectorToPoint(estVec, history(foid)(3)), estPos:Position \u003d mk_Position(estCoo, estAlt) in return (calculateNeighborhood(estPos))\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  private calculateNeighborhood: (Position -\u003e set of (Position))\n\tcalculateNeighborhood(pos) \u003d\u003d\n{pos, mk_Position(addVectorToPoint(mk_Vector(2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(-2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, 2), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, -2), pos), (pos.altitude))}\nprivate  private predictAltitude: (seq of (nat) -\u003e nat)\n\tpredictAltitude(alts) \u003d\u003d\n(alts(1) + (alts(1) - alts(2)))\n\tpre ((len alts) \u003d 2)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nfor all r in set radars do\nr.isFinished()\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nfor all r in set radars do\nr.Scan(MSAW`airspace);\nupdateHistory();\nfindThreats();\nbusy :\u003d false\n)\nprivate  per isFinished \u003d\u003e (not busy)\nprivate  mutex(Step)\nend AirTrafficController\n","class Environment is subclass of [GLOBAL, BaseThread]\nprivate static  InputTP \u003d InputTP\nprivate static  inline \u003d inline\nprivate static  FOOut \u003d FOOut\nprivate static  RadarOut \u003d RadarOut\nprivate static  outline \u003d outline\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (outline) :\u003d []\nprivate  airspace:[AirSpace] :\u003d nil\nprivate  busy:bool :\u003d true\nprivate  updating:bool :\u003d false\nprivate  simtime:Time :\u003d (undefined)\npublic  Environment(String, nat1, bool) (String * nat1 * bool \u003d\u003d\u003e Environment)\n\tEnvironment(String, nat1, bool)(fname, p, isP) \u003d\u003d\n(\n\nlet mk_(-, mk_(timeval, input)) \u003d ((io.freadval))[InputTP](fname) in (\n\ninlines :\u003d input;\nsimtime :\u003d timeval\n);\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  setAirSpace(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tsetAirSpace(AirSpace)(as) \u003d\u003d\nairspace :\u003d as\npublic  handleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time) (FOId * Coordinates * Altitude * FOWarning * MinimumSafetyAltitude * Time \u003d\u003d\u003e ())\n\thandleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time)(id, coord, alt, warn, msa, t) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(id, coord, alt, warn, msa, t)])\npublic  handleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time) (Coordinates * nat1 * RadarWarning * nat * Time \u003d\u003d\u003e ())\n\thandleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time)(coord, range, radWarn, num, pt) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(coord, range, radWarn, num, pt)])\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (outline)](outlines) in skip\nprivate  updateFOs() (() \u003d\u003d\u003e ())\n\tupdateFOs()() \u003d\u003d\n(\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d (World`timerRef.GetTime)()\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(id, x, y, altitude, pt) \u003d (hd inlines) in if (pt \u003c\u003d curtime)\nthen\n(\n\nairspace.updateFO(id, mk_Coordinates(x, y), altitude);\ninlines :\u003d (tl inlines);\nupdating :\u003d true;\ndone :\u003d ((len inlines) \u003d 0)\n)else\ndone :\u003d true\n)else\nbusy :\u003d false\n)\npublic  isFinished() (() \u003d\u003d\u003e ())\n\tisFinished()() \u003d\u003d\nskip\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif ((World`timerRef.GetTime)() \u003c simtime)\nthen\n(\n\nupdateFOs();\nif updating\nthen\nupdating :\u003d false\n)else\nbusy :\u003d false\n)\nprivate  mutex(handleFOWarningEvent)\nprivate  per isFinished \u003d\u003e (not busy)\nprivate  mutex(handleRadarWarningEvent)\nprivate  mutex(handleRadarWarningEvent, handleFOWarningEvent)\nend Environment\n","class Obstacle is subclass of [GLOBAL]\nprivate  MSA:MinimumSafetyAltitude :\u003d (undefined)\nprivate  location:Coordinates :\u003d (undefined)\nprivate  radius:nat1 :\u003d (undefined)\nprivate  securityRadius:nat :\u003d (undefined)\nprivate  type:ObstacleType :\u003d (undefined)\npublic  Obstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType) (MinimumSafetyAltitude * Coordinates * nat * nat * ObstacleType \u003d\u003d\u003e Obstacle)\n\tObstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType)(msa, loc, ra, secRa, tp) \u003d\u003d\n(\n\nMSA :\u003d msa;\nlocation :\u003d loc;\nradius :\u003d ra;\nsecurityRadius :\u003d secRa;\ntype :\u003d tp\n)\npublic  getType() (() \u003d\u003d\u003e ObstacleType)\n\tgetType()() \u003d\u003d\nreturn (type)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (location)\npublic  getSecureRange() (() \u003d\u003d\u003e nat1)\n\tgetSecureRange()() \u003d\u003d\nreturn ((radius + securityRadius))\npublic  getMSA() (() \u003d\u003d\u003e MinimumSafetyAltitude)\n\tgetMSA()() \u003d\u003d\nreturn (MSA)\nend Obstacle\n","class World\npublic static  env:[Environment] :\u003d nil\npublic static  timerRef:TimeStamp :\u003d new TimeStamp()\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Environment(\"scenario.txt\", 1, true);\nenv.setAirSpace(MSAW`airspace);\nMSAW`atc.addObstacle(MSAW`militaryZone);\nMSAW`atc.addRadar(MSAW`radar1);\nMSAW`atc.addRadar(MSAW`radar2);\ntimerRef.DoneInitialising()\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nenv.isFinished();\nMSAW`atc.isFinished();\nenv.showResult()\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n"]