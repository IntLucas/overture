["beta:nat1 \u003d 2","epsilon_r:real \u003d 1","epsilon_t:real \u003d 1","bytemax:int \u003d 10000","maxint:int \u003d 100000","Phi:Fl_elt \u003d mk_Fl_elt(\u003cphi\u003e, 1)","zerot:Time \u003d mk_(0, 0)","t_absreal:Time \u003d mk_(1, 1)","t_absint:Time \u003d mk_(1, 1)","t_realmonminus:Time \u003d mk_(1, 1)","t_intmonminus:Time \u003d mk_(1, 1)","t_not:Time \u003d mk_(1, 1)","t_discard:Time \u003d mk_(1, 1)","t_round:Time \u003d mk_(1, 1)","t_mantissa:Time \u003d mk_(1, 1)","t_exponent:Time \u003d mk_(1, 1)","t_odd:Time \u003d mk_(1, 1)","t_float:Time \u003d mk_(1, 1)","t_min:Time \u003d mk_(1, 1)","t_max:Time \u003d mk_(1, 1)","t_intbinop:Time \u003d mk_(1, 1)","t_realbinop:Time \u003d mk_(1, 1)","t_intcomp:Time \u003d mk_(1, 1)","t_realcomp:Time \u003d mk_(1, 1)","t_tr_eq:Time \u003d mk_(1, 1)","t_real_eq:Time \u003d mk_(1, 1)","t_int_eq:Time \u003d mk_(1, 1)","t_void_eq:Time \u003d mk_(1, 1)","t_and:Time \u003d mk_(1, 1)","t_skip:Time \u003d mk_(1, 1)","t_access:Time \u003d mk_(1, 1)","t_comp_extract:Time \u003d mk_(1, 1)","t_update:Time \u003d mk_(1, 1)","t_construct_ev:Time \u003d mk_(1, 1)","t_const_type:Time \u003d mk_(1, 1)","t_widen_type:Time \u003d mk_(1, 1)","t_if:Time \u003d mk_(1, 1)","Errvalue \u003d Errvalue","Id \u003d Id","Flavdom \u003d Flavdom","Fl_elt \u003d Fl_elt","Tr \u003d Tr","TrType \u003d TrType","EqOp \u003d EqOp","Int \u003d Int","IntType \u003d IntType","NumOp \u003d NumOp","CompOp \u003d CompOp","Real \u003d Real","Floatrng \u003d Floatrng","Float \u003d Float","Void \u003d Void","VoidType \u003d VoidType","Structure \u003d Structure","StructValue \u003d StructValue","Component \u003d Component","StructureType \u003d StructureType","CompType \u003d CompType","Vector \u003d Vector","VectorValue \u003d VectorValue","VectorType \u003d VectorType","Union \u003d Union","UnionValue \u003d UnionValue","UnionType \u003d UnionType","Expressible_type \u003d Expressible_type","Location \u003d Location","Expressible_value \u003d Expressible_value","Storable_value \u003d Storable_value","Store \u003d Store","Time \u003d Time","PState \u003d PState","Denotable_value \u003d Denotable_value","Env \u003d Env","EnvState \u003d EnvState","EST_value \u003d EST_value","EST_Iterate \u003d EST_Iterate","Param \u003d Param","Proc \u003d Proc","Formal_elt \u003d Formal_elt","Program \u003d Program","Expression \u003d Expression","Operation \u003d Operation","MonOperation \u003d MonOperation","MonOpMonOperand \u003d MonOpMonOperand","MonOp \u003d MonOp","CompileTimeOp \u003d CompileTimeOp","VectorOperation \u003d VectorOperation","VectorOp \u003d VectorOp","Multiple \u003d Multiple","ToPart \u003d ToPart","Upto \u003d Upto","Downto \u003d Downto","BinaryOperation \u003d BinaryOperation","BinaryOp \u003d BinaryOp","BoolOp \u003d BoolOp","VecBinOp \u003d VecBinOp","Value \u003d Value","ConstantValue \u003d ConstantValue","IntegerDenotation \u003d IntegerDenotation","FloatingDenotation \u003d FloatingDenotation","BooleanDenotation \u003d BooleanDenotation","Ascii_Char \u003d Ascii_Char","Ascii_string \u003d Ascii_string","NamedValue \u003d NamedValue","FlavourExtract \u003d FlavourExtract","Flavouring \u003d Flavouring","Flavour \u003d Flavour","FlavourStrip \u003d FlavourStrip","VectorExtract \u003d VectorExtract","VectorTrimming \u003d VectorTrimming","CompileTimeValue \u003d CompileTimeValue","VectorVal \u003d VectorVal","Sequence \u003d Sequence","Call \u003d Call","StructureValue \u003d StructureValue","Widening \u003d Widening","Type \u003d Type","PrimitiveType \u003d PrimitiveType","Number \u003d Number","Range \u003d Range","FloatType \u003d FloatType","VoidValType \u003d VoidValType","VecType \u003d VecType","StrucType \u003d StrucType","FlavouredType \u003d FlavouredType","UnionTp \u003d UnionTp","TypeName \u003d TypeName","Conditional \u003d Conditional","IfThenOnly \u003d IfThenOnly","IfThenElse \u003d IfThenElse","CaseExpr \u003d CaseExpr","CaseLimb \u003d CaseLimb","Tester \u003d Tester","SkeletonType \u003d SkeletonType","NumSkel \u003d NumSkel","Errors \u003d Errors","StrucSkel \u003d StrucSkel","FlavSkel \u003d FlavSkel","VecSkel \u003d VecSkel","UnionSkel \u003d UnionSkel","StrucTest \u003d StrucTest","NonStrucTest \u003d NonStrucTest","Outlimb \u003d Outlimb","OuterLoop \u003d OuterLoop","OuterIntLoop \u003d OuterIntLoop","OverRange \u003d OverRange","LoopId \u003d LoopId","OuterVecLoop \u003d OuterVecLoop","OverVectors \u003d OverVectors","OverVector \u003d OverVector","InnerLoop \u003d InnerLoop","IntLoop \u003d IntLoop","InnerControl \u003d InnerControl","PartialRange \u003d PartialRange","VecLoop \u003d VecLoop","TimeLoop \u003d TimeLoop","TimeInterval \u003d TimeInterval","Assignment \u003d Assignment","NvAssignment \u003d NvAssignment","MultAssignment \u003d MultAssignment","StrAssignment \u003d StrAssignment","Scope \u003d Scope","SimpleScope \u003d SimpleScope","Declaration \u003d Declaration","ImportDecl \u003d ImportDecl","ExportDecl \u003d ExportDecl","LetDecl \u003d LetDecl","SimpleLetDecl \u003d SimpleLetDecl","StrucLetDecl \u003d StrucLetDecl","VarDecl \u003d VarDecl","ProcDec \u003d ProcDec","NonLocals \u003d NonLocals","ProcHeading \u003d ProcHeading","Formal \u003d Formal","Representation \u003d Representation","PrimitiveRep \u003d PrimitiveRep","NumRep \u003d NumRep","FloatRep \u003d FloatRep","StrucRep \u003d StrucRep","VecRep \u003d VecRep","UnionRep \u003d UnionRep","FlavouredRep \u003d FlavouredRep","TypeDec \u003d TypeDec","PackageScope \u003d PackageScope","GuardedScope \u003d GuardedScope","GuardedDeclaration \u003d GuardedDeclaration","WhereDecl \u003d WhereDecl","Assertion \u003d Assertion","TimedExpression \u003d TimedExpression","TimeTakes \u003d TimeTakes","TimeAssertion \u003d TimeAssertion","private fl_mult: (Flavdom * Flavdom -\u003e Flavdom)\n\tfl_mult(f1, f2) \u003d\u003d\n(if (Phi in set (f1 union f2))\nthen {Phi}\nelse (({mk_Fl_elt((f.label), ((f.dim) + (f\u0027.dim))) | f in set f1, f\u0027 in set f2 \u0026 ((f.label) \u003d (f\u0027.label))} union {f | f in set f1 \u0026 (forall f\u0027 in set f2 \u0026 ((f\u0027.label) \u003c\u003e (f.label)))}) union {f | f in set f2 \u0026 (forall f\u0027 in set f1 \u0026 ((f\u0027.label) \u003c\u003e (f.label)))}))","private fl_div: (Flavdom * Flavdom -\u003e Flavdom)\n\tfl_div(f1, f2) \u003d\u003d\n(if (Phi in set (f1 union f2))\nthen {Phi}\nelse (({mk_Fl_elt((f.label), ((f.dim) - (f\u0027.dim))) | f in set f1, f\u0027 in set f2 \u0026 ((f.label) \u003d (f\u0027.label))} union {f | f in set f1 \u0026 (forall f\u0027 in set f2 \u0026 ((f\u0027.label) \u003c\u003e (f.label)))}) union {mk_Fl_elt((f.label), -(f.dim)) | f in set f2 \u0026 (forall f\u0027 in set f1 \u0026 ((f\u0027.label) \u003c\u003e (f.label)))}))","private phi_remove: (Expressible_type -\u003e Expressible_type)\n\tphi_remove(tp) \u003d\u003d\n(cases tp :\nmk_VoidType(t) -\u003e mk_VoidType((t \\ {Phi})),\nmk_TrType(range, fl) -\u003e mk_TrType(range, (fl \\ {Phi})),\nmk_IntType(rep, range, fl) -\u003e mk_IntType(rep, range, (fl \\ {Phi})),\nmk_Float(range, abse, rele, fl) -\u003e mk_Float(range, abse, rele, (fl \\ {Phi})),\nmk_VectorType(lower, upper, tp, fl) -\u003e mk_VectorType(lower, upper, tp, (fl \\ {Phi})),\nmk_StructureType(tps, fl) -\u003e mk_StructureType(tps, (fl \\ {Phi})),\nmk_UnionType(tps, fl) -\u003e mk_UnionType(tps, (fl \\ {Phi}))\n end)","private tr_eq: (Tr * Tr * EqOp -\u003e Expressible_value)\n\ttr_eq(t1, t2, op) \u003d\u003d\n(if (((t1.type).fl) \u003c\u003e ((t2.type).fl))\nthen \u003cerr\u003e\nelseif (op \u003d \u003cEQ\u003e)\nthen mk_Tr(((t1.val) \u003d (t2.val)), mk_TrType({(b1 \u003d b2) | b1 in set ((t1.type).range), b2 in set ((t2.type).range)}, {}))\nelse mk_Tr(((t1.val) \u003c\u003e (t2.val)), mk_TrType({(b1 \u003c\u003e b2) | b1 in set ((t1.type).range), b2 in set ((t2.type).range)}, {})))","private tr_and: (Tr * Tr -\u003e Expressible_value)\n\ttr_and(t1, t2) \u003d\u003d\n(if (((t1.type).fl) \u003c\u003e ((t2.type).fl))\nthen \u003cerr\u003e\nelse mk_Tr(((t1.val) and (t2.val)), mk_TrType({(b1 and b2) | b1 in set ((t1.type).range), b2 in set ((t2.type).range)}, ((t1.type).fl))))","private tr_or: (Tr * Tr -\u003e Expressible_value)\n\ttr_or(t1, t2) \u003d\u003d\n(if (((t1.type).fl) \u003c\u003e ((t2.type).fl))\nthen \u003cerr\u003e\nelse mk_Tr(((t1.val) or (t2.val)), mk_TrType({(b1 or b2) | b1 in set ((t1.type).range), b2 in set ((t2.type).range)}, ((t1.type).fl))))","private tr_not: (Tr -\u003e Expressible_value)\n\ttr_not(t) \u003d\u003d\nmk_Tr((not (t.val)), mk_TrType({(not b) | b in set ((t.type).range)}, ((t.type).fl)))","private int_eq: (Int * Int * EqOp -\u003e Expressible_value)\n\tint_eq(z1, z2, op) \u003d\u003d\n(if (((z1.type).fl) \u003c\u003e ((z2.type).fl))\nthen \u003cerr\u003e\nelseif (op \u003d \u003cEQ\u003e)\nthen mk_Tr(((z1.val) \u003d (z2.val)), mk_TrType({(i \u003d j) | i in set ((z1.type).range), j in set ((z2.type).range)}, {}))\nelse mk_Tr(((z1.val) \u003c\u003e (z2.val)), mk_TrType({(i \u003c\u003e j) | i in set ((z1.type).range), j in set ((z2.type).range)}, {})))","private min: (set of (real) -\u003e real)\n\tmin(s) \u003d\u003d\nlet m in set s in (if ((card s) \u003d 1)\nthen m\nelse let sm:real \u003d min((s \\ {m})) in (if (m \u003c sm)\nthen m\nelse sm))\n\tpre (s \u003c\u003e {})","private max: (set of (real) -\u003e real)\n\tmax(s) \u003d\u003d\nlet m in set s in (if ((card s) \u003d 1)\nthen m\nelse let sm:real \u003d max((s \\ {m})) in (if (m \u003e sm)\nthen m\nelse sm))\n\tpre (s \u003c\u003e {})","private intbinop: (Int * Int * NumOp -\u003e Expressible_value)\n\tintbinop(x, y, mk_NumOp(op)) \u003d\u003d\n(cases op :\n(\u003cnumplus\u003e) -\u003e intplus(x, y),\n(\u003cbinaryminus\u003e) -\u003e intbinminus(x, y),\n(\u003cnummult\u003e) -\u003e intmult(x, y),\n(\u003cnumdiv\u003e) -\u003e intdiv(x, y),\n(\u003cnummod\u003e) -\u003e intmod(x, y),\n(\u003cnummax\u003e) -\u003e intmax(x, y),\n(\u003cnummin\u003e) -\u003e intmin(x, y)\n end)","private intplus: (Int * Int -\u003e Expressible_value)\n\tintplus(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in (if (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((min({(abs min(range)), (abs max(range))}) \u003e\u003d bytemax) or ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e)))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in mk_Int(((x.val) + (y.val)), mk_IntType(rep, range, ((x.type).fl)))))","private intbinminus: (Int * Int -\u003e Expressible_value)\n\tintbinminus(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in (if (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((min({(abs min(range)), (abs max(range))}) \u003e\u003d bytemax) or ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e)))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in mk_Int(((x.val) - (y.val)), mk_IntType(rep, range, ((x.type).fl)))))","private intmult: (Int * Int -\u003e Expressible_value)\n\tintmult(x, y) \u003d\u003d\nlet fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in (if (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((min({(abs min(range)), (abs max(range))}) \u003e\u003d bytemax) or ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e)))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in mk_Int(((x.val) * (y.val)), mk_IntType(rep, range, fl)))","private intdiv: (Int * Int -\u003e Expressible_value)\n\tintdiv(x, y) \u003d\u003d\n(if (0 in set ((y.type).range))\nthen \u003cerr\u003e\nelse let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in (if (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if (exists r in set range \u0026 ((abs r) \u003e\u003d bytemax))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in mk_Int(((x.val) div (y.val)), mk_IntType(rep, range, fl))))","private intmod: (Int * Int -\u003e Expressible_value)\n\tintmod(x, y) \u003d\u003d\n(if (0 in set ((y.type).range))\nthen \u003cerr\u003e\nelse let range:set of (int) \u003d {(i mod j) | i in set ((x.type).range), j in set ((y.type).range)} in mk_Int(((x.val) mod (y.val)), mk_IntType(((y.type).rep), range, ((x.type).fl))))","private intmax: (Int * Int -\u003e Expressible_value)\n\tintmax(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in mk_Int(max({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))","private intmin: (Int * Int -\u003e Expressible_value)\n\tintmin(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in mk_Int(min({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))","private absint: (Int -\u003e Int)\n\tabsint(z) \u003d\u003d\nmk_Int((abs (z.val)), mk_IntType(((z.type).rep), {(abs i) | i in set ((z.type).range)}, ((z.type).fl)))","private intmonminus: (Int -\u003e Int)\n\tintmonminus(z) \u003d\u003d\nmk_Int(-(z.val), mk_IntType(((z.type).rep), {-i | i in set ((z.type).range)}, ((z.type).fl)))","private odd: (Int -\u003e Tr)\n\todd(z) \u003d\u003d\nlet range:set of (bool) \u003d {((x mod 2) \u003d 0) | x in set ((z.type).range)} in mk_Tr((((z.val) mod 2) \u003d 0), mk_TrType(range, {}))","private intcomp: (Int * Int * CompOp -\u003e Expressible_value)\n\tintcomp(x, y, op) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let p:((int * int) -\u003e bool) \u003d (lambda [mk_(i, j):(int * int)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j)\n end)) in let val:bool \u003d p(mk_((x.val), (y.val))), range:set of (bool) \u003d {p(mk_(i, j)) | i in set ((x.type).range), j in set ((y.type).range)} in mk_Tr(val, mk_TrType(range, {})))","private ascii: (char -\u003e int)\n\tascii(c) \u003d\u003d\n1","private float: (Int -\u003e Real)\n\tfloat(z) \u003d\u003d\nmk_Real((z.val), mk_Float({mk_Floatrng(min(((z.type).range)), max(((z.type).range)))}, maxint, maxint, {}))","private real_eq: (Real * Real * EqOp -\u003e Expressible_value)\n\treal_eq(r, s, op) \u003d\u003d\n(if (((r.type).fl) \u003c\u003e ((s.type).fl))\nthen \u003cerr\u003e\nelse let r1:set of (int) \u003d (dunion {{(floor (((1 - ((r.type).relerr)) * (range.lower)) - ((r.type).abserr))), ... ,(floor ((0.5 + ((1 + ((r.type).relerr)) * (range.upper))) + ((r.type).abserr)))} | range in set ((r.type).range)}), r2:set of (int) \u003d (dunion {{(floor (((1 - ((s.type).relerr)) * (range.lower)) - ((s.type).abserr))), ... ,(floor ((0.5 + ((1 + ((s.type).relerr)) * (range.upper))) + ((s.type).abserr)))} | range in set ((s.type).range)}) in let range:set of (bool) \u003d (if ((r1 inter r2) \u003d {})\nthen {false}\nelse {true, false}) in (if (op \u003d \u003cEQ\u003e)\nthen mk_Tr(((r.val) \u003d (s.val)), mk_TrType(range, {}))\nelse mk_Tr(((r.val) \u003c\u003e (s.val)), mk_TrType({(not t) | t in set range}, {}))))","private absreal: (Real -\u003e Real)\n\tabsreal(r) \u003d\u003d\nlet new_range:set of (Floatrng) \u003d {mk_Floatrng(min({(abs (range.lower)), (abs (range.upper))}), max({(abs (range.lower)), (abs (range.upper))})) | range in set ((r.type).range)} in mk_Real((abs (r.val)), mu((r.type), range |-\u003e new_range))","private realmonminus: (Real -\u003e Real)\n\trealmonminus(r) \u003d\u003d\nmk_Real(-(r.val), mu((r.type), range |-\u003e {mk_Floatrng(-(range.upper), -(range.lower)) | range in set ((r.type).range)}))","private realbinop: (Real * Real * NumOp -\u003e Expressible_value)\n\trealbinop(x, y, mk_NumOp(op)) \u003d\u003d\n(cases op :\n\u003cnumplus\u003e -\u003e realplus(x, y),\n\u003cbinaryminus\u003e -\u003e realbinminus(x, y),\n\u003cnummult\u003e -\u003e realmult(x, y),\n\u003cnumdiv\u003e -\u003e realdiv(x, y),\n\u003cnummax\u003e -\u003e realmax(x, y)\nothers \u003cerr\u003e\n end)","private realplus: (Real * Real -\u003e Expressible_value)\n\trealplus(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let As:real \u003d ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val:real \u003d ((x.val) + (y.val)), type:Float \u003d mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))","private realbinminus: (Real * Real -\u003e Expressible_value)\n\trealbinminus(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let As:real \u003d ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val:real \u003d ((x.val) - (y.val)), type:Float \u003d mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))","private realmult: (Real * Real -\u003e Expressible_value)\n\trealmult(x, y) \u003d\u003d\nlet range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let As:real \u003d ((((((Xmax * Ymax) * (((x.type).relerr) + ((y.type).relerr))) + ((((x.type).abserr) * Ymax) * (1 + ((y.type).relerr)))) + ((((y.type).abserr) * Xmax) * (1 + ((x.type).relerr)))) + (((x.type).abserr) * ((y.type).abserr))) + (epsilon_t * XYmax)), fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) * (y.val)), mk_Float(range, As, epsilon_r, fl)))","private realdiv: (Real * Real -\u003e Expressible_value)\n\trealdiv(x, y) \u003d\u003d\n(if (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))\nthen \u003cerr\u003e\nelse let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)\nthen \u003cerr\u003e\nelse let As:real \u003d ((((((Xmax * Ymax) * max({((x.type).relerr), ((y.type).relerr)})) + (Ymax * ((x.type).abserr))) + (Xmax * ((y.type).abserr))) / (Ymin ** 2)) + (epsilon_t * XYmax)), fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) / (y.val)), mk_Float(range, As, epsilon_r, fl))))","private realmax: (Real * Real -\u003e Expressible_value)\n\trealmax(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let val:real \u003d max({(x.val), (y.val)}), abserr:real \u003d max({((x.type).abserr), ((y.type).abserr)}), relerr:real \u003d max({((x.type).relerr), ((y.type).relerr)}), range:set of (Floatrng) \u003d {mk_Floatrng(max({(xr.lower), (yr.lower)}), max({(xr.upper), (yr.upper)})) | xr in set ((x.type).range), yr in set ((y.type).range)} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))","private realmin: (Real * Real -\u003e Expressible_value)\n\trealmin(x, y) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let val:real \u003d min({(x.val), (y.val)}), abserr:real \u003d max({((x.type).abserr), ((y.type).abserr)}), relerr:real \u003d max({((x.type).relerr), ((y.type).relerr)}), range:set of (Floatrng) \u003d {mk_Floatrng(min({(xr.lower), (yr.lower)}), min({(xr.upper), (yr.upper)})) | xr in set ((x.type).range), yr in set ((y.type).range)} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))","private discard: (Real -\u003e Int)\n\tdiscard(r) \u003d\u003d\nmk_Int((floor ((r.val) + 0.5)), mk_IntType(\u003cword\u003e, (dunion {{(range.lower), ... ,(range.upper)} | range in set ((r.type).range)}), {}))","private round: (Real -\u003e Int)\n\tround(r) \u003d\u003d\n(if is_((r.val), int)\nthen mk_Int((r.val), mk_IntType(\u003cword\u003e, (dunion {{(range.lower), ... ,(range.upper)} | range in set ((r.type).range)}), {}))\nelse mk_Int((floor ((r.val) + 0.5)), mk_IntType(\u003cword\u003e, (dunion {{(range.lower), ... ,(range.upper)} | range in set ((r.type).range)}), {})))","private realcomp: (Real * Real * CompOp -\u003e Expressible_value)\n\trealcomp(x, y, op) \u003d\u003d\n(if (((x.type).fl) \u003c\u003e ((y.type).fl))\nthen \u003cerr\u003e\nelse let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in let val:bool \u003d p(mk_((x.val), (y.val))), range:set of (bool) \u003d (if (max(xrange) \u003c min(yrange))\nthen {p(mk_(max(xrange), min(yrange)))}\nelseif (min(xrange) \u003e max(yrange))\nthen {p(mk_(max(yrange), min(xrange)))}\nelse {true, false}) in mk_Tr(val, mk_TrType(range, {})))","private inf: (Real -\u003e Real)\n\tinf(r) \u003d\u003d\nlet m:real \u003d ((min({(range.lower) | range in set ((r.type).range)}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))","private sup: (Real -\u003e Real)\n\tsup(r) \u003d\u003d\nlet m:real \u003d ((max({(range.upper) | range in set ((r.type).range)}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))","private absonly: (Real -\u003e Real)\n\tabsonly(mk_Real(r, f)) \u003d\u003d\nlet abse:real \u003d ((f.abserr) + (r * (f.relerr))) in mk_Real(r, mu(f, abserr |-\u003e abse, relerr |-\u003e 0))","private relonly: (Real -\u003e Real)\n\trelonly(mk_Real(r, f)) \u003d\u003d\n(if (r \u003d 0)\nthen mk_Real(r, mu(f, relerr |-\u003e 0, abserr |-\u003e 0))\nelse let rel:real \u003d ((f.relerr) + ((f.abserr) / r)) in mk_Real(r, mu(f, relerr |-\u003e rel, abserr |-\u003e 0)))","private abserr: (Real -\u003e Real)\n\tabserr(r) \u003d\u003d\nmk_Real(((r.type).abserr), mk_Float({mk_Floatrng(((r.type).abserr), ((r.type).abserr))}, 0, 0, {Phi}))","private relerr: (Real -\u003e Real)\n\trelerr(r) \u003d\u003d\nmk_Real(((r.type).relerr), mk_Float({mk_Floatrng(((r.type).relerr), ((r.type).relerr))}, 0, 0, {Phi}))","private void_eq: (Void * Void * EqOp -\u003e Expressible_value)\n\tvoid_eq(v1, v2, op) \u003d\u003d\n(if (((v1.type) \u003d (v2.type)) and (op \u003d \u003cEQ\u003e))\nthen mk_Tr(true, mk_TrType({true}, {}))\nelseif (((v1.type) \u003c\u003e (v2.type)) and (op \u003d \u003cNEQ\u003e))\nthen mk_Tr(true, mk_TrType({true}, {}))\nelse mk_Tr(false, mk_TrType({false}, {})))","private construct_ev: (Component * CompType -\u003e Expressible_value)\n\tconstruct_ev(v, t) \u003d\u003d\n(if is_(v, real)\nthen mk_Real(v, t)\nelseif is_(v, bool)\nthen mk_Tr(v, t)\nelse mk_Int(v, t))","private comp_extract: (Structure * Flavdom -\u003e Expressible_value)\n\tcomp_extract(s, fl) \u003d\u003d\nlet matches:set of (nat1) \u003d {i | i in set (inds (s.val)) \u0026 ((((s.type).tps)(i).fl) \u003d fl)} in (if ((card matches) \u003c\u003e 1)\nthen \u003cerr\u003e\nelse let {i}:set of (nat1) \u003d matches in construct_ev((s.val)(i), ((s.type).tps)(i)))","private struc_length: (StructureType -\u003e nat)\n\tstruc_length(s) \u003d\u003d\n(len (s.tps))","private vector_extract: (Vector * int -\u003e Expressible_value)\n\tvector_extract(v, i) \u003d\u003d\n(v.val)(((i - ((v.type).lower)) + 1))","private vector_subv: (VectorValue * int * int -\u003e VectorValue)\n\tvector_subv(v, l, u) \u003d\u003d\n(v(l, ... ,u))","private vector_length: (VectorType -\u003e nat)\n\tvector_length(v) \u003d\u003d\n((((v.type).upper) - ((v.type).lower)) + 1)","private vector_flatten: (VectorValue -\u003e VectorValue)\n\tvector_flatten(vs) \u003d\u003d\n(conc vs)","private vector_sum: (VectorValue -\u003e Expressible_value)\n\tvector_sum(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s)))","private vector_product: (VectorValue -\u003e Expressible_value)\n\tvector_product(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s)))","private vector_all: (VectorValue -\u003e Expressible_value)\n\tvector_all(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b)))","private vector_some: (VectorValue -\u003e Expressible_value)\n\tvector_some(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b)))","private vector_max: (VectorValue -\u003e Expressible_value)\n\tvector_max(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s)))","private vector_min: (VectorValue -\u003e Expressible_value)\n\tvector_min(v) \u003d\u003d\n(if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s)))","private vector_concat: (Vector * Vector -\u003e Vector)\n\tvector_concat(v1, v2) \u003d\u003d\nlet type:Expressible_type \u003d (if tleq(((v1.type).type), ((v2.type).type))\nthen ((v2.type).type)\nelse ((v1.type).type)), lower:int \u003d ((v1.type).lower), upper:int \u003d (((((v1.type).upper) + ((v2.type).upper)) - ((v2.type).lower)) + 1), fl:Flavdom \u003d ((v1.type).fl), vec:seq of ((Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d ((v1.val) ^ (v2.val)) in let new_type:VectorType \u003d mk_VectorType(lower, upper, type, fl) in mk_Vector(vec, new_type)","private widen_type: (Expressible_value * Expressible_type -\u003e Expressible_value)\n\twiden_type(x, type) \u003d\u003d\n(if ((x \u003d \u003cerr\u003e) or is_(x, Void))\nthen \u003cerr\u003e\nelse mu(x, type |-\u003e type))","private const_type: (Expressible_value -\u003e (Errvalue | Expressible_type))\n\tconst_type(v) \u003d\u003d\n(if is_(v, Void)\nthen (v.type)\nelseif is_(v, Vector)\nthen mk_VectorType(((v.type).lower), ((v.type).upper), seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), ((v.type).fl))\nelseif is_(v, Structure)\nthen mk_StructureType([const_type(construct_ev((v.val)(i), ((v.type).tps)(i))) | i in set (inds (v.val))], ((v.type).fl))\nelseif is_(v, Union)\nthen const_type((v.val))\nelseif (v \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_(v, Real)\nthen mk_Float({mk_Floatrng((floor (v.val)), (if is_((v.val), int)\nthen (v.val)\nelse (floor ((v.val) + 0.5))))}, ((v.type).abserr), ((v.type).relerr), ((v.type).fl))\nelseif is_(v, Int)\nthen mk_IntType(((v.type).rep), {(v.val)}, ((v.type).fl))\nelse mk_TrType({(v.val)}, ((v.type).fl)))","private fleq: (Expressible_type * Expressible_type -\u003e bool)\n\tfleq(t1, t2) \u003d\u003d\n(if (is_(t1, VoidType) and is_(t2, VoidType))\nthen (t1 \u003d t2)\nelseif (not (is_(t1, VoidType) and is_(t2, VoidType)))\nthen ((t1.fl) \u003d (t2.fl))\nelse false)","private replace_flavour: (Expressible_type * Flavdom -\u003e (Errvalue | Expressible_type))\n\treplace_flavour(type, flav) \u003d\u003d\n(cases type :\nmk_VoidType(fl) -\u003e mk_VoidType(flav),\nmk_TrType(r, f) -\u003e mk_TrType(r, flav),\nmk_Float(r, a, re, f) -\u003e mk_Float(r, a, re, flav),\nmk_IntType(rep, r, f) -\u003e mk_IntType(rep, r, flav),\nmk_VectorType(l, u, t, f) -\u003e mk_VectorType(l, u, t, flav),\nmk_UnionType(tps, fl) -\u003e mk_UnionType(tps, flav),\nmk_StructureType(tps, fl) -\u003e mk_StructureType(tps, flav)\n end)","private lub: (Expressible_type * Expressible_type -\u003e (Errvalue | Expressible_type))\n\tlub(t1, t2) \u003d\u003d\n(if (is_(t1, TrType) and (is_(t2, TrType) and fleq(t1, t2)))\nthen trlub(t1, t2)\nelseif (is_(t1, Float) and (is_(t2, Float) and fleq(t1, t2)))\nthen floatlub(t1, t2)\nelseif (is_(t1, IntType) and (is_(t2, IntType) and fleq(t1, t2)))\nthen intlub(t1, t2)\nelseif (is_(t1, VectorType) and (is_(t2, VectorType) and fleq(t1, t2)))\nthen vectorlub(t1, t2)\nelseif (is_(t1, StructureType) and (is_(t2, StructureType) and fleq(t1, t2)))\nthen struclub(t1, t2)\nelseif (is_(t1, UnionType) and (is_(t2, UnionType) and fleq(t1, t2)))\nthen unionlub(t1, t2)\nelseif (is_(t1, VoidType) and (is_(t2, VoidType) and fleq(t1, t2)))\nthen t1\nelse \u003cerr\u003e)","private trlub: (TrType * TrType -\u003e TrType)\n\ttrlub(t1, t2) \u003d\u003d\nmk_TrType(((t1.range) union (t2.range)), (t1.fl))","private floatlub: (Float * Float -\u003e Float)\n\tfloatlub(t1, t2) \u003d\u003d\nmk_Float(((t1.range) union (t2.range)), max({(t1.abserr), (t2.abserr)}), max({(t1.relerr), (t2.relerr)}), (t1.fl))","private intlub: (IntType * IntType -\u003e (Errvalue | IntType))\n\tintlub(t1, t2) \u003d\u003d\n(if (((t1.rep) \u003d \u003cbyte\u003e) and ((t2.rep) \u003d \u003cbyte\u003e))\nthen mk_IntType(\u003cbyte\u003e, ((t1.range) union (t2.range)), (t1.fl))\nelseif (((t1.rep) \u003d \u003cword\u003e) and ((t2.rep) \u003d \u003cword\u003e))\nthen mk_IntType(\u003cword\u003e, ((t1.range) union (t2.range)), (t1.fl))\nelse \u003cerr\u003e)","private vectorlub: (VectorType * VectorType -\u003e (Errvalue | VectorType))\n\tvectorlub(t1, t2) \u003d\u003d\n(if (((t1.lower) \u003c\u003e (t2.lower)) or (((t1.upper) \u003c\u003e (t2.upper)) or (lub((t1.type), (t2.type)) \u003d \u003cerr\u003e)))\nthen \u003cerr\u003e\nelse mk_VectorType((t1.lower), (t1.upper), lub((t1.type), (t2.type)), (t1.fl)))","private struclub: (StructureType * StructureType -\u003e (Errvalue | StructureType))\n\tstruclub(t1, t2) \u003d\u003d\n(if ((len (t1.tps)) \u003c\u003e (len (t2.tps)))\nthen \u003cerr\u003e\nelseif (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))\nthen \u003cerr\u003e\nelse mk_StructureType([lub((t1.tps)(i), (t2.tps)(i)) | i in set (inds (t1.tps))], (t1.fl)))","private unionlub: (UnionType * UnionType -\u003e (Errvalue | UnionType))\n\tunionlub(t1, t2) \u003d\u003d\n(if ((card (t1.tps)) \u003c\u003e (card (t2.tps)))\nthen \u003cerr\u003e\nelse let lub:(Errvalue | Expressible_type) \u003d setlub(((t1.tps) union (t2.tps))) in (if (lub \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_(lub, UnionType)\nthen mk_UnionType((lub.tps), (t1.fl))\nelse mk_UnionType({lub}, (t1.fl))))","private seqlub: (seq1 of (Expressible_type) -\u003e (Errvalue | Expressible_type))\n\tseqlub(tps) \u003d\u003d\n(if ((len tps) \u003d 1)\nthen (hd tps)\nelseif (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse lub(lub(tps(1), tps(2)), seqlub((tl tps))))","private setlub: (set of (Expressible_type) -\u003e (Errvalue | Expressible_type))\n\tsetlub(s) \u003d\u003d\n(if (exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e))\nthen (if (forall t in set s \u0026 (is_(t, TrType) or (is_(t, IntType) or (is_(t, Float) or is_(t, VoidType)))))\nthen let t1:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, TrType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, TrType)}, t2:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, IntType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, IntType)}, t3:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, Float) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, Float)}, t4:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, VoidType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, VoidType)} in (if ((exists t, t\u0027 in set (dunion {t1, t2, t3, t4}) \u0026 ((t.fl) \u003d (t\u0027.fl))) or (exists t in set (dunion {t1, t2, t3}), mk_VoidType(f) in set t4 \u0026 ((t.fl) \u003d f)))\nthen \u003cerr\u003e\nelse mk_UnionType((((t1 union t2) union t3) union t4), {}))\nelse \u003cerr\u003e)\nelse let t in set s in (if (s \u003d {t})\nthen t\nelse lub(t, setlub((s \\ {t})))))","private gt: (Expressible_type * Expressible_type -\u003e bool)\n\tgt(t1, t2) \u003d\u003d\n((lub(t1, t2) \u003d t1) or ((fleq(t1, t2) and ((is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range))))) or (((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range))))) or ((is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or ((is_(t2, Float) and (is_(t1, Float) and (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) and (((t2.abserr) + ((t2.relerr) * max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t2.range)}))) \u003c\u003d ((t1.abserr) + ((t1.relerr) * max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t1.range)}))))))) or (is_(t1, UnionType) and (is_(t2, UnionType) and (forall t in set (t1.tps) \u0026 (exists t\u0027 in set (t2.tps) \u0026 (lub(t, t\u0027) \u003d t)))))))))) or (is_(t2, UnionType) and (exists t in set (t2.tps) \u0026 gt(t1, t)))))","private tleq: (Expressible_type * Expressible_type -\u003e bool)\n\ttleq(t1, t2) \u003d\u003d\n(lub(t1, t2) \u003d t2)","private next_locn: (Location -\u003e Location)\n\tnext_locn(mk_Location(l)) \u003d\u003d\nmk_Location((l + 1))","private access: (Location -\u003e (Store -\u003e Storable_value))\n\taccess(l)(s) \u003d\u003d\ns(l)","private update: (Location -\u003e (Storable_value -\u003e (Store -\u003e Store)))\n\tupdate(l)(v)(s) \u003d\u003d\n(s ++ {l |-\u003e v})","private multi_update: (seq of (Location) -\u003e (seq of (Storable_value) -\u003e (Store -\u003e Store)))\n\tmulti_update(ls)(vs)(s) \u003d\u003d\n(if (ls \u003d [])\nthen s\nelse multi_update((tl ls))((tl vs))((s ++ {(hd ls) |-\u003e (hd vs)})))\n\tpre ((len ls) \u003d (len vs))","private timeleq: (Time * Time -\u003e bool)\n\ttimeleq(mk_(lt1, ut1), mk_(lt2, ut2)) \u003d\u003d\n((lt2 \u003c\u003d lt1) and ((lt1 \u003c\u003d ut1) and (ut1 \u003c\u003d ut2)))","private access_env: (Id -\u003e (Env -\u003e Denotable_value))\n\taccess_env(i)(mk_(m, l)) \u003d\u003d\nm(i)","private update_env: (Id -\u003e (Denotable_value -\u003e (Env -\u003e Env)))\n\tupdate_env(i)(d)(mk_(m, l)) \u003d\u003d\nmk_((m ++ {i |-\u003e d}), l)","private empty_env: (Location -\u003e Env)\n\tempty_env(l) \u003d\u003d\nmk_({|-\u003e}, l)","private multi_update_env: (seq of ((Id * Denotable_value)) -\u003e (Env -\u003e Env))\n\tmulti_update_env(s)(e) \u003d\u003d\n(if (s \u003d [])\nthen e\nelse let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in multi_update_env((tl s))(update_env(id)(v)(e)))","private reserve_locn: (Env -\u003e (Location * Env))\n\treserve_locn(mk_(m, l)) \u003d\u003d\nmk_(l, mk_(m, next_locn(l)))","private instantiate_formals: (seq of (Formal_elt) -\u003e (Param -\u003e (Env -\u003e (Env | Errvalue))))\n\tinstantiate_formals(formals)(params)(e) \u003d\u003d\n(if ((len formals) \u003c\u003e (len params))\nthen \u003cerr\u003e\nelse let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in (if (false in set (elems lubs_eq))\nthen \u003cerr\u003e\nelse let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in multi_update_env([mk_((formals(i).id), vals(i)) | i in set (inds vals)])(e)))","private mantissa: (Real -\u003e Real)\n\tmantissa(r) \u003d\u003d\nr","private exponent: (Real -\u003e Real)\n\texponent(r) \u003d\u003d\nr","private tplus: (Time * Time -\u003e Time)\n\ttplus(mk_(l1, u1), mk_(l2, u2)) \u003d\u003d\nmk_((l1 + l2), (u1 + u2))","private dtplus: (seq of (Time) -\u003e Time)\n\tdtplus(ts) \u003d\u003d\n(if (ts \u003d [])\nthen zerot\nelse tplus((hd ts), dtplus((tl ts))))","private t_trimming_op: (int -\u003e Time)\n\tt_trimming_op(l) \u003d\u003d\nmk_(1, 1)","private t_vector_extract: (int -\u003e Time)\n\tt_vector_extract(l) \u003d\u003d\nmk_(1, 1)","private t_vector_concat: (int * int -\u003e Time)\n\tt_vector_concat(l, m) \u003d\u003d\nmk_(1, 1)","private t_vectorsum: (int -\u003e Time)\n\tt_vectorsum(l) \u003d\u003d\nmk_(1, 1)","private t_vectorproduct: (int -\u003e Time)\n\tt_vectorproduct(l) \u003d\u003d\nmk_(1, 1)","private t_vector_all: (int -\u003e Time)\n\tt_vector_all(l) \u003d\u003d\nmk_(1, 1)","private t_vector_some: (int -\u003e Time)\n\tt_vector_some(l) \u003d\u003d\nmk_(1, 1)","private t_vector_max: (int -\u003e Time)\n\tt_vector_max(l) \u003d\u003d\nmk_(1, 1)","private t_vector_min: (int -\u003e Time)\n\tt_vector_min(l) \u003d\u003d\nmk_(1, 1)","private t_vector_flatten: (int -\u003e Time)\n\tt_vector_flatten(l) \u003d\u003d\nmk_(1, 1)","private t_vector_subv: (int -\u003e Time)\n\tt_vector_subv(l) \u003d\u003d\nmk_(1, 1)","private t_multi_update: (int -\u003e Time)\n\tt_multi_update(l) \u003d\u003d\nmk_(1, 1)","private choose: (Expressible_type -\u003e Expressible_value)\n\tchoose(tp) \u003d\u003d\nlet val:Expressible_value be st (lub(const_type(val), tp) \u003d tp) in widen_type(const_type(val), tp)","private eval_Program: (Program -\u003e (Location -\u003e (Store -\u003e EST_value)))\n\teval_Program(mk_Program(expr))(l)(sto) \u003d\u003d\neval_Expression(expr)(empty_env(l))(mk_PState(sto, zerot))","private eval_Expression: (Expression -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Expression(mk_Expression(expr))(env)(ps) \u003d\u003d\n(cases expr :\nmk_Operation(op) -\u003e eval_Operation(expr)(env)(ps),\nmk_InnerLoop(l) -\u003e eval_InnerLoop(expr)(env)(ps),\nmk_Assignment(a) -\u003e eval_Assignment(expr)(env)(ps),\nmk_Scope(s) -\u003e eval_Scope(expr)(env)(ps),\nmk_GuardedScope(d, i, o) -\u003e eval_GuardedScope(expr)(env)(ps),\nmk_Assertion(exp, tp) -\u003e eval_Assertion(expr)(env)(ps),\nmk_TimedExpression(t) -\u003e eval_TimedExpression(expr)(env)(ps)\n end)","private eval_Operation: (Operation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Operation(mk_Operation(op))(e)(ps) \u003d\u003d\n(cases op :\nmk_MonOperation(mo) -\u003e eval_MonOperation(op)(e)(ps),\nmk_BinaryOperation(l, bo, r) -\u003e eval_BinaryOperation(op)(e)(ps)\n end)","private eval_MonOperation: (MonOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_MonOperation(mk_MonOperation(mo))(e)(ps) \u003d\u003d\n(cases mo :\nmk_MonOpMonOperand(opr, opnd) -\u003e eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)(ps),\nmk_VectorOperation(v, m, op) -\u003e eval_VectorOperation(mk_VectorOperation(v, m, op))(e)(ps),\nmk_Value(v) -\u003e eval_Value(mk_Value(v))(e)(ps)\n end)","private eval_MonOpMonOperand: (MonOpMonOperand -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse (cases opr :\n\u003cnumabs\u003e -\u003e eval_Abs(x),\n\u003cunaryminus\u003e -\u003e eval_MonMinus(x),\n\u003cnot\u003e -\u003e eval_Not(x),\nmk_CompileTimeOp(o) -\u003e eval_CompileTimeOp(opr)(x),\n\u003cdiscard\u003e -\u003e eval_Discard(x),\n\u003cround\u003e -\u003e eval_Round(x),\n\u003codd\u003e -\u003e eval_Odd(x),\n\u003cfloat\u003e -\u003e eval_Float(x),\n\u003cmantissa\u003e -\u003e eval_Mantissa(x),\n\u003cexponent\u003e -\u003e eval_Exponent(x)\n end))","private eval_Abs: (EST_value -\u003e EST_value)\n\teval_Abs(mk_EST_value(val, sto, time)) \u003d\u003d\n(if is_(val, Real)\nthen mk_EST_value(absreal(val), sto, tplus(time, t_absreal))\nelseif is_(val, Int)\nthen mk_EST_value(absint(val), sto, tplus(time, t_absint))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_MonMinus: (EST_value -\u003e EST_value)\n\teval_MonMinus(mk_EST_value(val, sto, time)) \u003d\u003d\n(if is_(val, Real)\nthen mk_EST_value(realmonminus(val), sto, tplus(time, t_realmonminus))\nelseif is_(val, Int)\nthen mk_EST_value(intmonminus(val), sto, tplus(time, t_intmonminus))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_Not: (EST_value -\u003e EST_value)\n\teval_Not(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Tr))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(tr_not(val), sto, tplus(time, t_not)))","private eval_CompileTimeOp: (CompileTimeOp -\u003e (EST_value -\u003e EST_value))\n\teval_CompileTimeOp(mk_CompileTimeOp(op))(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse (cases op :\n\u003cinf\u003e -\u003e mk_EST_value(inf(val), sto, time),\n\u003csup\u003e -\u003e mk_EST_value(sup(val), sto, time),\n\u003cabsonly\u003e -\u003e mk_EST_value(absonly(val), sto, time),\n\u003crelonly\u003e -\u003e mk_EST_value(relonly(val), sto, time),\n\u003cabserr\u003e -\u003e mk_EST_value(abserr(val), sto, time),\n\u003crelerr\u003e -\u003e mk_EST_value(relerr(val), sto, time)\n end))","private eval_Discard: (EST_value -\u003e EST_value)\n\teval_Discard(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(discard(val), sto, tplus(time, t_discard)))","private eval_Round: (EST_value -\u003e EST_value)\n\teval_Round(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(round(val), sto, tplus(time, t_round)))","private eval_Mantissa: (EST_value -\u003e EST_value)\n\teval_Mantissa(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(mantissa(val), sto, tplus(time, t_mantissa)))","private eval_Exponent: (EST_value -\u003e EST_value)\n\teval_Exponent(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(exponent(val), sto, tplus(time, t_exponent)))","private eval_Odd: (EST_value -\u003e EST_value)\n\teval_Odd(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(odd(val), sto, tplus(time, t_odd)))","private eval_Float: (EST_value -\u003e EST_value)\n\teval_Float(mk_EST_value(val, sto, time)) \u003d\u003d\n(if (not is_(val, Real))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(float(val), sto, tplus(time, t_float)))","private eval_VectorOperation: (VectorOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_VectorOperation(mk_VectorOperation(vo, mo, mult))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in (if (not is_((x.val), Vector))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let v:EST_value \u003d (if (mult \u003d nil)\nthen x\nelse eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))(mult)(e)) in (if ((v.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse (cases vo :\n\u003csum\u003e -\u003e eval_VectorSum(v),\n\u003cproduct\u003e -\u003e eval_VectorProduct(v),\n\u003cvecmax\u003e -\u003e eval_VectorMax(v),\n\u003cvecmin\u003e -\u003e eval_VectorMin(v),\n\u003call\u003e -\u003e eval_VectorAll(v),\n\u003csome\u003e -\u003e eval_VectorSome(v),\n\u003cflatten\u003e -\u003e eval_VectorFlatten(v)\n end)))","private eval_VectorMult: (EST_value -\u003e (Multiple -\u003e (Env -\u003e EST_value)))\n\teval_VectorMult(mk_EST_value(est_val, sto, time))(mk_Multiple(op, to_p))(e) \u003d\u003d\nlet mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelseif (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in (if ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse let new_val:VectorValue \u003d vector_subv(val, lower, upper), new_type:VectorType \u003d mk_VectorType(lower, upper, (type.type), (type.fl)) in let new_v:Vector \u003d mk_Vector(new_val, new_type), new_t:Time \u003d tplus(tplus((b2.time), t_vector_subv((upper - lower))), tplus(t_min, t_max)) in mk_EST_value(new_v, sto, new_t)))","private eval_VectorSum: (EST_value -\u003e EST_value)\n\teval_VectorSum(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (is_((type.type), Float) or is_((type.type), IntType))\nthen mk_EST_value(vector_sum(val), sto, tplus(time, t_vectorsum(((type.upper) - (type.lower)))))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_VectorProduct: (EST_value -\u003e EST_value)\n\teval_VectorProduct(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (is_((type.type), Float) or is_((type.type), IntType))\nthen mk_EST_value(vector_product(val), sto, tplus(time, t_vectorproduct(((type.upper) - (type.lower)))))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_VectorMax: (EST_value -\u003e EST_value)\n\teval_VectorMax(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (is_((type.type), Float) or is_((type.type), IntType))\nthen mk_EST_value(vector_max(val), sto, tplus(time, t_vector_max(((type.upper) - (type.lower)))))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_VectorMin: (EST_value -\u003e EST_value)\n\teval_VectorMin(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (is_((type.type), Float) or is_((type.type), IntType))\nthen mk_EST_value(vector_min(val), sto, tplus(time, t_vector_min(((type.upper) - (type.lower)))))\nelse mk_EST_value(\u003cerr\u003e, sto, zerot))","private eval_VectorAll: (EST_value -\u003e EST_value)\n\teval_VectorAll(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (not is_((type.type), TrType))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(vector_all(val), sto, tplus(time, t_vector_all(((type.upper) - (type.lower))))))","private eval_VectorSome: (EST_value -\u003e EST_value)\n\teval_VectorSome(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (not is_((type.type), TrType))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse mk_EST_value(vector_some(val), sto, tplus(time, t_vector_some(((type.upper) - (type.lower))))))","private eval_VectorFlatten: (EST_value -\u003e EST_value)\n\teval_VectorFlatten(mk_EST_value(mk_Vector(val, type), sto, time)) \u003d\u003d\n(if (not is_((type.type), VectorType))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse let new_val:VectorValue \u003d vector_flatten(val) in let new_upper:int \u003d (((len new_val) + (type.lower)) - 1) in let new_time:Time \u003d tplus(time, t_vector_flatten(((type.upper) - (type.lower)))), new_type:VectorType \u003d mk_VectorType((type.lower), new_upper, (type.type), (type.fl)) in mk_EST_value(mk_Vector(new_val, new_type), sto, new_time))","private eval_BinaryOperation: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_BinaryOperation(bo)(e)(ps) \u003d\u003d\nlet mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in (cases op :\nmk_NumOp(opr) -\u003e eval_NumOp(bo)(e)(ps),\n\u003cnumgt\u003e -\u003e eval_CompOp(bo)(e)(ps),\n\u003cnumlt\u003e -\u003e eval_CompOp(bo)(e)(ps),\n\u003cnumge\u003e -\u003e eval_CompOp(bo)(e)(ps),\n\u003cnumle\u003e -\u003e eval_CompOp(bo)(e)(ps),\n\u003cand\u003e -\u003e eval_BoolOp(bo)(e)(ps),\n\u003cor\u003e -\u003e eval_BoolOp(bo)(e)(ps),\n\u003cEQ\u003e -\u003e eval_EqOp(bo)(e)(ps),\n\u003cNEQ\u003e -\u003e eval_EqOp(bo)(e)(ps),\n\u003cconcat\u003e -\u003e eval_Concat(bo)(e)(ps)\n end)","private eval_NumOp: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_NumOp(mk_BinaryOperation(left, mk_BinaryOp(opr), right))(e)(ps) \u003d\u003d\nlet a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in (cases opr :\nmk_NumOp(op) -\u003e (cases mk_((a1.val), (a2.val)) :\nmk_(mk_Int(v1, t1), mk_Int(v2, t2)) -\u003e (if (op \u003c\u003e \u003cnumdiv\u003e)\nthen let val:Expressible_value \u003d intbinop(mk_Int(v1, t1), mk_Int(v2, t2), mk_NumOp(op)) in (if (val \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse mk_EST_value(val, (ps.sto), tplus((a2.time), t_intbinop)))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)),\nmk_(mk_Real(v1, t1), mk_Real(v2, t2)) -\u003e (if (op not in set {\u003cnumdiv\u003e, \u003cnummod\u003e})\nthen let val:Expressible_value \u003d realbinop(mk_Real(v1, t1), mk_Real(v2, t2), mk_NumOp(op)) in (if (val \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse mk_EST_value(val, (ps.sto), tplus((a2.time), t_realbinop)))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))\nothers mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\n end),\n\u003creplaceflav\u003e -\u003e (if (((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void))\nthen let mk_VoidType(f):(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((a2.val).type) in mk_EST_value(mu((a1.val), type |-\u003e replace_flavour(((a1.val).type), f)), (ps.sto), (a2.time))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))\nothers mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\n end)","private eval_CompOp: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_CompOp(mk_BinaryOperation(left, mk_BinaryOp(opr), right))(e)(ps) \u003d\u003d\nlet a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in (if (is_((a1.val), Int) and is_((a2.val), Int))\nthen mk_EST_value(intcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_intcomp))\nelseif (is_((a1.val), Real) and is_((a2.val), Real))\nthen mk_EST_value(realcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_realcomp))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private eval_EqOp: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_EqOp(mk_BinaryOperation(left, mk_BinaryOp(op), right))(e)(ps) \u003d\u003d\nlet a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in (if (is_((a1.val), Tr) and is_((a2.val), Tr))\nthen mk_EST_value(tr_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_tr_eq))\nelseif (is_((a1.val), Real) and is_((a2.val), Real))\nthen mk_EST_value(real_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_real_eq))\nelseif (is_((a1.val), Int) and is_((a2.val), Int))\nthen mk_EST_value(int_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_int_eq))\nelseif (is_((a1.val), Void) and is_((a2.val), Void))\nthen mk_EST_value(void_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_void_eq))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private eval_BoolOp: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_BoolOp(mk_BinaryOperation(left, mk_BinaryOp(op), right))(e)(ps) \u003d\u003d\nlet a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in (if (not (is_((a2.val), Tr) and is_((a2.val), Tr)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse (cases op :\n\u003cand\u003e -\u003e mk_EST_value(tr_and((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and)),\n\u003cor\u003e -\u003e mk_EST_value(tr_or((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and))\n end))","private eval_Concat: (BinaryOperation -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Concat(mk_BinaryOperation(left, op, right))(e)(ps) \u003d\u003d\nlet a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in (if (not (is_((a1.val), Vector) and is_((a2.val), Vector)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let new_vec:Vector \u003d vector_concat((a1.val), (a2.val)), new_time:Time \u003d tplus((a2.time), t_vector_concat(vector_length(((a1.val).type)), vector_length(((a2.val).type)))) in mk_EST_value(new_vec, (ps.sto), new_time))","private eval_Value: (Value -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Value(mk_Value(val))(e)(ps) \u003d\u003d\n(cases val :\nmk_ConstantValue(c) -\u003e eval_ConstantValue(mk_ConstantValue(c))(ps),\nmk_NamedValue(n) -\u003e eval_NamedValue(mk_NamedValue(n))(e)(ps),\nmk_VectorVal(v) -\u003e eval_VectorVal(mk_VectorVal(v))(e)(ps),\nmk_StructureValue(s) -\u003e eval_StructureValue(mk_StructureValue(s))(e)(ps),\nmk_Sequence(s) -\u003e eval_Sequence(mk_Sequence(s))(e)(ps),\nmk_Call(id, acts) -\u003e eval_Call(mk_Call(id, acts))(e)(ps),\nmk_Conditional(c) -\u003e eval_Conditional(val)(e)(ps),\nmk_Widening(exp, t) -\u003e eval_Widening(val)(e)(ps),\nmk_OuterLoop(l) -\u003e eval_OuterLoop(val)(e)(ps)\n end)","private eval_ConstantValue: (ConstantValue -\u003e (PState -\u003e EST_value))\n\teval_ConstantValue(mk_ConstantValue(cv))(ps) \u003d\u003d\n(cases cv :\nmk_IntegerDenotation(z) -\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((abs z) \u003e\u003d bytemax)\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in mk_EST_value(mk_Int(z, mk_IntType(rep, {z}, {})), (ps.sto), (ps.time)),\nmk_FloatingDenotation(r) -\u003e mk_EST_value(mk_Real(r, mk_Float({mk_Floatrng((floor r), (if is_(r, int)\nthen r\nelse (floor (r + 0.5))))}, 0, 0, {})), (ps.sto), (ps.time)),\nmk_BooleanDenotation(b) -\u003e mk_EST_value(mk_Tr(b, mk_TrType({b}, {})), (ps.sto), (ps.time)),\nmk_Ascii_Char(c) -\u003e mk_EST_value(mk_Int(ascii(c), mk_IntType(\u003cbyte\u003e, {ascii(c)}, {})), (ps.sto), (ps.time)),\nmk_Ascii_string(s) -\u003e mk_EST_value(mk_Vector([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], mk_VectorType(1, (len s), seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), {})), (ps.sto), (ps.time)),\nmk_Flavouring(fl) -\u003e mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType(eval_Flavouring(cv))), (ps.sto), (ps.time)),\n\u003cskip\u003e -\u003e mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), tplus((ps.time), t_skip))\n end)","private eval_NamedValue: (NamedValue -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_NamedValue(mk_NamedValue(nv))(e)(ps) \u003d\u003d\n(cases nv :\nmk_FlavourExtract(n, fl) -\u003e eval_FlavourExtract(nv)(e)(ps),\nmk_FlavourStrip(n, fl) -\u003e eval_FlavourStrip(nv)(e)(ps),\nmk_VectorExtract(n, i) -\u003e eval_VectorExtract(nv)(e)(ps),\nmk_VectorTrimming(n, t, i) -\u003e eval_VectorTrimming(nv)(e)(ps)\nothers eval_Identifier(nv)(e)(ps)\n end)","private eval_Identifier: (Id -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Identifier(id)(mk_(m, l))(mk_PState(sto, time)) \u003d\u003d\n(if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e let mk_Storable_value(v):Storable_value \u003d access(mk_Location(l))(sto) in mk_EST_value(v, sto, tplus(time, t_access)),\nmk_Storable_value(v) -\u003e mk_EST_value(v, sto, time)\n end)\nelse mk_EST_value(\u003cerr\u003e, sto, time))","private eval_FlavourExtract: (FlavourExtract -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_FlavourExtract(mk_FlavourExtract(nv, fl))(e)(ps) \u003d\u003d\nlet n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in (if (not is_((n.val), Structure))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), (ps.time))\nelse mk_EST_value(comp_extract((n.val), f), (ps.sto), tplus((n.time), t_comp_extract)))","private eval_Flavouring: (Flavouring -\u003e Flavdom)\n\teval_Flavouring(mk_Flavouring(fls)) \u003d\u003d\n(if (fls \u003d [])\nthen {}\nelse ({eval_Flavour((hd fls))} union eval_Flavouring(mk_Flavouring((tl fls)))))","private eval_Flavour: (Flavour -\u003e Fl_elt)\n\teval_Flavour(mk_Flavour(name, index)) \u003d\u003d\nmk_Fl_elt(name, index)","private eval_FlavourStrip: (FlavourStrip -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_FlavourStrip(mk_FlavourStrip(nv, fl))(e)(ps) \u003d\u003d\nlet n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in (if (not is_((n.val), Structure))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), (ps.time))\nelse let n\u0027:Expressible_value \u003d comp_extract((n.val), f) in let n\u0027\u0027:Structure \u003d mk_Structure((n\u0027.val), mk_StructureType(((n\u0027.type).tps), {})) in mk_EST_value(n\u0027\u0027, (ps.sto), tplus((n.time), t_comp_extract)))","private eval_VectorExtract: (VectorExtract -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_VectorExtract(mk_VectorExtract(n, i))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_NamedValue(n)(e)(ps) in (if (not is_((x.val), Vector))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), (ps.time))\nelse let index:EST_value \u003d eval_Operation(i)(e)(mu(ps, time |-\u003e (x.time))), length:int \u003d (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in (if (not is_((index.val), Int))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), (ps.time))\nelseif (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), (ps.time))\nelse mk_EST_value(vector_extract((x.val), ((index.val).val)), (ps.sto), tplus((index.time), t_vector_extract(length)))))","private eval_VectorTrimming: (VectorTrimming -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_VectorTrimming(mk_VectorTrimming(name, to_p, ctv))(e)(ps) \u003d\u003d\nlet vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in (if ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in (if (not (is_((v.val), Real) or is_((v.val), Int)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in (if (new_v \u003d [])\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let new_l:int \u003d (((vec.val).type).lower), new_u:int \u003d (((((vec.val).type).lower) + (len new_v)) - 1), new_t:(Errvalue | Expressible_type) \u003d seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl:Flavdom \u003d (((vec.val).type).fl) in let new_vec:Vector \u003d mk_Vector(new_v, mk_VectorType(new_l, new_u, new_t, new_fl)), new_time:Time \u003d tplus((vec.time), t_trimming_op((new_u - new_l))) in mk_EST_value(new_vec, (ps.sto), new_time))))","private eval_CompileTimeValue: (CompileTimeValue -\u003e (Env -\u003e EST_value))\n\teval_CompileTimeValue(mk_CompileTimeValue(op))(mk_(m, l)) \u003d\u003d\nlet locs:set of (Id) \u003d {id | id in set (dom m) \u0026 is_(m(id), Location)} in let new_m:map (Id) to (Denotable_value) \u003d (locs \u003c-: m) in let new_env:(map (Id) to (Denotable_value) * Location) \u003d mk_(new_m, l) in eval_Operation(op)(new_env)(mk_PState({|-\u003e}, zerot))","private eval_VectorVal: (VectorVal -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_VectorVal(mk_VectorVal(ops))(e)(ps) \u003d\u003d\nlet vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in (if (\u003cerr\u003e in set (elems val))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d seqlub([(val(i).type) | i in set (inds val)]) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let tp:VectorType \u003d mk_VectorType(1, (len val), type, {}) in let x:Vector \u003d mk_Vector(val, tp) in mk_EST_value(x, (ps.sto), time)))","private eval_StructureValue: (StructureValue -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_StructureValue(mk_StructureValue(ops))(e)(ps) \u003d\u003d\nlet vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (if (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [((vals(i).val).type) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]), comps:seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) \u003d [((vals(i).val).val) | i in set (inds vals)] in let type:StructureType \u003d mk_StructureType(tps, {}) in let val:Structure \u003d mk_Structure(comps, type) in mk_EST_value(val, (ps.sto), time))","private eval_Sequence: (Sequence -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Sequence(mk_Sequence(exprs))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression((hd exprs))(e)(ps) in (if ((len exprs) \u003d 1)\nthen x\nelseif is_((x.val), Void)\nthen eval_Sequence(mk_Sequence((tl exprs)))(e)(mk_PState((x.sto), (x.time)))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private eval_Call: (Call -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Call(mk_Call(id, acts))(mk_(m, l))(mk_PState(sto, time)) \u003d\u003d\n(if (id not in set (dom m))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in (if (not is_(pp, Proc))\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in (if (\u003cerr\u003e in set {(x.val) | x in set (elems params)})\nthen mk_EST_value(\u003cerr\u003e, sto, zerot)\nelse p([(params(i).val) | i in set (inds params)])(mk_PState(sto, (params((len params)).time))))))","private eval_Acts: (seq of (Operation) -\u003e (Env -\u003e (PState -\u003e seq of (EST_value))))\n\teval_Acts(ops)(e)(ps) \u003d\u003d\n(if (ops \u003d [])\nthen []\nelse let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in ([x] ^ eval_Acts((tl ops))(e)(mk_PState((ps.sto), (x.time)))))","private eval_Widening: (Widening -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Widening(mk_Widening(expr, dest_type))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let xt:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type), dt:(Errvalue | Expressible_type) \u003d eval_Type(dest_type)(e) in (if (dt \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let dt\u0027:Expressible_type \u003d phi_remove(dt) in (if gt(dt\u0027, xt)\nthen mk_EST_value(widen_type((x.val), dt\u0027), (ps.sto), (x.time))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))))","private eval_Type: (Type -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_Type(mk_Type(tp))(e) \u003d\u003d\n(cases tp :\nmk_PrimitiveType(p) -\u003e eval_PrimitiveType(tp)(e),\nmk_VecType(range, tpe) -\u003e eval_VecType(tp)(e),\nmk_StrucType(tps) -\u003e eval_StrucType(tp)(e),\nmk_FlavouredType(fl, tpe) -\u003e eval_FlavouredType(tp)(e),\nmk_UnionTp(tps) -\u003e eval_UnionTp(tp)(e),\nmk_TypeName(id) -\u003e eval_TypeName(tp)(e)\n end)","private eval_PrimitiveType: (PrimitiveType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_PrimitiveType(mk_PrimitiveType(pt))(e) \u003d\u003d\n(if is_(pt, Number)\nthen eval_Number(pt)(e)\nelseif is_(pt, FloatType)\nthen eval_FloatType(pt)(e)\nelse eval_VoidValType(pt)(e))","private eval_Number: (Number -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_Number(mk_Number(rep, range))(e) \u003d\u003d\nlet ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in (if (\u003cerr\u003e in set ranges)\nthen \u003cerr\u003e\nelseif (rep \u003d \u003cbit\u003e)\nthen (if (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))\nthen \u003cerr\u003e\nelse let m:map (nat) to (bool) \u003d {0 |-\u003e false, 1 |-\u003e true} in mk_TrType({m(v) | v in set (dunion ranges)}, {}))\nelseif (rep \u003d \u003cbyte\u003e)\nthen (if (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))\nthen \u003cerr\u003e\nelse mk_IntType(rep, (dunion ranges), {}))\nelseif (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))\nthen \u003cerr\u003e\nelse mk_IntType(rep, (dunion ranges), {}))","private eval_Range: (Range -\u003e (Env -\u003e (Errvalue | set of (int))))\n\teval_Range(mk_Range(lower, upper))(e) \u003d\u003d\n(if (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))\nthen \u003cerr\u003e\nelseif (lower \u003d nil)\nthen {x | x:int \u0026 ((0 \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val)))}\nelseif (upper \u003d nil)\nthen {x | x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d maxint))}\nelse {x | x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val)))})","private eval_FloatType: (FloatType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_FloatType(mk_FloatType(ranges, abserr, relerr))(e) \u003d\u003d\n(if (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))\nthen \u003cerr\u003e\nelse let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in (if (not (is_(abse, Real) and is_(rele, Real)))\nthen \u003cerr\u003e\nelse mk_Float({mk_Floatrng(min(eval_Range(range)(e)), max(eval_Range(range)(e))) | range in set (elems ranges)}, (abse.val), (rele.val), {})))","private eval_VoidValType: (VoidValType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_VoidValType(fl) \u003d\u003d\n(lambda [e:(unresolved DEFAULT`Env)] \u0026 mk_VoidType(eval_Flavouring(fl)))","private eval_StrucType: (StrucType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_StrucType(mk_StrucType(tps))(e) \u003d\u003d\nlet typs:seq of ((Errvalue | Expressible_type)) \u003d [eval_Type(tps(i))(e) | i in set (inds tps)] in (if (exists tp in set (elems typs) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))\nthen \u003cerr\u003e\nelseif (exists tp1, tp2 in set (elems typs) \u0026 ((tp1 \u003c\u003e tp2) and ((tp1.fl) \u003d (tp2.fl))))\nthen \u003cerr\u003e\nelse mk_StructureType(typs, {}))","private eval_VecType: (VecType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_VecType(mk_VecType(range, tp)) \u003d\u003d\n(lambda [e:(unresolved DEFAULT`Env)] \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))\nthen \u003cerr\u003e\nelse mk_VectorType(min(nrange), max(nrange), typ, {})))","private eval_FlavouredType: (FlavouredType -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_FlavouredType(mk_FlavouredType(fl, tp))(e) \u003d\u003d\nlet flavour:Flavdom \u003d eval_Flavouring(fl), typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in (if (typ \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (cases typ :\nmk_VoidType(t) -\u003e mk_VoidType((t union flavour)),\nmk_TrType(range, fl) -\u003e mk_TrType(range, (fl union flavour)),\nmk_IntType(rep, range, fl) -\u003e mk_IntType(rep, range, (fl union flavour)),\nmk_Float(range, abse, rele, fl) -\u003e mk_Float(range, abse, rele, (fl union flavour)),\nmk_VectorType(lower, upper, tp, fl) -\u003e mk_VectorType(lower, upper, tp, (fl union flavour)),\nmk_StructureType(tps, fl) -\u003e mk_StructureType(tps, (fl union flavour)),\nmk_UnionType(tps, fl) -\u003e mk_UnionType(tps, (fl union flavour))\n end))","private eval_UnionTp: (UnionTp -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_UnionTp(mk_UnionTp(tps))(e) \u003d\u003d\nlet typs:set of ((Errvalue | Expressible_type)) \u003d {eval_Type(tps(i))(e) | i in set (inds tps)} in (if (exists tp in set typs \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))\nthen \u003cerr\u003e\nelseif (exists t1, t2 in set typs \u0026 fleq(t1, t2))\nthen \u003cerr\u003e\nelse mk_UnionType(typs, {}))","private eval_TypeName: (TypeName -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_TypeName(mk_TypeName(id))(mk_(m, l)) \u003d\u003d\n(if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e)","private eval_Scope: (Scope -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Scope(mk_Scope(s))(e)(ps) \u003d\u003d\n(if is_(s, SimpleScope)\nthen eval_SimpleScope(s)(e)(ps)\nelse eval_PackageScope(s)(e)(ps))","private eval_SimpleScope: (SimpleScope -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_SimpleScope(mk_SimpleScope(decls, expr))(e)(ps) \u003d\u003d\nlet old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in (if (new_env_st \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_(new_env, new_sto):EnvState \u003d new_env_st in eval_Expression(expr)(new_env)(new_sto))","private eval_Decls: (seq of (Declaration) -\u003e (EnvState -\u003e EnvState))\n\teval_Decls(decls)(env_st) \u003d\u003d\n(if (env_st \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif (decls \u003d [])\nthen env_st\nelse eval_Decls((tl decls))(eval_Declaration((hd decls))(env_st)))","private eval_Declaration: (Declaration -\u003e (EnvState -\u003e EnvState))\n\teval_Declaration(decl)(env_st) \u003d\u003d\n(cases decl :\nmk_ImportDecl(id, tp) -\u003e eval_ImportDecl(decl)(env_st),\nmk_ExportDecl(id, expr) -\u003e eval_ExportDecl(decl)(env_st),\nmk_LetDecl(l) -\u003e eval_LetDecl(decl)(env_st),\nmk_VarDecl(id, expr) -\u003e eval_VarDecl(decl)(env_st),\nmk_ProcDec(nls, ph, expr) -\u003e eval_ProcDec(decl)(env_st),\nmk_TypeDec(id, type) -\u003e eval_TypeDec(decl)(env_st)\n end)","private eval_ImportDecl: (ImportDecl -\u003e (EnvState -\u003e EnvState))\n\teval_ImportDecl(mk_ImportDecl(id, tp))(mk_(e, ps)) \u003d\u003d\nlet type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in (if (type \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in let nn_e:Env \u003d update_env(id)(l)(n_e), sto:Store \u003d update(l)(mk_Storable_value(val))((ps.sto)), t:Time \u003d tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))","private eval_ExportDecl: (ExportDecl -\u003e (EnvState -\u003e EnvState))\n\teval_ExportDecl(mk_ExportDecl(id, expr))(mk_(e, ps)) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in let nn_e:Env \u003d update_env(id)(l)(n_e), sto:Store \u003d update(l)(mk_Storable_value((x.val)))((ps.sto)), t:Time \u003d tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))","private eval_LetDecl: (LetDecl -\u003e (EnvState -\u003e EnvState))\n\teval_LetDecl(mk_LetDecl(decl))(es) \u003d\u003d\n(if is_(decl, SimpleLetDecl)\nthen eval_SimpleLetDecl(decl)(es)\nelse eval_StrucLetDecl(decl)(es))","private eval_SimpleLetDecl: (SimpleLetDecl -\u003e (EnvState -\u003e EnvState))\n\teval_SimpleLetDecl(mk_SimpleLetDecl(id, expr))(mk_(e, ps)) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(update_env(id)((x.val))(e), mk_PState((ps.sto), (x.time))))","private eval_StrucLetDecl: (StrucLetDecl -\u003e (EnvState -\u003e EnvState))\n\teval_StrucLetDecl(mk_StrucLetDecl(ids, expr))(mk_(e, ps)) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))\nthen \u003cerr\u003e\nelseif ((len ids) \u003c\u003e struc_length(((x.val).type)))\nthen \u003cerr\u003e\nelse let id_vals:seq of ((Id * Expressible_value)) \u003d [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in let new_env:Env \u003d multi_update_env(id_vals)(e) in mk_(new_env, mk_PState((ps.sto), (x.time))))","private eval_VarDecl: (VarDecl -\u003e (EnvState -\u003e EnvState))\n\teval_VarDecl(mk_VarDecl(id, expr))(mk_(e, ps)) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in let nn_e:Env \u003d update_env(id)(l)(n_e), sto:Store \u003d update(l)(mk_Storable_value((x.val)))((ps.sto)), t:Time \u003d tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))","private eval_ProcDec: (ProcDec -\u003e (EnvState -\u003e EnvState))\n\teval_ProcDec(mk_ProcDec(nls, ph, expr))(mk_(e, ps)) \u003d\u003d\nlet env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in (if (env_st \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in let pr:Proc \u003d mk_Proc((lambda [a:(unresolved DEFAULT`Param)] \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (lambda [nps:(unresolved DEFAULT`PState)] \u0026 (if (nn_e \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(nn_e)(nps) in (if (((x.val) \u003c\u003e \u003cerr\u003e) and ((is_((x.val), Void) and (((x.val).type) \u003d mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) \u003d {Phi}))))\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse x))))) in mk_(update_env(id)(pr)(e), mk_PState((ps.sto), (ns.time))))","private eval_NonLocals: (NonLocals -\u003e (Env -\u003e (PState -\u003e EnvState)))\n\teval_NonLocals(mk_NonLocals(ids, decls))(mk_(m, l))(ps) \u003d\u003d\nlet ids_map:(map (?) to (?) | map (Id) to (Denotable_value)) \u003d (if (ids \u003d nil)\nthen {|-\u003e}\nelse ((elems ids) \u003c: m)) in (if (decls \u003d nil)\nthen mk_(mk_(ids_map, l), ps)\nelse eval_Decls(decls)(mk_(mk_(ids_map, l), ps)))","private eval_Formals: (seq of (Formal) -\u003e (Env -\u003e seq of (Formal_elt)))\n\teval_Formals(fls)(e) \u003d\u003d\n[eval_Formal(fls(i))(e) | i in set (inds fls)]","private eval_Formal: (Formal -\u003e (Env -\u003e Formal_elt))\n\teval_Formal(mk_Formal(id, rep, fl))(e) \u003d\u003d\nlet n_rep:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), n_fl:Flavdom \u003d eval_Flavouring(fl) in mk_Formal_elt(id, n_rep, n_fl)","private eval_Representation: (Representation -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_Representation(rep)(e) \u003d\u003d\n(cases rep :\nmk_PrimitiveRep(p) -\u003e eval_PrimitiveRep(rep)(e),\nmk_StrucRep(rs) -\u003e eval_StrucRep(rep)(e),\nmk_VecRep(range, r) -\u003e eval_VecRep(rep)(e),\nmk_UnionRep(rs) -\u003e eval_UnionRep(rep)(e),\nmk_FlavouredRep(f, r) -\u003e eval_FlavouredRep(rep)(e),\nmk_Type(t) -\u003e eval_Type(rep)(e)\n end)","private eval_PrimitiveRep: (PrimitiveRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_PrimitiveRep(mk_PrimitiveRep(rep))(e) \u003d\u003d\n(if is_(rep, NumRep)\nthen eval_NumRep(rep)(e)\nelse eval_FloatRep(rep)(e))","private eval_NumRep: (NumRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_NumRep(mk_NumRep(rep, range))(e) \u003d\u003d\nlet ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in (if (\u003cerr\u003e in set ranges)\nthen \u003cerr\u003e\nelseif (rep \u003d \u003cbit\u003e)\nthen (if (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))\nthen \u003cerr\u003e\nelse let rngs:set of (bool) \u003d (if (range \u003d nil)\nthen {true, false}\nelse {{0 |-\u003e false, 1 |-\u003e true}(r) | r in set (dunion ranges)}) in mk_TrType(rngs, {}))\nelseif (rep \u003d \u003cbyte\u003e)\nthen (if (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))\nthen \u003cerr\u003e\nelse let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-bytemax, ... ,bytemax}\nelse (dunion ranges)) in mk_IntType(rep, rngs, {}))\nelseif (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))\nthen \u003cerr\u003e\nelse let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-maxint, ... ,maxint}\nelse (dunion ranges)) in mk_IntType(rep, rngs, {}))","private eval_FloatRep: (FloatRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_FloatRep(mk_FloatRep(range, abserr, relerr))(e) \u003d\u003d\nlet ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in (if ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))\nthen \u003cerr\u003e\nelse let rngs:set of (Floatrng) \u003d (if (range \u003d nil)\nthen {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}\nelse {mk_Floatrng(min(r), max(r)) | r in set ranges}) in mk_Float(rngs, ((abse.val).val), ((rele.val).val), {}))","private eval_StrucRep: (StrucRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_StrucRep(mk_StrucRep(reps))(e) \u003d\u003d\nlet tps:seq of ((Errvalue | Expressible_type)) \u003d [eval_Representation(reps(i))(e) | i in set (inds reps)] in (if (exists tp in set (elems tps) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))\nthen \u003cerr\u003e\nelseif (exists tp1, tp2 in set (elems tps) \u0026 fleq(tp1, tp2))\nthen \u003cerr\u003e\nelse mk_StructureType(tps, {}))","private eval_VecRep: (VecRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_VecRep(mk_VecRep(range, rep))(e) \u003d\u003d\nlet nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in (if ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))\nthen \u003cerr\u003e\nelse mk_VectorType(min(nrange), max(nrange), type, {}))","private eval_UnionRep: (UnionRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_UnionRep(mk_UnionRep(reps))(e) \u003d\u003d\nlet tps:set of ((Errvalue | Expressible_type)) \u003d {eval_Representation(rep)(e) | rep in set (elems reps)} in (if (exists tp in set tps \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))\nthen \u003cerr\u003e\nelseif (exists tp1, tp2 in set tps \u0026 fleq(tp1, tp2))\nthen \u003cerr\u003e\nelse mk_UnionType(tps, {}))","private eval_FlavouredRep: (FlavouredRep -\u003e (Env -\u003e (Errvalue | Expressible_type)))\n\teval_FlavouredRep(mk_FlavouredRep(fl, rep))(e) \u003d\u003d\nlet type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), flav:Flavdom \u003d eval_Flavouring(fl) in (if (type \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse replace_flavour(type, flav))","private eval_TypeDec: (TypeDec -\u003e (EnvState -\u003e EnvState))\n\teval_TypeDec(mk_TypeDec(id, tp))(mk_(e, ps)) \u003d\u003d\nlet type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in (if (type \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(update_env(id)(type)(e), ps))","private eval_PackageScope: (PackageScope -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_PackageScope(mk_PackageScope(ids, decls, expr))(mk_(m, l))(ps) \u003d\u003d\nlet env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in (if (new_env_st \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_(mk_(nm, nl), nps):EnvState \u003d new_env_st in (if (not ((elems ids) subset ((dom nm) \\ (dom m))))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let ne:(map (Id) to (Denotable_value) * Location) \u003d mk_((((elems ids) union (dom m)) \u003c: nm), nl) in eval_Expression(expr)(ne)(nps)))","private eval_GuardedScope: (GuardedScope -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_GuardedScope(mk_GuardedScope(decls, incl, outcl))(e)(ps) \u003d\u003d\nlet g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in (if (g_decl \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in let in_val:EST_value \u003d eval_Sequence(incl)(ne)(nps), out_val:EST_value \u003d eval_Sequence(outcl)(ne)(nps) in (if (((in_val.val) \u003d \u003cerr\u003e) or ((out_val.val) \u003d \u003cerr\u003e))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d setlub({((in_val.val).type), ((out_val.val).type)}) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse (if val\nthen mk_EST_value(widen_type((in_val.val), type), (in_val.sto), tplus((in_val.time), t_if))\nelse mk_EST_value(widen_type((out_val.val), type), (out_val.sto), tplus((out_val.time), t_if))))))","private eval_GuardedDeclarations: (seq1 of (GuardedDeclaration) -\u003e (bool -\u003e (Env -\u003e (PState -\u003e ((Env * PState * bool) | Errvalue)))))\n\teval_GuardedDeclarations(decls)(b)(e)(ps) \u003d\u003d\nlet gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in (if ((len decls) \u003d 1)\nthen gdcl\nelseif (gdcl \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in eval_GuardedDeclarations((tl decls))((b and tr))(ne)(nps))","private eval_GuardedDecl: (GuardedDeclaration -\u003e (Env -\u003e (PState -\u003e ((Env * PState * bool) | Errvalue))))\n\teval_GuardedDecl(decl)(e)(ps) \u003d\u003d\n(if is_(decl, WhereDecl)\nthen eval_WhereDecl(decl)(e)(ps)\nelse let d:EnvState \u003d eval_Declaration(decl)(mk_(e, ps)) in (if (d \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(ne, nps):EnvState \u003d d in mk_(ne, nps, true)))","private eval_WhereDecl: (WhereDecl -\u003e (Env -\u003e (PState -\u003e ((Env * PState * bool) | Errvalue))))\n\teval_WhereDecl(mk_WhereDecl(type, expr, id))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in (cases t :\n\u003cerr\u003e -\u003e \u003cerr\u003e\nothers let env:Env \u003d (if (id \u003d nil)\nthen e\nelse update_env(id)((x.val))(e)) in let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (cases xt :\n\u003cerr\u003e -\u003e \u003cerr\u003e\nothers let val:bool \u003d gt(t, xt) in mk_(env, mk_PState((ps.sto), (x.time)), val)\n end)\n end))","private eval_Assertion: (Assertion -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Assertion(mk_Assertion(expr, tp))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (cases xt :\n\u003cerr\u003e -\u003e mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nothers (if (not (tleq(type, ((x.val).type)) and tleq(xt, type)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let val:Expressible_value \u003d widen_type((x.val), phi_remove(type)) in mk_EST_value(val, (x.sto), tplus((x.time), t_widen_type)))\n end)))","private eval_Conditional: (Conditional -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Conditional(mk_Conditional(cond))(e)(ps) \u003d\u003d\n(if is_(cond, IfThenOnly)\nthen eval_IfThenOnly(cond)(e)(ps)\nelseif is_(cond, IfThenElse)\nthen eval_IfThenElse(cond)(e)(ps)\nelse eval_CaseExpr(cond)(e)(ps))","private eval_IfThenOnly: (IfThenOnly -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_IfThenOnly(mk_IfThenOnly(prop, action))(e)(ps) \u003d\u003d\nlet cond:EST_value \u003d eval_Expression(prop)(e)(ps), aseq:EST_value \u003d eval_Sequence(action)(e)(mu(ps, time |-\u003e tplus((cond.time), t_if))) in (if ((not is_((cond.val), Tr)) or (not is_((aseq.val), Void)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif ((cond.val).val)\nthen aseq\nelse mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), tplus((ps.time), tplus((cond.time), t_if))))","private eval_IfThenElse: (IfThenElse -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_IfThenElse(mk_IfThenElse(prop, thenaction, elseaction))(e)(ps) \u003d\u003d\nlet cond:EST_value \u003d eval_Expression(prop)(e)(ps) in (if (not is_((cond.val), Tr))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let then_x:EST_value \u003d eval_Sequence(thenaction)(e)(ps), else_x:EST_value \u003d eval_Sequence(elseaction)(e)(ps) in let type:(Errvalue | Expressible_type) \u003d lub(((then_x.val).type), ((else_x.val).type)) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif ((cond.val).val)\nthen mu(then_x, val |-\u003e widen_type((then_x.val), type), time |-\u003e tplus((then_x.time), (cond.time)))\nelse mu(else_x, val |-\u003e widen_type((else_x.val), type), time |-\u003e tplus((else_x.time), (cond.time)))))","private eval_CaseExpr: (CaseExpr -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_CaseExpr(mk_CaseExpr(expr, limbs, outlimb))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in (if (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in (if (patlub \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif (lub(type_x, patlub) \u003c\u003e patlub)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in mk_EST_value(widen_type((mv.val), type), (mv.sto), time)))))","private eval_Limbs: (seq1 of (CaseLimb) -\u003e (Expressible_value -\u003e (Env -\u003e (PState -\u003e seq1 of ((Expressible_type * EST_value))))))\n\teval_Limbs(limbs)(x)(e)(ps) \u003d\u003d\nlet mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in (if ((len limbs) \u003d 1)\nthen [mk_(t, v)]\nelse ([mk_(t, v)] ^ eval_Limbs((tl limbs))(x)(e)(mu(ps, time |-\u003e (v.time)))))","private eval_Limb: (CaseLimb -\u003e (Expressible_value -\u003e (Env -\u003e (PState -\u003e (Expressible_type * EST_value)))))\n\teval_Limb(mk_CaseLimb(test, sequ))(x)(e)(ps) \u003d\u003d\nlet t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in (if (t \u003d \u003cerr\u003e)\nthen mk_(mk_VoidType({}), mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))\nelse let mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u003d t in let val:EST_value \u003d eval_Sequence(sequ)(env)(mu(ps, time |-\u003e tm)) in (if ((val.val) \u003d \u003cerr\u003e)\nthen mk_(mk_VoidType({}), mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))\nelse mk_(type, val)))","private eval_Tester: (Tester -\u003e (Expressible_value -\u003e (Env -\u003e (PState -\u003e ((Expressible_type * Env * Time) | Errvalue)))))\n\teval_Tester(tester)(x)(e)(ps) \u003d\u003d\n(cases tester :\nmk_SkeletonType(t) -\u003e let nt:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tester)((x.type))(e) in (if (nt \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(nt, e, (ps.time))),\nmk_StrucTest(s) -\u003e eval_StrucTest(tester)(x)(e)(ps),\nmk_NonStrucTest(id, tp, fl) -\u003e eval_NonStrucTest(tester)(x)(e)(ps)\n end)","private eval_SkeletonType: (SkeletonType -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_SkeletonType(mk_SkeletonType(skel))(t)(e) \u003d\u003d\n(cases skel :\nmk_Type(t) -\u003e eval_Type(skel)(e),\nmk_NumSkel(r, er) -\u003e eval_NumSkel(skel)(t)(e),\nmk_StrucSkel(s) -\u003e eval_StrucSkel(skel)(t)(e),\nmk_FlavSkel(s, fl) -\u003e eval_FlavSkel(skel)(t)(e),\nmk_VecSkel(s) -\u003e eval_VecSkel(skel)(t)(e),\nmk_UnionSkel(s) -\u003e eval_UnionSkel(skel)(t)(e)\n end)","private eval_NumSkel: (NumSkel -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_NumSkel(mk_NumSkel(ranges, errors))(x_type)(e) \u003d\u003d\n(if (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))\nthen \u003cerr\u003e\nelse let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in (if (\u003cerr\u003e in set rngs)\nthen \u003cerr\u003e\nelse (cases x_type :\nmk_TrType(range, fl) -\u003e (if (not ((dunion rngs) subset {0, 1}))\nthen \u003cerr\u003e\nelse mk_TrType({{0 |-\u003e false, 1 |-\u003e true}(v) | v in set (dunion rngs)}, fl)),\nmk_IntType(rep, range, fl) -\u003e (if (((rep \u003d \u003cbyte\u003e) and (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d bytemax))) or (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint)))\nthen \u003cerr\u003e\nelse mk_IntType(rep, (dunion rngs), fl)),\nmk_Float(rs, abse, rele, fl) -\u003e (if (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))\nthen \u003cerr\u003e\nelse let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in (if (not (is_(abserr, real) and is_(relerr, real)))\nthen \u003cerr\u003e\nelse mk_Float({mk_Floatrng(min(r), max(r)) | r in set rngs}, abserr, relerr, fl)))\n end)))","private eval_StrucSkel: (StrucSkel -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_StrucSkel(mk_StrucSkel(comps))(x_type)(e) \u003d\u003d\n(if (not is_(x_type, StructureType))\nthen \u003cerr\u003e\nelseif (struc_length(x_type) \u003c\u003e (len comps))\nthen \u003cerr\u003e\nelse let t:seq of ((CompType | Errvalue | Expressible_type)) \u003d [(if (comps(i) \u003d \u003cnil\u003e)\nthen (x_type.tps)(i)\nelse eval_SkeletonType(comps(i))((x_type.tps)(i))(e)) | i in set (inds comps)] in (if (exists tp in set (elems t) \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or is_(tp, Float)))))\nthen \u003cerr\u003e\nelse mk_StructureType(t, (x_type.fl))))","private eval_FlavSkel: (FlavSkel -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_FlavSkel(mk_FlavSkel(skel, fl))(x_type)(e) \u003d\u003d\nlet t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e), f:Flavdom \u003d eval_Flavouring(fl) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse replace_flavour(t, f))","private eval_VecSkel: (VecSkel -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_VecSkel(mk_VecSkel(skel))(x_type)(e) \u003d\u003d\nlet t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (cases x_type :\nmk_VectorType(l, u, tp, fl) -\u003e mk_VectorType(l, u, t, fl)\nothers \u003cerr\u003e\n end))","private eval_UnionSkel: (UnionSkel -\u003e (Expressible_type -\u003e (Env -\u003e (Errvalue | Expressible_type))))\n\teval_UnionSkel(mk_UnionSkel(skels))(x_type)(e) \u003d\u003d\nlet fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in (if ((card (dom fls)) \u003c\u003e (card (rng fls)))\nthen \u003cerr\u003e\nelseif is_(x_type, UnionType)\nthen let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in (if (not ((rng fls) subset (rng x_fls)))\nthen \u003cerr\u003e\nelse let tps:set of ((Errvalue | Expressible_type)) \u003d {(cases skel :\nmk_FlavSkel(s, f) -\u003e eval_FlavSkel(skel)(tp)(e),\nmk_FlavouredType(f, t) -\u003e eval_FlavouredType(skel)(e)\nothers eval_VoidValType(skel)(e)\n end) | skel in set (elems skels), tp in set (x_type.tps) \u0026 (fls(skel) \u003d x_fls(tp))} in (if (exists tp in set tps \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or (is_(tp, Float) or is_(tp, VoidType))))))\nthen \u003cerr\u003e\nelse mk_UnionType(tps, (x_type.fl))))\nelse let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in (if (fl not in set (rng fls))\nthen \u003cerr\u003e\nelse let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (cases skel :\nmk_FlavSkel(s, f) -\u003e eval_FlavSkel(skel)(x_type)(e),\nmk_FlavouredType(f, t) -\u003e eval_FlavouredType(skel)(e)\nothers eval_VoidValType(skel)(e)\n end)))","private eval_NonStrucTest: (NonStrucTest -\u003e (Expressible_value -\u003e (Env -\u003e (PState -\u003e ((Expressible_type * Env * Time) | Errvalue)))))\n\teval_NonStrucTest(mk_NonStrucTest(id, fl, skel))(x)(e)(ps) \u003d\u003d\nlet t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in (if (id \u003d nil)\nthen mk_(t\u0027, e, (ps.time))\nelse mk_(t\u0027, update_env(id)(x)(e), (ps.time))))","private eval_StrucTest: (StrucTest -\u003e (Expressible_value -\u003e (Env -\u003e (PState -\u003e ((Expressible_type * Env * Time) | Errvalue)))))\n\teval_StrucTest(mk_StrucTest(tests))(x)(e)(ps) \u003d\u003d\n(if (not is_(x, Structure))\nthen \u003cerr\u003e\nelseif (struc_length((x.type)) \u003c\u003e (len tests))\nthen \u003cerr\u003e\nelse let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in (if (ts \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(tps, env, time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d ts in mk_(mk_StructureType(tps, ((x.type).fl)), env, time)))","private eval_Testseq: (seq of ((\u003cnil\u003e | NonStrucTest)) -\u003e (seq of (Expressible_value) -\u003e (Env -\u003e (PState -\u003e ((seq of (Expressible_type) * Env * Time) | Errvalue)))))\n\teval_Testseq(tests)(xs)(e)(ps) \u003d\u003d\n(if (tests \u003d [])\nthen mk_([], e, (ps.time))\nelse let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-\u003e time)) in (if (ts \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let mk_(tps, n_env, n_time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d ts in mk_(([tp] ^ tps), n_env, n_time))))","private eval_OuterLoop: (OuterLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_OuterLoop(mk_OuterLoop(oul))(e)(ps) \u003d\u003d\n(if is_(oul, OuterIntLoop)\nthen eval_OuterIntLoop(oul)(e)(ps)\nelse eval_OuterVecLoop(oul)(e)(ps))","private eval_OuterIntLoop: (OuterIntLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_OuterIntLoop(mk_OuterIntLoop(mk_OverRange(id, range), actns))(e)(ps) \u003d\u003d\nlet nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (nrange \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in (if (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in mk_EST_value(mk_Vector(vec_val, mk_VectorType(1, (len vec_val), type, {})), (ps.sto), tplus((ps.time), time)))))","private eval_OuterVecLoop: (OuterVecLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_OuterVecLoop(mk_OuterVecLoop(ovs, actions))(e)(ps) \u003d\u003d\nlet idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in (if (idvs \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in (if (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in (if (type \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in let new_vec:Vector \u003d mk_Vector(vec_val, new_tp) in mk_EST_value(new_vec, (ps.sto), tplus((ps.time), time)))))","private eval_OverVectors: (OverVectors -\u003e (Env -\u003e (PState -\u003e (Errvalue | seq1 of ((Id * Vector * Time))))))\n\teval_OverVectors(ovs)(e)(ps) \u003d\u003d\nlet indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists i in set (inds indices) \u0026 let mk_(id, v, t):(Id * Expressible_value * Time) \u003d indices(i) in (not is_(v, Vector)))\nthen \u003cerr\u003e\nelse indices)","private eval_InnerLoop: (InnerLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_InnerLoop(mk_InnerLoop(innerl))(e)(ps) \u003d\u003d\n(cases innerl :\nmk_IntLoop(inc, actions) -\u003e eval_IntLoop(innerl)(e)(ps),\nmk_VecLoop(ovs, actions) -\u003e eval_VecLoop(innerl)(e)(ps),\nmk_TimeLoop(time, actions) -\u003e eval_TimeLoop(innerl)(e)(ps)\n end)","private eval_IntLoop: (IntLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_IntLoop(mk_IntLoop(inc, actions))(e)(ps) \u003d\u003d\nlet idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in (if (idrng \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in eval_SeqIterate(actions)(new_env)(x)) in let exi:EST_Iterate \u003d NIterate(f, (len range))(mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time)), 1)) in (exi.expst))","private eval_InnerControl: (InnerControl -\u003e (Env -\u003e (PState -\u003e ((Id * seq of (int)) | Errvalue))))\n\teval_InnerControl(inc)(e)(ps) \u003d\u003d\n(cases inc :\nmk_OverRange(cnt, range) -\u003e let r:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (r \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(cnt, [x | x in set r])),\nmk_PartialRange(cnt, from_b, to_b, inc) -\u003e let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen \u003cerr\u003e\nelse let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))\nthen \u003cerr\u003e\nelse let r:seq of (real) \u003d [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 ((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))\n end)","private eval_SeqIterate: (Sequence -\u003e (Env -\u003e (EST_Iterate -\u003e EST_Iterate)))\n\teval_SeqIterate(sequ)(e)(exi) \u003d\u003d\n(if (((exi.expst).val) \u003d \u003cerr\u003e)\nthen mu(exi, i |-\u003e ((exi.i) + 1))\nelse let new_expst:EST_value \u003d eval_Sequence(sequ)(e)(mk_PState(((exi.expst).sto), ((exi.expst).time))) in mk_EST_Iterate(new_expst, ((exi.i) + 1)))","private eval_VecLoop: (VecLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_VecLoop(mk_VecLoop(ovs, actions))(e)(ps) \u003d\u003d\nlet indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in (if (indices \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-\u003e new_expst))) in let mk_(-, v, -):(Id * Vector * Time) \u003d indices(1) in let exi:EST_Iterate \u003d NIterate(f, (len (v.val)))(mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), tplus((ps.time), time)), 1)) in (exi.expst))","private eval_TimeLoop: (TimeLoop -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_TimeLoop(mk_TimeLoop(time, actions))(e)(ps) \u003d\u003d\nlet t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in (if ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif (exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t))\nthen let its:nat \u003d (iota n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))), f:(EST_value -\u003e EST_value) \u003d (lambda [exs:(unresolved DEFAULT`EST_value)] \u0026 eval_Sequence(actions)(e)(mk_PState((exs.sto), (exs.time)))) in Iterate(f, its)(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time)))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private eval_Assignment: (Assignment -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_Assignment(mk_Assignment(ass))(env)(ps) \u003d\u003d\n(cases ass :\nmk_NvAssignment(d, e) -\u003e eval_NvAssignment(ass)(env)(ps),\nmk_MultAssignment(d, m, e) -\u003e eval_MultAssignment(ass)(env)(ps),\nmk_StrAssignment(d, e) -\u003e eval_StrAssignment(ass)(env)(ps)\n end)","private eval_NvAssignment: (NvAssignment -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_NvAssignment(mk_NvAssignment(dest, expr))(e)(ps) \u003d\u003d\nlet l:Denotable_value \u003d access_env(dest)(e) in (if (not is_(l, Location))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if ((x.val) \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (if gt((dest_val.type), ((x.val).type))\nthen let new_sto:Store \u003d update(l)(mk_Storable_value(widen_type((x.val), (dest_val.type))))((ps.sto)) in mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), new_sto, tplus(tplus((ps.time), t_update), t_access))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))))","private eval_MultAssignment: (MultAssignment -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_MultAssignment(mk_MultAssignment(dest, mult, expr))(e)(ps) \u003d\u003d\nlet l:Denotable_value \u003d access_env(dest)(e) in (if (not is_(l, Location))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in (if (not is_(v, Vector))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in (if (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), update(l)(mk_Storable_value(new_vec))((ps.sto)), new_time))))","private eval_StrAssignment: (StrAssignment -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_StrAssignment(mk_StrAssignment(dest, expr))(e)(ps) \u003d\u003d\nlet ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in (if (exists l in set (elems ls) \u0026 (not is_(l, Location)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif ((len ls) \u003c\u003e struc_length(((x.val).type)))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (if (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelse let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), multi_update(ls)(ys)((ps.sto)), new_t))))","private eval_TimedExpression: (TimedExpression -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_TimedExpression(mk_TimedExpression(texpr))(e)(ps) \u003d\u003d\n(if is_(texpr, TimeTakes)\nthen eval_TimeTakes(texpr)(e)(ps)\nelse eval_TimeAssertion(texpr)(e)(ps))","private eval_TimeTakes: (TimeTakes -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_TimeTakes(mk_TimeTakes(expr, time))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(mu(ps, time |-\u003e zerot)), t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e) in (if (((x.val) \u003d \u003cerr\u003e) or (t \u003d \u003cerr\u003e))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif timeleq((x.time), t)\nthen mu(x, time |-\u003e tplus((ps.time), (x.time)))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private eval_TimeInterval: (TimeInterval -\u003e (Env -\u003e (Errvalue | Time)))\n\teval_TimeInterval(time)(e) \u003d\u003d\nlet range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in (if ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))\nthen \u003cerr\u003e\nelse mk_(min(range), max(range)))","private eval_TimeAssertion: (TimeAssertion -\u003e (Env -\u003e (PState -\u003e EST_value)))\n\teval_TimeAssertion(mk_TimeAssertion(expr, time))(e)(ps) \u003d\u003d\nlet x:EST_value \u003d eval_Expression(expr)(e)(mu(ps, time |-\u003e zerot)), t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e) in (if (((x.val) \u003d \u003cerr\u003e) or (t \u003d \u003cerr\u003e))\nthen mk_EST_value(\u003cerr\u003e, (ps.sto), zerot)\nelseif timeleq(t, (x.time))\nthen mu(x, time |-\u003e tplus((ps.time), t))\nelse mk_EST_value(\u003cerr\u003e, (ps.sto), zerot))","private Iterate: ((EST_value -\u003e EST_value) * nat -\u003e (EST_value -\u003e EST_value))\n\tIterate(f, n) \u003d\u003d\n(if (n \u003d 0)\nthen (lambda [x:(unresolved DEFAULT`EST_value)] \u0026 x)\nelseif (n \u003d 1)\nthen f\nelse (f comp Iterate(f, (n - 1))))","private NIterate: ((EST_Iterate -\u003e EST_Iterate) * nat -\u003e (EST_Iterate -\u003e EST_Iterate))\n\tNIterate(f, n) \u003d\u003d\n(if (n \u003d 0)\nthen (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 x)\nelseif (n \u003d 1)\nthen f\nelse (f comp NIterate(f, (n - 1))))"]