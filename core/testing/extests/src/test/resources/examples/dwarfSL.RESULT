["size:nat \u003d 8","letters:set of (char) \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027, \u0027g\u0027, \u0027h\u0027, \u0027i\u0027, \u0027j\u0027, \u0027k\u0027, \u0027l\u0027, \u0027m\u0027, \u0027n\u0027, \u0027o\u0027, \u0027p\u0027, \u0027q\u0027, \u0027r\u0027, \u0027s\u0027, \u0027t\u0027, \u0027u\u0027, \u0027v\u0027, \u0027w\u0027, \u0027x\u0027, \u0027y\u0027, \u0027z\u0027}","black:char \u003d \u0027*\u0027","white:char \u003d \u0027_\u0027","word \u003d word\n\tinv w \u003d\u003d (((elems w) subset letters) and ((len w) \u003e\u003d 2))","pos \u003d pos\n\tinv pos_v \u003d\u003d (pos_v \u003c\u003d size)","position \u003d position","grid \u003d grid\n\tinv gr \u003d\u003d (((rng gr) subset (letters union {white, black})) and ((dom gr) \u003d {mk_position(i, j) | i in set {1, ... ,size}, j in set {1, ... ,size}}))","HV \u003d HV","state crosswordsof\n[cwgrid : grid, valid_words : set of (word), waiting_words : set of (word)]\n\tinv mk_crosswords(gr, val, wait) \u003d\u003d CW_INVARIANT(gr, val, wait)\n\tinit mk_crosswords(gr, val, wait) \u003d\u003d ((val \u003d {}) and ((wait \u003d {}) and (forall i in set {1, ... ,size} \u0026 (forall j in set {1, ... ,size} \u0026 (gr(mk_position(i, j)) \u003d white)))))","private CW_INVARIANT: (grid * set of (word) * set of (word) +\u003e bool)\n\tCW_INVARIANT(gr, val, wait) \u003d\u003d\n(((val inter wait) \u003d {}) and ((WORDS(gr) subset (val union wait)) and (wait subset WORDS(gr))))","private WORDS: (grid +\u003e set of (word))\n\tWORDS(g) \u003d\u003d\n(HOR_WORDS(g) union VER_WORDS(g))","private HOR_WORDS: (grid +\u003e set of (word))\n\tHOR_WORDS(g) \u003d\u003d\n(dunion {WORDS_OF_SEQ(LINE(i, g)) | i in set {1, ... ,size}})","private VER_WORDS: (grid +\u003e set of (word))\n\tVER_WORDS(g) \u003d\u003d\n(dunion {WORDS_OF_SEQ(COL(i, g)) | i in set {1, ... ,size}})","private LINE: (pos * grid +\u003e seq of (char))\n\tLINE(i, g) \u003d\u003d\n[g(mk_position(i, c)) | c in set {1, ... ,size}]","private COL: (pos * grid +\u003e seq of (char))\n\tCOL(i, g) \u003d\u003d\n[g(mk_position(l, i)) | l in set {1, ... ,size}]","private WORDS_OF_SEQ: (seq of (char) +\u003e set of (word))\n\tWORDS_OF_SEQ(s) \u003d\u003d\n{w | w:word \u0026 (exists s1, s2:seq of (char) \u0026 ((s \u003d ((s1 ^ w) ^ s2)) and (((s1 \u003d []) or ((s1((len s1)) \u003d black) or (s1((len s1)) \u003d white))) and ((s2 \u003d []) or ((s2(1) \u003d black) or (s2(1) \u003d white))))))}","private COMPATIBLE: (grid * word * position * HV +\u003e bool)\n\tCOMPATIBLE(g, w, p, d) \u003d\u003d\n(((d \u003d \u003cH\u003e) \u003d\u003e (((((p.h) + (len w)) - 1) \u003c\u003d size) and (forall i in set (inds w) \u0026 ((g(mk_position((((p.h) + i) - 1), (p.v))) \u003d white) or (g(mk_position((((p.h) + i) - 1), (p.v))) \u003d w(i)))))) and ((d \u003d \u003cV\u003e) \u003d\u003e (((((p.v) + (len w)) - 1) \u003c\u003d size) and (forall i in set (inds w) \u0026 ((g(mk_position((p.h), (((p.v) + i) - 1))) \u003d white) or (g(mk_position((p.h), (((p.v) + i) - 1))) \u003d w(i)))))))","private IS_LOCATED: (grid * word * position * HV +\u003e bool)\n\tIS_LOCATED(g, w, p, d) \u003d\u003d\n(((d \u003d \u003cH\u003e) \u003d\u003e (forall i in set (inds w) \u0026 (g(mk_position((((p.h) + i) - 1), (p.v))) \u003d w(i)))) and ((d \u003d \u003cV\u003e) \u003d\u003e (forall i in set (inds w) \u0026 (g(mk_position((p.h), (((p.v) + i) - 1))) \u003d w(i)))))","private IN_WORD: (grid * position * HV +\u003e bool)\n\tIN_WORD(g, p, d) \u003d\u003d\n(((d \u003d \u003cH\u003e) \u003d\u003e (exists i, j:pos \u0026 ((i \u003c\u003d (p.h)) and ((j \u003e\u003d (p.h)) and ((i \u003c j) and (forall k in set {i, ... ,j} \u0026 (g(mk_position(k, (p.v))) in set letters))))))) and ((d \u003d \u003cV\u003e) \u003d\u003e (exists i, j:pos \u0026 ((i \u003c\u003d (p.v)) and ((j \u003e\u003d (p.v)) and ((i \u003c j) and (forall k in set {i, ... ,j} \u0026 (g(mk_position((p.h), k)) in set letters))))))))","VALIDATE_WORD([w]word)\n\text [wr[valid_words]set of (word), wr[waiting_words]set of (word)]\n\tpre (w in set waiting_words)\n\tpost ((valid_words \u003d (valid_words~ union {w})) and (waiting_words \u003d (waiting_words~ \\ {w})))","ADD_WORD([w]word, [p]position, [d]HV)\n\text [wr[cwgrid]grid, rd[valid_words]set of (word), wr[waiting_words]set of (word)]\n\tpre COMPATIBLE(cwgrid, w, p, d)\n\tpost (((d \u003d \u003cH\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-\u003e w(i) | i in set (inds w)}))) and (((d \u003d \u003cV\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-\u003e w(i) | i in set (inds w)}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))","ADD_BLACK([p]position)\n\text [wr[cwgrid]grid]\n\tpre (cwgrid(p) \u003d white)\n\tpost (cwgrid \u003d (cwgrid~ ++ {p |-\u003e black}))","DELETE_BLACK([p]position)\n\text [wr[cwgrid]grid]\n\tpre (cwgrid(p) \u003d black)\n\tpost (cwgrid \u003d (cwgrid~ ++ {p |-\u003e white}))","STRONG_DELETE([w]word, [p]position, [d]HV)\n\text [wr[cwgrid]grid, rd[valid_words]set of (word), wr[waiting_words]set of (word)]\n\tpre IS_LOCATED(cwgrid, w, p, d)\n\tpost (((d \u003d \u003cH\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-\u003e white | i in set (inds w)}))) and (((d \u003d \u003cV\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-\u003e white | i in set (inds w)}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))","SOFT_DELETE([w]word, [p]position, [d]HV)\n\text [wr[cwgrid]grid, rd[valid_words]set of (word), wr[waiting_words]set of (word)]\n\tpre IS_LOCATED(cwgrid, w, p, d)\n\tpost (((d \u003d \u003cH\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-\u003e white | i in set (inds w) \u0026 (not IN_WORD(cwgrid~, mk_position((((p.h) + i) - 1), (p.v)), \u003cV\u003e))}))) and (((d \u003d \u003cV\u003e) \u003d\u003e (cwgrid \u003d (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-\u003e white | i in set (inds w) \u0026 (not IN_WORD(cwgrid~, mk_position((p.h), (((p.v) + i) - 1)), \u003cH\u003e))}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))"]