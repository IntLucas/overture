["class Accelerometer\nprivate  mController:Controller :\u003d (undefined)\npublic  Accelerometer(Controller) (Controller \u003d\u003d\u003e Accelerometer)\n\tAccelerometer(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  getAccelerationData() (() \u003d\u003d\u003e (real * real * real))\n\tgetAccelerationData()() \u003d\u003d\nduration (0) (\nax:real :\u003d (mController.getValue)(\"ACC_X\")\nay:real :\u003d (mController.getValue)(\"ACC_Y\")\naz:real :\u003d (mController.getValue)(\"ACC_Z\")\n\nreturn (mk_(ax, ay, az))\n)\nend Accelerometer\n","class Actuator is subclass of [IActuatorReal]\nprivate  value:real :\u003d (undefined)\npublic  Actuator(real) (real \u003d\u003d\u003e Actuator)\n\tActuator(real)(v) \u003d\u003d\nvalue :\u003d v\npublic  Actuator() (() \u003d\u003d\u003e Actuator)\n\tActuator()() \u003d\u003d\nActuator(0.0)\npublic  SetValue(real) (real \u003d\u003d\u003e ())\n\tSetValue(real)(v) \u003d\u003d\n(\n\nIO`printf(\"SetValue \u003d %s\n\", [v]);\nvalue :\u003d v\n)\nend Actuator\n","system ChessWay\nprivate  fpga1:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E7)\nprivate  fpga2:CPU :\u003d new CPU(\u003cFP\u003e, 1.0E7)\nprivate  bus:BUS :\u003d new BUS(\u003cFCFS\u003e, 100000.0, {fpga1, fpga2})\npublic static  acc_in:[ISensorReal] :\u003d nil\npublic static  vel_in:[ISensorReal] :\u003d nil\npublic static  acc_out:[IActuatorReal] :\u003d nil\npublic static  vel_out:[IActuatorReal] :\u003d nil\npublic static  lctrl:LeftController :\u003d new LeftController()\npublic static  rctrl:RightController :\u003d new RightController()\npublic static  debug:bool :\u003d true\npublic  ChessWay() (() \u003d\u003d\u003e ChessWay)\n\tChessWay()() \u003d\u003d\n(\n\nfpga1.deploy(lctrl, \"LeftCtrl\");\nfpga2.deploy(rctrl, \"RightCtrl\")\n)\nend ChessWay\n","class Controller\npublic static  SAMPLETIME:real \u003d 0.001\npublic  mName:seq of (char) :\u003d (undefined)\npublic  mMotorActuator:MotorActuator :\u003d (undefined)\npublic  mMotorSensor:MotorSensor :\u003d (undefined)\npublic  Controller(seq of (char)) (seq of (char) \u003d\u003d\u003e Controller)\n\tController(seq of (char))(pName) \u003d\u003d\n(\n\nmName :\u003d pName;\nmMotorActuator :\u003d new MotorActuator(self);\nmMotorSensor :\u003d new MotorSensor(self)\n)\nprotected  mEnvironment:[Environment] :\u003d nil\npublic  setEnvironment(Environment) (Environment \u003d\u003d\u003e ())\n\tsetEnvironment(Environment)(pEnvironment) \u003d\u003d\nmEnvironment :\u003d pEnvironment\npublic  setValue(seq of (char), real) (seq of (char) * real \u003d\u003d\u003e ())\n\tsetValue(seq of (char), real)(pName, pValue) \u003d\u003d\nmEnvironment.setValue(((mName ^ \"_\") ^ pName), pValue)\n\tpre (mEnvironment \u003c\u003e nil)\npublic  getValue(seq of (char)) (seq of (char) \u003d\u003d\u003e real)\n\tgetValue(seq of (char))(pName) \u003d\u003d\nreturn ((mEnvironment.getValue)(((mName ^ \"_\") ^ pName)))\n\tpre (mEnvironment \u003c\u003e nil)\nprotected static  DEBUGCTRLLOOP:nat1 \u003d 2\nprotected  printDiagnostics(nat) (nat \u003d\u003d\u003e ())\n\tprintDiagnostics(nat)(pLoopCnt) \u003d\u003d\nduration (0) (\n\nIO`printf((mName ^ \" controller at %s on %s\n\"), [pLoopCnt, (time / 1.0E9)]);\nmMotorActuator.printDiagnostics()\n)\npublic  PowerUp() (() \u003d\u003d\u003e ())\n\tPowerUp()() \u003d\u003d\nis subclass responsibility\nprivate async  CtrlLoop() (() \u003d\u003d\u003e ())\n\tCtrlLoop()() \u003d\u003d\n(\n\nduration (0) CtrlLoopEntry();\nCtrlLoopBody();\nduration (0) CtrlLoopExit()\n)\npublic  CtrlLoopEntry() (() \u003d\u003d\u003e ())\n\tCtrlLoopEntry()() \u003d\u003d\nskip\npublic  CtrlLoopBody() (() \u003d\u003d\u003e ())\n\tCtrlLoopBody()() \u003d\u003d\nis subclass responsibility\npublic  CtrlLoopExit() (() \u003d\u003d\u003e ())\n\tCtrlLoopExit()() \u003d\u003d\nskip\nprotected  thread periodic(1, 0, 0, 0)(CtrlLoop())\nend Controller\n","class DTControl is subclass of [DTObject]\npublic  Output(real) (real \u003d\u003d\u003e real)\n\tOutput(real)(err) \u003d\u003d\nis subclass responsibility\nend DTControl\n","class DTObject\nprotected  sampletime:real :\u003d 1.0E-9\npublic  SetSampleTime(real) (real \u003d\u003d\u003e ())\n\tSetSampleTime(real)(s) \u003d\u003d\nsampletime :\u003d s\n\tpre (s \u003e\u003d 0)\nend DTObject\n","class DirectionSwitch\nprivate  mController:Controller :\u003d (undefined)\npublic  DirectionSwitch(Controller) (Controller \u003d\u003d\u003e DirectionSwitch)\n\tDirectionSwitch(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic static  tDirectionStatus \u003d tDirectionStatus\npublic  getStatus() (() \u003d\u003d\u003e tDirectionStatus)\n\tgetStatus()() \u003d\u003d\nduration (0) (\ndir:real :\u003d (mController.getValue)(\"DIRECTION\")\n\nif (dir \u003c 0.0)\nthen\nreturn (\u003cLEFT\u003e);\nif (dir \u003e 0.0)\nthen\nreturn (\u003cRIGHT\u003e);\nreturn (\u003cNEUTRAL\u003e)\n)\nend DirectionSwitch\n","class Environment\nprivate static  reserved:set of (seq of (char)) \u003d {\"LEFT_ACC_X\", \"LEFT_ACC_Y\", \"LEFT_ACC_Z\", \"LEFT_HALL1\", \"LEFT_HALL2\", \"LEFT_HALL3\", \"LEFT_PWM\", \"LEFT_ACTUATED\", \"LEFT_YAW_RATE\", \"RIGHT_HALL1\", \"RIGHT_HALL2\", \"RIGHT_HALL3\", \"RIGHT_PWM\", \"RIGHT_ACTUATED\", \"RIGHT_DIRECTION\", \"RIGHT_ONOFF\", \"RIGHT_SAFETY\", \"USER\", \"LEFT_ACC\", \"RIGHT_VEL\"}\npublic static  tCtCurve \u003d tCtCurve\npublic static  tCtBehavior \u003d tCtBehavior\n\tinv tcb \u003d\u003d (forall tc in set (rng tcb) \u0026 (forall i in set ((inds tc) \\ {1}) \u0026 ((tc((i - 1)).#1) \u003c (tc(i).#1))))\nprivate  mCtBehavior:tCtBehavior :\u003d {|-\u003e}\npublic  loadCsvFile(seq of (char), seq of (char)) (seq of (char) * seq of (char) \u003d\u003d\u003e ())\n\tloadCsvFile(seq of (char), seq of (char))(pctvar, pfname) \u003d\u003d\n(\nlcnt:nat :\u003d 1\nlctc:seq of (tCtCurve) :\u003d [mk_(0.0, 0.0, 0.0)]\n\nIO`printf(\"Reading CSV file %s\n\", [pfname]);\nlet mk_(rb, rv) \u003d CSV`flinecount(pfname) in if rb\nthen\n(\ncx:real :\u003d 0\ncy:real :\u003d 0\n\nIO`printf(\"Reading %s lines from CSV file\n\", [rv]);\nwhile (rv \u003e\u003d lcnt) do let mk_(-, vs):(bool * [seq of (real)]) \u003d (CSV`freadval)[seq of (real)](pfname, lcnt) in (\n\nif (vs(1) \u003e cx)\nthen\n(\n\nlctc :\u003d (lctc ^ [mk_((cx + 0.5), cy, 0.0)]);\ncx :\u003d vs(1);\ncy :\u003d vs(2)\n)else\ncy :\u003d ((cy + vs(2)) / 2);\nlcnt :\u003d (lcnt + 1)\n);\nif ((lctc((len lctc)).#1) \u003c cx)\nthen\nlctc :\u003d (lctc ^ [mk_((cx + 0.5), cy, 0.0)]);\nmCtBehavior :\u003d (mCtBehavior ++ {pctvar |-\u003e lctc});\nevalSensors(0);\nmUser.evaluate()\n)else\n(\n\nIO`println(\"Loading CSV file failed\");\nerror\n)\n)\n\tpre (pctvar in set reserved)\npublic  loadScenario(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tloadScenario(seq of (char))(pfname) \u003d\u003d\n(\n\nIO`printf(\"Reading scenario %s\n\", [pfname]);\nlet mk_(rb, rv) \u003d (IO`freadval)[tCtBehavior](pfname) in if rb\nthen\n(\n\nIO`println(\"Scenario loaded successfully\");\nmCtBehavior :\u003d rv;\nevalSensors(0);\nmUser.evaluate()\n)else\n(\n\nIO`println(\"Loading scenario failed\");\nerror\n)\n)\npublic  evalSensors(real) (real \u003d\u003d\u003e ())\n\tevalSensors(real)(ptime) \u003d\u003d\nfor all iname in set (dom mCtBehavior) do\nlet behaviors \u003d mCtBehavior(iname) in let behavior \u003d (hd behaviors) in if ((len behaviors) \u003d 1)\nthen\nevalSingle(ptime, iname, behavior)else\nlet mk_(ltime, -, -) \u003d (hd (tl behaviors)) in if (ltime \u003c\u003d ptime)\nthen\n(\n\nmCtBehavior :\u003d (mCtBehavior ++ {iname |-\u003e (tl behaviors)});\nevalSingle(ptime, iname, (hd (tl behaviors)))\n)else\nevalSingle(ptime, iname, behavior)\npublic  evalSingle(real, seq of (char), tCtCurve) (real * seq of (char) * tCtCurve \u003d\u003d\u003e ())\n\tevalSingle(real, seq of (char), tCtCurve)(ptime, pname, mk_(ltime, lvalue, ldir)) \u003d\u003d\nsetValue(pname, (lvalue + (ldir * (ptime - ltime))))\n\tpre (ptime \u003e\u003d ltime)\npublic static  debug:nat :\u003d 1\nprivate  mWorld:World :\u003d (undefined)\nprivate  mMaxSimTime:nat :\u003d (undefined)\nprivate  mLeftWheel:Wheel :\u003d (undefined)\nprivate  mRightWheel:Wheel :\u003d (undefined)\nprivate  mLeftHall:HallSensor :\u003d (undefined)\nprivate  mRightHall:HallSensor :\u003d (undefined)\nprivate  mUser:User :\u003d (undefined)\npublic  Environment(World, nat) (World * nat \u003d\u003d\u003e Environment)\n\tEnvironment(World, nat)(pWorld, pMaxSimTime) \u003d\u003d\n(\n\nmWorld :\u003d pWorld;\nmMaxSimTime :\u003d pMaxSimTime;\nmLeftWheel :\u003d new Wheel(\"LEFT\", self);\nmRightWheel :\u003d new Wheel(\"RIGHT\", self);\nmLeftHall :\u003d new HallSensor(\"LEFT\", self, mLeftWheel);\nmRightHall :\u003d new HallSensor(\"RIGHT\", self, mRightWheel);\nmLeftHall.evaluate();\nmRightHall.evaluate();\nmUser :\u003d new User(self, mLeftWheel, mRightWheel)\n)\nprivate  ain:ISensorReal :\u003d ChessWay`acc_in\nprivate  vin:ISensorReal :\u003d ChessWay`vel_in\nprivate  aout:IActuatorReal :\u003d ChessWay`acc_out\nprivate  vout:IActuatorReal :\u003d ChessWay`vel_out\nprivate  mValues:map (seq of (char)) to (real) :\u003d {|-\u003e}\npublic  setValue(seq of (char), real) (seq of (char) * real \u003d\u003d\u003e ())\n\tsetValue(seq of (char), real)(pName, pValue) \u003d\u003d\nduration (0) (\ncurrentValue:[real] :\u003d (if (pName in set (dom mValues))\nthen mValues(pName)\nelse nil)\n\nmValues :\u003d (mValues ++ {pName |-\u003e pValue});\nsetCosimValue(pName, pValue);\nif ((debug \u003e 1) and (pValue \u003c\u003e currentValue))\nthen\n(\n\nIO`print((pName ^ \" is set to \"));\nIO`print(pValue);\nIO`print(\" at \");\nIO`print((time / 1.0E9));\nIO`print(\"\n\")\n)\n)\n\tpre (pName in set reserved)\nprivate  setCosimValue(seq of (char), real) (seq of (char) * real \u003d\u003d\u003e ())\n\tsetCosimValue(seq of (char), real)(pName, pValue) \u003d\u003d\nif (mWorld.cosim)\nthen\ncases pName :\n  \"LEFT_ACC\" -\u003e ChessWay`acc_out.SetValue(pValue)  \"RIGHT_VEL\" -\u003e ChessWay`vel_out.SetValue(pValue)  others -\u003e skip end\npublic  getValue(seq of (char)) (seq of (char) \u003d\u003d\u003e real)\n\tgetValue(seq of (char))(pName) \u003d\u003d\nduration (0) if (pName not in set (dom mValues))\nthen\n(\n\nIO`print(((\"warning: \" ^ pName) ^ \" read before initialised\n\"));\nreturn (0.0)\n)else\n(\nretval:real :\u003d getCosimValue(pName)\n\nif (debug \u003e 1)\nthen\n(\n\nIO`print((pName ^ \" was \"));\nIO`print(retval);\nIO`print(\" at \");\nIO`print((time / 1.0E9));\nIO`print(\"\n\")\n);\nreturn (retval)\n)\n\tpre (pName in set reserved)\nprivate  getCosimValue(seq of (char)) (seq of (char) \u003d\u003d\u003e real)\n\tgetCosimValue(seq of (char))(pName) \u003d\u003d\ncases pName :\n  \"LEFT_ACC\" -\u003e return ((ChessWay`acc_in.GetValue)())  \"RIGHT_VEL\" -\u003e return ((ChessWay`vel_in.GetValue)())  others -\u003e return (mValues(pName)) end\nprivate  mutex(setValue)\nprivate  mutex(getValue)\nprivate  mutex(setValue, getValue)\nprivate  mainLoop() (() \u003d\u003d\u003e ())\n\tmainLoop()() \u003d\u003d\n(\nticks:nat :\u003d time\nclock:real :\u003d (ticks / World`SIM_RESOLUTION)\n\nevalSensors(clock);\nmLeftWheel.evaluate();\nmRightWheel.evaluate();\nmLeftHall.evaluate();\nmRightHall.evaluate();\nmUser.evaluate();\nif (debug \u003e 0)\nthen\nprintDiagnostics();\nif (ticks \u003e\u003d mMaxSimTime)\nthen\nterminate()\n)\nprivate  terminate() (() \u003d\u003d\u003e ())\n\tterminate()() \u003d\u003d\n(\n\nprintEnvironment();\nmWorld.signal()\n)\nprotected  thread periodic(1, 0, 0, 0)(mainLoop())\nprivate  printDiagnostics() (() \u003d\u003d\u003e ())\n\tprintDiagnostics()() \u003d\u003d\n(\n\nIO`print(\"\nEnvironment.mainLoop         \u003d \");\nIO`print((time / 1.0E9));\nIO`print(\"\n\")\n)\npublic  printEnvironment() (() \u003d\u003d\u003e ())\n\tprintEnvironment()() \u003d\u003d\n(\n\nIO`print(\"Dump of the environment\n\");\nfor all pKey in set (dom mValues) do\n(\n\nIO`print(pKey);\nIO`print(\" \u003d \");\nIO`print(mValues(pKey));\nIO`print(\"\n\")\n)\n)\nend Environment\n","class Gyroscope\nprivate  mController:Controller :\u003d (undefined)\npublic  Gyroscope(Controller) (Controller \u003d\u003d\u003e Gyroscope)\n\tGyroscope(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  getYawRateData() (() \u003d\u003d\u003e real)\n\tgetYawRateData()() \u003d\u003d\nduration (0) return ((mController.getValue)(\"YAW_RATE\"))\nend Gyroscope\n","class HallSensor\nprivate  mName:seq of (char) :\u003d (undefined)\nprivate  mEnvironment:Environment :\u003d (undefined)\nprivate  mWheel:Wheel :\u003d (undefined)\nprivate  private convert: (real -\u003e nat)\n\tconvert(prad) \u003d\u003d\nlet degrees:int \u003d (floor ((prad * MATH`pi) / 180)) in (degrees mod 360)\npublic  HallSensor(seq of (char), Environment, Wheel) (seq of (char) * Environment * Wheel \u003d\u003d\u003e HallSensor)\n\tHallSensor(seq of (char), Environment, Wheel)(pName, pEnvironment, pWheel) \u003d\u003d\n(\n\nmName :\u003d pName;\nmEnvironment :\u003d pEnvironment;\nmWheel :\u003d pWheel\n)\nprivate  setSensor(seq of (char), bool) (seq of (char) * bool \u003d\u003d\u003e ())\n\tsetSensor(seq of (char), bool)(pSensor, pValue) \u003d\u003d\nif pValue\nthen\nmEnvironment.setValue(pSensor, 1.0)else\nmEnvironment.setValue(pSensor, 0.0)\npublic  setSensors(bool, bool, bool) (bool * bool * bool \u003d\u003d\u003e ())\n\tsetSensors(bool, bool, bool)(ph1, ph2, ph3) \u003d\u003d\n(\n\nsetSensor((mName ^ \"_HALL1\"), ph1);\nsetSensor((mName ^ \"_HALL2\"), ph2);\nsetSensor((mName ^ \"_HALL3\"), ph3)\n)\npublic  evaluate() (() \u003d\u003d\u003e ())\n\tevaluate()() \u003d\u003d\nlet position \u003d convert((mWheel.position)) in cases (position div 60) :\n  0 -\u003e setSensors(true, false, true)  1 -\u003e setSensors(true, false, false)  2 -\u003e setSensors(true, true, false)  3 -\u003e setSensors(false, true, false)  4 -\u003e setSensors(false, true, true)  5 -\u003e setSensors(false, false, true)  others -\u003e error end\nend HallSensor\n","class IActuatorReal\npublic  SetValue(real) (real \u003d\u003d\u003e ())\n\tSetValue(real)(v) \u003d\u003d\nis subclass responsibility\nend IActuatorReal\n","class ISensorReal\npublic  GetValue() (() \u003d\u003d\u003e real)\n\tGetValue()() \u003d\u003d\nis subclass responsibility\nend ISensorReal\n","class LeftController is subclass of [Controller]\nprivate static  KP1:real \u003d 0.009\nprivate static  KI1:real \u003d 8.69565217391\nprivate static  KD1:real \u003d 0.02875\nprivate static  BETA1:real \u003d 0.1\npublic  ctrl:DTControl :\u003d (undefined)\npublic  mAccelerometer:Accelerometer :\u003d (undefined)\npublic  mGyroscope:Gyroscope :\u003d (undefined)\npublic  LeftController() (() \u003d\u003d\u003e LeftController)\n\tLeftController()() \u003d\u003d\n(\n\nChessWay`acc_in :\u003d new Sensor();\nChessWay`acc_out :\u003d new Actuator();\nctrl :\u003d new PID(KP1, KI1, KD1, BETA1);\nctrl.SetSampleTime(SAMPLETIME);\nmAccelerometer :\u003d new Accelerometer(self);\nmGyroscope :\u003d new Gyroscope(self);\nController(\"LEFT\")\n)\nprivate  mRight:[RightController] :\u003d nil\npublic  setRightController(RightController) (RightController \u003d\u003d\u003e ())\n\tsetRightController(RightController)(pRight) \u003d\u003d\nmRight :\u003d pRight\n\tpre (mRight \u003d nil)\nprivate  mLoopCnt:nat :\u003d 0\nprivate  mTimeEntry:nat :\u003d 0\nprivate  mDebug:nat :\u003d 0\npublic  CtrlLoopEntry() (() \u003d\u003d\u003e ())\n\tCtrlLoopEntry()() \u003d\u003d\n(\n\nmLoopCnt :\u003d (mLoopCnt + 1);\nmTimeEntry :\u003d time;\nif (mDebug \u003e\u003d DEBUGCTRLLOOP)\nthen\nIO`printf(\"LeftController.mainLoop  (S) \u003d %s (%s)\n\", [(mTimeEntry / 1.0E9), mLoopCnt])\n)\npublic  CtrlLoopBody() (() \u003d\u003d\u003e ())\n\tCtrlLoopBody()() \u003d\u003d\nduration (0) (\nuser:real :\u003d (mEnvironment.getValue)(\"USER\")\n\nIO`printf(\"user \u003d %s\n\", [user]);\nChessWay`acc_out.SetValue((ctrl.Output)(((ChessWay`acc_in.GetValue)() - user)));\nskip\n)\npublic  CtrlLoopExit() (() \u003d\u003d\u003e ())\n\tCtrlLoopExit()() \u003d\u003d\n(\nmTimeExit:nat :\u003d time\n\nif (mDebug \u003e\u003d DEBUGCTRLLOOP)\nthen\nIO`printf(\"LeftController.mainLoop  (F) \u003d %s (%s)\n\", [(mTimeExit / 1.0E9), mLoopCnt]);\nif (mDebug \u003e DEBUGCTRLLOOP)\nthen\nIO`printf(\"LeftController execution time was %s\n\", [((mTimeExit - mTimeEntry) / 1.0E9)])\n)\npublic  PowerUp() (() \u003d\u003d\u003e ())\n\tPowerUp()() \u003d\u003d\nduration (100) (\n\nmMotorActuator.initActuator();\nmMotorActuator.printDiagnostics()\n)\n\tpre (mRight \u003c\u003e nil)\npublic  printDiagnostics() (() \u003d\u003d\u003e ())\n\tprintDiagnostics()() \u003d\u003d\nduration (0) Controller`printDiagnostics(mLoopCnt)\npublic  computeResponse((bool * bool * bool), (real * real * real), real) ((bool * bool * bool) * (real * real * real) * real \u003d\u003d\u003e real)\n\tcomputeResponse((bool * bool * bool), (real * real * real), real)(-, -, -) \u003d\u003d\nreturn (-0.1)\nend LeftController\n","class MotorActuator is subclass of [IActuatorReal]\nprivate static  tDriveStatus \u003d tDriveStatus\nprivate  mDriveStatus:tDriveStatus :\u003d \u003cFREERUNNING\u003e\nprivate  mController:Controller :\u003d (undefined)\npublic  MotorActuator(Controller) (Controller \u003d\u003d\u003e MotorActuator)\n\tMotorActuator(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  initActuator() (() \u003d\u003d\u003e ())\n\tinitActuator()() \u003d\u003d\n(\n\nmDriveStatus :\u003d \u003cFREERUNNING\u003e;\nmController.setValue(\"ACTUATED\", 0);\nmController.setValue(\"PWM\", 0)\n)\npublic  isActuated() (() \u003d\u003d\u003e bool)\n\tisActuated()() \u003d\u003d\nreturn ((mDriveStatus \u003d \u003cACTUATED\u003e))\npublic  setFreeRunning() (() \u003d\u003d\u003e ())\n\tsetFreeRunning()() \u003d\u003d\nif isActuated()\nthen\n(\n\nmDriveStatus :\u003d \u003cFREERUNNING\u003e;\nduration (0) mController.setValue(\"ACTUATED\", 0);\nduration (0) if ChessWay`debug\nthen\nprintDiagnostics()\n)\npublic  setActuated() (() \u003d\u003d\u003e ())\n\tsetActuated()() \u003d\u003d\nif (not isActuated())\nthen\n(\n\nmDriveStatus :\u003d \u003cACTUATED\u003e;\nduration (0) mController.setValue(\"ACTUATED\", 1);\nduration (0) if ChessWay`debug\nthen\nprintDiagnostics()\n)\npublic  SetValue(real) (real \u003d\u003d\u003e ())\n\tSetValue(real)(v) \u003d\u003d\nif ((mController.mName) \u003d \"LEFT\")\nthen\nmController.setValue(\"ACC\", v)else\nmController.setValue(\"VEL\", v)\npublic  setPWM(real) (real \u003d\u003d\u003e ())\n\tsetPWM(real)(pPWM) \u003d\u003d\nif isActuated()\nthen\nduration (0) mController.setValue(\"PWM\", pPWM)else\nskip\n\tpre ((pPWM \u003e\u003d -1.0) and (pPWM \u003c\u003d 1.0))\npublic  printDiagnostics() (() \u003d\u003d\u003e ())\n\tprintDiagnostics()() \u003d\u003d\n(\n\nIO`print(((mController.mName) ^ \" motor is \"));\nIO`print(mDriveStatus);\nIO`print(\" at \");\nIO`print((time / 1.0E9));\nIO`print(\"\n\")\n)\nend MotorActuator\n","class MotorSensor is subclass of [ISensorReal]\nprivate  mController:Controller :\u003d (undefined)\npublic  MotorSensor(Controller) (Controller \u003d\u003d\u003e MotorSensor)\n\tMotorSensor(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  GetValue() (() \u003d\u003d\u003e real)\n\tGetValue()() \u003d\u003d\nif ((mController.mName) \u003d \"LEFT\")\nthen\nmController.getValue(\"ACC\")else\nmController.getValue(\"VEL\")\npublic  getHallSensorData() (() \u003d\u003d\u003e (bool * bool * bool))\n\tgetHallSensorData()() \u003d\u003d\nduration (0) (\nh1:real :\u003d (mController.getValue)(\"HALL1\")\nh2:real :\u003d (mController.getValue)(\"HALL2\")\nh3:real :\u003d (mController.getValue)(\"HALL3\")\n\nreturn (mk_((h1 \u003e 0), (h2 \u003e 0), (h3 \u003e 0)))\n)\nend MotorSensor\n","class OnOffSwitch\nprivate  mController:Controller :\u003d (undefined)\npublic  OnOffSwitch(Controller) (Controller \u003d\u003d\u003e OnOffSwitch)\n\tOnOffSwitch(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  getStatus() (() \u003d\u003d\u003e bool)\n\tgetStatus()() \u003d\u003d\nduration (0) return (((mController.getValue)(\"ONOFF\") \u003e 0))\nend OnOffSwitch\n","class P is subclass of [DTControl]\nprotected  k:real :\u003d (undefined)\npublic  P(real) (real \u003d\u003d\u003e P)\n\tP(real)(k_) \u003d\u003d\n(\n\nk :\u003d k_\n)\npublic  P() (() \u003d\u003d\u003e P)\n\tP()() \u003d\u003d\nP(DEF_K)\npublic  Output(real) (real \u003d\u003d\u003e real)\n\tOutput(real)(err) \u003d\u003d\n(\n\nreturn ((k * err))\n)\nprivate static  DEF_K:real \u003d 0.2\nend P\n","class PD is subclass of [DTControl]\nprotected  k:real :\u003d (undefined)\nprotected  tauD:real :\u003d (undefined)\nprotected  beta:real :\u003d (undefined)\nprotected  uD:real :\u003d (undefined)\nprotected  prev_err:real :\u003d (undefined)\npublic  PD(real, real, real) (real * real * real \u003d\u003d\u003e PD)\n\tPD(real, real, real)(k_, tauD_, beta_) \u003d\u003d\n(\n\nk :\u003d k_;\ntauD :\u003d tauD_;\nbeta :\u003d beta_;\nuD :\u003d 0.0;\nprev_err :\u003d 0.0\n)\npublic  PD(real, real) (real * real \u003d\u003d\u003e PD)\n\tPD(real, real)(k_, tauD_) \u003d\u003d\nPD(k_, tauD_, DEF_BETA)\npublic  PD() (() \u003d\u003d\u003e PD)\n\tPD()() \u003d\u003d\nPD(DEF_K, DEF_TAUD, DEF_BETA)\npublic  Output(real) (real \u003d\u003d\u003e real)\n\tOutput(real)(err) \u003d\u003d\n(\nfactor:real :\u003d (1 / (sampletime + (tauD * beta)))\n\nuD :\u003d (factor * ((((tauD * uD) * beta) + ((tauD * k) * (err - prev_err))) + ((sampletime * k) * err)));\nprev_err :\u003d err;\nreturn (uD)\n)\nprivate static  DEF_K:real \u003d 0.2\nprivate static  DEF_TAUD:real \u003d 1.0\nprivate static  DEF_BETA:real \u003d 0.1\nend PD\n","class PI is subclass of [DTControl]\nprotected  k:real :\u003d (undefined)\nprotected  tauI:real :\u003d (undefined)\nprotected  uP:real :\u003d (undefined)\nprotected  uI:real :\u003d (undefined)\npublic  PI(real, real) (real * real \u003d\u003d\u003e PI)\n\tPI(real, real)(k_, tauI_) \u003d\u003d\n(\n\nk :\u003d k_;\ntauI :\u003d tauI_;\nuP :\u003d 0;\nuI :\u003d 0\n)\npublic  PI() (() \u003d\u003d\u003e PI)\n\tPI()() \u003d\u003d\nPI(DEF_K, DEF_TAUI)\npublic  Output(real) (real \u003d\u003d\u003e real)\n\tOutput(real)(err) \u003d\u003d\n(\nbi:real :\u003d ((k * sampletime) / tauI)\n\nuP :\u003d (k * err);\nuI :\u003d (uI + (bi * err));\nreturn ((uP + uI))\n)\nprivate static  DEF_K:real \u003d 1\nprivate static  DEF_TAUI:real \u003d 0.5\nend PI\n","class PID is subclass of [DTControl]\nprotected  k:real :\u003d (undefined)\nprotected  tauI:real :\u003d (undefined)\nprotected  tauD:real :\u003d (undefined)\nprotected  beta:real :\u003d (undefined)\nprotected  uP:real :\u003d (undefined)\nprotected  uD:real :\u003d (undefined)\nprotected  uI:real :\u003d (undefined)\nprotected  prev_err:real :\u003d (undefined)\npublic  PID(real, real, real, real) (real * real * real * real \u003d\u003d\u003e PID)\n\tPID(real, real, real, real)(k_, tauI_, tauD_, beta_) \u003d\u003d\n(\n\nk :\u003d k_;\ntauI :\u003d tauI_;\ntauD :\u003d tauD_;\nbeta :\u003d beta_;\nuP :\u003d 0;\nuD :\u003d 0;\nuI :\u003d 0;\nprev_err :\u003d 0\n)\n\tpre ((tauI_ \u003c\u003e 0) and ((tauD_ \u003c\u003e 0) and ((beta_ \u003e 0) and (beta_ \u003c\u003d 1))))\npublic  PID(real, real, real) (real * real * real \u003d\u003d\u003e PID)\n\tPID(real, real, real)(k_, tauI_, tauD_) \u003d\u003d\nPID(k_, tauI_, tauD_, DEF_BETA)\n\tpre ((tauI_ \u003c\u003e 0) and (tauD_ \u003c\u003e 0))\npublic  PID() (() \u003d\u003d\u003e PID)\n\tPID()() \u003d\u003d\nPID(DEF_K, DEF_TAUI, DEF_TAUD, DEF_BETA)\npublic  Output(real) (real \u003d\u003d\u003e real)\n\tOutput(real)(err) \u003d\u003d\n(\nfactor:real :\u003d (1 / (sampletime + (tauD * beta)))\n\nuD :\u003d (factor * ((((tauD * uD) * beta) + ((tauD * k) * (err - prev_err))) + ((sampletime * k) * err)));\nuI :\u003d (uI + ((sampletime * tauD) / tauI));\nprev_err :\u003d err;\nreturn ((uI + uD))\n)\nprivate static  DEF_K:real \u003d 0.2\nprivate static  DEF_TAUI:real \u003d 0.5\nprivate static  DEF_TAUD:real \u003d 1.0\nprivate static  DEF_BETA:real \u003d 0.1\nend PID\n","class RightController is subclass of [Controller]\nprivate static  KP2:real \u003d 20\nprivate static  KI2:real \u003d 78.431372549\nprivate static  KD2:real \u003d 0.0031875\nprivate static  BETA2:real \u003d 0.1\npublic  ctrl:DTControl :\u003d (undefined)\npublic  mSafetySwitch:SafetySwitch :\u003d (undefined)\npublic  mOnOffSwitch:OnOffSwitch :\u003d (undefined)\npublic  mDirectionSwitch:DirectionSwitch :\u003d (undefined)\npublic  RightController() (() \u003d\u003d\u003e RightController)\n\tRightController()() \u003d\u003d\n(\n\nChessWay`vel_in :\u003d new Sensor();\nChessWay`vel_out :\u003d new Actuator();\nctrl :\u003d new P(KP2);\nctrl.SetSampleTime(SAMPLETIME);\nmSafetySwitch :\u003d new SafetySwitch(self);\nmOnOffSwitch :\u003d new OnOffSwitch(self);\nmDirectionSwitch :\u003d new DirectionSwitch(self);\nController(\"RIGHT\")\n)\nprivate  mLeft:[LeftController] :\u003d nil\npublic  setLeftController(LeftController) (LeftController \u003d\u003d\u003e ())\n\tsetLeftController(LeftController)(pLeft) \u003d\u003d\nmLeft :\u003d pLeft\n\tpre (mLeft \u003d nil)\nprivate  mLoopCnt:nat :\u003d 0\nprivate  mTimeEntry:nat :\u003d 0\nprivate  mDebug:nat :\u003d 0\npublic  CtrlLoopEntry() (() \u003d\u003d\u003e ())\n\tCtrlLoopEntry()() \u003d\u003d\nduration (0) (\n\nmLoopCnt :\u003d (mLoopCnt + 1);\nmTimeEntry :\u003d time;\nif (mDebug \u003e\u003d DEBUGCTRLLOOP)\nthen\nIO`printf(\"RightController.mainLoop (S) \u003d %s (%s)\n\", [(mTimeEntry / 1.0E9), mLoopCnt])\n)\npublic  CtrlLoopBody() (() \u003d\u003d\u003e ())\n\tCtrlLoopBody()() \u003d\u003d\nduration (0) (\n\nChessWay`vel_out.SetValue((ctrl.Output)((ChessWay`vel_in.GetValue)()));\nskip\n)\npublic  CtrlLoopExit() (() \u003d\u003d\u003e ())\n\tCtrlLoopExit()() \u003d\u003d\nduration (0) (\nmTimeExit:nat :\u003d time\n\nif (mDebug \u003e\u003d DEBUGCTRLLOOP)\nthen\nIO`printf(\"RightController.mainLoop (F) \u003d %s (%s)\n\", [(mTimeExit / 1.0E9), mLoopCnt]);\nif (mDebug \u003e DEBUGCTRLLOOP)\nthen\nIO`printf(\"RightController execution time was %s\n\", [((mTimeExit - mTimeEntry) / 1.0E9)])\n)\npublic  PowerUp() (() \u003d\u003d\u003e ())\n\tPowerUp()() \u003d\u003d\nduration (100) (\n\nmMotorActuator.initActuator();\nmMotorActuator.printDiagnostics()\n)\n\tpre (mLeft \u003c\u003e nil)\npublic  printDiagnostics() (() \u003d\u003d\u003e ())\n\tprintDiagnostics()() \u003d\u003d\nduration (0) Controller`printDiagnostics(mLoopCnt)\npublic  computeResponse((bool * bool * bool), bool, bool, tDirectionStatus) ((bool * bool * bool) * bool * bool * tDirectionStatus \u003d\u003d\u003e real)\n\tcomputeResponse((bool * bool * bool), bool, bool, tDirectionStatus)(-, -, onoff, -) \u003d\u003d\n(\n\nif onoff\nthen\n(\n\nmMotorActuator.setActuated();\nmLeft.mMotorActuator.setActuated()\n)else\n(\n\nmMotorActuator.setFreeRunning();\nmLeft.mMotorActuator.setFreeRunning()\n);\nreturn (0.1)\n)\nend RightController\n","class SafetySwitch\nprivate  mController:Controller :\u003d (undefined)\npublic  SafetySwitch(Controller) (Controller \u003d\u003d\u003e SafetySwitch)\n\tSafetySwitch(Controller)(pController) \u003d\u003d\nmController :\u003d pController\npublic  getStatus() (() \u003d\u003d\u003e bool)\n\tgetStatus()() \u003d\u003d\nduration (0) return (((mController.getValue)(\"SAFETY\") \u003e 0))\nend SafetySwitch\n","class Sensor is subclass of [ISensorReal]\nprivate  value:real :\u003d (undefined)\npublic  Sensor(real) (real \u003d\u003d\u003e Sensor)\n\tSensor(real)(v) \u003d\u003d\nvalue :\u003d v\npublic  Sensor() (() \u003d\u003d\u003e Sensor)\n\tSensor()() \u003d\u003d\nSensor(0.0)\npublic  GetValue() (() \u003d\u003d\u003e real)\n\tGetValue()() \u003d\u003d\n(\n\nIO`printf(\"GetValue \u003d %s\n\", [value]);\nreturn (value)\n)\nend Sensor\n","class SetpointProfileCSV\nprivate  filename:seq of (char) :\u003d (undefined)\nprivate  lines:int :\u003d (undefined)\nprivate  line:int :\u003d (undefined)\nprivate  setpoint:real :\u003d (undefined)\nprivate  next_setpoint:[(real * real)] :\u003d (undefined)\npublic  SetpointProfileCSV(real, seq of (char)) (real * seq of (char) \u003d\u003d\u003e SetpointProfileCSV)\n\tSetpointProfileCSV(real, seq of (char))(init, file) \u003d\u003d\n(\n\nfilename :\u003d file;\nline :\u003d 1;\nlet mk_(success, l):(bool * int) \u003d CSV`flinecount(file) in (\n\nif (not success)\nthen\nquit(\"Failed to read input file \u0027%s\u0027: %s.\", [file, (new CSV().ferror)()]);\nlines :\u003d l\n);\nsetpoint :\u003d init;\nnext_setpoint :\u003d nil\n)\npublic  SetpointProfileCSV(seq of (char)) (seq of (char) \u003d\u003d\u003e SetpointProfileCSV)\n\tSetpointProfileCSV(seq of (char))(file) \u003d\u003d\nSetpointProfileCSV(0.0, file)\nprivate  ReadNextSetpoint() (() \u003d\u003d\u003e ())\n\tReadNextSetpoint()() \u003d\u003d\n(\n\nlet mk_(-, vals):(bool * [seq of (real)]) \u003d (CSV`freadval)[seq of (real)](filename, line) in (\n\nif ((len vals) \u003c\u003e 2)\nthen\nquit(\"Incorrect number of values in %s line %s (expected: 2, actual: %s)\n\", [filename, line, (len vals)])else\n(\n\nnext_setpoint :\u003d mk_(vals(1), vals(2));\nline :\u003d (line + 1)\n)\n)\n)\n\tpre ((line \u003c\u003d lines) and (next_setpoint \u003d nil))\npublic  GetSetpoint() (() \u003d\u003d\u003e real)\n\tGetSetpoint()() \u003d\u003d\n(\ncurtime:real :\u003d (time / 1.0E9)\n\nif (line \u003d lines)\nthen\nreturn (setpoint);\nif (next_setpoint \u003d nil)\nthen\nReadNextSetpoint();\nlet mk_(t, sp):[(real * real)] \u003d next_setpoint in if (curtime \u003e\u003d t)\nthen\n(\n\nsetpoint :\u003d sp;\nnext_setpoint :\u003d nil\n);\nIO`printf(\"setpoint (%s) \u003d %s\n\", [curtime, setpoint]);\nreturn (setpoint)\n)\nprivate  quit(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tquit(seq of (char), seq of (?))(m, s) \u003d\u003d\n(\n\nIO`printf((m ^ \"\n\"), s);\nexit;\n)\nprivate  quit(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tquit(seq of (char))(m) \u003d\u003d\n(\n\nIO`println(m);\nexit;\n)\nend SetpointProfileCSV\n","class User\nprivate static  gravity:real \u003d 9.80665\nprivate  mEnvironment:Environment :\u003d (undefined)\nprivate  mLeftWheel:Wheel :\u003d (undefined)\nprivate  mRightWheel:Wheel :\u003d (undefined)\nprivate  last:nat :\u003d 0\nprivate  angle:real :\u003d 0.0\npublic  User(Environment, Wheel, Wheel) (Environment * Wheel * Wheel \u003d\u003d\u003e User)\n\tUser(Environment, Wheel, Wheel)(pEnvironment, pLeftWheel, pRightWheel) \u003d\u003d\n(\n\nmEnvironment :\u003d pEnvironment;\nmLeftWheel :\u003d pLeftWheel;\nmRightWheel :\u003d pRightWheel\n)\npublic  evaluate() (() \u003d\u003d\u003e ())\n\tevaluate()() \u003d\u003d\n(\nuser:real :\u003d (mEnvironment.getValue)(\"USER\")\nnow:nat :\u003d time\n\nlet dt \u003d ((now - last) / World`SIM_RESOLUTION) in let rate \u003d (if (dt \u003d 0)\nthen 0\nelse ((angle - user) / dt)) in mEnvironment.setValue(\"LEFT_YAW_RATE\", rate);\nlet dx \u003d (MATH`cos(user) * gravity) in mEnvironment.setValue(\"LEFT_ACC_X\", dx);\nlet dy \u003d (MATH`sin(user) * gravity) in mEnvironment.setValue(\"LEFT_ACC_Y\", dy);\nlet dz \u003d ((mLeftWheel.acc) - (mRightWheel.acc)) in mEnvironment.setValue(\"LEFT_ACC_Z\", dz);\nangle :\u003d user;\nlast :\u003d now\n)\nend User\n","class Wheel\nprivate static  MAX_ACC:real \u003d 62.8318531\nprivate  mName:seq of (char) :\u003d (undefined)\nprivate  mEnvironment:Environment :\u003d (undefined)\nprivate  last:nat :\u003d 0\npublic  acc:real :\u003d 0.0\npublic  speed:real :\u003d 0.0\npublic  position:real :\u003d 0.0\npublic  Wheel(seq of (char), Environment) (seq of (char) * Environment \u003d\u003d\u003e Wheel)\n\tWheel(seq of (char), Environment)(pname, penv) \u003d\u003d\n(\n\nmName :\u003d pname;\nmEnvironment :\u003d penv\n)\nprivate  isActuated() (() \u003d\u003d\u003e bool)\n\tisActuated()() \u003d\u003d\nreturn (((mEnvironment.getValue)((mName ^ \"_ACTUATED\")) \u003d 1))\nprivate  getPWM() (() \u003d\u003d\u003e real)\n\tgetPWM()() \u003d\u003d\nreturn ((mEnvironment.getValue)((mName ^ \"_PWM\")))\npublic  evaluate() (() \u003d\u003d\u003e ())\n\tevaluate()() \u003d\u003d\n(\npwm:real :\u003d (if isActuated()\nthen getPWM()\nelse 0.0)\nold_acc:real :\u003d acc\nold_speed:real :\u003d speed\nnow:nat :\u003d time\n\nlet dt \u003d ((now - last) / World`SIM_RESOLUTION) in (\n\nacc :\u003d (MAX_ACC * pwm);\nspeed :\u003d (speed + ((0.5 * dt) * (old_acc + acc)));\nposition :\u003d (position + ((0.5 * dt) * (old_speed + speed)));\nlast :\u003d now\n)\n)\nend Wheel\n","class World\npublic static  SIM_RESOLUTION:nat1 \u003d 1.0E9\npublic static  MAX_SIM_TIME:nat1 \u003d (20 * SIM_RESOLUTION)\npublic static  cosim:bool :\u003d false\npublic  run() (() \u003d\u003d\u003e ())\n\trun()() \u003d\u003d\n(\n\ncosim :\u003d true;\nRunScenario(\"steeringsignal1.csv\")\n)\npublic  RunVdmRt() (() \u003d\u003d\u003e ())\n\tRunVdmRt()() \u003d\u003d\nRunScenario(\"scenario1.txt\")\npublic  RunScenario(seq1 of (char)) (seq1 of (char) \u003d\u003d\u003e ())\n\tRunScenario(seq1 of (char))(fname) \u003d\u003d\n(\nenv:Environment :\u003d new Environment(self, MAX_SIM_TIME)\n\nif cosim\nthen\nenv.loadCsvFile(\"USER\", fname)else\nenv.loadScenario(fname);\nChessWay`lctrl.setEnvironment(env);\nChessWay`rctrl.setEnvironment(env);\nChessWay`lctrl.setRightController(ChessWay`rctrl);\nChessWay`rctrl.setLeftController(ChessWay`lctrl);\nIO`print(\"Starting ChessWay DE simulation\n\");\nChessWay`lctrl.PowerUp();\nChessWay`rctrl.PowerUp();\nstart ({env, ChessWay`lctrl, ChessWay`rctrl});\nwaitForSimulationEnd();\nIO`print(\"ChessWay DE simulation completed at \");\nIO`print((time / SIM_RESOLUTION));\nIO`print(\" sec\n\")\n)\npublic  finish:bool :\u003d false\nprivate  waitForSimulationEnd() (() \u003d\u003d\u003e ())\n\twaitForSimulationEnd()() \u003d\u003d\nif ChessWay`debug\nthen\n(\n\nChessWay`lctrl.printDiagnostics();\nChessWay`rctrl.printDiagnostics()\n)\npublic  signal() (() \u003d\u003d\u003e ())\n\tsignal()() \u003d\u003d\n(\n\nfinish :\u003d true;\nIO`println(\"Environment requests end of simulation\")\n)\nprivate  per waitForSimulationEnd \u003d\u003e finish\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n","class CSV is subclass of [IO]\npublic static  public static fwriteval: (seq1 of (char) * seq of (?) * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) * int -\u003e (bool * [@p]))\n\tfreadval(f, index) \u003d\u003d\nis not yet specified\npublic static  public static flinecount: (seq1 of (char) -\u003e (bool * int))\n\tflinecount(f) \u003d\u003d\nis not yet specified\npublic static  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\nend CSV\n"]