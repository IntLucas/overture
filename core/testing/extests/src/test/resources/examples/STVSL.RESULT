["state AAHof\n[active_axes : set of (RotAxis), ignore_hcm : set of (RotAxis), toggle : EngageState, timeout : nat]\n\tinit s \u003d\u003d (s \u003d mk_AAH({}, {}, \u003cAAH_off\u003e, 0))","EngageState \u003d EngageState","click_timeout:nat \u003d 10","Transition (ControlButton * SixDofCommand * nat \u003d\u003d\u003e ())\n\tTransition(button_pos, hcm_cmd, clock) \u003d\u003d\nlet engage:EngageState \u003d ButtonTransition(toggle, button_pos, active_axes, clock, timeout), starting:bool \u003d ((toggle \u003d \u003cAAH_off\u003e) and (engage \u003d \u003cAAH_started\u003e)) in (\n\nactive_axes :\u003d {a | a in set AUX`rot_axis_set \u0026 (starting or ((engage \u003c\u003e \u003cAAH_off\u003e) and ((a in set active_axes) and (((hcm_cmd.rot)(a) \u003d \u003cZero\u003e) or (a in set ignore_hcm)))))};\nignore_hcm :\u003d {a | a in set AUX`rot_axis_set \u0026 ((starting and ((hcm_cmd.rot)(a) \u003c\u003e \u003cZero\u003e)) or ((not starting) and (a in set ignore_hcm)))};\ntimeout :\u003d (if ((toggle \u003d \u003cAAH_on\u003e) and (engage \u003d \u003cpressed_once\u003e))\nthen (clock + click_timeout)\nelse timeout);\ntoggle :\u003d engage\n)","ActiveAxes (() \u003d\u003d\u003e set of (RotAxis))\n\tActiveAxes() \u003d\u003d\nreturn (active_axes)","IgnoreHcm (() \u003d\u003d\u003e set of (RotAxis))\n\tIgnoreHcm() \u003d\u003d\nreturn (ignore_hcm)","Toggle (() \u003d\u003d\u003e EngageState)\n\tToggle() \u003d\u003d\nreturn (toggle)","private AllAxesOff: (set of (RotAxis) +\u003e bool)\n\tAllAxesOff(active) \u003d\u003d\n(active \u003d {})","private ButtonTransition: (EngageState * ControlButton * set of (RotAxis) * nat * nat +\u003e EngageState)\n\tButtonTransition(estate, button, active, clock, timeout) \u003d\u003d\n(cases mk_(estate, button) :\nmk_(\u003cAAH_off\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cAAH_off\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_started\u003e, \u003cUp\u003e) -\u003e \u003cAAH_on\u003e,\nmk_(\u003cAAH_started\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_on\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff(active)\nthen \u003cAAH_off\u003e\nelse \u003cAAH_on\u003e),\nmk_(\u003cAAH_on\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cpressed_once\u003e, \u003cUp\u003e) -\u003e \u003cAAH_closing\u003e,\nmk_(\u003cpressed_once\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cAAH_closing\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff(active)\nthen \u003cAAH_off\u003e\nelseif (clock \u003e timeout)\nthen \u003cAAH_on\u003e\nelse \u003cAAH_closing\u003e),\nmk_(\u003cAAH_closing\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e\n end)","arbitrary_value:token \u003d mk_token(1001)","axis_command_set:set of (AxisCommand) \u003d {\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e}","tran_axis_set:set of (TranAxis) \u003d {\u003cX\u003e, \u003cY\u003e, \u003cZ\u003e}","rot_axis_set:set of (RotAxis) \u003d {\u003cRoll\u003e, \u003cPitch\u003e, \u003cYaw\u003e}","null_tran_command:TranCommand \u003d {a |-\u003e \u003cZero\u003e | a in set tran_axis_set}","null_rot_command:RotCommand \u003d {a |-\u003e \u003cZero\u003e | a in set rot_axis_set}","null_six_dof:SixDofCommand \u003d mk_SixDofCommand(null_tran_command, null_rot_command)","AxisCommand \u003d AxisCommand","TranAxis \u003d TranAxis","RotAxis \u003d RotAxis","TranCommand \u003d TranCommand\n\tinv cmd \u003d\u003d ((dom cmd) \u003d tran_axis_set)","RotCommand \u003d RotCommand\n\tinv cmd \u003d\u003d ((dom cmd) \u003d rot_axis_set)","SixDofCommand \u003d SixDofCommand","SwitchPositions \u003d SwitchPositions","ControlModeSwitch \u003d ControlModeSwitch","ControlButton \u003d ControlButton","HandGripPosition \u003d HandGripPosition","private GripCommand: (HandGripPosition * ControlModeSwitch +\u003e SixDofCommand)\n\tGripCommand(mk_HandGripPosition(vert, horiz, trans, twist), mode) \u003d\u003d\nlet tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen trans\nelse \u003cZero\u003e)} in mk_AUX`SixDofCommand(tran, rot)","state SAFERof\n[clock : nat]\n\tinit s \u003d\u003d (s \u003d mk_SAFER(0))","ControlCycle (SwitchPositions * HandGripPosition * RotCommand \u003d\u003d\u003e ThrusterSet)\n\tControlCycle(mk_SwitchPositions(mode, aah), raw_grip, aah_cmd) \u003d\u003d\nlet grip_cmd:SixDofCommand \u003d HCM`GripCommand(raw_grip, mode), thrusters:ThrusterSet \u003d TS`SelectedThrusters(grip_cmd, aah_cmd, AAH`ActiveAxes(), AAH`IgnoreHcm()) in (\n\nAAH`Transition(aah, grip_cmd, clock);\nclock :\u003d (clock + 1);\nreturn (thrusters)\n)\n\tpost (((card RESULT) \u003c\u003d 4) and ThrusterConsistency(RESULT))","private ThrusterConsistency: (set of (ThrusterName) +\u003e bool)\n\tThrusterConsistency(thrusters) \u003d\u003d\n((not ({\u003cB1\u003e, \u003cF1\u003e} subset thrusters)) and ((not ({\u003cB2\u003e, \u003cF2\u003e} subset thrusters)) and ((not ({\u003cB3\u003e, \u003cF3\u003e} subset thrusters)) and ((not ({\u003cB4\u003e, \u003cF4\u003e} subset thrusters)) and ((not (((thrusters inter {\u003cL1R\u003e, \u003cL1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR2R\u003e, \u003cR2F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cL3R\u003e, \u003cL3F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR4R\u003e, \u003cR4F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cD1R\u003e, \u003cD1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU3R\u003e, \u003cU3F\u003e}) \u003c\u003e {}))) and (not (((thrusters inter {\u003cD2R\u003e, \u003cD2F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU4R\u003e, \u003cU4F\u003e}) \u003c\u003e {}))))))))))","switches_tran_up:HCM`SwitchPositions \u003d mk_HCM`SwitchPositions(\u003cTran\u003e, \u003cUp\u003e)","switch_positions:set of (SwitchPositions) \u003d {mk_HCM`SwitchPositions(mode, aah) | mode in set {\u003cTran\u003e, \u003cRot\u003e}, aah in set {\u003cUp\u003e, \u003cDown\u003e}}","zero_grip:HandGripPosition \u003d mk_HCM`HandGripPosition(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e)","all_grip_positions:set of (HandGripPosition) \u003d {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | vert, horiz, trans, twist in set AUX`axis_command_set}","all_rot_commands:set of (RotCommand) \u003d {{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set AUX`axis_command_set}","grip_positions:set of (HandGripPosition) \u003d {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | vert, horiz, trans, twist in set AUX`axis_command_set \u0026 (((vert \u003d \u003cZero\u003e) and ((horiz \u003d \u003cZero\u003e) and (trans \u003d \u003cZero\u003e))) or (((vert \u003d \u003cZero\u003e) and ((horiz \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))) or (((vert \u003d \u003cZero\u003e) and ((trans \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))) or ((horiz \u003d \u003cZero\u003e) and ((trans \u003d \u003cZero\u003e) and (twist \u003d \u003cZero\u003e))))))}","possibilities:set of ((SwitchPositions * HandGripPosition * RotCommand)) \u003d {mk_(switch, grip, aah_law) | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands}","private BigTest: (() -\u003e map ((SwitchPositions * HandGripPosition * RotCommand)) to (ThrusterSet))\n\tBigTest() \u003d\u003d\n{mk_(switch, grip, aah_law) |-\u003e SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands}","private HugeTest: (() -\u003e map ((SwitchPositions * HandGripPosition * RotCommand)) to (ThrusterSet))\n\tHugeTest() \u003d\u003d\n{mk_(switch, grip, aah_law) |-\u003e SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands}","private ConvertAxisCmd: (seq of (char) -\u003e AxisCommand)\n\tConvertAxisCmd(str) \u003d\u003d\n(cases str :\n\"neg\" -\u003e \u003cNeg\u003e,\n\"pos\" -\u003e \u003cPos\u003e,\n\"zero\" -\u003e \u003cZero\u003e\nothers (undefined)\n end)","private ConvertTIds: (ThrusterSet +\u003e seq of (seq of (char)))\n\tConvertTIds(ts) \u003d\u003d\n(if (ts \u003d {})\nthen []\nelse let t in set ts in ([ConvertTId(t)] ^ ConvertTIds((ts \\ {t}))))","private ConvertTId: (ThrusterName +\u003e seq of (char))\n\tConvertTId(tnm) \u003d\u003d\n(cases tnm :\n\u003cB1\u003e -\u003e \"B1\",\n\u003cB2\u003e -\u003e \"B2\",\n\u003cB3\u003e -\u003e \"B3\",\n\u003cB4\u003e -\u003e \"B4\",\n\u003cF1\u003e -\u003e \"F1\",\n\u003cF2\u003e -\u003e \"F2\",\n\u003cF3\u003e -\u003e \"F3\",\n\u003cF4\u003e -\u003e \"F4\",\n\u003cL1R\u003e -\u003e \"L1R\",\n\u003cL1F\u003e -\u003e \"L1F\",\n\u003cR2R\u003e -\u003e \"R2R\",\n\u003cR2F\u003e -\u003e \"R2F\",\n\u003cL3R\u003e -\u003e \"L3R\",\n\u003cL3F\u003e -\u003e \"L3F\",\n\u003cR4R\u003e -\u003e \"R4R\",\n\u003cR4F\u003e -\u003e \"R4F\",\n\u003cD1R\u003e -\u003e \"D1R\",\n\u003cD1F\u003e -\u003e \"D1F\",\n\u003cD2R\u003e -\u003e \"D2R\",\n\u003cD2F\u003e -\u003e \"D2F\",\n\u003cU3R\u003e -\u003e \"U3R\",\n\u003cU3F\u003e -\u003e \"U3F\",\n\u003cU4R\u003e -\u003e \"U4R\",\n\u003cU4F\u003e -\u003e \"U4F\"\n end)","StartTest (() \u003d\u003d\u003e ())\n\tStartTest() \u003d\u003d\n(\n\nGUI`GUI_Init_Tcl();\nGEOM`InitGeom()\n)","RunTest (() \u003d\u003d\u003e bool)\n\tRunTest() \u003d\u003d\nlet cl:seq of (seq of (char)) \u003d GUI`GetCommand() in if (cl \u003d [])\nthen\nreturn (false)else\nlet [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:seq of (seq of (char)) \u003d cl, ts:ThrusterSet \u003d SAFER`ControlCycle(mk_HCM`SwitchPositions((if (mode \u003d \"translation\")\nthen \u003cTran\u003e\nelse \u003cRot\u003e), (if (aah \u003d \"1\")\nthen \u003cUp\u003e\nelse \u003cDown\u003e)), mk_HCM`HandGripPosition(ConvertAxisCmd(vert), ConvertAxisCmd(horiz), ConvertAxisCmd(trans), ConvertAxisCmd(twist)), {\u003cRoll\u003e |-\u003e ConvertAxisCmd(roll), \u003cPitch\u003e |-\u003e ConvertAxisCmd(pitch), \u003cYaw\u003e |-\u003e ConvertAxisCmd(yaw)}) in (\n\nGEOM`ShowThrust(ConvertTIds(ts));\nreturn (true)\n)","Loop (() \u003d\u003d\u003e ())\n\tLoop() \u003d\u003d\n(\n\nStartTest();\nwhile RunTest() do skip;\nGEOM`ShowThrust([\"stop\"])\n)","Move (() \u003d\u003d\u003e ())\n\tMove() \u003d\u003d\nGEOM`ShowThrust([\"move\"])","NoMove (() \u003d\u003d\u003e ())\n\tNoMove() \u003d\u003d\nGEOM`ShowThrust([\"nomove\"])","ThrusterName \u003d ThrusterName","ThrusterSet \u003d ThrusterSet","private RotCmdsPresent: (RotCommand +\u003e bool)\n\tRotCmdsPresent(cmd) \u003d\u003d\n(exists a in set (dom cmd) \u0026 (cmd(a) \u003c\u003e \u003cZero\u003e))","private PrioritizedTranCmd: (TranCommand +\u003e TranCommand)\n\tPrioritizedTranCmd(tran) \u003d\u003d\n(if (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cX\u003e |-\u003e tran(\u003cX\u003e)})\nelseif (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cY\u003e |-\u003e tran(\u003cY\u003e)})\nelseif (tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cZ\u003e |-\u003e tran(\u003cZ\u003e)})\nelse AUX`null_tran_command)","private CombinedRotCmds: (RotCommand * RotCommand * set of (RotAxis) +\u003e RotCommand)\n\tCombinedRotCmds(hcm_rot, aah, ignore_hcm) \u003d\u003d\nlet aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in ({a |-\u003e aah(a) | a in set aah_axes} munion {a |-\u003e hcm_rot(a) | a in set (AUX`rot_axis_set \\ aah_axes)})","private IntegratedCommands: (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +\u003e SixDofCommand)\n\tIntegratedCommands(mk_SixDofCommand(tran, rot), aah, active_axes, ignore_hcm) \u003d\u003d\n(if AAH`AllAxesOff(active_axes)\nthen (if RotCmdsPresent(rot)\nthen mk_AUX`SixDofCommand(AUX`null_tran_command, rot)\nelse mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), AUX`null_rot_command))\nelse (if RotCmdsPresent(rot)\nthen mk_AUX`SixDofCommand(AUX`null_tran_command, CombinedRotCmds(rot, aah, ignore_hcm))\nelse mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), aah)))","private BFThrusters: (AxisCommand * AxisCommand * AxisCommand +\u003e (ThrusterSet * ThrusterSet))\n\tBFThrusters(A, B, C) \u003d\u003d\n(cases mk_(A, B, C) :\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB3\u003e, \u003cB4\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e}, {\u003cB1\u003e, \u003cB4\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cB4\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB3\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e}, {\u003cB1\u003e, \u003cB4\u003e}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cB2\u003e}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e}, {\u003cB2\u003e, \u003cB3\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB4\u003e, \u003cF1\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB4\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cF1\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB3\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cB2\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cB1\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cB1\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF1\u003e}, {\u003cF2\u003e, \u003cF3\u003e}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF1\u003e, \u003cF2\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF2\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF1\u003e, \u003cF3\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF2\u003e, \u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF2\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cF3\u003e, \u003cF4\u003e}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cF4\u003e}, {\u003cF2\u003e, \u003cF3\u003e})\n end)","private LRUDThrusters: (AxisCommand * AxisCommand * AxisCommand +\u003e (ThrusterSet * ThrusterSet))\n\tLRUDThrusters(A, B, C) \u003d\u003d\n(cases mk_(A, B, C) :\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cL1R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cL1R\u003e, \u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cU3R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({\u003cU3R\u003e, \u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({\u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cL1R\u003e, \u003cR4R\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cR2R\u003e, \u003cL3R\u003e}, {}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({\u003cD1R\u003e, \u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({\u003cD1R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) -\u003e mk_({\u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) -\u003e mk_({\u003cR2R\u003e, \u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) -\u003e mk_({\u003cR2R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) -\u003e mk_({}, {}),\nmk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) -\u003e mk_({}, {})\n end)","private SelectedThrusters: (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +\u003e ThrusterSet)\n\tSelectedThrusters(hcm, aah, active_axes, ignore_hcm) \u003d\u003d\nlet mk_SixDofCommand(tran, rot):SixDofCommand \u003d IntegratedCommands(hcm, aah, active_axes, ignore_hcm), mk_(bf_mandatory, bf_optional):(ThrusterSet * ThrusterSet) \u003d BFThrusters(tran(\u003cX\u003e), rot(\u003cPitch\u003e), rot(\u003cYaw\u003e)), mk_(lrud_mandatory, lrud_optional):(ThrusterSet * ThrusterSet) \u003d LRUDThrusters(tran(\u003cY\u003e), tran(\u003cZ\u003e), rot(\u003cRoll\u003e)), bf_thr:ThrusterSet \u003d (if (rot(\u003cRoll\u003e) \u003d \u003cZero\u003e)\nthen (bf_optional union bf_mandatory)\nelse bf_mandatory), lrud_thr:ThrusterSet \u003d (if ((rot(\u003cPitch\u003e) \u003d \u003cZero\u003e) and (rot(\u003cYaw\u003e) \u003d \u003cZero\u003e))\nthen (lrud_optional union lrud_mandatory)\nelse lrud_mandatory) in (bf_thr union lrud_thr)","Input \u003d Input\n\tinv inp \u003d\u003d ((len inp) \u003d 9)","ThrusterMatrix \u003d ThrusterMatrix\n\tinv tm \u003d\u003d (((len tm) \u003d 4) and (forall i in set (inds tm) \u0026 ((len tm(i)) \u003d 6)))","private RunControlCycle: (Input -\u003e ThrusterMatrix)\n\tRunControlCycle(input) \u003d\u003d\nlet mk_(swpos, hgpos, rcom):(SwitchPositions * HandGripPosition * RotCommand) \u003d TransformInput(input) in let ts:ThrusterSet \u003d SAFER`ControlCycle(swpos, hgpos, rcom) in GenerateThrusterMatrix(ts)","private TransformInput: (Input -\u003e (SwitchPositions * HandGripPosition * RotCommand))\n\tTransformInput(input) \u003d\u003d\nlet [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d input in let swpos:HCM`SwitchPositions \u003d mk_HCM`SwitchPositions((if (mode \u003d 1)\nthen \u003cTran\u003e\nelse \u003cRot\u003e), (if (aah \u003d 0)\nthen \u003cUp\u003e\nelse \u003cDown\u003e)), hgpos:HCM`HandGripPosition \u003d mk_HCM`HandGripPosition(ConvertAxisCmd(vert), ConvertAxisCmd(horiz), ConvertAxisCmd(trans), ConvertAxisCmd(twist)), rcom:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to (AxisCommand) \u003d {\u003cRoll\u003e |-\u003e ConvertAxisCmd(roll), \u003cPitch\u003e |-\u003e ConvertAxisCmd(pitch), \u003cYaw\u003e |-\u003e ConvertAxisCmd(yaw)} in mk_(swpos, hgpos, rcom)","private ConvertAxisCmd: (nat -\u003e AxisCommand)\n\tConvertAxisCmd(n) \u003d\u003d\n(cases n :\n0 -\u003e \u003cNeg\u003e,\n1 -\u003e \u003cPos\u003e,\n2 -\u003e \u003cZero\u003e\nothers (undefined)\n end)","private GenerateThrusterMatrix: (ThrusterSet +\u003e ThrusterMatrix)\n\tGenerateThrusterMatrix(ts) \u003d\u003d\nlet tson:set of ((nat * nat)) \u003d {GenerateThrusterLabel(t) | t in set ts} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]","private GenerateThrusterLabel: (ThrusterName +\u003e (nat * nat))\n\tGenerateThrusterLabel(tnm) \u003d\u003d\n(cases tnm :\n\u003cB1\u003e -\u003e mk_(1, 4),\n\u003cB2\u003e -\u003e mk_(2, 4),\n\u003cB3\u003e -\u003e mk_(4, 4),\n\u003cB4\u003e -\u003e mk_(3, 4),\n\u003cF1\u003e -\u003e mk_(1, 1),\n\u003cF2\u003e -\u003e mk_(2, 1),\n\u003cF3\u003e -\u003e mk_(4, 1),\n\u003cF4\u003e -\u003e mk_(3, 1),\n\u003cL1R\u003e -\u003e mk_(1, 2),\n\u003cL1F\u003e -\u003e mk_(1, 3),\n\u003cR2R\u003e -\u003e mk_(2, 2),\n\u003cR2F\u003e -\u003e mk_(2, 3),\n\u003cL3R\u003e -\u003e mk_(4, 2),\n\u003cL3F\u003e -\u003e mk_(4, 3),\n\u003cR4R\u003e -\u003e mk_(3, 2),\n\u003cR4F\u003e -\u003e mk_(3, 3),\n\u003cD1R\u003e -\u003e mk_(1, 6),\n\u003cD1F\u003e -\u003e mk_(1, 5),\n\u003cD2R\u003e -\u003e mk_(2, 6),\n\u003cD2F\u003e -\u003e mk_(2, 5),\n\u003cU3R\u003e -\u003e mk_(4, 6),\n\u003cU3F\u003e -\u003e mk_(4, 5),\n\u003cU4R\u003e -\u003e mk_(3, 6),\n\u003cU4F\u003e -\u003e mk_(3, 5)\n end)","switchpos:HCM`SwitchPositions \u003d mk_HCM`SwitchPositions(\u003cTran\u003e, \u003cDown\u003e)","handgrippos:HCM`HandGripPosition \u003d mk_HCM`HandGripPosition(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e)","rotcomm:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to (\u003cZero\u003e) \u003d {\u003cRoll\u003e |-\u003e \u003cZero\u003e, \u003cPitch\u003e |-\u003e \u003cZero\u003e, \u003cYaw\u003e |-\u003e \u003cZero\u003e}"]