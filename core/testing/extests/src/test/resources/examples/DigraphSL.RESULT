["private TransHDFD: (HDFD * MSs * (\u003cEXPL\u003e | \u003cIMPL\u003e) -\u003e set of (Module))\n\tTransHDFD(hdfd, mss, style) \u003d\u003d\nlet mainmod:Module \u003d MakeDFDModule(hdfd, mss, style) in let mk_(-, -, -, dfdmap, -):HDFD \u003d hdfd in let mods:set of (Module) \u003d (dunion {TransHDFD(dfd, mss, style) | dfd in set (rng dfdmap)}) in ({mainmod} union mods)","private MakeDFDModule: (HDFD * MSs * (\u003cEXPL\u003e | \u003cIMPL\u003e) -\u003e Module)\n\tMakeDFDModule(mk_(dfdid, dss, dfdtopo, dfdmap, dfdsig), mss, style) \u003d\u003d\nlet i:Interface \u003d MakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap), defs:Definitions \u003d MakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) in mk_(ModIdConf(dfdid), i, defs)","private MakeInterface: (DFDId * DSs * DFDTopo * DFDSig * DFDMap -\u003e Interface)\n\tMakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap) \u003d\u003d\nlet tmimp:Import \u003d MakeTypeModImp(dss, (dom dfdtopo)), dfdmimps:set of (Import) \u003d MakeDFDModImps((dom dfdmap), dfdsig), exp:Export \u003d MakeOpExp(dfdid, dfdsig(dfdid)) in mk_(({tmimp} union dfdmimps), exp)\n\tpre (dfdid in set (dom dfdsig))","private MakeTypeModImp: (DSs * set of (FlowId) -\u003e Import)\n\tMakeTypeModImp(dss, fids) \u003d\u003d\nlet tysigs:set of (TypeSig) \u003d ({mk_TypeSig(DSIdConf(dsid)) | dsid in set dss} union {mk_TypeSig(FlowIdTypeConf(fid)) | fid in set fids}) in mk_(TypeModConf(), tysigs)","private MakeDFDModImps: (set of (DFDId) * DFDSig -\u003e set of (Import))\n\tMakeDFDModImps(dfdids, dfdsig) \u003d\u003d\n{mk_(ModIdConf(id), {MakeOpSig(id, dfdsig(id))}) | id in set dfdids}\n\tpre (dfdids subset (dom dfdsig))","private MakeOpExp: (DFDId * Signature -\u003e Export)\n\tMakeOpExp(dfdid, sig) \u003d\u003d\n{MakeOpSig(dfdid, sig)}","private MakeOpSig: (DFDId * Signature -\u003e OpSig)\n\tMakeOpSig(dfdid, sig) \u003d\u003d\nlet opty:OpType \u003d MakeOpType(sig), opst:seq of (Id) \u003d MakeOpState(sig) in mk_OpSig(OpIdConf(dfdid), opty, opst)","private MakeOpType: (Signature -\u003e OpType)\n\tMakeOpType(mk_(il, ol, -)) \u003d\u003d\nmk_OpType(MakeType(il), MakeType(ol))","private MakeType: (seq of (FlowId) -\u003e [Type])\n\tMakeType(fidl) \u003d\u003d\n(cases (len fidl) :\n0 -\u003e nil,\n1 -\u003e FlowIdTypeConf((hd fidl))\nothers mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)])\n end)","private MakeOpState: (Signature -\u003e seq of (Id))\n\tMakeOpState(mk_(-, -, sl)) \u003d\u003d\n[let mk_(s, -):(StId * Mode) \u003d sl(i) in StateVarConf(s) | i in set (inds sl)]","private MakeDefinitions: (DFDId * DSs * DFDTopo * DFDSig * MSs * (\u003cEXPL\u003e | \u003cIMPL\u003e) -\u003e Definitions)\n\tMakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) \u003d\u003d\nlet dst:[StateDef] \u003d MakeState(dfdid, dss, CollectExtDFs(dfdtopo)), msdescs:set of (Definition) \u003d MakeMSDescs(dfdsig, mss), dfdop:OpDef \u003d MakeDFDOp(dfdid, dfdtopo, dfdsig, style) in (if (dst \u003d nil)\nthen ({dfdop} union msdescs)\nelse ({dst, dfdop} union msdescs))","private MakeState: (DFDId * DSs * set of (FlowId) -\u003e [StateDef])\n\tMakeState(dfdid, dss, fids) \u003d\u003d\n(if ((dss \u003d {}) and (fids \u003d {}))\nthen nil\nelse let fl:seq of (Field) \u003d MakeFieldList((dss union fids)) in mk_StateDef(StateIdConf(dfdid), fl))","private MakeFieldList: (set of (StId) -\u003e seq of (Field))\n\tMakeFieldList(ids) \u003d\u003d\n(if (ids \u003d {})\nthen []\nelse let id in set ids in ([MakeField(id)] ^ MakeFieldList((ids \\ {id}))))","private Card: (set of (StId) -\u003e nat)\n\tCard(s) \u003d\u003d\n(card s)","private MakeField: (StId -\u003e Field)\n\tMakeField(id) \u003d\u003d\nmk_Field(StateVarConf(id), StateTypeConf(id))","private MakeMSDescs: (DFDSig * MSs -\u003e set of (Definition))\n\tMakeMSDescs(dfdsig, mss) \u003d\u003d\n(if (forall id in set (dom dfdsig) \u0026 is_(id, DFDId))\nthen {}\nelse let id in set (dom dfdsig) be st is_(id, MSId) in let def\u0027:(ImplOp | MS) \u003d (if (id in set (dom mss))\nthen mss(id)\nelse MakeOp(id, dfdsig(id))) in ({def\u0027} union MakeMSDescs(({id} \u003c-: dfdsig), mss)))","private MakeOp: (MSId * (seq of (FlowId) * seq of (FlowId) * State) -\u003e ImplOp)\n\tMakeOp(msid, mk_(din, out, dst)) \u003d\u003d\nlet partpl:seq of (ParType) \u003d MakeInpPar(din), residtp:[IdType] \u003d MakeOutPair(out), dext:seq of (ExtVarInf) \u003d MakeExt(dst), body:ImplOpBody \u003d mk_ImplOpBody(nil, mk_BoolLit(true)) in mk_ImplOp(OpIdConf(msid), partpl, residtp, dext, body)","private MakeInpPar: (seq of (FlowId) -\u003e seq of (ParType))\n\tMakeInpPar(fidl) \u003d\u003d\n[mk_ParType(mk_PatternId(FlowIdVarConf(fidl(i))), FlowIdTypeConf(fidl(i))) | i in set (inds fidl)]","private MakeOutPair: (seq of (FlowId) -\u003e [IdType])\n\tMakeOutPair(fidl) \u003d\u003d\n(cases (len fidl) :\n0 -\u003e nil,\n1 -\u003e mk_IdType(FlowIdVarConf((hd fidl)), FlowIdTypeConf((hd fidl)))\nothers let t:ProductType \u003d mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)]) in mk_IdType(ResultIdConf(), t)\n end)","private MakeExt: (State -\u003e seq of (ExtVarInf))\n\tMakeExt(dst) \u003d\u003d\n[MakeExtVar(dst(i)) | i in set (inds dst)]","private MakeExtVar: ((StId * Mode) -\u003e ExtVarInf)\n\tMakeExtVar(mk_(id, mode)) \u003d\u003d\nmk_ExtVarInf(mode, VarConf(id), TypeConf(id))","private MakeDFDOp: (DFDId * DFDTopo * DFDSig * (\u003cEXPL\u003e | \u003cIMPL\u003e) -\u003e OpDef)\n\tMakeDFDOp(dfdid, dfdtopo, dfdsig, style) \u003d\u003d\n(if (style \u003d \u003cEXPL\u003e)\nthen MakeDFDExplOp(dfdid, dfdtopo, dfdsig)\nelse MakeDFDImplOp(dfdid, dfdtopo, dfdsig))\n\tpre (if (style \u003d \u003cEXPL\u003e)\nthen pre_MakeDFDExplOp(dfdid, dfdtopo, dfdsig)\nelse pre_MakeDFDImplOp(dfdid, dfdtopo, dfdsig))","private MakeDFDImplOp: (DFDId * DFDTopo * DFDSig -\u003e ImplOp)\n\tMakeDFDImplOp(dfdid, dfdtopo, dfdsig) \u003d\u003d\nlet mk_(din, out, dst):Signature \u003d dfdsig(dfdid) in let partpl:seq of (ParType) \u003d MakeInpPar(din), residtp:[IdType] \u003d MakeOutPair(out), dext:seq of (ExtVarInf) \u003d MakeExt(dst), body:ImplOpBody \u003d MakeImplOpBody(dfdid, dfdtopo, dfdsig) in mk_ImplOp(OpIdConf(dfdid), partpl, residtp, dext, body)\n\tpre ((dfdid in set (dom dfdsig)) and pre_MakeImplOpBody(dfdid, dfdtopo, dfdsig))","private MakeImplOpBody: (DFDId * DFDTopo * DFDSig -\u003e ImplOpBody)\n\tMakeImplOpBody(dfdid, dfdtopo, dfdsig) \u003d\u003d\nlet intm:map (StId) to (nat) \u003d {stid |-\u003e 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm:map (StId) to (nat) \u003d {stid |-\u003e Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))}, dpre:Expr \u003d MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm), dpost:Expr \u003d MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in mk_ImplOpBody(dpre, dpost)\n\tpre let intm:map (StId) to (nat) \u003d {stid |-\u003e 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm:map (StId) to (nat) \u003d {stid |-\u003e Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and pre_MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm))","IntM \u003d IntM","private MakePreExpr: (DFDId * DFDTopo * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) \u003d\u003d\nlet mk_(-, out, dst):Signature \u003d dfdsig(dfdid) in let fids:set of (FlowId) \u003d NeedsQuant(dfdtopo, dfdsig, {}, {}), pred:Expr \u003d MakePrePred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)\nthen let bind:MultTypeBind \u003d MakeExistsBind(fids, dst, intm, maxm, \u003cPRE\u003e) in mk_ExistsExpr(bind, pred)\nelse pred)\n\tpre (dfdid in set (dom dfdsig))","private MakePrePred: (DFDTopo * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePrePred(dfdtopo, dfdsig, intm, maxm) \u003d\u003d\nlet eos:set of (seq1 of (ProcId)) \u003d ExecutionOrders(dfdtopo) in DBinOp(\u003cOR\u003e, {MakePreForEO(piseq, dfdsig, intm, maxm) | piseq in set eos})","private MakePreForEO: (seq1 of (ProcId) * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePreForEO(piseq, dfdsig, intm, maxm) \u003d\u003d\nlet nid:ProcId \u003d (hd piseq) in let intm\u0027:map (StId) to (nat) \u003d {stid |-\u003e (if (mk_(stid, \u003cREADWRITE\u003e) in set CollectStIds({dfdsig(nid)}))\nthen (intm(stid) + 1)\nelse intm(stid)) | stid in set (dom intm)} in let dpre:Apply \u003d MakeQuotedApply(nid, dfdsig(nid), intm\u0027, maxm, \u003cPRE\u003e, \u003cPRE\u003e), dpost:Apply \u003d MakeQuotedApply(nid, dfdsig(nid), intm\u0027, maxm, \u003cPRE\u003e, \u003cPOST\u003e) in (if ((len piseq) \u003d 1)\nthen dpre\nelse let pred:BinaryExpr \u003d mk_BinaryExpr(dpre, \u003cAND\u003e, dpost) in mk_BinaryExpr(pred, \u003cAND\u003e, MakePreForEO((tl piseq), dfdsig, intm\u0027, maxm)))","private MakePostExpr: (DFDId * DFDTopo * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) \u003d\u003d\nlet mk_(-, out, dst):Signature \u003d dfdsig(dfdid), fids:set of (FlowId) \u003d NeedsQuant(dfdtopo, dfdsig, (elems out), {}), body:Expr \u003d MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) in (if ((len out) \u003c\u003d 1)\nthen body\nelse mk_LetExpr(MakePattern(out), ResultIdConf(), body))\n\tpre let mk_(-, out, dst):Signature \u003d dfdsig(dfdid), fids:set of (FlowId) \u003d NeedsQuant(dfdtopo, dfdsig, (elems out), {}) in pre_MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm)","private MakeInExpr: (seq of (FlowId) * State * set of (FlowId) * DFDTopo * DFDSig * IntM * IntM -\u003e Expr)\n\tMakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) \u003d\u003d\nlet pred:Expr \u003d MakePostPred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)\nthen let bind:MultTypeBind \u003d MakeExistsBind(fids, dst, intm, maxm, \u003cPOST\u003e) in mk_ExistsExpr(bind, pred)\nelse pred)\n\tpre pre_MakeExistsBind(fids, dst, intm, maxm, \u003cPOST\u003e)","private MakePostPred: (DFDTopo * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePostPred(dfdtopo, dfdsig, intm, maxm) \u003d\u003d\nlet eos:set of (seq1 of (ProcId)) \u003d ExecutionOrders(dfdtopo) in DBinOp(\u003cOR\u003e, {MakePostForEO(piseq, dfdsig, intm, maxm) | piseq in set eos})","private MakePostForEO: (seq1 of (ProcId) * DFDSig * IntM * IntM -\u003e Expr)\n\tMakePostForEO(piseq, dfdsig, intm, maxm) \u003d\u003d\nlet nid:ProcId \u003d (hd piseq) in let intm\u0027:map (StId) to (nat) \u003d {stid |-\u003e (if (mk_(stid, \u003cREADWRITE\u003e) in set CollectStIds({dfdsig(nid)}))\nthen (intm(stid) + 1)\nelse intm(stid)) | stid in set (dom intm)} in let dpre:Apply \u003d MakeQuotedApply(nid, dfdsig(nid), intm\u0027, maxm, \u003cPOST\u003e, \u003cPRE\u003e), dpost:Apply \u003d MakeQuotedApply(nid, dfdsig(nid), intm\u0027, maxm, \u003cPOST\u003e, \u003cPOST\u003e) in (if ((len piseq) \u003d 1)\nthen mk_BinaryExpr(dpre, \u003cAND\u003e, dpost)\nelse let pred:BinaryExpr \u003d mk_BinaryExpr(dpre, \u003cAND\u003e, dpost) in mk_BinaryExpr(pred, \u003cAND\u003e, MakePostForEO((tl piseq), dfdsig, intm\u0027, maxm)))\n\tpre let nid:ProcId \u003d (hd piseq) in ((nid in set (dom dfdsig)) and (pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, \u003cPOST\u003e, \u003cPRE\u003e) and pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, \u003cPOST\u003e, \u003cPOST\u003e)))","private MakeExistsBind: (set of (FlowId) * State * IntM * IntM * (\u003cPOST\u003e | \u003cPRE\u003e) -\u003e MultTypeBind)\n\tMakeExistsBind(fs, dst, intm, maxm, c) \u003d\u003d\nlet outl:seq of (TypeBind) \u003d MakeTypeBindList(fs), stl:seq of (TypeBind) \u003d [let mk_(s, -):(StId * Mode) \u003d dst(i), p:seq of (PatternId) \u003d MakePatternIds(s, (intm(s) + 1), maxm(s), c) in mk_TypeBind(p, StateTypeConf(s)) | i in set (inds dst) \u0026 let mk_(-, m):(StId * Mode) \u003d dst(i) in (m \u003d \u003cREADWRITE\u003e)] in mk_MultTypeBind((outl ^ stl))\n\tpre (forall mk_(s, \u003cREADWRITE\u003e) in set (elems dst) \u0026 ((s in set (dom intm)) and (s in set (dom maxm))))","private ExecutionOrders: (DFDTopo -\u003e set of (seq1 of (ProcId)))\n\tExecutionOrders(dfdtopo) \u003d\u003d\nlet top:set of (([ProcId] * [ProcId])) \u003d {mk_(fid, tid) | mk_(fid, tid) in set (rng dfdtopo) \u0026 ((is_(fid, DFDId) or (is_(fid, MSId) or (fid \u003d nil))) and (is_(tid, DFDId) or (is_(tid, MSId) or (tid \u003d nil))))}, top2:set of (([ProcId] * [ProcId])) \u003d {mk_(fid, tid) | mk_(fid, tid) in set (rng dfdtopo) \u0026 ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in let piset:set of ([ProcId]) \u003d ((dunion {{pi_1, pi_2} | mk_(pi_1, pi_2) in set top}) \\ {nil}) in {piseq | piseq in set PossibleSeqs(piset) \u0026 (forall i, j in set (inds piseq) \u0026 ((j \u003c i) \u003d\u003e (piseq(j) not in set TransClosure(piseq(i), top2, {}))))}","private MakeQuotedApply: ((DFDId | MSId) * Signature * IntM * IntM * (\u003cPOST\u003e | \u003cPRE\u003e) * (\u003cPOST\u003e | \u003cPRE\u003e) -\u003e Apply)\n\tMakeQuotedApply(id, mk_(din, out, dst), intm, maxm, c, c2) \u003d\u003d\nlet inarg:seq of (Id) \u003d [FlowIdVarConf(din(i)) | i in set (inds din)], oldstarg:seq of (Id) \u003d [let mk_(s, m):(StId * Mode) \u003d dst(i) in (if (m \u003d \u003cREAD\u003e)\nthen StateVarIntConf(s, intm(s), maxm(s), c)\nelse StateVarIntConf(s, (intm(s) - 1), maxm(s), c)) | i in set (inds dst)], outarg:seq of (Id) \u003d [FlowIdVarConf(out(i)) | i in set (inds out)], starg:seq of (Id) \u003d [let mk_(s, -):(StId * Mode) \u003d dst(i) in StateVarIntConf(s, intm(s), maxm(s), c) | i in set (inds dst) \u0026 let mk_(-, m):(StId * Mode) \u003d dst(i) in (m \u003d \u003cREADWRITE\u003e)] in (if (c2 \u003d \u003cPRE\u003e)\nthen mk_Apply((\"pre_\" ^ OpIdConf(id)), (inarg ^ oldstarg))\nelse mk_Apply((\"post_\" ^ OpIdConf(id)), (((inarg ^ oldstarg) ^ outarg) ^ starg)))\n\tpre (forall mk_(s, m) in set (elems dst) \u0026 (((s in set (dom intm)) and ((s in set (dom maxm)) and (m \u003d \u003cREADWRITE\u003e))) \u003d\u003e (intm(s) \u003e 0)))","private MakeDFDExplOp: (DFDId * DFDTopo * DFDSig -\u003e ExplOp)\n\tMakeDFDExplOp(dfdid, dfdtopo, dfdsig) \u003d\u003d\nlet mk_(din, -, -):Signature \u003d dfdsig(dfdid), eos:set of (seq1 of (ProcId)) \u003d ExecutionOrders(dfdtopo), intm:map (StId) to (nat) \u003d {stid |-\u003e 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm:map (StId) to (nat) \u003d {stid |-\u003e Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in let optype:OpType \u003d MakeOpType(dfdsig(dfdid)), parms:seq of (PatternId) \u003d [mk_PatternId(FlowIdVarConf(din(i))) | i in set (inds din)], bodys:set of (Stmt) \u003d {MakeStmtForEO(piseq, dfdid, dfdsig) | piseq in set eos}, dpre:Expr \u003d MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in let body:Stmt \u003d MakeNonDetStmt(bodys) in mk_ExplOp(OpIdConf(dfdid), optype, parms, body, dpre)\n\tpre ((dfdid in set (dom dfdsig)) and let intm:map (StId) to (nat) \u003d {stid |-\u003e 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm:map (StId) to (nat) \u003d {stid |-\u003e Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and (forall piseq in set ExecutionOrders(dfdtopo) \u0026 pre_MakeStmtForEO(piseq, dfdid, dfdsig))))","private MakeStmtForEO: (seq1 of (ProcId) * DFDId * DFDSig -\u003e Stmt)\n\tMakeStmtForEO(piseq, dfdid, dfdsig) \u003d\u003d\nlet nid:ProcId \u003d (hd piseq) in let mk_(call, pat):(Call * [Pattern]) \u003d MakeCallAndPat(nid, dfdsig(nid)), kind:(\u003cOPCALL\u003e | \u003cOPRES\u003e) \u003d FindKind(dfdsig(nid)) in (if ((len piseq) \u003d 1)\nthen let mk_(-, out, -):Signature \u003d dfdsig(dfdid) in let ret:Return \u003d mk_Return(MakeResult(out)) in (if (kind \u003d \u003cOPRES\u003e)\nthen mk_DefStmt(pat, call, ret)\nelse mk_Sequence([call, ret]))\nelse let rest:Stmt \u003d MakeStmtForEO((tl piseq), dfdid, dfdsig) in (if (kind \u003d \u003cOPRES\u003e)\nthen mk_DefStmt(pat, call, rest)\nelse (if is_(rest, Sequence)\nthen let mk_Sequence(sl):Sequence \u003d rest in mk_Sequence(([call] ^ sl))\nelse mk_Sequence([call, rest]))))\n\tpre ((hd piseq) in set (dom dfdsig))","private MakeCallAndPat: ((DFDId | MSId) * Signature -\u003e (Call * [Pattern]))\n\tMakeCallAndPat(id, mk_(din, out, -)) \u003d\u003d\nlet inarg:seq of (Id) \u003d [FlowIdVarConf(din(i)) | i in set (inds din)], outarg:seq of (Id) \u003d [FlowIdVarConf(out(i)) | i in set (inds out)] in mk_(mk_Call(OpIdConf(id), inarg), MakePattern(outarg))","private FindKind: (Signature -\u003e (\u003cOPCALL\u003e | \u003cOPRES\u003e))\n\tFindKind(sig) \u003d\u003d\n(cases sig :\nmk_(-, [], -) -\u003e \u003cOPCALL\u003e\nothers \u003cOPRES\u003e\n end)","private MakePattern: (seq of (Id) -\u003e [Pattern])\n\tMakePattern(idl) \u003d\u003d\n(cases (len idl) :\n0 -\u003e nil,\n1 -\u003e mk_PatternId((hd idl))\nothers mk_TuplePattern([mk_PatternId(idl(i)) | i in set (inds idl)])\n end)","private MakeResult: (seq1 of (Id) -\u003e Expr)\n\tMakeResult(idl) \u003d\u003d\n(if ((len idl) \u003d 1)\nthen FlowIdVarConf((hd idl))\nelse mk_TupleConstructor([FlowIdVarConf(idl(i)) | i in set (inds idl)]))","private DBinOp: (BinaryOp * set of (Expr) -\u003e Expr)\n\tDBinOp(op, es) \u003d\u003d\nlet e in set es in (if ((card es) \u003d 1)\nthen e\nelse mk_BinaryExpr(e, op, DBinOp(op, (es \\ {e}))))\n\tpre (es \u003c\u003e {})","private CollectExtDFs: (DFDTopo -\u003e set of (FlowId))\n\tCollectExtDFs(dfdtopo) \u003d\u003d\n{fid | fid in set (dom dfdtopo) \u0026 let mk_(pid_1, pid_2):([ProcId] * [ProcId]) \u003d dfdtopo(fid) in (is_(pid_1, EPId) or is_(pid_2, EPId))}","private NeedsQuant: (DFDTopo * DFDSig * set of (FlowId) * set of (ProcId) -\u003e set of (FlowId))\n\tNeedsQuant(dfdtopo, dfdsig, notneeded, pids) \u003d\u003d\nlet top:set of (([ProcId] * [ProcId])) \u003d {mk_(fid, tid) | mk_(fid, tid) in set (rng dfdtopo) \u0026 ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (if ((dom dfdsig) \u003d pids)\nthen {}\nelse let pid in set ((dom dfdsig) \\ pids) in (if ((TransClosure(pid, top, {}) \u003d {}) and (EquivClass(top, {pid}) \u003d (dom dfdsig)))\nthen NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid}))\nelse let mk_(-, out, -):Signature \u003d dfdsig(pid) in ((NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid})) union (elems out)) \\ notneeded)))","private QuantNec: (seq of (FlowId) * State * set of (FlowId) * IntM * IntM -\u003e bool)\n\tQuantNec(out, dst, fids, intm, maxm) \u003d\u003d\n((fids \u003c\u003e {}) or (exists mk_(s, m) in set (elems dst) \u0026 ((m \u003d \u003cREADWRITE\u003e) and (intm(s) \u003c maxm(s)))))\n\tpre (forall mk_(s, -) in set (elems dst) \u0026 ((s in set (dom intm)) and (s in set (dom maxm))))","private MakeTypeBindList: (set of (FlowId) -\u003e seq of (TypeBind))\n\tMakeTypeBindList(fids) \u003d\u003d\n(if (fids \u003d {})\nthen []\nelse let fid in set fids in let pat:seq1 of (PatternId) \u003d [mk_PatternId(FlowIdVarConf(fid))], first:TypeBind \u003d mk_TypeBind(pat, FlowIdTypeConf(fid)) in ([first] ^ MakeTypeBindList((fids \\ {fid}))))","private CardFId: (set of (FlowId) -\u003e nat)\n\tCardFId(s) \u003d\u003d\n(card s)","private MakePatternIds: ((DSId | Id) * nat * nat * (\u003cPOST\u003e | \u003cPRE\u003e) -\u003e seq of (PatternId))\n\tMakePatternIds(id, n, max, c) \u003d\u003d\n(if ((n \u003d max) and (c \u003d \u003cPOST\u003e))\nthen [mk_PatternId(StateVarConf(id))]\nelse (cases n :\n0 -\u003e (if (c \u003d \u003cPRE\u003e)\nthen [mk_PatternId(StateVarConf(id))]\nelse [mk_PatternId(StateOldVarConf(id))])\nothers MakePatternSeq(StateVarConf(id), n, max)\n end))","private MakePatternSeq: (Id * nat * nat -\u003e seq of (PatternId))\n\tMakePatternSeq(id, n, max) \u003d\u003d\n(if (n \u003d max)\nthen [mk_PatternId((id ^ \"\u0027\"))]\nelse ([mk_PatternId((id ^ \"\u0027\"))] ^ MakePatternSeq((id ^ \"\u0027\"), (n + 1), max)))\n\tpre (n \u003c\u003d max)","private TowardsMax: (Id * nat * nat -\u003e nat)\n\tTowardsMax(-, n, max) \u003d\u003d\n(max - n)","private EquivClass: (set of ((ProcId * ProcId)) * set of ((DFDId | MSId)) -\u003e set of ((DFDId | MSId)))\n\tEquivClass(top, ids) \u003d\u003d\n(if (exists mk_(fid, tid) in set top \u0026 (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))))\nthen let mk_(fid, tid) in set top be st (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))) in EquivClass(top, (ids union {fid, tid}))\nelse ids)","private MakeNonDetStmt: (set of (Stmt) -\u003e Stmt)\n\tMakeNonDetStmt(stmts) \u003d\u003d\n(cases (card stmts) :\n1 -\u003e let {s}:set of (Stmt) \u003d stmts in s\nothers mk_NonDetStmt(stmts)\n end)\n\tpre ((card stmts) \u003c\u003e 0)","private CollectStIds: (set of (Signature) -\u003e set of ((StId * Mode)))\n\tCollectStIds(sigs) \u003d\u003d\n(dunion {(elems dst) | mk_(-, -, dst) in set sigs})","private NoOfWr: (set of (Signature) * StId -\u003e nat)\n\tNoOfWr(sigs, stid) \u003d\u003d\n(if (sigs \u003d {})\nthen 0\nelse let sig in set sigs in let mk_(-, -, dst):Signature \u003d sig in (if (mk_(stid, \u003cREADWRITE\u003e) in set (elems dst))\nthen (1 + NoOfWr((sigs \\ {sig}), stid))\nelse NoOfWr((sigs \\ {sig}), stid)))","private Reduce: (nat -\u003e nat)\n\tReduce(n) \u003d\u003d\n(if ((n \u003d 0) or (n \u003d 1))\nthen n\nelse (n - 1))","private ModIdConf: (DFDId -\u003e Id)\n\tModIdConf(mk_DFDId(id)) \u003d\u003d\n(id ^ \"Module\")","private StateIdConf: (DFDId -\u003e Id)\n\tStateIdConf(mk_DFDId(id)) \u003d\u003d\n(id ^ \"State\")","private DSIdConf: (DSId -\u003e Id)\n\tDSIdConf(mk_DSId(id)) \u003d\u003d\nid","private OpIdConf: ((DFDId | Id | MSId) -\u003e Id)\n\tOpIdConf(id) \u003d\u003d\n(cases id :\nmk_MSId(id\u0027) -\u003e id\u0027,\nmk_DFDId(id\u0027) -\u003e id\u0027\nothers id\n end)","private StateVarIntConf: ((DSId | Id) * nat * nat * (\u003cPOST\u003e | \u003cPRE\u003e) -\u003e Id)\n\tStateVarIntConf(id, n, max, c) \u003d\u003d\n(if ((max \u003d n) and (c \u003d \u003cPOST\u003e))\nthen StateVarConf(id)\nelse (cases n :\n0 -\u003e (if (c \u003d \u003cPRE\u003e)\nthen StateVarConf(id)\nelse StateOldVarConf(id)),\n1 -\u003e (StateVarConf(id) ^ \"\u0027\")\nothers (StateVarIntConf(id, (n - 1), max, c) ^ \"\u0027\")\n end))","private VarConf: (StId -\u003e Id)\n\tVarConf(id) \u003d\u003d\n(if is_(id, DSId)\nthen StateVarConf(id)\nelse FlowIdVarConf(id))","private TypeConf: ((DSId | FlowId) -\u003e Id)\n\tTypeConf(id) \u003d\u003d\n(if is_(id, DSId)\nthen StateTypeConf(id)\nelse FlowIdTypeConf(id))","private FlowIdVarConf: (Id -\u003e Id)\n\tFlowIdVarConf(id) \u003d\u003d\nToLower(id)","private FlowIdTypeConf: (Id -\u003e Id)\n\tFlowIdTypeConf(id) \u003d\u003d\nToUpper(id)","private StateTypeConf: ((DSId | Id) -\u003e Id)\n\tStateTypeConf(id) \u003d\u003d\nToUpper(id)","private StateVarConf: ((DSId | Id) -\u003e Id)\n\tStateVarConf(id) \u003d\u003d\nToLower(id)","private StateOldVarConf: ((DSId | Id) -\u003e Id)\n\tStateOldVarConf(id) \u003d\u003d\n(ToLower(id) ^ \"old\")","private TypeModConf: (() -\u003e Id)\n\tTypeModConf() \u003d\u003d\n\"TypeModule\"","private ResultIdConf: (() -\u003e Id)\n\tResultIdConf() \u003d\u003d\n\"r\"","private PossibleSeqs: (set of (ProcId) -\u003e set of (seq of (ProcId)))\n\tPossibleSeqs(pids) \u003d\u003d\n(if (pids \u003d {})\nthen {}\nelse (if ((card pids) \u003d 1)\nthen {[pid] | pid in set pids}\nelse let pid in set pids in let rest:set of (seq of (ProcId)) \u003d PossibleSeqs((pids \\ {pid})) in (dunion {InsertPId(pid, seq\u0027) | seq\u0027 in set rest})))","private CardPSet: (set of (ProcId) -\u003e nat)\n\tCardPSet(s) \u003d\u003d\n(card s)","private InsertPId: (ProcId * seq of (ProcId) -\u003e set of (seq of (ProcId)))\n\tInsertPId(pid, seq\u0027) \u003d\u003d\n{(((seq\u0027(1, ... ,i)) ^ [pid]) ^ (seq\u0027((i + 1), ... ,(len seq\u0027)))) | i in set {0, ... ,(len seq\u0027)}}","private ToLower: ((DFDId | DSId | EPId | Id | MSId) -\u003e Id)\n\tToLower(id) \u003d\u003d\nlet realid:(DFDId | DSId | EPId | Id | MSId | seq of (char)) \u003d (cases id :\nmk_DSId(id\u0027) -\u003e id\u0027,\nmk_DFDId(id\u0027) -\u003e id\u0027,\nmk_EPId(id\u0027) -\u003e id\u0027,\nmk_MSId(id\u0027) -\u003e id\u0027\nothers id\n end) in [LowerChar(realid(i)) | i in set (inds realid)]","private LowerChar: (char -\u003e char)\n\tLowerChar(c) \u003d\u003d\n(cases c :\nchar value [A] -\u003e \u0027a\u0027,\nchar value [B] -\u003e \u0027b\u0027,\nchar value [C] -\u003e \u0027c\u0027,\nchar value [D] -\u003e \u0027d\u0027,\nchar value [E] -\u003e \u0027e\u0027,\nchar value [F] -\u003e \u0027f\u0027,\nchar value [G] -\u003e \u0027g\u0027,\nchar value [H] -\u003e \u0027h\u0027,\nchar value [I] -\u003e \u0027i\u0027,\nchar value [J] -\u003e \u0027j\u0027,\nchar value [K] -\u003e \u0027k\u0027,\nchar value [L] -\u003e \u0027l\u0027,\nchar value [M] -\u003e \u0027m\u0027,\nchar value [N] -\u003e \u0027n\u0027,\nchar value [O] -\u003e \u0027o\u0027,\nchar value [P] -\u003e \u0027p\u0027,\nchar value [Q] -\u003e \u0027q\u0027,\nchar value [R] -\u003e \u0027r\u0027,\nchar value [S] -\u003e \u0027s\u0027,\nchar value [T] -\u003e \u0027t\u0027,\nchar value [U] -\u003e \u0027u\u0027,\nchar value [V] -\u003e \u0027v\u0027,\nchar value [W] -\u003e \u0027w\u0027,\nchar value [X] -\u003e \u0027x\u0027,\nchar value [Y] -\u003e \u0027y\u0027,\nchar value [Z] -\u003e \u0027z\u0027\nothers c\n end)","private ToUpper: ((DFDId | DSId | EPId | Id | MSId) -\u003e Id)\n\tToUpper(id) \u003d\u003d\nlet realid:(DFDId | DSId | EPId | Id | MSId | seq of (char)) \u003d (cases id :\nmk_DSId(id\u0027) -\u003e id\u0027,\nmk_DFDId(id\u0027) -\u003e id\u0027,\nmk_EPId(id\u0027) -\u003e id\u0027,\nmk_MSId(id\u0027) -\u003e id\u0027\nothers id\n end) in [UpperChar(realid(i)) | i in set (inds realid)]","private UpperChar: (char -\u003e char)\n\tUpperChar(c) \u003d\u003d\n(cases c :\nchar value [a] -\u003e \u0027A\u0027,\nchar value [b] -\u003e \u0027B\u0027,\nchar value [c] -\u003e \u0027C\u0027,\nchar value [d] -\u003e \u0027D\u0027,\nchar value [e] -\u003e \u0027E\u0027,\nchar value [f] -\u003e \u0027F\u0027,\nchar value [g] -\u003e \u0027G\u0027,\nchar value [h] -\u003e \u0027H\u0027,\nchar value [i] -\u003e \u0027I\u0027,\nchar value [j] -\u003e \u0027J\u0027,\nchar value [k] -\u003e \u0027K\u0027,\nchar value [l] -\u003e \u0027L\u0027,\nchar value [m] -\u003e \u0027M\u0027,\nchar value [n] -\u003e \u0027N\u0027,\nchar value [o] -\u003e \u0027O\u0027,\nchar value [p] -\u003e \u0027P\u0027,\nchar value [q] -\u003e \u0027Q\u0027,\nchar value [r] -\u003e \u0027R\u0027,\nchar value [s] -\u003e \u0027S\u0027,\nchar value [t] -\u003e \u0027T\u0027,\nchar value [u] -\u003e \u0027U\u0027,\nchar value [v] -\u003e \u0027V\u0027,\nchar value [w] -\u003e \u0027W\u0027,\nchar value [x] -\u003e \u0027X\u0027,\nchar value [y] -\u003e \u0027Y\u0027,\nchar value [z] -\u003e \u0027Z\u0027\nothers c\n end)","SA \u003d SA\n\tinv mk_(hdfd, dd, -) \u003d\u003d (FlowTypeDefined(hdfd, dd) and TopLevelSigOK(hdfd))","HDFD \u003d HDFD","DSs \u003d DSs","DSId \u003d DSId","DFDTopo \u003d DFDTopo\n\tinv dfdtopo \u003d\u003d let top:set of (([ProcId] * [ProcId])) \u003d {mk_(fid, tid) | mk_(fid, tid) in set (rng dfdtopo) \u0026 ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (NotRecursive(top) and (forall flowid in set (dom dfdtopo) \u0026 FlowConnectOK(dfdtopo(flowid))))","FlowId \u003d FlowId","ProcId \u003d ProcId","DFDMap \u003d DFDMap","DFDSig \u003d DFDSig","Signature \u003d Signature\n\tinv mk_(-, out, sta) \u003d\u003d ((sta \u003d []) \u003d\u003e (((out \u003c\u003e []) and (out \u003d [])) \u003d\u003e (exists mk_(-, m) in set (elems sta) \u0026 (m \u003d \u003cREADWRITE\u003e))))","Input \u003d Input","Output \u003d Output","State \u003d State","StId \u003d StId","Mode \u003d Mode","DD \u003d DD","MSs \u003d MSs","MS \u003d MS","DFDId \u003d DFDId","EPId \u003d EPId","MSId \u003d MSId","private FlowTypeDefined: (HDFD * DD -\u003e bool)\n\tFlowTypeDefined(mk_(-, -, dfdtop, -, -), dd) \u003d\u003d\n(forall fid in set (dom dfdtop) \u0026 (FlowIdTypeConf(fid) in set (dom dd)))","private TopLevelSigOK: (HDFD -\u003e bool)\n\tTopLevelSigOK(mk_(sysid, -, dfdtop, -, dfdsig)) \u003d\u003d\n((sysid in set (dom dfdsig)) and let mk_(din, out, dst):Signature \u003d dfdsig(sysid) in ((din \u003d []) and ((out \u003d []) and (forall flowid in set (dom dfdtop) \u0026 let mk_(fid, tid):([ProcId] * [ProcId]) \u003d dfdtop(flowid) in ((is_(fid, EPId) \u003d\u003e (mk_(flowid, \u003cREAD\u003e) in set (elems dst))) and (is_(tid, EPId) \u003d\u003e (mk_(flowid, \u003cREADWRITE\u003e) in set (elems dst))))))))","private DFDSigConsistent: (DFDId * DFDTopo * DSs * DFDMap * DFDSig -\u003e bool)\n\tDFDSigConsistent(id, dfdtop, dss, dfdmap, dfdsig) \u003d\u003d\n(DSConnected(dss, dfdsig) and (SigsAllRight(dfdtop, dfdsig) and (IdsInSigsAvail(dss, dfdtop, (rng dfdsig)) and SigsForAllUsedIds(id, (rng dfdtop), dfdmap, dfdsig))))","private DSConnected: (DSs * DFDSig -\u003e bool)\n\tDSConnected(dss, dfdsig) \u003d\u003d\n(forall dsid in set dss \u0026 (exists mk_(-, -, dst) in set (rng dfdsig) \u0026 (exists i in set (inds dst) \u0026 let mk_(id, -):(StId * Mode) \u003d dst(i) in (dsid \u003d id))))","private SigsAllRight: (DFDTopo * DFDSig -\u003e bool)\n\tSigsAllRight(dfdtop, dfdsig) \u003d\u003d\n(forall flowid in set (dom dfdtop) \u0026 (cases dfdtop(flowid) :\nmk_(id, mk_EPId(-)) -\u003e let mk_(-, -, dst):Signature \u003d dfdsig(id) in (mk_(flowid, \u003cREADWRITE\u003e) in set (elems dst)),\nmk_(mk_EPId(-), id) -\u003e let mk_(-, -, dst):Signature \u003d dfdsig(id) in (mk_(flowid, \u003cREAD\u003e) in set (elems dst)),\nmk_(nil, id) -\u003e let mk_(din, -, -):Signature \u003d dfdsig(id) in (flowid in set (elems din)),\nmk_(id, nil) -\u003e let mk_(-, out, -):Signature \u003d dfdsig(id) in (flowid in set (elems out)),\nmk_(fid, tid) -\u003e let mk_(-, out, -):Signature \u003d dfdsig(fid), mk_(din, -, -):Signature \u003d dfdsig(tid) in ((flowid in set (elems out)) and (flowid in set (elems din)))\n end))","private IdsInSigsAvail: (DSs * DFDTopo * set of (Signature) -\u003e bool)\n\tIdsInSigsAvail(dss, dfdtop, sigs) \u003d\u003d\nlet fids:set of (FlowId) \u003d CollectExtDFs(dfdtop) in (forall mk_(din, out, dst) in set sigs \u0026 (((elems din) subset (dom dfdtop)) and (((elems out) subset (dom dfdtop)) and ((elems dst) subset {mk_(id, m) | id in set (dss union fids), m in set {\u003cREAD\u003e, \u003cREADWRITE\u003e}}))))","private LowerLevelUsed: (DFDTopo * DFDMap -\u003e bool)\n\tLowerLevelUsed(dfdtop, dfdmap) \u003d\u003d\nlet ids:set of (DFDId) \u003d (dom dfdmap) in (forall mk_(fid, tid) in set (rng dfdtop) \u0026 ((is_(fid, DFDId) \u003d\u003e (fid in set ids)) and (is_(tid, DFDId) \u003d\u003e (tid in set ids))))","private SigsForAllUsedIds: (DFDId * set of (([ProcId] * [ProcId])) * DFDMap * DFDSig -\u003e bool)\n\tSigsForAllUsedIds(id, top, dfdmap, dfdsig) \u003d\u003d\n((forall dfdid in set (dom dfdmap) \u0026 let mk_(-, -, -, -, dfdsig\u0027):HDFD \u003d dfdmap(dfdid) in (dfdsig\u0027(dfdid) \u003d dfdsig(dfdid))) and let sigs:set of ((DFDId | MSId)) \u003d (dom dfdsig) in ((id in set sigs) and (forall mk_(fid, tid) in set top \u0026 (((is_(fid, MSId) or is_(fid, DFDId)) \u003d\u003e (fid in set sigs)) and ((is_(tid, MSId) or is_(tid, DFDId)) \u003d\u003e (tid in set sigs))))))","private FlowConnectOK: (([ProcId] * [ProcId]) -\u003e bool)\n\tFlowConnectOK(mk_(fid, tid)) \u003d\u003d\n(((is_(fid, EPId) or (fid \u003d nil)) \u003d\u003e (is_(tid, DFDId) or is_(tid, MSId))) and ((is_(tid, EPId) or (tid \u003d nil)) \u003d\u003e (is_(fid, DFDId) or is_(fid, MSId))))","private NotRecursive: (set of (((DFDId | MSId) * (DFDId | MSId))) -\u003e bool)\n\tNotRecursive(top) \u003d\u003d\n(forall mk_(f, -) in set top \u0026 (f not in set TransClosure(f, top, {})))","private TransClosure: ((DFDId | MSId) * set of (((DFDId | MSId) * (DFDId | MSId))) * set of ((DFDId | MSId)) -\u003e set of ((DFDId | MSId)))\n\tTransClosure(pid, top, dset) \u003d\u003d\n(if (exists mk_(fromid, toid) in set top \u0026 (((fromid \u003d pid) or (fromid in set dset)) and (toid not in set dset)))\nthen let mk_(fromid, toid) in set top be st (((fromid \u003d pid) or (fromid in set dset)) and (toid not in set dset)) in TransClosure(pid, top, (dset union {toid}))\nelse dset)","Document \u003d Document","Module \u003d Module","ModuleId \u003d ModuleId","Interface \u003d Interface","Imports \u003d Imports","Import \u003d Import","Export \u003d Export","ModuleSig \u003d ModuleSig","Sig \u003d Sig","TypeSig \u003d TypeSig","TypeId \u003d TypeId","OpSig \u003d OpSig","Definitions \u003d Definitions","Definition \u003d Definition","StateDef \u003d StateDef","Field \u003d Field","OpDef \u003d OpDef","ExplOp \u003d ExplOp","ImplOp \u003d ImplOp","ImplOpBody \u003d ImplOpBody","ParType \u003d ParType","IdType \u003d IdType","ExtVarInf \u003d ExtVarInf","ReadWriteMode \u003d ReadWriteMode","OpType \u003d OpType","Type \u003d Type","ProductType \u003d ProductType","MapType \u003d MapType","SetType \u003d SetType","SeqType \u003d SeqType","BasicType \u003d BasicType","EnumType \u003d EnumType","OptionalType \u003d OptionalType","UnionType \u003d UnionType","Stmt \u003d Stmt","DclStmt \u003d DclStmt","AssDef \u003d AssDef","DefStmt \u003d DefStmt","NonDetStmt \u003d NonDetStmt","Call \u003d Call","Sequence \u003d Sequence","Return \u003d Return","Expr \u003d Expr","LetExpr \u003d LetExpr","IfExpr \u003d IfExpr","QuantExpr \u003d QuantExpr","ExistsExpr \u003d ExistsExpr","BinaryExpr \u003d BinaryExpr","BinaryOp \u003d BinaryOp","TupleConstructor \u003d TupleConstructor","Apply \u003d Apply","BoolLit \u003d BoolLit","MultTypeBind \u003d MultTypeBind","TypeBind \u003d TypeBind","Pattern \u003d Pattern","PatternId \u003d PatternId","TuplePattern \u003d TuplePattern","Id \u003d Id"]