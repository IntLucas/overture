["class Actuator\nprotected  ID:nat :\u003d (undefined)\nprotected  Type:nodeType :\u003d (undefined)\nprotected  Corr:correction :\u003d (undefined)\nprotected  Env:Surroundings :\u003d (undefined)\npublic  GetID() (() \u003d\u003d\u003e nat)\n\tGetID()() \u003d\u003d\nreturn (ID)\npublic  GetType() (() \u003d\u003d\u003e nodeType)\n\tGetType()() \u003d\u003d\nreturn (Type)\nprotected  GetCorr() (() \u003d\u003d\u003e correction)\n\tGetCorr()() \u003d\u003d\nreturn (Corr)\nend Actuator\n","class BaseThread\nprotected  period:nat1 :\u003d 1\nprotected  isPeriodic:bool :\u003d true\nprotected  BaseThread() (() \u003d\u003d\u003e BaseThread)\n\tBaseThread()() \u003d\u003d\n(\n\nWorld`timerRef.RegisterThread(self);\nif (not (World`timerRef.IsInitialising)())\nthen\nstart (self)\n)\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nis subclass responsibility\nprotected  thread (\n\nif isPeriodic\nthen\n(\n\nwhile true do (\n\nStep();\nWorld`timerRef.WaitRelative(period)\n)\n)else\n(\n\nStep();\nWorld`timerRef.WaitRelative(0);\nWorld`timerRef.UnRegisterThread()\n)\n)\nend BaseThread\n","class Environment is subclass of [BaseThread]\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  simtime:nat :\u003d 1.0E9\nprivate  finished:bool :\u003d false\npublic static  inline \u003d inline\npublic  Environment(seq of (char), nat1, bool) (seq of (char) * nat1 * bool \u003d\u003d\u003e Environment)\n\tEnvironment(seq of (char), nat1, bool)(fname, p, isP) \u003d\u003d\n(\n\nperiod :\u003d p;\nisPeriodic :\u003d isP;\nlet mk_(-, mk_(t, input)) \u003d ((io.freadval))[(nat * seq of (inline))](fname) in (\n\ninlines :\u003d input;\nsimtime :\u003d t\n)\n)\nprivate  CreateSignal() (() \u003d\u003d\u003e ())\n\tCreateSignal()() \u003d\u003d\n(\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:nat :\u003d (World`timerRef.GetTime)()\n\nlet mk_(temp, humid, time) \u003d (hd inlines) in (\n\nif (time \u003d curtime)\nthen\n(\n\nHA`Sur.SetTemp(temp);\nHA`Sur.SetHumid(humid);\nIO`print(([time] ^ [\"New env values set!\"]));\nIO`print(\" \n\");\ninlines :\u003d (tl inlines);\nreturn\n)\n)\n)else\n(\n\nfinished :\u003d true;\nreturn\n)\n)\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif ((World`timerRef.GetTime)() \u003c simtime)\nthen\nCreateSignal()else\nfinished :\u003d true\n)\nprivate  per IsFinished \u003d\u003e finished\nend Environment\n","class HA\npublic static  Sur:Surroundings :\u003d new Surroundings()\npublic static  TempNode:TemperatureSensor :\u003d new TemperatureSensor(1, \u003cTEMPSENSOR\u003e, 0, Sur, 3, true)\npublic static  HumidNode:HumidSensor :\u003d new HumidSensor(2, \u003cHUMIDSENSOR\u003e, 0, Sur, 3, true)\npublic static  ThermNode:Thermostat :\u003d new Thermostat(3, \u003cTHERMOSTAT\u003e, Sur, 5, true)\npublic static  WinNode:Window :\u003d new Window(4, \u003cWINDOW\u003e, Sur, 5, true)\npublic static  Host:HostController :\u003d new HostController(22, 75, 3, true)\nend HA\n","class HostController is subclass of [BaseThread]\nprivate  finished:bool :\u003d false\nprivate  print:bool :\u003d true\nprivate  TargetTemp:nat :\u003d (undefined)\nprivate  Temp:nat :\u003d 0\nprivate  TargetHumid:nat :\u003d (undefined)\nprivate  Humid:nat :\u003d 0\nprivate  NodeList:map (nat) to (nodeType) :\u003d {|-\u003e}\nprivate  Algo:algType :\u003d \u003cNONE\u003e\nprivate static  algType \u003d algType\npublic  HostController(nat, nat, nat1, bool) (nat * nat * nat1 * bool \u003d\u003d\u003e HostController)\n\tHostController(nat, nat, nat1, bool)(t, h, p, isP) \u003d\u003d\n(\n\nTargetTemp :\u003d t;\nTargetHumid :\u003d h;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\nprivate  UpdateValues() (() \u003d\u003d\u003e ())\n\tUpdateValues()() \u003d\u003d\n(\n\nfor all r in set (rng NodeList) do\n(\n\nif (r \u003d \u003cHUMIDSENSOR\u003e)\nthen\nHumid :\u003d (HA`HumidNode.ReadValue)();\nif (r \u003d \u003cTEMPSENSOR\u003e)\nthen\nTemp :\u003d (HA`TempNode.ReadValue)()\n)\n)\nprivate  Algorithm() (() \u003d\u003d\u003e ())\n\tAlgorithm()() \u003d\u003d\n(\n\ncases Algo :\n  \u003cTHTW\u003e -\u003e THTWAlgo()  \u003cTTW\u003e -\u003e TTWAlgo()  \u003cTT\u003e -\u003e TTAlgo()  \u003cTW\u003e -\u003e TWAlgo()  \u003cHW\u003e -\u003e HWAlgo()  \u003cNONE\u003e -\u003e return end\n)\nprivate  THTWAlgo() (() \u003d\u003d\u003e ())\n\tTHTWAlgo()() \u003d\u003d\n(\n\nif (Humid \u003e TargetHumid)\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cOPEN\u003e);\nHA`ThermNode.SetCorrection(\u003cNONE\u003e);\nprint :\u003d true\n)elseif (Temp \u003e (TargetTemp + 1))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cDEC\u003e);\nprint :\u003d true\n)elseif (Temp \u003c (TargetTemp - 1))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cINC\u003e);\nprint :\u003d true\n)else\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cNONE\u003e);\nif print\nthen\n(\n\nIO`print(([(World`timerRef.GetTime)()] ^ [\"Target values reached\"]));\nIO`print(\" \n\")\n);\nprint :\u003d false\n)\n)\nprivate  TTWAlgo() (() \u003d\u003d\u003e ())\n\tTTWAlgo()() \u003d\u003d\n(\n\nif (Temp \u003e (TargetTemp + 2))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cOPEN\u003e);\nHA`ThermNode.SetCorrection(\u003cDEC\u003e);\nprint :\u003d true\n)elseif (Temp \u003e (TargetTemp + 1))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cDEC\u003e);\nprint :\u003d true\n)elseif (Temp \u003c (TargetTemp - 1))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cINC\u003e);\nprint :\u003d true\n)else\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nHA`ThermNode.SetCorrection(\u003cNONE\u003e);\nif print\nthen\n(\n\nIO`print(([(World`timerRef.GetTime)()] ^ [\"Target values reached\"]));\nIO`print(\" \n\")\n);\nprint :\u003d false\n)\n)\nprivate  TTAlgo() (() \u003d\u003d\u003e ())\n\tTTAlgo()() \u003d\u003d\n(\n\nif (Temp \u003e (TargetTemp + 1))\nthen\n(\n\nHA`ThermNode.SetCorrection(\u003cDEC\u003e);\nprint :\u003d true\n)elseif (Temp \u003c (TargetTemp - 1))\nthen\n(\n\nHA`ThermNode.SetCorrection(\u003cDEC\u003e);\nprint :\u003d true\n)else\n(\n\nHA`ThermNode.SetCorrection(\u003cNONE\u003e);\nif print\nthen\n(\n\nIO`print(([(World`timerRef.GetTime)()] ^ [\"Target values reached\"]));\nIO`print(\" \n\")\n);\nprint :\u003d false\n)\n)\nprivate  TWAlgo() (() \u003d\u003d\u003e ())\n\tTWAlgo()() \u003d\u003d\n(\n\nif (Temp \u003e (TargetTemp + 1))\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cOPEN\u003e);\nprint :\u003d true\n)else\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nif print\nthen\n(\n\nIO`print(([(World`timerRef.GetTime)()] ^ [\"Target values reached\"]));\nIO`print(\" \n\")\n);\nprint :\u003d false\n)\n)\nprivate  HWAlgo() (() \u003d\u003d\u003e ())\n\tHWAlgo()() \u003d\u003d\n(\n\nif (Humid \u003e TargetHumid)\nthen\n(\n\nHA`WinNode.SetCorrection(\u003cOPEN\u003e);\nprint :\u003d true\n)else\n(\n\nHA`WinNode.SetCorrection(\u003cCLOSE\u003e);\nif print\nthen\n(\n\nIO`print(([(World`timerRef.GetTime)()] ^ [\"Target values reached\"]));\nIO`print(\" \n\")\n);\nprint :\u003d false\n)\n)\nprivate  UpdateAlgorithm() (() \u003d\u003d\u003e ())\n\tUpdateAlgorithm()() \u003d\u003d\n(\n\nif ((rng NodeList) \u003d {})\nthen\nAlgo :\u003d \u003cNONE\u003eelseif ((rng NodeList) \u003d {\u003cTEMPSENSOR\u003e, \u003cHUMIDSENSOR\u003e, \u003cTHERMOSTAT\u003e, \u003cWINDOW\u003e})\nthen\nAlgo :\u003d \u003cTHTW\u003eelseif ((rng NodeList) \u003d {\u003cTEMPSENSOR\u003e, \u003cTHERMOSTAT\u003e, \u003cWINDOW\u003e})\nthen\nAlgo :\u003d \u003cTTW\u003eelseif ((rng NodeList) \u003d {\u003cTEMPSENSOR\u003e, \u003cTHERMOSTAT\u003e})\nthen\nAlgo :\u003d \u003cTT\u003eelseif ((rng NodeList) \u003d {\u003cTEMPSENSOR\u003e, \u003cWINDOW\u003e})\nthen\nAlgo :\u003d \u003cTW\u003eelseif ((rng NodeList) \u003d {\u003cHUMIDSENSOR\u003e, \u003cWINDOW\u003e})\nthen\nAlgo :\u003d \u003cHW\u003eelse\nAlgo :\u003d \u003cNONE\u003e\n)\nprivate  printStr(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tprintStr(seq of (char))(str) \u003d\u003d\n(\n\nprint :\u003d false;\nIO`print(str)\n)\npublic  AddNode(nat, nodeType) (nat * nodeType \u003d\u003d\u003e ())\n\tAddNode(nat, nodeType)(id, type) \u003d\u003d\n(\n\nNodeList :\u003d (NodeList ++ {id |-\u003e type});\nUpdateAlgorithm()\n)\n\tpre (id not in set (dom NodeList))\n\tpost ((card (dom NodeList)) \u003d ((card (dom NodeList~)) + 1))\npublic  RemoveNode(nat, nodeType) (nat * nodeType \u003d\u003d\u003e ())\n\tRemoveNode(nat, nodeType)(id, type) \u003d\u003d\n(\n\nif (NodeList(id) \u003d type)\nthen\nNodeList :\u003d ({id} \u003c-: NodeList)\n)\n\tpre (id in set (dom NodeList))\n\tpost ((card (dom NodeList)) \u003d ((card (dom NodeList~)) - 1))\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nUpdateValues();\nAlgorithm()\n)\nprivate  per IsFinished \u003d\u003e finished\nprivate  per printStr \u003d\u003e print\nend HostController\n","class HumidSensor is subclass of [Sensor, BaseThread]\nprivate  finished:bool :\u003d false\npublic  HumidSensor(nat, nodeType, nat, Surroundings, nat1, bool) (nat * nodeType * nat * Surroundings * nat1 * bool \u003d\u003d\u003e HumidSensor)\n\tHumidSensor(nat, nodeType, nat, Surroundings, nat1, bool)(id, type, val, envir, p, isP) \u003d\u003d\n(\n\nID :\u003d id;\nType :\u003d type;\nValue :\u003d val;\nEnv :\u003d envir;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nValue :\u003d (Env.ReadHumid)()\nprivate  per IsFinished \u003d\u003e finished\nend HumidSensor\n","class NetworkTypes\npublic static  nodeType \u003d nodeType\npublic static  correction \u003d correction\nend NetworkTypes\n","class Sensor\nprotected  ID:nat :\u003d (undefined)\nprotected  Type:nodeType :\u003d (undefined)\nprotected  Value:nat :\u003d (undefined)\nprotected  Env:Surroundings :\u003d (undefined)\npublic  GetID() (() \u003d\u003d\u003e nat)\n\tGetID()() \u003d\u003d\nreturn (ID)\npublic  GetType() (() \u003d\u003d\u003e nodeType)\n\tGetType()() \u003d\u003d\nreturn (Type)\npublic  ReadValue() (() \u003d\u003d\u003e nat)\n\tReadValue()() \u003d\u003d\nreturn (Value)\nend Sensor\n","class Surroundings\nprivate  envTemp:nat :\u003d (undefined)\nprivate  envHumid:nat :\u003d (undefined)\npublic  Surroundings() (() \u003d\u003d\u003e Surroundings)\n\tSurroundings()() \u003d\u003d\n(\n\nenvTemp :\u003d 20;\nenvHumid :\u003d 75\n)\npublic  SetTemp(nat) (nat \u003d\u003d\u003e ())\n\tSetTemp(nat)(t) \u003d\u003d\nenvTemp :\u003d t\npublic  SetHumid(nat) (nat \u003d\u003d\u003e ())\n\tSetHumid(nat)(h) \u003d\u003d\nenvHumid :\u003d h\npublic  ReadTemp() (() \u003d\u003d\u003e nat)\n\tReadTemp()() \u003d\u003d\nreturn (envTemp)\npublic  IncTemp() (() \u003d\u003d\u003e ())\n\tIncTemp()() \u003d\u003d\nenvTemp :\u003d (envTemp + 1)\npublic  DecTemp() (() \u003d\u003d\u003e ())\n\tDecTemp()() \u003d\u003d\nenvTemp :\u003d (envTemp - 1)\npublic  ReadHumid() (() \u003d\u003d\u003e nat)\n\tReadHumid()() \u003d\u003d\nreturn (envHumid)\npublic  IncHumid() (() \u003d\u003d\u003e ())\n\tIncHumid()() \u003d\u003d\nenvHumid :\u003d (envHumid + 1)\npublic  DecHumid() (() \u003d\u003d\u003e ())\n\tDecHumid()() \u003d\u003d\nenvHumid :\u003d (envHumid - 1)\nprivate  mutex(IncTemp)\nprivate  mutex(DecTemp)\nprivate  mutex(SetTemp)\nprivate  mutex(ReadTemp, IncTemp, DecTemp, SetTemp)\nprivate  mutex(IncHumid)\nprivate  mutex(DecHumid)\nprivate  mutex(SetHumid)\nprivate  mutex(ReadHumid, IncHumid, DecHumid, SetHumid)\nend Surroundings\n","class TemperatureSensor is subclass of [Sensor, BaseThread]\nprivate  finished:bool :\u003d false\npublic  TemperatureSensor(nat, nodeType, nat, Surroundings, nat1, bool) (nat * nodeType * nat * Surroundings * nat1 * bool \u003d\u003d\u003e TemperatureSensor)\n\tTemperatureSensor(nat, nodeType, nat, Surroundings, nat1, bool)(id, type, val, envir, p, isP) \u003d\u003d\n(\n\nID :\u003d id;\nType :\u003d type;\nValue :\u003d val;\nEnv :\u003d envir;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\nValue :\u003d (Env.ReadTemp)()\nprivate  per IsFinished \u003d\u003e finished\nend TemperatureSensor\n","class Thermostat is subclass of [Actuator, BaseThread]\nprivate  finished:bool :\u003d false\npublic  Thermostat(nat, nodeType, Surroundings, nat1, bool) (nat * nodeType * Surroundings * nat1 * bool \u003d\u003d\u003e Thermostat)\n\tThermostat(nat, nodeType, Surroundings, nat1, bool)(id, type, envir, p, isP) \u003d\u003d\n(\n\nID :\u003d id;\nType :\u003d type;\nCorr :\u003d \u003cNONE\u003e;\nEnv :\u003d envir;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  SetCorrection(correction) (correction \u003d\u003d\u003e ())\n\tSetCorrection(correction)(cor) \u003d\u003d\nCorr :\u003d cor\n\tpre ((cor \u003d \u003cINC\u003e) or ((cor \u003d \u003cDEC\u003e) or (cor \u003d \u003cNONE\u003e)))\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\ntempCorr:correction :\u003d GetCorr()\n\nif (tempCorr \u003d \u003cINC\u003e)\nthen\nHA`Sur.IncTemp()elseif (tempCorr \u003d \u003cDEC\u003e)\nthen\nHA`Sur.DecTemp()\n)\nprivate  per IsFinished \u003d\u003e finished\nend Thermostat\n","class TimeStamp\npublic static  stepLength:nat \u003d 1\nprivate  currentTime:nat :\u003d 0\nprivate  wakeUpMap:map (nat) to ([nat]) :\u003d {|-\u003e}\nprivate  barrierCount:nat :\u003d 0\nprivate  registeredThreads:set of (BaseThread) :\u003d {}\nprivate  isInitialising:bool :\u003d true\npublic  TimeStamp(nat) (nat \u003d\u003d\u003e TimeStamp)\n\tTimeStamp(nat)(count) \u003d\u003d\nbarrierCount :\u003d count\npublic  RegisterThread(BaseThread) (BaseThread \u003d\u003d\u003e ())\n\tRegisterThread(BaseThread)(t) \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount + 1);\nregisteredThreads :\u003d (registeredThreads union {t})\n)\npublic  UnRegisterThread() (() \u003d\u003d\u003e ())\n\tUnRegisterThread()() \u003d\u003d\n(\n\nbarrierCount :\u003d (barrierCount - 1)\n)\npublic  IsInitialising() (() \u003d\u003d\u003e bool)\n\tIsInitialising()() \u003d\u003d\nreturn (isInitialising)\npublic  DoneInitialising() (() \u003d\u003d\u003e ())\n\tDoneInitialising()() \u003d\u003d\n(\n\nif isInitialising\nthen\n(\n\nisInitialising :\u003d false;\nfor all t in set registeredThreads do\nstart (t)\n)\n)\npublic  WaitRelative(nat) (nat \u003d\u003d\u003e ())\n\tWaitRelative(nat)(val) \u003d\u003d\n(\n\nWaitAbsolute((currentTime + val))\n)\npublic  WaitAbsolute(nat) (nat \u003d\u003d\u003e ())\n\tWaitAbsolute(nat)(val) \u003d\u003d\n(\n\nAddToWakeUpMap(threadid, val);\nBarrierReached();\nAwake()\n)\nprivate  BarrierReached() (() \u003d\u003d\u003e ())\n\tBarrierReached()() \u003d\u003d\n(\n\nwhile ((card (dom wakeUpMap)) \u003d barrierCount) do (\n\ncurrentTime :\u003d (currentTime + stepLength);\nlet threadSet:set of (nat) \u003d {th | th in set (dom wakeUpMap) \u0026 ((wakeUpMap(th) \u003c\u003e nil) and (wakeUpMap(th) \u003c\u003d currentTime))} in for all t in set threadSet do\nwakeUpMap :\u003d ({t} \u003c-: wakeUpMap)\n)\n)\n\tpost (forall x in set (rng wakeUpMap) \u0026 ((x \u003d nil) or (x \u003e\u003d currentTime)))\nprivate  AddToWakeUpMap(nat, [nat]) (nat * [nat] \u003d\u003d\u003e ())\n\tAddToWakeUpMap(nat, [nat])(tId, val) \u003d\u003d\nwakeUpMap :\u003d (wakeUpMap ++ {tId |-\u003e val})\npublic  NotifyThread(nat) (nat \u003d\u003d\u003e ())\n\tNotifyThread(nat)(tId) \u003d\u003d\nwakeUpMap :\u003d ({tId} \u003c-: wakeUpMap)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nprivate  Awake() (() \u003d\u003d\u003e ())\n\tAwake()() \u003d\u003d\nskip\npublic  ThreadDone() (() \u003d\u003d\u003e ())\n\tThreadDone()() \u003d\u003d\nAddToWakeUpMap(threadid, nil)\nprivate  per Awake \u003d\u003e (threadid not in set (dom wakeUpMap))\nprivate  mutex(IsInitialising)\nprivate  mutex(DoneInitialising)\nprivate  mutex(AddToWakeUpMap)\nprivate  mutex(NotifyThread)\nprivate  mutex(BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread)\nprivate  mutex(AddToWakeUpMap, BarrierReached)\nprivate  mutex(NotifyThread, BarrierReached)\nprivate  mutex(AddToWakeUpMap, NotifyThread, BarrierReached)\nend TimeStamp\n","class Window is subclass of [Actuator, BaseThread]\nprivate  finished:bool :\u003d false\npublic  Window(nat, nodeType, Surroundings, nat1, bool) (nat * nodeType * Surroundings * nat1 * bool \u003d\u003d\u003e Window)\n\tWindow(nat, nodeType, Surroundings, nat1, bool)(id, type, envir, p, isP) \u003d\u003d\n(\n\nID :\u003d id;\nType :\u003d type;\nCorr :\u003d \u003cCLOSE\u003e;\nEnv :\u003d envir;\nperiod :\u003d p;\nisPeriodic :\u003d isP\n)\npublic  SetCorrection(correction) (correction \u003d\u003d\u003e ())\n\tSetCorrection(correction)(cor) \u003d\u003d\nCorr :\u003d cor\n\tpre ((cor \u003d \u003cOPEN\u003e) or (cor \u003d \u003cCLOSE\u003e))\npublic  Finish() (() \u003d\u003d\u003e ())\n\tFinish()() \u003d\u003d\nfinished :\u003d true\npublic  IsFinished() (() \u003d\u003d\u003e ())\n\tIsFinished()() \u003d\u003d\nskip\nprotected  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nif (GetCorr() \u003d \u003cOPEN\u003e)\nthen\n(\n\nHA`Sur.DecHumid();\nHA`Sur.DecTemp()\n)\n)\nprivate  per IsFinished \u003d\u003e finished\nend Window\n","class World\nprivate  env:Environment :\u003d (undefined)\npublic static  timerRef:TimeStamp :\u003d new TimeStamp()\nprivate  ha:HA :\u003d (undefined)\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nha :\u003d new HA();\nenv :\u003d new Environment(\"scenario.txt\", 1, true);\nha.Host.AddNode(((ha.TempNode).GetID)(), ((ha.TempNode).GetType)());\nha.Host.AddNode(((ha.HumidNode).GetID)(), ((ha.HumidNode).GetType)());\nha.Host.AddNode(((ha.ThermNode).GetID)(), ((ha.ThermNode).GetType)());\nha.Host.AddNode(((ha.WinNode).GetID)(), ((ha.WinNode).GetType)());\nWorld`timerRef.DoneInitialising()\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nenv.IsFinished();\nIO`print(\"Test run finished at time: \");\nIO`print((timerRef.GetTime)())\n)\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]