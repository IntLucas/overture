["class Alphabet\nprivate  alph:seq of (char) :\u003d []\nprivate  invAlphabetInv(alph)\nprivate  private AlphabetInv: (seq of (char) -\u003e bool)\n\tAlphabetInv(palph) \u003d\u003d\n((((len palph) mod 2) \u003d 0) and ((card (elems palph)) \u003d (len palph)))\npublic  Alphabet(seq of (char)) (seq of (char) \u003d\u003d\u003e Alphabet)\n\tAlphabet(seq of (char))(pa) \u003d\u003d\nalph :\u003d pa\n\tpre AlphabetInv(pa)\npublic  GetChar(nat) (nat \u003d\u003d\u003e char)\n\tGetChar(nat)(pidx) \u003d\u003d\nreturn (alph(pidx))\n\tpre (pidx in set (inds alph))\npublic  GetIndex(char) (char \u003d\u003d\u003e nat)\n\tGetIndex(char)(pch) \u003d\u003d\nlet pidx in set {i | i in set (inds alph) \u0026 (alph(i) \u003d pch)} in return (pidx)\n\tpre (pch in set (elems alph))\npublic  GetIndices() (() \u003d\u003d\u003e set of (nat))\n\tGetIndices()() \u003d\u003d\nreturn ((inds alph))\npublic  GetSize() (() \u003d\u003d\u003e nat)\n\tGetSize()() \u003d\u003d\nreturn ((len alph))\npublic  Shift(nat, nat) (nat * nat \u003d\u003d\u003e nat)\n\tShift(nat, nat)(pidx, poffset) \u003d\u003d\nif ((pidx + poffset) \u003e (len alph))\nthen\nreturn (((pidx + poffset) - (len alph)))else\nreturn ((pidx + poffset))\n\tpre ((pidx in set (inds alph)) and (poffset \u003c\u003d (len alph)))\npublic  Shift(nat) (nat \u003d\u003d\u003e nat)\n\tShift(nat)(pidx) \u003d\u003d\nShift(pidx, 1)\nend Alphabet\n","class AlphabetTest is subclass of [TestCase]\nprivate static  str:seq of (char) \u003d \"ABCD\"\npublic  AlphabetTest(seq of (char)) (seq of (char) \u003d\u003d\u003e AlphabetTest)\n\tAlphabetTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\ntc:Alphabet :\u003d new Alphabet(str)\n\nfor all i in set (inds str) do\n(\n\nAssertTrue(((tc.GetChar)(i) \u003d str(i)));\nAssertTrue(((tc.GetIndex)(str(i)) \u003d i));\nAssertTrue(((tc.Shift)(1, i) \u003d (tc.Shift)(i)))\n);\nAssertTrue(((tc.GetSize)() \u003d 4));\nAssertTrue(((tc.GetIndices)() \u003d {1, ... ,4}))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend AlphabetTest\n","class Component\nprotected  next:[Component] :\u003d nil\nprotected  alph:Alphabet :\u003d (undefined)\npublic  Successors() (() \u003d\u003d\u003e set of (Component))\n\tSuccessors()() \u003d\u003d\nif (next \u003d nil)\nthen\nreturn ({self})else\nreturn (({self} union (next.Successors)()))\npublic  SetNext(Component) (Component \u003d\u003d\u003e ())\n\tSetNext(Component)(pcom) \u003d\u003d\nnext :\u003d pcom\n\tpre ((next \u003d nil) and (self not in set (pcom.Successors)()))\npublic  Substitute(nat) (nat \u003d\u003d\u003e nat)\n\tSubstitute(nat)(-) \u003d\u003d\nis subclass responsibility\npublic  Rotate() (() \u003d\u003d\u003e ())\n\tRotate()() \u003d\u003d\nskip\npublic  Rotate(nat) (nat \u003d\u003d\u003e ())\n\tRotate(nat)(-) \u003d\u003d\nskip\nend Component\n","class Configuration is subclass of [Component]\nprotected  config:inmap (nat) to (nat) :\u003d (undefined)\nprotected  Encode(nat) (nat \u003d\u003d\u003e nat)\n\tEncode(nat)(penc) \u003d\u003d\nif (penc in set (dom config))\nthen\nreturn (config(penc))else\nreturn (penc)\nprotected  Decode(nat) (nat \u003d\u003d\u003e nat)\n\tDecode(nat)(pdec) \u003d\u003d\nlet invcfg:map (nat) to (nat) \u003d (inverse config) in if (pdec in set (dom invcfg))\nthen\nreturn (invcfg(pdec))else\nreturn (pdec)\npublic  Substitute(nat) (nat \u003d\u003d\u003e nat)\n\tSubstitute(nat)(pidx) \u003d\u003d\nreturn (Decode((next.Substitute)(Encode(pidx))))\n\tpre (next \u003c\u003e nil)\nend Configuration\n","class ConfigurationTest is subclass of [Configuration, TestCase]\nprivate static  cfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 3 |-\u003e 4}\npublic  ConfigurationTest(seq of (char)) (seq of (char) \u003d\u003d\u003e ConfigurationTest)\n\tConfigurationTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nconfig :\u003d cfg\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\n\nAssertTrue((Encode(1) \u003d 2));\nAssertTrue((Encode(2) \u003d 2));\nAssertTrue((Encode(3) \u003d 4));\nAssertTrue((Encode(4) \u003d 4));\nAssertTrue((Decode(1) \u003d 1));\nAssertTrue((Decode(2) \u003d 1));\nAssertTrue((Decode(3) \u003d 3));\nAssertTrue((Decode(4) \u003d 3))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend ConfigurationTest\n","class EnigmaTest\npublic  Execute() (() \u003d\u003d\u003e ())\n\tExecute()() \u003d\u003d\n(\nts:TestSuite :\u003d new TestSuite()\n\nts.AddTest(new AlphabetTest(\"Alphabet\"));\nts.AddTest(new ConfigurationTest(\"Configuration\"));\nts.AddTest(new ReflectorTest(\"Reflector\"));\nts.AddTest(new RotorTest(\"Rotor\"));\nts.AddTest(new PlugboardTest(\"Plugboard\"));\nts.AddTest(new SimpleEnigmaTest(\"SimpleEnigma\"));\nts.Run()\n)\nend EnigmaTest\n","class Plugboard is subclass of [Configuration]\nprivate  invPlugboardInv(config, alph)\nprivate  private PlugboardInv: (inmap (nat) to (nat) * Alphabet -\u003e bool)\n\tPlugboardInv(pconfig, palph) \u003d\u003d\n((dom pconfig) subset (palph.GetIndices)())\npublic  Plugboard(Alphabet, inmap (nat) to (nat)) (Alphabet * inmap (nat) to (nat) \u003d\u003d\u003e Plugboard)\n\tPlugboard(Alphabet, inmap (nat) to (nat))(pa, pcfg) \u003d\u003d\natomic (alph :\u003d pa, config :\u003d (pcfg munion (inverse pcfg)))\n\tpre ((((dom pcfg) inter (rng pcfg)) \u003d {}) and PlugboardInv(pcfg, pa))\npublic  Substitute(nat) (nat \u003d\u003d\u003e nat)\n\tSubstitute(nat)(pidx) \u003d\u003d\n(\n\nnext.Rotate();\nConfiguration`Substitute(pidx)\n)\n\tpre ((pidx in set (alph.GetIndices)()) and (isofclass(Rotor,next) or isofclass(Reflector,next)))\nend Plugboard\n","class PlugboardTest is subclass of [TestCase]\nprivate static  refcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 3 |-\u003e 4}\nprivate static  rotcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 2 |-\u003e 1, 3 |-\u003e 4, 4 |-\u003e 3}\nprivate static  pbcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 3}\nprivate  alph:Alphabet :\u003d (undefined)\npublic  PlugboardTest(seq of (char)) (seq of (char) \u003d\u003d\u003e PlugboardTest)\n\tPlugboardTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nalph :\u003d new Alphabet(\"ABCD\")\nprotected  SimpleTest() (() \u003d\u003d\u003e ())\n\tSimpleTest()() \u003d\u003d\n(\ntc:Plugboard :\u003d new Plugboard(alph, pbcfg)\n\ntc.SetNext(new Reflector(1, alph, refcfg));\nAssertTrue(((tc.Substitute)(1) \u003d 4));\nAssertTrue(((tc.Substitute)(2) \u003d 3));\nAssertTrue(((tc.Substitute)(3) \u003d 2));\nAssertTrue(((tc.Substitute)(4) \u003d 1))\n)\nprotected  ComplexTest() (() \u003d\u003d\u003e ())\n\tComplexTest()() \u003d\u003d\n(\ntc:Plugboard :\u003d new Plugboard(alph, pbcfg)\nrot:Rotor :\u003d new Rotor(1, 1, alph, rotcfg)\n\nrot.SetNext(new Reflector(1, alph, refcfg));\ntc.SetNext(rot);\nAssertTrue(((tc.Substitute)(1) \u003d 4));\nAssertTrue(((tc.Substitute)(2) \u003d 3));\nAssertTrue(((tc.Substitute)(3) \u003d 2));\nAssertTrue(((tc.Substitute)(4) \u003d 1))\n)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\n\nSimpleTest();\nComplexTest()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend PlugboardTest\n","class Reflector is subclass of [Configuration]\nprivate  invReflectorInv(next, config, alph)\nprivate  private ReflectorInv: ([Component] * inmap (nat) to (nat) * Alphabet -\u003e bool)\n\tReflectorInv(pnext, pconfig, palph) \u003d\u003d\n((pnext \u003d nil) and ((((dom pconfig) inter (rng pconfig)) \u003d {}) and (((dom pconfig) union (rng pconfig)) \u003d (palph.GetIndices)())))\npublic  Reflector(nat, Alphabet, inmap (nat) to (nat)) (nat * Alphabet * inmap (nat) to (nat) \u003d\u003d\u003e Reflector)\n\tReflector(nat, Alphabet, inmap (nat) to (nat))(psp, pa, pcfg) \u003d\u003d\natomic (alph :\u003d pa, config :\u003d {(pa.Shift)(i, (psp - 1)) |-\u003e (pa.Shift)(pcfg(i), (psp - 1)) | i in set (dom pcfg)})\n\tpre ((psp in set (pa.GetIndices)()) and ReflectorInv(next, pcfg, pa))\npublic  Substitute(nat) (nat \u003d\u003d\u003e nat)\n\tSubstitute(nat)(pidx) \u003d\u003d\nif (pidx in set (dom config))\nthen\nEncode(pidx)else\nDecode(pidx)\nend Reflector\n","class ReflectorTest is subclass of [TestCase]\nprivate static  cfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 3 |-\u003e 4}\nprivate  alph:Alphabet :\u003d (undefined)\npublic  ReflectorTest(seq of (char)) (seq of (char) \u003d\u003d\u003e ReflectorTest)\n\tReflectorTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nalph :\u003d new Alphabet(\"ABCD\")\nprivate  SimpleTest() (() \u003d\u003d\u003e ())\n\tSimpleTest()() \u003d\u003d\n(\ntc1:Reflector :\u003d new Reflector(1, alph, cfg)\ntc2:Reflector :\u003d new Reflector(2, alph, cfg)\n\nAssertTrue(((tc1.Substitute)(1) \u003d 2));\nAssertTrue(((tc1.Substitute)(2) \u003d 1));\nAssertTrue(((tc1.Substitute)(3) \u003d 4));\nAssertTrue(((tc1.Substitute)(4) \u003d 3));\nAssertTrue(((tc2.Substitute)(1) \u003d 4));\nAssertTrue(((tc2.Substitute)(2) \u003d 3));\nAssertTrue(((tc2.Substitute)(3) \u003d 2));\nAssertTrue(((tc2.Substitute)(4) \u003d 1))\n)\nprivate  ComplexTest() (() \u003d\u003d\u003e ())\n\tComplexTest()() \u003d\u003d\nfor all x in set (alph.GetIndices)() do\n(\ntc:Reflector :\u003d new Reflector(x, alph, cfg)\n\nfor all y in set (alph.GetIndices)() do\nAssertTrue(((tc.Substitute)((tc.Substitute)(y)) \u003d y))\n)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\n\nSimpleTest();\nComplexTest()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend ReflectorTest\n","class Rotor is subclass of [Configuration]\nprivate  latch_pos:nat :\u003d (undefined)\nprivate  latch_lock:bool :\u003d false\nprivate  invRotorInv(latch_pos, config, alph)\nprivate  private RotorInv: (nat * inmap (nat) to (nat) * Alphabet -\u003e bool)\n\tRotorInv(platch_pos, pconfig, palph) \u003d\u003d\nlet ainds:set of (nat) \u003d (palph.GetIndices)() in ((platch_pos in set ainds) and (((dom pconfig) \u003d ainds) and (((rng pconfig) \u003d ainds) and (exists x in set (dom pconfig) \u0026 (x \u003c\u003e pconfig(x))))))\npublic  Rotor(nat, nat, Alphabet, inmap (nat) to (nat)) (nat * nat * Alphabet * inmap (nat) to (nat) \u003d\u003d\u003e Rotor)\n\tRotor(nat, nat, Alphabet, inmap (nat) to (nat))(psp, plp, pa, pcfg) \u003d\u003d\natomic (latch_pos :\u003d (pa.Shift)(plp, (psp - 1)), alph :\u003d pa, config :\u003d {(pa.Shift)(i, (psp - 1)) |-\u003e (pa.Shift)(pcfg(i), (psp - 1)) | i in set (dom pcfg)})\n\tpre ((psp in set (pa.GetIndices)()) and RotorInv(plp, pcfg, pa))\npublic  Rotate() (() \u003d\u003d\u003e ())\n\tRotate()() \u003d\u003d\n(\n\nnext.Rotate(latch_pos);\nif (latch_pos \u003d (alph.GetSize)())\nthen\nlatch_pos :\u003d 1else\nlatch_pos :\u003d (latch_pos + 1);\nconfig :\u003d {(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)};\nlatch_lock :\u003d true\n)\n\tpre (isofclass(Rotor,next) or isofclass(Reflector,next))\npublic  Rotate(nat) (nat \u003d\u003d\u003e ())\n\tRotate(nat)(ppos) \u003d\u003d\nif ((ppos \u003d latch_pos) and (not latch_lock))\nthen\nRotate()else\nlatch_lock :\u003d false\n\tpre (ppos in set (alph.GetIndices)())\nend Rotor\n","class RotorTest is subclass of [TestCase]\nprivate static  refcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 3 |-\u003e 4}\nprivate static  rotcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 1, 2 |-\u003e 3, 3 |-\u003e 2, 4 |-\u003e 4}\nprivate  alph:Alphabet :\u003d (undefined)\npublic  RotorTest(seq of (char)) (seq of (char) \u003d\u003d\u003e RotorTest)\n\tRotorTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nalph :\u003d new Alphabet(\"ABCD\")\nprotected  SimpleTest() (() \u003d\u003d\u003e ())\n\tSimpleTest()() \u003d\u003d\n(\ntc:Rotor :\u003d new Rotor(1, 1, alph, rotcfg)\n\ntc.SetNext(new Reflector(1, alph, refcfg));\nAssertTrue(((tc.Substitute)(1) \u003d 3));\nAssertTrue(((tc.Substitute)(2) \u003d 4));\nAssertTrue(((tc.Substitute)(3) \u003d 1));\nAssertTrue(((tc.Substitute)(4) \u003d 2));\ntc.Rotate();\nAssertTrue(((tc.Substitute)(1) \u003d 2));\nAssertTrue(((tc.Substitute)(2) \u003d 1));\nAssertTrue(((tc.Substitute)(3) \u003d 4));\nAssertTrue(((tc.Substitute)(4) \u003d 3));\ntc.Rotate();\nAssertTrue(((tc.Substitute)(1) \u003d 3));\nAssertTrue(((tc.Substitute)(2) \u003d 4));\nAssertTrue(((tc.Substitute)(3) \u003d 1));\nAssertTrue(((tc.Substitute)(4) \u003d 2));\ntc.Rotate();\nAssertTrue(((tc.Substitute)(1) \u003d 2));\nAssertTrue(((tc.Substitute)(2) \u003d 1));\nAssertTrue(((tc.Substitute)(3) \u003d 4));\nAssertTrue(((tc.Substitute)(4) \u003d 3))\n)\nprotected  ComplexTest() (() \u003d\u003d\u003e ())\n\tComplexTest()() \u003d\u003d\n(\ntc1:Rotor :\u003d new Rotor(1, 1, alph, rotcfg)\ntc2:Rotor :\u003d new Rotor(1, 1, alph, rotcfg)\n\ntc1.SetNext(new Reflector(1, alph, refcfg));\ntc2.SetNext(tc1);\nAssertTrue(((tc2.Substitute)(1) \u003d 2));\nAssertTrue(((tc2.Substitute)(2) \u003d 1));\nAssertTrue(((tc2.Substitute)(3) \u003d 4));\nAssertTrue(((tc2.Substitute)(4) \u003d 3));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 2));\nAssertTrue(((tc2.Substitute)(2) \u003d 1));\nAssertTrue(((tc2.Substitute)(3) \u003d 4));\nAssertTrue(((tc2.Substitute)(4) \u003d 3));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 3));\nAssertTrue(((tc2.Substitute)(2) \u003d 4));\nAssertTrue(((tc2.Substitute)(3) \u003d 1));\nAssertTrue(((tc2.Substitute)(4) \u003d 2));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 2));\nAssertTrue(((tc2.Substitute)(2) \u003d 1));\nAssertTrue(((tc2.Substitute)(3) \u003d 4));\nAssertTrue(((tc2.Substitute)(4) \u003d 3));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 3));\nAssertTrue(((tc2.Substitute)(2) \u003d 4));\nAssertTrue(((tc2.Substitute)(3) \u003d 1));\nAssertTrue(((tc2.Substitute)(4) \u003d 2));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 2));\nAssertTrue(((tc2.Substitute)(2) \u003d 1));\nAssertTrue(((tc2.Substitute)(3) \u003d 4));\nAssertTrue(((tc2.Substitute)(4) \u003d 3));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 2));\nAssertTrue(((tc2.Substitute)(2) \u003d 1));\nAssertTrue(((tc2.Substitute)(3) \u003d 4));\nAssertTrue(((tc2.Substitute)(4) \u003d 3));\ntc2.Rotate();\nAssertTrue(((tc2.Substitute)(1) \u003d 4));\nAssertTrue(((tc2.Substitute)(2) \u003d 3));\nAssertTrue(((tc2.Substitute)(3) \u003d 2));\nAssertTrue(((tc2.Substitute)(4) \u003d 1))\n)\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\n\nSimpleTest();\nComplexTest()\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend RotorTest\n","class SimpleEnigma is subclass of [Component]\nprivate static  refcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 3, 2 |-\u003e 4}\nprivate static  rotcfg:inmap (nat) to (nat) \u003d {1 |-\u003e 2, 2 |-\u003e 4, 3 |-\u003e 3, 4 |-\u003e 1}\nprivate static  pbcfg:inmap (nat) to (nat) \u003d {2 |-\u003e 3}\npublic  SimpleEnigma() (() \u003d\u003d\u003e SimpleEnigma)\n\tSimpleEnigma()() \u003d\u003d\n(\ncp:Component :\u003d (undefined)\n\nalph :\u003d new Alphabet(\"ABCD\");\nnext :\u003d new Reflector(4, alph, refcfg);\ncp :\u003d new Rotor(3, 3, alph, rotcfg);\ncp.SetNext(next);\nnext :\u003d cp;\ncp :\u003d new Rotor(2, 2, alph, rotcfg);\ncp.SetNext(next);\nnext :\u003d cp;\ncp :\u003d new Rotor(1, 1, alph, rotcfg);\ncp.SetNext(next);\nnext :\u003d cp;\ncp :\u003d new Plugboard(alph, pbcfg);\ncp.SetNext(next);\nnext :\u003d cp\n)\npublic  Keystroke(char) (char \u003d\u003d\u003e char)\n\tKeystroke(char)(pch) \u003d\u003d\nlet pidx:nat \u003d (alph.GetIndex)(pch) in return ((alph.GetChar)((next.Substitute)(pidx)))\n\tpre isofclass(Plugboard,next)\npublic  Substitute(nat) (nat \u003d\u003d\u003e nat)\n\tSubstitute(nat)(-) \u003d\u003d\nreturn (1)\nend SimpleEnigma\n","class SimpleEnigmaTest is subclass of [TestCase]\npublic  SimpleEnigmaTest(seq of (char)) (seq of (char) \u003d\u003d\u003e SimpleEnigmaTest)\n\tSimpleEnigmaTest(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nskip\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\n(\nse1:SimpleEnigma :\u003d new SimpleEnigma()\nse2:SimpleEnigma :\u003d new SimpleEnigma()\n\nfor in \u0027SimpleEnigmaTest\u0027 (SimpleEnigmaTest.vdmpp) at line 14:10chADefPatternBind[ch \u003d char]ADefPatternBind in \"ABCDDCBAABCDDCBAAABBCCDD\" do\nAssertTrue(((se1.Keystroke)((se2.Keystroke)(ch)) \u003d ch))\n)\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nskip\nend SimpleEnigmaTest\n","class Test\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(-) \u003d\u003d\nis subclass responsibility\nend Test\n","class TestCase is subclass of [Test]\nprotected  name:seq of (char) :\u003d (undefined)\npublic  TestCase(seq of (char)) (seq of (char) \u003d\u003d\u003e TestCase)\n\tTestCase(seq of (char))(nm) \u003d\u003d\nname :\u003d nm\npublic  GetName() (() \u003d\u003d\u003e seq of (char))\n\tGetName()() \u003d\u003d\nreturn (name)\nprotected  AssertTrue(bool) (bool \u003d\u003d\u003e ())\n\tAssertTrue(bool)(pb) \u003d\u003d\nif (not pb)\nthen\nexit (\u003cFAILURE\u003e)\nprotected  AssertFalse(bool) (bool \u003d\u003d\u003e ())\n\tAssertFalse(bool)(pb) \u003d\u003d\nif pb\nthen\nexit (\u003cFAILURE\u003e)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(ptr) \u003d\u003d\ntrap in \u0027TestCase\u0027 (TestCase.vdmpp) at line 22:10\u003cFAILURE\u003eADefPatternBind[]ADefPatternBind with ptr.AddFailure(self) in (\n\nSetUp();\nRunTest();\nTearDown()\n)\nprotected  SetUp() (() \u003d\u003d\u003e ())\n\tSetUp()() \u003d\u003d\nis subclass responsibility\nprotected  RunTest() (() \u003d\u003d\u003e ())\n\tRunTest()() \u003d\u003d\nis subclass responsibility\nprotected  TearDown() (() \u003d\u003d\u003e ())\n\tTearDown()() \u003d\u003d\nis subclass responsibility\nend TestCase\n","class TestResult\nprivate  failures:seq of (TestCase) :\u003d []\npublic  AddFailure(TestCase) (TestCase \u003d\u003d\u003e ())\n\tAddFailure(TestCase)(ptst) \u003d\u003d\nfailures :\u003d (failures ^ [ptst])\npublic  Print(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tPrint(seq of (char))(pstr) \u003d\u003d\nlet - \u003d (new IO().echo)((pstr ^ \"\n\")) in skip\npublic  Show() (() \u003d\u003d\u003e ())\n\tShow()() \u003d\u003d\nif (failures \u003d [])\nthen\nPrint(\"No failures detected\")else\nfor in \u0027TestResult\u0027 (TestResult.vdmpp) at line 19:11failureADefPatternBind[failure \u003d TestCase]ADefPatternBind in failures do\nPrint(((failure.GetName)() ^ \" failed\"))\nend TestResult\n","class TestSuite is subclass of [Test]\nprivate  tests:seq of (Test) :\u003d []\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\nntr:TestResult :\u003d new TestResult()\n\nRun(ntr);\nntr.Show()\n)\npublic  Run(TestResult) (TestResult \u003d\u003d\u003e ())\n\tRun(TestResult)(result) \u003d\u003d\nfor in \u0027TestSuite\u0027 (TestSuite.vdmpp) at line 16:9testADefPatternBind[test \u003d Test]ADefPatternBind in tests do\ntest.Run(result)\npublic  AddTest(Test) (Test \u003d\u003d\u003e ())\n\tAddTest(Test)(test) \u003d\u003d\ntests :\u003d (tests ^ [test])\nend TestSuite\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n"]