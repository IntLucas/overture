["class AirSpace is subclass of [GLOBAL]\nprivate  airspace:map (FOId) to (FO) :\u003d {|-\u003e}\npublic  addFO(FO) (FO \u003d\u003d\u003e ())\n\taddFO(FO)(fo) \u003d\u003d\nairspace :\u003d (airspace ++ {(fo.getId)() |-\u003e fo})\npublic  removeFO(FOId) (FOId \u003d\u003d\u003e ())\n\tremoveFO(FOId)(id) \u003d\u003d\nairspace :\u003d ({id} \u003c-: airspace)\npublic  getFO(FOId) (FOId \u003d\u003d\u003e FO)\n\tgetFO(FOId)(id) \u003d\u003d\nreturn (airspace(id))\n\tpre (id in set (dom airspace))\npublic  getAirspace() (() \u003d\u003d\u003e set of (FO))\n\tgetAirspace()() \u003d\u003d\nreturn ((rng airspace))\npublic  updateFO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e ())\n\tupdateFO(FOId, Coordinates, Altitude)(id, coord, alt) \u003d\u003d\nif (id in set (dom airspace))\nthen\n(\n\nlet fo:FO \u003d airspace(id) in (\n\nfo.setCoordinates(coord);\nfo.setAltitude(alt)\n)\n)else\n(\n\nlet newfo:FO \u003d new FO(id, coord, alt) in airspace :\u003d (airspace munion {id |-\u003e newfo})\n)\nend AirSpace\n","class FO is subclass of [GLOBAL]\nprivate  id:FOId :\u003d (undefined)\nprivate  coord:Coordinates :\u003d (undefined)\nprivate  alt:Altitude :\u003d (undefined)\npublic  FO(FOId, Coordinates, Altitude) (FOId * Coordinates * Altitude \u003d\u003d\u003e FO)\n\tFO(FOId, Coordinates, Altitude)(i, c, a) \u003d\u003d\n(\n\nid :\u003d i;\ncoord :\u003d c;\nalt :\u003d a\n)\npublic  getId() (() \u003d\u003d\u003e FOId)\n\tgetId()() \u003d\u003d\nreturn (id)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (coord)\npublic  setCoordinates(Coordinates) (Coordinates \u003d\u003d\u003e ())\n\tsetCoordinates(Coordinates)(c) \u003d\u003d\ncoord :\u003d c\npublic  getAltitude() (() \u003d\u003d\u003e Altitude)\n\tgetAltitude()() \u003d\u003d\nreturn (alt)\npublic  setAltitude(Altitude) (Altitude \u003d\u003d\u003e ())\n\tsetAltitude(Altitude)(a) \u003d\u003d\nalt :\u003d a\npublic  getPosition() (() \u003d\u003d\u003e Position)\n\tgetPosition()() \u003d\u003d\nreturn (mk_Position(coord, alt))\nend FO\n","class GLOBAL\npublic static  Altitude \u003d Altitude\n\tinv a \u003d\u003d (a \u003e\u003d 0)\npublic static  FOId \u003d FOId\npublic static  RadarId \u003d RadarId\npublic static  Coordinates \u003d Coordinates\npublic static  Time \u003d Time\npublic static  String \u003d String\npublic static  ObstacleType \u003d ObstacleType\npublic static  FOWarning \u003d FOWarning\npublic static  RadarWarning \u003d RadarWarning\npublic static  MinimumSafetyAltitude \u003d MinimumSafetyAltitude\npublic static  Position \u003d Position\npublic static  History \u003d History\npublic static  Vector \u003d Vector\nprotected  protected isPointInRange: (Coordinates * nat1 * Coordinates -\u003e bool)\n\tisPointInRange(center, range, point) \u003d\u003d\n(((((center.X) - (point.X)) ** 2) + (((center.Y) - (point.Y)) ** 2)) \u003c\u003d (range ** 2))\nprotected  protected vectorSum: (Vector * Vector -\u003e Vector)\n\tvectorSum(v1, v2) \u003d\u003d\nmk_Vector(((v1.X) + (v2.X)), ((v1.Y) + (v2.Y)))\nprotected  protected vectorDiv: (Vector * int -\u003e Vector)\n\tvectorDiv(v, n) \u003d\u003d\nmk_Vector(((v.X) / n), ((v.Y) / n))\n\tpre (n \u003c\u003e 0)\nprotected  protected addVectorToPoint: (Vector * Position -\u003e Coordinates)\n\taddVectorToPoint(v, p) \u003d\u003d\nmk_Coordinates((((p.coord).X) + (v.X)), (((p.coord).Y) + (v.Y)))\nprotected  protected vectorLength: (Vector -\u003e real)\n\tvectorLength(v) \u003d\u003d\nMATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))\nprotected  protected unitVector: (Vector -\u003e Vector)\n\tunitVector(v) \u003d\u003d\nlet l:real \u003d vectorLength(v) in mk_Vector(((v.X) / l), ((v.Y) / l))\nprotected  protected dotProduct: (Vector * Vector -\u003e real)\n\tdotProduct(v1, v2) \u003d\u003d\n(((v1.X) * (v2.X)) + ((v1.Y) * (v2.Y)))\nprotected  protected angleBetweenVectors: (Vector * Vector -\u003e real)\n\tangleBetweenVectors(v1, v2) \u003d\u003d\nlet uv1:Vector \u003d unitVector(v1), uv2:Vector \u003d unitVector(v2), dvs:real \u003d dotProduct(uv1, uv2), angle:real \u003d MATH`acos(dvs) in radians2degree(angle)\nprotected  protected radians2degree: (real -\u003e real)\n\tradians2degree(r) \u003d\u003d\n(r * (180 / MATH`pi))\nprotected  protected atan2: (real * real -\u003e real)\n\tatan2(y, x) \u003d\u003d\n(2 * MATH`atan((y / (MATH`sqrt(((x ** 2) + (y ** 2))) + x))))\n\tpre (not ((x \u003d 0) and (y \u003d 0)))\nprotected  protected signedVectorAngle: (Vector * Vector -\u003e real)\n\tsignedVectorAngle(v1, v2) \u003d\u003d\n(atan2((v2.Y), (v2.X)) - atan2((v1.Y), (v1.X)))\nprotected  protected vectorAngle: (Vector -\u003e (real * real))\n\tvectorAngle(v) \u003d\u003d\nmk_(radians2degree(MATH`acos(((v.X) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))), radians2degree(MATH`asin(((v.Y) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2)))))))\nprotected  protected vectorRotate: (Vector * real -\u003e Vector)\n\tvectorRotate(v, a) \u003d\u003d\nlet x\u0027:real \u003d ((MATH`cos(a) * (v.X)) - (MATH`sin(a) * (v.Y))), y\u0027:real \u003d ((MATH`cos(a) * (v.Y)) + (MATH`sin(a) * (v.X))) in mk_Vector(round(x\u0027), round(y\u0027))\nprotected  protected round: (real -\u003e real)\n\tround(r) \u003d\u003d\nlet fr:int \u003d (floor r), dif:real \u003d (abs (r - fr)) in (if (dif \u003c (10 ** -10))\nthen fr\nelse r)\npublic  test(real, real, real, real) (real * real * real * real \u003d\u003d\u003e (Vector * Vector * real * real * Vector * real * real))\n\ttest(real, real, real, real)(x1, y1, x2, y2) \u003d\u003d\nlet v1:Vector \u003d mk_Vector(x1, y1), v2:Vector \u003d mk_Vector(x2, y2) in return (mk_(unitVector(v1), unitVector(v2), dotProduct(unitVector(v1), unitVector(v2)), atan2(1.0E-6, 0.0), vectorRotate(v2, signedVectorAngle(v1, v2)), radians2degree(signedVectorAngle(v1, v2)), angleBetweenVectors(v1, v2)))\nend GLOBAL\n","class MSAW is subclass of [GLOBAL]\npublic static  atc:AirTrafficController :\u003d new AirTrafficController()\npublic static  radar1:Radar :\u003d new Radar(6, 11, 20)\npublic static  radar2:Radar :\u003d new Radar(30, 30, 5)\npublic static  airspace:AirSpace :\u003d new AirSpace()\npublic static  militaryZone:Obstacle :\u003d new Obstacle(\u003cNotAllowed\u003e, mk_Coordinates(25, 0), 5, 5, \u003cMilitary_Area\u003e)\nend MSAW\n","class Radar is subclass of [GLOBAL]\nprivate  location:Coordinates :\u003d (undefined)\nprivate  range:nat1 :\u003d (undefined)\nprivate  detected:map (FOId) to (FO) :\u003d (undefined)\nprivate  priority:seq of (FO) :\u003d []\nprivate  radarDisplay:dk_au_eng_Radar :\u003d (undefined)\nprivate static  rc:int :\u003d 0\npublic  Radar(int, int, nat1) (int * int * nat1 \u003d\u003d\u003e Radar)\n\tRadar(int, int, nat1)(x, y, r) \u003d\u003d\n(\n\nlocation :\u003d mk_Coordinates(x, y);\nrange :\u003d r;\ndetected :\u003d {|-\u003e};\nradarDisplay :\u003d new dk_au_eng_Radar();\nsetupRadar(radarDisplay)\n)\npublic  Scan(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tScan(AirSpace)(as) \u003d\u003d\n(\n\ndetected :\u003d {(x.getId)() |-\u003e x | x in set (as.getAirspace)() \u0026 InRange(x)};\nUpdatePriorityList();\nDisplayScan()\n)\nprivate  InRange(FO) (FO \u003d\u003d\u003e bool)\n\tInRange(FO)(fo) \u003d\u003d\nlet foLocation:Coordinates \u003d (fo.getCoordinates)() in return (isPointInRange(location, range, foLocation))\npublic  getDetected() (() \u003d\u003d\u003e set of (FO))\n\tgetDetected()() \u003d\u003d\nreturn ((rng detected))\npublic  getDetectedMap() (() \u003d\u003d\u003e map (FOId) to (FO))\n\tgetDetectedMap()() \u003d\u003d\nreturn (detected)\npublic  saturatedRadar() (() \u003d\u003d\u003e bool)\n\tsaturatedRadar()() \u003d\u003d\nreturn (((card (dom detected)) \u003e (range / 4)))\npublic  getSaturatingFOs() (() \u003d\u003d\u003e set of (FOId))\n\tgetSaturatingFOs()() \u003d\u003d\nreturn ({(priority(i).getId)() | i in set (inds priority) \u0026 (i \u003e (floor (range / 4)))})\npublic  getLocation() (() \u003d\u003d\u003e Coordinates)\n\tgetLocation()() \u003d\u003d\nreturn (location)\npublic  getRange() (() \u003d\u003d\u003e nat1)\n\tgetRange()() \u003d\u003d\nreturn (range)\nprivate  UpdatePriorityList() (() \u003d\u003d\u003e ())\n\tUpdatePriorityList()() \u003d\u003d\nlet notDetect:set of (FO) \u003d ((elems priority) \\ (rng detected)), newlyDet:set of (FO) \u003d ((rng detected) \\ (elems priority)) in (\n\nfor all fobj in set notDetect do\nlet id:seq of (char) \u003d (VDMUtil`val2seq_of_char)[FOId]((fobj.getId)()) in radarDisplay.RemFlyingObject(id);\nfor all fobj in set newlyDet do\nlet mk_Coordinates(X, Y):Coordinates \u003d (fobj.getCoordinates)(), token2seq_of_char:(token +\u003e seq of (char)) \u003d (VDMUtil`val2seq_of_char)[token] in radarDisplay.AddFlyingObject(X, Y, 0, token2seq_of_char((fobj.getId)()));\nremoveNotDetected(notDetect);\naddNewlyDetected(newlyDet)\n)\nprivate  removeNotDetected(set of (FO)) (set of (FO) \u003d\u003d\u003e ())\n\tremoveNotDetected(set of (FO))(fos) \u003d\u003d\npriority :\u003d [priority(i) | i in set (inds priority) \u0026 (priority(i) in set fos)]\nprivate  addNewlyDetected(set of (FO)) (set of (FO) \u003d\u003d\u003e ())\n\taddNewlyDetected(set of (FO))(newlyDetect) \u003d\u003d\npriority :\u003d (priority ^ set2seqFO(newlyDetect))\nprivate  setupRadar(dk_au_eng_Radar) (dk_au_eng_Radar \u003d\u003d\u003e ())\n\tsetupRadar(dk_au_eng_Radar)(r) \u003d\u003d\n(\n\nr.SetWindowPosition(((450 * rc) + 50), 100);\nr.SetStepSize(5);\nr.SetScanTime(60);\nr.SetScanWidth(350);\nlet int2seq_of_char:(int +\u003e seq of (char)) \u003d (VDMUtil`val2seq_of_char)[int], mk_Coordinates(x, y):Coordinates \u003d location in r.SetTitle(((((\"MSAW Radar: (\" ^ int2seq_of_char(x)) ^ \",\") ^ int2seq_of_char(y)) ^ \")\"));\nrc :\u003d (rc + 1)\n)\nprivate  DisplayScan() (() \u003d\u003d\u003e ())\n\tDisplayScan()() \u003d\u003d\nfor all x in set {1, ... ,(360 / 5)} do\nradarDisplay.StepRadar()\nprivate  private set2seqFO: (set of (FO) -\u003e seq of (FO))\n\tset2seqFO(fos) \u003d\u003d\n(if (fos \u003d {})\nthen []\nelse let fo in set fos in ([fo] ^ set2seqFO((fos \\ {fo}))))\nprivate  private set2seqFOm: (set of (FO) -\u003e nat)\n\tset2seqFOm(fos) \u003d\u003d\n(card fos)\nend Radar\n","class UseATC\nprivate static  id:token \u003d mk_token(1)\nprivate static  fo:FO \u003d new FO(id, mk_GLOBAL`Coordinates(1, -1), 50)\nprivate static  c1:Coordinates \u003d mk_GLOBAL`Coordinates(2, -2)\nprivate static  c2:Coordinates \u003d mk_GLOBAL`Coordinates(3, -3)\nprivate  atc:AirTrafficController :\u003d new AirTrafficController()\npublic  [TestATC][[[r:Radar \u003d new Radar(-8, -9, 42)]c in set {c1, c2}ALetBeStBindingTraceDefinition([[([[atc.updateHistory(){1,1}, atc.cleanUpHistory(){1,1}, atc.addRadar(r){1,1}, atc.findThreats(){1,1}, fo.setCoordinates(c){1,1}]]){2,4}], [atc.getDirectionVectors(id){1,1}]]){1,1}def c in set {c1, c2}]]\nend UseATC\n","class AirTrafficController is subclass of [GLOBAL]\nprivate  radars:set of (Radar) :\u003d {}\nprivate  obstacles:set of (Obstacle) :\u003d {}\nprivate  history:map (FOId) to (seq of (Position)) :\u003d {|-\u003e}\npublic  getDirectionVectors(FOId) (FOId \u003d\u003d\u003e seq of (Vector))\n\tgetDirectionVectors(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), p1:Position \u003d hist(3), p2:Position \u003d hist(2), p3:Position \u003d hist(1) in return ([mk_Vector((((p1.coord).X) - ((p2.coord).X)), (((p1.coord).Y) - ((p2.coord).Y))), mk_Vector((((p2.coord).X) - ((p3.coord).X)), (((p2.coord).Y) - ((p3.coord).Y)))])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  getAltitudeHistory(FOId) (FOId \u003d\u003d\u003e seq of (nat))\n\tgetAltitudeHistory(FOId)(id) \u003d\u003d\nlet hist:seq of (Position) \u003d history(id), lastHist:seq of (Position) \u003d (hist(1, ... ,2)) in return ([(lastHist(i).altitude) | i in set (inds lastHist)])\n\tpre ((id in set (dom history)) and ((len history(id)) \u003d 3))\npublic  updateHistory() (() \u003d\u003d\u003e ())\n\tupdateHistory()() \u003d\u003d\n(\n\ncleanUpHistory();\nfor all r in set radars do\n(\n\nfor all fo in set (r.getDetected)() do\nregisterHistory(fo)\n)\n)\nprivate  registerHistory(FO) (FO \u003d\u003d\u003e ())\n\tregisterHistory(FO)(fo) \u003d\u003d\n(\n\nlet id:FOId \u003d (fo.getId)(), coor:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)() in if (id in set (dom history))\nthen\nhistory :\u003d (history ++ {id |-\u003e addHistory(history(id), coor, alt)})else\nhistory :\u003d (history munion {id |-\u003e addHistory([], coor, alt)})\n)\npublic  cleanUpHistory() (() \u003d\u003d\u003e ())\n\tcleanUpHistory()() \u003d\u003d\n(\n\nlet alldetected:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}), allids:set of (FOId) \u003d {(fo.getId)() | fo in set alldetected} in history :\u003d (allids \u003c: history)\n)\nprivate  private addHistory: (History * Coordinates * Altitude -\u003e History)\n\taddHistory(hist, coord, alt) \u003d\u003d\n(if ((len hist) \u003c 3)\nthen (hist ^ [mk_Position(coord, alt)])\nelse ((tl hist) ^ [mk_Position(coord, alt)]))\npublic  addRadar(Radar) (Radar \u003d\u003d\u003e ())\n\taddRadar(Radar)(r) \u003d\u003d\nradars :\u003d ({r} union radars)\npublic  addObstacle(Obstacle) (Obstacle \u003d\u003d\u003e ())\n\taddObstacle(Obstacle)(ob) \u003d\u003d\nobstacles :\u003d ({ob} union obstacles)\npublic  findThreats() (() \u003d\u003d\u003e ())\n\tfindThreats()() \u003d\u003d\nlet allFOs:set of (FO) \u003d (dunion {(r.getDetected)() | r in set radars}) in (\n\nfor all fo in set allFOs do\nfor all ob in set obstacles do\nif (not isFOSafe(ob, (fo.getPosition)()))\nthen\nwriteObjectWarning(ob, fo)else\nif ((len history((fo.getId)())) \u003d 3)\nthen\nwillFObeSafe(ob, fo);\nfor all r in set radars do\nif (r.saturatedRadar)()\nthen\nwriteRadarWarning(r)\n)\npublic  detectedByTwoRadars(set of (Radar)) (set of (Radar) \u003d\u003d\u003e set of (FO))\n\tdetectedByTwoRadars(set of (Radar))(r) \u003d\u003d\nreturn ((dunion {((a.getDetected)() inter (b.getDetected)()) | a, b in set r \u0026 (a \u003c\u003e b)}))\npublic  detectedByAllRadars(set of (Radar)) (set of (Radar) \u003d\u003d\u003e set of (FO))\n\tdetectedByAllRadars(set of (Radar))(r) \u003d\u003d\nreturn ((dinter {(rad.getDetected)() | rad in set r}))\npublic  Step() (() \u003d\u003d\u003e ())\n\tStep()() \u003d\u003d\n(\n\nfor all r in set radars do\nr.Scan(MSAW`airspace);\nupdateHistory();\nfindThreats()\n)\nprivate  private isFOatSafeAltitude: (MinimumSafetyAltitude * Position -\u003e bool)\n\tisFOatSafeAltitude(msa, pos) \u003d\u003d\n((msa \u003c\u003e \u003cNotAllowed\u003e) and (msa \u003c (pos.altitude)))\nprivate  isFOSafe(Obstacle, Position) (Obstacle * Position \u003d\u003d\u003e bool)\n\tisFOSafe(Obstacle, Position)(obs, pos) \u003d\u003d\nlet obsloc:Coordinates \u003d (obs.getCoordinates)(), secureRange:nat1 \u003d (obs.getSecureRange)(), foloc:Coordinates \u003d (pos.coord) in if isPointInRange(obsloc, secureRange, foloc)\nthen\nisFOatSafeAltitude((obs.getMSA)(), pos)else\nreturn (false)\nprivate  willFObeSafe(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twillFObeSafe(Obstacle, FO)(obs, fo) \u003d\u003d\nlet pred:[set of (Position)] \u003d isPredictPossible(fo) in for all p in set pred do\nif (not isFOSafe(obs, p))\nthen\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:\u003cEstimationWarning\u003e \u003d \u003cEstimationWarning\u003e, msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d (World`timerRef.GetTime)() in (\n\nWorld`env.handleFOWarningEvent(id, cs, alt, type, msa, t);\nreturn\n)\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  writeObjectWarning(Obstacle, FO) (Obstacle * FO \u003d\u003d\u003e ())\n\twriteObjectWarning(Obstacle, FO)(obs, fo) \u003d\u003d\nlet id:FOId \u003d (fo.getId)(), cs:Coordinates \u003d (fo.getCoordinates)(), alt:Altitude \u003d (fo.getAltitude)(), type:ObstacleType \u003d (obs.getType)(), msa:MinimumSafetyAltitude \u003d (obs.getMSA)(), t:nat \u003d (World`timerRef.GetTime)() in World`env.handleFOWarningEvent(id, cs, alt, type, msa, t)\nprivate  writeRadarWarning(Radar) (Radar \u003d\u003d\u003e ())\n\twriteRadarWarning(Radar)(r) \u003d\u003d\nlet coord:Coordinates \u003d (r.getLocation)(), range:nat1 \u003d (r.getRange)(), radWarn:\u003cSaturated\u003e \u003d \u003cSaturated\u003e, num:nat \u003d (card (r.getDetected)()), t:nat \u003d (World`timerRef.GetTime)() in World`env.handleRadarWarningEvent(coord, range, radWarn, num, t)\nprivate  isPredictPossible(FO) (FO \u003d\u003d\u003e [set of (Position)])\n\tisPredictPossible(FO)(fo) \u003d\u003d\nlet hist:seq of (Position) \u003d history((fo.getId)()) in if ((len hist) \u003c 3)\nthen\nreturn (nil)else\nreturn (predictPosition(fo))\n\tpre ((fo.getId)() in set (dom history))\nprivate  predictPosition(FO) (FO \u003d\u003d\u003e set of (Position))\n\tpredictPosition(FO)(fo) \u003d\u003d\nlet foid:FOId \u003d (fo.getId)(), vs:seq of (Vector) \u003d getDirectionVectors(foid), estVec:Vector \u003d vectorRotate(vs(1), signedVectorAngle(vs(2), vs(1))), estAlt:nat \u003d predictAltitude(getAltitudeHistory(foid)), estCoo:Coordinates \u003d addVectorToPoint(estVec, history(foid)(3)), estPos:Position \u003d mk_Position(estCoo, estAlt) in return (calculateNeighborhood(estPos))\n\tpre (((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3))\nprivate  private calculateNeighborhood: (Position -\u003e set of (Position))\n\tcalculateNeighborhood(pos) \u003d\u003d\n{pos, mk_Position(addVectorToPoint(mk_Vector(2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(-2, 0), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, 2), pos), (pos.altitude)), mk_Position(addVectorToPoint(mk_Vector(0, -2), pos), (pos.altitude))}\nprivate  private predictAltitude: (seq of (nat) -\u003e nat)\n\tpredictAltitude(alts) \u003d\u003d\n(alts(1) + (alts(1) - alts(2)))\n\tpre ((len alts) \u003d 2)\nend AirTrafficController\n","class dk_au_eng_Radar\npublic  AddFlyingObject(int, int, int, seq of (char)) (int * int * int * seq of (char) \u003d\u003d\u003e ())\n\tAddFlyingObject(int, int, int, seq of (char))(longtitude, latitude, altitude, transpondercode) \u003d\u003d\nis not yet specified\npublic  RemFlyingObject(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tRemFlyingObject(seq of (char))(transpondercode) \u003d\u003d\nis not yet specified\npublic  StepRadar() (() \u003d\u003d\u003e ())\n\tStepRadar()() \u003d\u003d\nis not yet specified\npublic  UpdateFlyingObject(seq of (char), int, int) (seq of (char) * int * int \u003d\u003d\u003e ())\n\tUpdateFlyingObject(seq of (char), int, int)(transponder, long, lat) \u003d\u003d\nis not yet specified\npublic  SetStepSize(int) (int \u003d\u003d\u003e ())\n\tSetStepSize(int)(size) \u003d\u003d\nis not yet specified\npublic  SetScanWidth(int) (int \u003d\u003d\u003e ())\n\tSetScanWidth(int)(width) \u003d\u003d\nis not yet specified\npublic  SetScanTime(int) (int \u003d\u003d\u003e ())\n\tSetScanTime(int)(time) \u003d\u003d\nis not yet specified\npublic  SetWindowPosition(int, int) (int * int \u003d\u003d\u003e ())\n\tSetWindowPosition(int, int)(x, y) \u003d\u003d\nis not yet specified\npublic  SetTitle(seq of (char)) (seq of (char) \u003d\u003d\u003e ())\n\tSetTitle(seq of (char))(title) \u003d\u003d\nis not yet specified\npublic  SetScanAngle(int) (int \u003d\u003d\u003e ())\n\tSetScanAngle(int)(angle) \u003d\u003d\nis not yet specified\npublic static  TestRadar() (() \u003d\u003d\u003e int)\n\tTestRadar()() \u003d\u003d\n(\n\nlet rad1:dk_au_eng_Radar \u003d new dk_au_eng_Radar(), rad2:dk_au_eng_Radar \u003d new dk_au_eng_Radar() in (\n\nrad2.SetWindowPosition(300, 300);\nrad1.SetScanWidth(60);\nrad1.SetScanTime(80);\nrad1.AddFlyingObject(120, 120, 0, \"LAN256\");\nrad1.AddFlyingObject(0, 80, 0, \"BA512\");\nrad1.SetStepSize(6);\nfor all x in set {-200, ... ,200} do\n(\n\nrad2.StepRadar();\nrad1.UpdateFlyingObject(\"BA512\", x, 80);\nrad1.SetWindowPosition((x + 250), 100);\nrad1.StepRadar()\n);\nreturn (0)\n)\n)\nend dk_au_eng_Radar\n","class Environment is subclass of [GLOBAL]\nprivate static  inline \u003d inline\nprotected static  FOOut \u003d FOOut\nprotected static  RadarOut \u003d RadarOut\nprotected static  outline \u003d outline\nprivate  io:IO :\u003d new IO()\nprivate  inlines:seq of (inline) :\u003d []\nprivate  outlines:seq of (outline) :\u003d []\nprivate  airspace:[AirSpace] :\u003d nil\nprivate  busy:bool :\u003d true\npublic  Environment(String) (String \u003d\u003d\u003e Environment)\n\tEnvironment(String)(fname) \u003d\u003d\nlet mk_(-, input) \u003d ((io.freadval))[seq of (inline)](fname) in inlines :\u003d input\npublic  setAirSpace(AirSpace) (AirSpace \u003d\u003d\u003e ())\n\tsetAirSpace(AirSpace)(as) \u003d\u003d\nairspace :\u003d as\npublic  handleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time) (FOId * Coordinates * Altitude * FOWarning * MinimumSafetyAltitude * Time \u003d\u003d\u003e ())\n\thandleFOWarningEvent(FOId, Coordinates, Altitude, FOWarning, MinimumSafetyAltitude, Time)(id, coord, alt, warn, msa, time) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(id, coord, alt, warn, msa, time)])\npublic  handleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time) (Coordinates * nat1 * RadarWarning * nat * Time \u003d\u003d\u003e ())\n\thandleRadarWarningEvent(Coordinates, nat1, RadarWarning, nat, Time)(coord, range, radWarn, num, pt) \u003d\u003d\noutlines :\u003d (outlines ^ [mk_(coord, range, radWarn, num, pt)])\npublic  showResult() (() \u003d\u003d\u003e ())\n\tshowResult()() \u003d\u003d\nlet - \u003d ((io.writeval))[seq of (outline)](outlines) in skip\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\n(\n\nwhile (not isFinished()) do (\n\nupdateFOs();\nMSAW`atc.Step();\nWorld`timerRef.StepTime()\n);\nshowResult()\n)\nprivate  updateFOs() (() \u003d\u003d\u003e ())\n\tupdateFOs()() \u003d\u003d\n(\n\nif ((len inlines) \u003e 0)\nthen\n(\ncurtime:Time :\u003d (World`timerRef.GetTime)()\ndone:bool :\u003d false\n\nwhile (not done) do let mk_(id, x, y, altitude, pt) \u003d (hd inlines) in if (pt \u003c\u003d curtime)\nthen\n(\n\nairspace.updateFO(id, mk_Coordinates(x, y), altitude);\ninlines :\u003d (tl inlines);\ndone :\u003d ((len inlines) \u003d 0)\n)else\ndone :\u003d true\n)else\nbusy :\u003d false\n)\npublic  isFinished() (() \u003d\u003d\u003e bool)\n\tisFinished()() \u003d\u003d\nreturn ((inlines \u003d []))\nend Environment\n","class Obstacle is subclass of [GLOBAL]\nprivate  MSA:MinimumSafetyAltitude :\u003d (undefined)\nprivate  location:Coordinates :\u003d (undefined)\nprivate  radius:nat1 :\u003d (undefined)\nprivate  securityRadius:nat :\u003d (undefined)\nprivate  type:ObstacleType :\u003d (undefined)\npublic  Obstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType) (MinimumSafetyAltitude * Coordinates * nat * nat * ObstacleType \u003d\u003d\u003e Obstacle)\n\tObstacle(MinimumSafetyAltitude, Coordinates, nat, nat, ObstacleType)(msa, loc, ra, secRa, tp) \u003d\u003d\n(\n\nMSA :\u003d msa;\nlocation :\u003d loc;\nradius :\u003d ra;\nsecurityRadius :\u003d secRa;\ntype :\u003d tp\n)\npublic  getType() (() \u003d\u003d\u003e ObstacleType)\n\tgetType()() \u003d\u003d\nreturn (type)\npublic  getCoordinates() (() \u003d\u003d\u003e Coordinates)\n\tgetCoordinates()() \u003d\u003d\nreturn (location)\npublic  getSecureRange() (() \u003d\u003d\u003e nat1)\n\tgetSecureRange()() \u003d\u003d\nreturn ((radius + securityRadius))\npublic  getMSA() (() \u003d\u003d\u003e MinimumSafetyAltitude)\n\tgetMSA()() \u003d\u003d\nreturn (MSA)\nend Obstacle\n","class Timer\nprivate  currentTime:nat :\u003d 0\nprivate static  stepLength:nat \u003d 100\npublic  StepTime() (() \u003d\u003d\u003e ())\n\tStepTime()() \u003d\u003d\ncurrentTime :\u003d (currentTime + stepLength)\npublic  GetTime() (() \u003d\u003d\u003e nat)\n\tGetTime()() \u003d\u003d\nreturn (currentTime)\nend Timer\n","class World\npublic static  env:[Environment] :\u003d nil\npublic static  timerRef:Timer :\u003d new Timer()\npublic  World() (() \u003d\u003d\u003e World)\n\tWorld()() \u003d\u003d\n(\n\nenv :\u003d new Environment(\"scenario.txt\");\nenv.setAirSpace(MSAW`airspace);\nMSAW`atc.addRadar(MSAW`radar1);\nMSAW`atc.addRadar(MSAW`radar2);\nMSAW`atc.addObstacle(MSAW`militaryZone)\n)\npublic  Run() (() \u003d\u003d\u003e ())\n\tRun()() \u003d\u003d\nenv.Run()\nend World\n","class IO\npublic static  filedirective \u003d filedirective\npublic static  public static writeval[(p)]: (@p -\u003e bool)\n\twriteval(val) \u003d\u003d\nis not yet specified\npublic static  public static fwriteval[(p)]: (seq1 of (char) * @p * filedirective -\u003e bool)\n\tfwriteval(filename, val, fdir) \u003d\u003d\nis not yet specified\npublic static  public static freadval[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tfreadval(filename) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic  echo(seq of (char)) (seq of (char) \u003d\u003d\u003e bool)\n\techo(seq of (char))(text) \u003d\u003d\nfecho(\"\", text, nil)\npublic  fecho(seq of (char), seq of (char), [filedirective]) (seq of (char) * seq of (char) * [filedirective] \u003d\u003d\u003e bool)\n\tfecho(seq of (char), seq of (char), [filedirective])(filename, text, fdir) \u003d\u003d\nis not yet specified\n\tpre ((filename \u003d \"\") \u003c\u003d\u003e (fdir \u003d nil))\npublic  ferror() (() \u003d\u003d\u003e seq of (char))\n\tferror()() \u003d\u003d\nis not yet specified\npublic static  print(?) (? \u003d\u003d\u003e ())\n\tprint(?)(arg) \u003d\u003d\nis not yet specified\npublic static  println(?) (? \u003d\u003d\u003e ())\n\tprintln(?)(arg) \u003d\u003d\nis not yet specified\npublic static  printf(seq of (char), seq of (?)) (seq of (char) * seq of (?) \u003d\u003d\u003e ())\n\tprintf(seq of (char), seq of (?))(format, args) \u003d\u003d\nis not yet specified\nend IO\n","class MATH\npublic static  public static sin: (real +\u003e real)\n\tsin(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static cos: (real +\u003e real)\n\tcos(v) \u003d\u003d\nis not yet specified\n\tpost ((abs RESULT) \u003c\u003d 1)\npublic static  public static tan: (real -\u003e real)\n\ttan(a) \u003d\u003d\nis not yet specified\n\tpre (cos(a) \u003c\u003e 0)\npublic static  public static cot: (real -\u003e real)\n\tcot(a) \u003d\u003d\nis not yet specified\n\tpre (sin(a) \u003c\u003e 0)\npublic static  public static asin: (real -\u003e real)\n\tasin(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static acos: (real -\u003e real)\n\tacos(a) \u003d\u003d\nis not yet specified\n\tpre ((abs a) \u003c\u003d 1)\npublic static  public static atan: (real +\u003e real)\n\tatan(v) \u003d\u003d\nis not yet specified\npublic static  public static acot: (real +\u003e real)\n\tacot(a) \u003d\u003d\natan((1 / a))\n\tpre (a \u003c\u003e 0)\npublic static  public static sqrt: (real -\u003e real)\n\tsqrt(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d 0)\npublic static  public static pi_f: (() +\u003e real)\n\tpi_f() \u003d\u003d\nis not yet specified\npublic static  srand(int) (int \u003d\u003d\u003e ())\n\tsrand(int)(a) \u003d\u003d\nlet -:int \u003d MATH`srand2(a) in skip\n\tpre (a \u003e\u003d -1)\npublic static  rand(int) (int \u003d\u003d\u003e int)\n\trand(int)(a) \u003d\u003d\nis not yet specified\npublic static  srand2(int) (int \u003d\u003d\u003e int)\n\tsrand2(int)(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e\u003d -1)\npublic static  public static exp: (real +\u003e real)\n\texp(a) \u003d\u003d\nis not yet specified\npublic static  public static ln: (real -\u003e real)\n\tln(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static log: (real -\u003e real)\n\tlog(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003e 0)\npublic static  public static fac: (nat -\u003e nat1)\n\tfac(a) \u003d\u003d\nis not yet specified\n\tpre (a \u003c 21)\npublic static  pi:real \u003d 3.141592653589793\nend MATH\n","class VDMUtil\npublic static  public static set2seq[(T)]: (set of (@T) +\u003e seq of (@T))\n\tset2seq(x) \u003d\u003d\nis not yet specified\npublic static  public static get_file_pos: (() +\u003e [(seq of (char) * nat * nat * seq of (char) * seq of (char))])\n\tget_file_pos() \u003d\u003d\nis not yet specified\npublic static  public static val2seq_of_char[(T)]: (@T +\u003e seq of (char))\n\tval2seq_of_char(x) \u003d\u003d\nis not yet specified\npublic static  public static seq_of_char2val[(p)]: (seq1 of (char) -\u003e (bool * [@p]))\n\tseq_of_char2val(s) \u003d\u003d\nis not yet specified\n\tpost let mk_(b, t):(bool * [@p]) \u003d RESULT in ((not b) \u003d\u003e (t \u003d nil))\npublic static  public static classname[(T)]: (@T -\u003e [seq1 of (char)])\n\tclassname(s) \u003d\u003d\nis not yet specified\nend VDMUtil\n"]