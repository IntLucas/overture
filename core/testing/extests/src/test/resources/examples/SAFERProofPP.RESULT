["class AAH\npublic static  EngageState \u003d EngageState\nprivate static  click_timeout:nat \u003d 10\nprivate  hcu:HandControlUnit :\u003d (undefined)\nprivate  clock:Clock :\u003d (undefined)\nprivate  rotcmd:RotationCommand :\u003d new RotationCommand()\nprivate  toggle:EngageState :\u003d \u003cAAH_off\u003e\nprivate  gripcmd:SixDOfCommand :\u003d (undefined)\nprivate  timeout:nat :\u003d 0\nprivate  ignore_hcm_rot:set of (Axis) :\u003d {}\nprivate  active_rot_axes:set of (Axis) :\u003d {}\npublic  Update() (() \u003d\u003d\u003e ())\n\tUpdate()() \u003d\u003d\nlet engage:EngageState \u003d ButtonTransition((hcu.ReadAAH)(), (clock.ReadTime)()), starting:bool \u003d ((toggle \u003d \u003cAAH_off\u003e) and (engage \u003d \u003cAAH_started\u003e)), mk_(-, rot):(AxisMap * AxisMap) \u003d (gripcmd.GetCommand)() in (\n\nactive_rot_axes :\u003d {a | a in set Command`allaxes \u0026 (starting or ((engage \u003c\u003e \u003cAAH_off\u003e) and ((a in set active_rot_axes) and ((rot(a) \u003d \u003cZero\u003e) or (a in set ignore_hcm_rot)))))};\nignore_hcm_rot :\u003d {a | a in set Command`allaxes \u0026 ((starting and (rot(a) \u003c\u003e \u003cZero\u003e)) or ((not starting) and (a in set ignore_hcm_rot)))};\ntimeout :\u003d (if ((toggle \u003d \u003cAAH_on\u003e) and (engage \u003d \u003cpressed_once\u003e))\nthen ((clock.ReadTime)() + click_timeout)\nelse timeout);\ntoggle :\u003d engage\n)\npublic  GetRotcmd() (() \u003d\u003d\u003e AxisMap)\n\tGetRotcmd()() \u003d\u003d\nreturn ((rotcmd.GetAxesdir)())\npublic  SetRotcmd(AxisMap) (AxisMap \u003d\u003d\u003e ())\n\tSetRotcmd(AxisMap)(m) \u003d\u003d\nrotcmd.SetAxesdir(m)\npublic  AllAxesOff() (() \u003d\u003d\u003e bool)\n\tAllAxesOff()() \u003d\u003d\nreturn ((active_rot_axes \u003d {}))\npublic  SetHCULink(HandControlUnit) (HandControlUnit \u003d\u003d\u003e ())\n\tSetHCULink(HandControlUnit)(h) \u003d\u003d\nhcu :\u003d h\npublic  SetClockLink(Clock) (Clock \u003d\u003d\u003e ())\n\tSetClockLink(Clock)(c) \u003d\u003d\nclock :\u003d c\npublic  GetIgnore_hcm() (() \u003d\u003d\u003e set of (Axis))\n\tGetIgnore_hcm()() \u003d\u003d\nreturn (ignore_hcm_rot)\npublic  SetSixDOfLink(SixDOfCommand) (SixDOfCommand \u003d\u003d\u003e ())\n\tSetSixDOfLink(SixDOfCommand)(s) \u003d\u003d\ngripcmd :\u003d s\npublic  GetActive_axes() (() \u003d\u003d\u003e set of (Axis))\n\tGetActive_axes()() \u003d\u003d\nreturn (active_rot_axes)\nprivate  ButtonTransition(Button, nat) (Button * nat \u003d\u003d\u003e EngageState)\n\tButtonTransition(Button, nat)(button_pos, count) \u003d\u003d\nreturn ((cases mk_(toggle, button_pos) :\nmk_(\u003cAAH_off\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cAAH_off\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_started\u003e, \u003cUp\u003e) -\u003e \u003cAAH_on\u003e,\nmk_(\u003cAAH_started\u003e, \u003cDown\u003e) -\u003e \u003cAAH_started\u003e,\nmk_(\u003cAAH_on\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff()\nthen \u003cAAH_off\u003e\nelse \u003cAAH_on\u003e),\nmk_(\u003cAAH_on\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cpressed_once\u003e, \u003cUp\u003e) -\u003e \u003cAAH_closing\u003e,\nmk_(\u003cpressed_once\u003e, \u003cDown\u003e) -\u003e \u003cpressed_once\u003e,\nmk_(\u003cAAH_closing\u003e, \u003cUp\u003e) -\u003e (if AllAxesOff()\nthen \u003cAAH_off\u003e\nelseif (count \u003e timeout)\nthen \u003cAAH_on\u003e\nelse \u003cAAH_closing\u003e),\nmk_(\u003cAAH_closing\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cUp\u003e) -\u003e \u003cAAH_off\u003e,\nmk_(\u003cpressed_twice\u003e, \u003cDown\u003e) -\u003e \u003cpressed_twice\u003e\n end))\nend AAH\n","class Clock\nprivate  count:nat :\u003d 0\npublic  SetTime(nat) (nat \u003d\u003d\u003e ())\n\tSetTime(nat)(t) \u003d\u003d\ncount :\u003d t\npublic  IncrTime() (() \u003d\u003d\u003e ())\n\tIncrTime()() \u003d\u003d\ncount :\u003d (count + 1)\npublic  ReadTime() (() \u003d\u003d\u003e nat)\n\tReadTime()() \u003d\u003d\nreturn (count)\nend Clock\n","class Command\npublic static  Axis \u003d Axis\npublic static  Direction \u003d Direction\npublic static  AxisMap \u003d AxisMap\n\tinv dir \u003d\u003d ((dom dir) \u003d {\u003caxis1\u003e, \u003caxis2\u003e, \u003caxis3\u003e})\npublic static  allaxes:set of (Axis) \u003d {\u003caxis1\u003e, \u003caxis2\u003e, \u003caxis3\u003e}\npublic static  X:\u003caxis1\u003e \u003d \u003caxis1\u003e\npublic static  Y:\u003caxis2\u003e \u003d \u003caxis2\u003e\npublic static  Z:\u003caxis3\u003e \u003d \u003caxis3\u003e\npublic static  PITCH:\u003caxis1\u003e \u003d \u003caxis1\u003e\npublic static  YAW:\u003caxis2\u003e \u003d \u003caxis2\u003e\npublic static  ROLL:\u003caxis3\u003e \u003d \u003caxis3\u003e\npublic static  nullaxesdir:AxisMap \u003d {a |-\u003e \u003cZero\u003e | a in set allaxes}\nprotected  axesdir:AxisMap :\u003d nullaxesdir\npublic  GetAxesdir() (() \u003d\u003d\u003e AxisMap)\n\tGetAxesdir()() \u003d\u003d\nreturn (axesdir)\npublic  SetAxesdir(AxisMap) (AxisMap \u003d\u003d\u003e ())\n\tSetAxesdir(AxisMap)(a) \u003d\u003d\naxesdir :\u003d a\npublic  GetDirection(Axis) (Axis \u003d\u003d\u003e Direction)\n\tGetDirection(Axis)(a) \u003d\u003d\nreturn (axesdir(a))\npublic  SetDirection(Axis, Direction) (Axis * Direction \u003d\u003d\u003e ())\n\tSetDirection(Axis, Direction)(a, d) \u003d\u003d\naxesdir :\u003d (axesdir ++ {a |-\u003e d})\npublic  SuppressAllAxes() (() \u003d\u003d\u003e ())\n\tSuppressAllAxes()() \u003d\u003d\naxesdir :\u003d nullaxesdir\nend Command\n","class HandControlUnit\npublic static  Button \u003d Button\npublic static  Mode \u003d Mode\nprivate  x:Direction :\u003d (undefined)\nprivate  pitch:Direction :\u003d (undefined)\nprivate  yaw_y:Direction :\u003d (undefined)\nprivate  roll_z:Direction :\u003d (undefined)\nprivate  aahbutton:Button :\u003d (undefined)\nprivate  modeswitch:Mode :\u003d (undefined)\npublic  SetAAH(Button) (Button \u003d\u003d\u003e ())\n\tSetAAH(Button)(aahbuttonarg) \u003d\u003d\naahbutton :\u003d aahbuttonarg\npublic  ReadAAH() (() \u003d\u003d\u003e Button)\n\tReadAAH()() \u003d\u003d\nreturn (aahbutton)\npublic  SetGrip(Direction, Direction, Direction, Direction) (Direction * Direction * Direction * Direction \u003d\u003d\u003e ())\n\tSetGrip(Direction, Direction, Direction, Direction)(xarg, pitcharg, yaw_yarg, roll_zarg) \u003d\u003d\n(\n\nx :\u003d xarg;\npitch :\u003d pitcharg;\nyaw_y :\u003d yaw_yarg;\nroll_z :\u003d roll_zarg\n)\npublic  SetMode(Mode) (Mode \u003d\u003d\u003e ())\n\tSetMode(Mode)(m) \u003d\u003d\nmodeswitch :\u003d m\npublic  ReadGrip() (() \u003d\u003d\u003e (Direction * Direction * Direction * Direction * Mode))\n\tReadGrip()() \u003d\u003d\nreturn (mk_(x, pitch, yaw_y, roll_z, modeswitch))\nend HandControlUnit\n","class IntegratedCommand is subclass of [SixDOfCommand]\nprivate  aah:AAH :\u003d (undefined)\npublic  SetAAHLink(AAH) (AAH \u003d\u003d\u003e ())\n\tSetAAHLink(AAH)(a) \u003d\u003d\naah :\u003d a\npublic  IntegrateCmds() (() \u003d\u003d\u003e ())\n\tIntegrateCmds()() \u003d\u003d\nif (aah.AllAxesOff)()\nthen\n(\n\nif (rotcmd.RotCmdsPresent)()\nthen\ntrancmd.SuppressAllAxes()else\ntrancmd.Prioritize()\n)else\n(\n\nif (rotcmd.RotCmdsPresent)()\nthen\n(\n\ntrancmd.SuppressAllAxes();\nCombineRotCmds()\n)else\n(\n\ntrancmd.Prioritize();\nrotcmd.SetAxesdir((aah.GetRotcmd)())\n)\n)\nprivate  CombineRotCmds() (() \u003d\u003d\u003e ())\n\tCombineRotCmds()() \u003d\u003d\nlet aah_axes:set of (Axis) \u003d ((aah.GetIgnore_hcm)() union {a | a in set Command`allaxes \u0026 ((rotcmd.GetAxesdir)()(a) \u003d \u003cZero\u003e)}) in rotcmd.SetAxesdir(({a |-\u003e (aah.GetRotcmd)()(a) | a in set aah_axes} munion {a |-\u003e (rotcmd.GetAxesdir)()(a) | a in set (Command`allaxes \\ aah_axes)}))\nend IntegratedCommand\n","class Interface\nprivate  ws:WorkSpace :\u003d new WorkSpace()\npublic static  Input \u003d Input\n\tinv inp \u003d\u003d ((len inp) \u003d 9)\npublic static  ThrusterMatrix \u003d ThrusterMatrix\n\tinv tm \u003d\u003d (((len tm) \u003d 4) and (forall i in set (inds tm) \u0026 ((len tm(i)) \u003d 6)))\npublic  SetupTopology() (() \u003d\u003d\u003e ())\n\tSetupTopology()() \u003d\u003d\nws.SetupTopology()\npublic  RunControlCycle(Input) (Input \u003d\u003d\u003e ThrusterMatrix)\n\tRunControlCycle(Input)(inp) \u003d\u003d\nlet mk_(x, p, y, z, m, ab, ah):(Direction * Direction * Direction * Direction * Mode * Button * AxisMap) \u003d TransformInput(inp) in let ts:set of (ThrusterPosition) \u003d (ws.ControlCycle)(x, p, y, z, m, ab, ah) in return (GenerateThrusterMatrix(ts))\nprivate  private TransformInput: (Input -\u003e (Direction * Direction * Direction * Direction * Mode * Button * AxisMap))\n\tTransformInput(inp) \u003d\u003d\nlet [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d inp in mk_(ConvertAxisCmd(horiz), ConvertAxisCmd(twist), ConvertAxisCmd(trans), ConvertAxisCmd(vert), (if (mode \u003d 1)\nthen \u003cTran\u003e\nelse \u003cRot\u003e), (if (aah \u003d 0)\nthen \u003cUp\u003e\nelse \u003cDown\u003e), {\u003caxis3\u003e |-\u003e ConvertAxisCmd(roll), \u003caxis1\u003e |-\u003e ConvertAxisCmd(pitch), \u003caxis2\u003e |-\u003e ConvertAxisCmd(yaw)})\nprivate  private ConvertAxisCmd: (nat -\u003e Direction)\n\tConvertAxisCmd(n) \u003d\u003d\n(cases n :\n0 -\u003e \u003cNeg\u003e,\n1 -\u003e \u003cPos\u003e,\n2 -\u003e \u003cZero\u003e\nothers (undefined)\n end)\nprivate  private GenerateThrusterMatrix: (set of (ThrusterPosition) +\u003e ThrusterMatrix)\n\tGenerateThrusterMatrix(ts) \u003d\u003d\nlet tson:set of ((nat * nat)) \u003d {GenerateThrusterLabel(t) | t in set ts} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]\nprivate  private GenerateThrusterLabel: (ThrusterPosition +\u003e (nat * nat))\n\tGenerateThrusterLabel(tnm) \u003d\u003d\n(cases tnm :\n\u003cB1\u003e -\u003e mk_(1, 4),\n\u003cB2\u003e -\u003e mk_(2, 4),\n\u003cB3\u003e -\u003e mk_(4, 4),\n\u003cB4\u003e -\u003e mk_(3, 4),\n\u003cF1\u003e -\u003e mk_(1, 1),\n\u003cF2\u003e -\u003e mk_(2, 1),\n\u003cF3\u003e -\u003e mk_(4, 1),\n\u003cF4\u003e -\u003e mk_(3, 1),\n\u003cL1R\u003e -\u003e mk_(1, 2),\n\u003cL1F\u003e -\u003e mk_(1, 3),\n\u003cR2R\u003e -\u003e mk_(2, 2),\n\u003cR2F\u003e -\u003e mk_(2, 3),\n\u003cL3R\u003e -\u003e mk_(4, 2),\n\u003cL3F\u003e -\u003e mk_(4, 3),\n\u003cR4R\u003e -\u003e mk_(3, 2),\n\u003cR4F\u003e -\u003e mk_(3, 3),\n\u003cD1R\u003e -\u003e mk_(1, 6),\n\u003cD1F\u003e -\u003e mk_(1, 5),\n\u003cD2R\u003e -\u003e mk_(2, 6),\n\u003cD2F\u003e -\u003e mk_(2, 5),\n\u003cU3R\u003e -\u003e mk_(4, 6),\n\u003cU3F\u003e -\u003e mk_(4, 5),\n\u003cU4R\u003e -\u003e mk_(3, 6),\n\u003cU4F\u003e -\u003e mk_(3, 5)\n end)\nprivate static  thrusters:(\u003cPos\u003e * \u003cZero\u003e * \u003cZero\u003e * \u003cZero\u003e * \u003cTran\u003e * \u003cDown\u003e * map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to (\u003cZero\u003e)) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e, \u003cTran\u003e, \u003cDown\u003e, {\u003cRoll\u003e |-\u003e \u003cZero\u003e, \u003cPitch\u003e |-\u003e \u003cZero\u003e, \u003cYaw\u003e |-\u003e \u003cZero\u003e})\nend Interface\n","class RotationCommand is subclass of [Command]\npublic  RotCmdsPresent() (() \u003d\u003d\u003e bool)\n\tRotCmdsPresent()() \u003d\u003d\nreturn ((exists a in set (dom axesdir) \u0026 (axesdir(a) \u003c\u003e \u003cZero\u003e)))\nend RotationCommand\n","class SixDOfCommand\nprotected  hcu:HandControlUnit :\u003d (undefined)\nprotected  rotcmd:RotationCommand :\u003d new RotationCommand()\nprotected  trancmd:TranslationCommand :\u003d new TranslationCommand()\npublic  GetCommand() (() \u003d\u003d\u003e (AxisMap * AxisMap))\n\tGetCommand()() \u003d\u003d\nreturn (mk_((trancmd.GetAxesdir)(), (rotcmd.GetAxesdir)()))\npublic  SetHCULink(HandControlUnit) (HandControlUnit \u003d\u003d\u003e ())\n\tSetHCULink(HandControlUnit)(h) \u003d\u003d\nhcu :\u003d h\npublic  ConvertGrip() (() \u003d\u003d\u003e ())\n\tConvertGrip()() \u003d\u003d\nlet mk_(x, pitch, yaw_y, roll_z, modeswitch):(Direction * Direction * Direction * Direction * Mode) \u003d (hcu.ReadGrip)(), tran:map ((\u003caxis1\u003e | \u003caxis2\u003e | \u003caxis3\u003e)) to ((\u003cZero\u003e | Direction)) \u003d {Command`X |-\u003e x, Command`Y |-\u003e (if (modeswitch \u003d \u003cTran\u003e)\nthen yaw_y\nelse \u003cZero\u003e), Command`Z |-\u003e (if (modeswitch \u003d \u003cTran\u003e)\nthen roll_z\nelse \u003cZero\u003e)}, rot:map ((\u003caxis1\u003e | \u003caxis2\u003e | \u003caxis3\u003e)) to ((\u003cZero\u003e | Direction)) \u003d {Command`ROLL |-\u003e (if (modeswitch \u003d \u003cRot\u003e)\nthen roll_z\nelse \u003cZero\u003e), Command`PITCH |-\u003e pitch, Command`YAW |-\u003e (if (modeswitch \u003d \u003cRot\u003e)\nthen yaw_y\nelse \u003cZero\u003e)} in (\n\ntrancmd.SetAxesdir(tran);\nrotcmd.SetAxesdir(rot)\n)\nend SixDOfCommand\n","class Test is subclass of [WorkSpace]\nprivate static  DirectionSet:set of (Direction) \u003d {\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e}\nprivate static  ModeSet:set of (Mode) \u003d {\u003cTran\u003e, \u003cRot\u003e}\nprivate static  AAHButtonSet:set of (Button) \u003d {\u003cUp\u003e, \u003cDown\u003e}\nprivate static  RotCmdSet:set of (AxisMap) \u003d {{\u003caxis1\u003e |-\u003e a, \u003caxis2\u003e |-\u003e b, \u003caxis3\u003e |-\u003e c} | a, b, c in set {\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e}}\nprivate  w:WorkSpace :\u003d new WorkSpace()\npublic  BigTest() (() \u003d\u003d\u003e nat)\n\tBigTest()() \u003d\u003d\n(\n\nSetupTopology();\nreturn ((card (dom {mk_(x, pitch, yaw_y, roll_z, modeswitch, \u003cUp\u003e) |-\u003e ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, \u003cUp\u003e, Command`nullaxesdir) | x, pitch, yaw_y, roll_z in set DirectionSet, modeswitch in set ModeSet})))\n)\npublic  HugeTest() (() \u003d\u003d\u003e nat)\n\tHugeTest()() \u003d\u003d\n(\n\nSetupTopology();\nreturn ((card (dom {mk_(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd) |-\u003e ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd) | x, pitch, yaw_y, roll_z in set DirectionSet, modeswitch in set ModeSet, aahbutton in set AAHButtonSet, aahcmd in set RotCmdSet})))\n)\npublic  [BT][[w.SetupTopology(){1,1}], [x, pitch, yaw_y, roll_z in set DirectionSetALetBeStBindingTraceDefinitionmodeswitch in set ModeSetALetBeStBindingTraceDefinitionw.ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, \u003cUp\u003e, Command`nullaxesdir){1,1}def modeswitch in set ModeSetdef x, pitch, yaw_y, roll_z in set DirectionSet]]\npublic  [HT][[w.SetupTopology(){1,1}], [x, pitch, yaw_y, roll_z in set DirectionSetALetBeStBindingTraceDefinitionmodeswitch in set ModeSetALetBeStBindingTraceDefinitionaahbutton in set AAHButtonSetALetBeStBindingTraceDefinitionaahcmd in set RotCmdSetALetBeStBindingTraceDefinitionw.ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd){1,1}def aahcmd in set RotCmdSetdef aahbutton in set AAHButtonSetdef modeswitch in set ModeSetdef x, pitch, yaw_y, roll_z in set DirectionSet]]\nend Test\n","class Thruster\npublic static  On_Off \u003d On_Off\nprivate  state:On_Off :\u003d \u003cOff\u003e\npublic  SetOn() (() \u003d\u003d\u003e ())\n\tSetOn()() \u003d\u003d\nstate :\u003d \u003cOn\u003e\npublic  SetOff() (() \u003d\u003d\u003e ())\n\tSetOff()() \u003d\u003d\nstate :\u003d \u003cOff\u003e\npublic  GetState() (() \u003d\u003d\u003e On_Off)\n\tGetState()() \u003d\u003d\nreturn (state)\nend Thruster\n","class ThrusterControl\nprivate static  bf_thrusters:ThrSelMap \u003d {|-\u003e}\nprivate static  bf_thrusters1:ThrSelMap \u003d {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}), mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cB4\u003e}, {}), mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e}, {\u003cB1\u003e, \u003cB4\u003e}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cB4\u003e}, {}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB3\u003e}, {}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e}, {\u003cB1\u003e, \u003cB4\u003e}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB2\u003e}, {}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e}, {\u003cB2\u003e, \u003cB3\u003e}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e, \u003cF1\u003e}, {}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e, \u003cF2\u003e}, {}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cF2\u003e}, {}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cF1\u003e}, {}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cF4\u003e}, {}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cF3\u003e}, {}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cF3\u003e}, {}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cF4\u003e}, {}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e}, {\u003cF2\u003e, \u003cF3\u003e}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e, \u003cF2\u003e}, {}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e}, {\u003cF1\u003e, \u003cF4\u003e}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e, \u003cF3\u003e}, {}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e, \u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e, \u003cF4\u003e}, {}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF3\u003e, \u003cF4\u003e}, {}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF4\u003e}, {\u003cF2\u003e, \u003cF3\u003e})}\nprivate static  lrud_thrusters:ThrSelMap \u003d {|-\u003e}\nprivate static  lrud_thrusters1:ThrSelMap \u003d {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e, \u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}), mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cU3R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cU3R\u003e, \u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}), mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e, \u003cR4R\u003e}, {}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e, \u003cL3R\u003e}, {}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cD1R\u003e, \u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}), mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cD1R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e, \u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}), mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {}), mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {})}\npublic static  ThrusterSet:set of (ThrusterPosition) \u003d {\u003cB1\u003e, \u003cB2\u003e, \u003cB3\u003e, \u003cB4\u003e, \u003cF1\u003e, \u003cF2\u003e, \u003cF3\u003e, \u003cF4\u003e, \u003cL1R\u003e, \u003cL1F\u003e, \u003cR2R\u003e, \u003cR2F\u003e, \u003cL3R\u003e, \u003cL3F\u003e, \u003cR4R\u003e, \u003cR4F\u003e, \u003cD1R\u003e, \u003cD1F\u003e, \u003cD2R\u003e, \u003cD2F\u003e, \u003cU3R\u003e, \u003cU3F\u003e, \u003cU4R\u003e, \u003cU4F\u003e}\npublic static  ThrusterPosition \u003d ThrusterPosition\npublic static  ThrSel \u003d ThrSel\nprivate  vda:ValveDriveAssembly :\u003d (undefined)\nprivate  intcmd:IntegratedCommand :\u003d (undefined)\nprivate  selected:set of (ThrusterPosition) :\u003d {}\nprivate  tslogic1:ThrusterSelectionTable :\u003d InitTable(bf_thrusters1)\nprivate  tslogic2:ThrusterSelectionTable :\u003d InitTable(lrud_thrusters1)\npublic  InitTable(ThrSelMap) (ThrSelMap \u003d\u003d\u003e ThrusterSelectionTable)\n\tInitTable(ThrSelMap)(table) \u003d\u003d\n(\ntmp:ThrusterSelectionTable :\u003d new ThrusterSelectionTable()\n\ntmp.MakeTable(table);\nreturn (tmp)\n)\nprivate  PrintSelected() (() \u003d\u003d\u003e set of (ThrusterPosition))\n\tPrintSelected()() \u003d\u003d\nreturn (selected)\npublic  SetIntCmdLink(IntegratedCommand) (IntegratedCommand \u003d\u003d\u003e ())\n\tSetIntCmdLink(IntegratedCommand)(i) \u003d\u003d\nintcmd :\u003d i\npublic  SetVDALink(ValveDriveAssembly) (ValveDriveAssembly \u003d\u003d\u003e ())\n\tSetVDALink(ValveDriveAssembly)(v) \u003d\u003d\nvda :\u003d v\npublic  SelectThrusters() (() \u003d\u003d\u003e ())\n\tSelectThrusters()() \u003d\u003d\nlet mk_(tran, rot):(AxisMap * AxisMap) \u003d (intcmd.GetCommand)(), lookup1:ThrSel \u003d (tslogic1.Lookup)(tran(Command`X), rot(Command`PITCH), rot(Command`YAW)), lookup2:ThrSel \u003d (tslogic2.Lookup)(tran(Command`Y), tran(Command`Z), rot(Command`ROLL)), bf_thr:set of (ThrusterPosition) \u003d (if (rot(Command`ROLL) \u003d \u003cZero\u003e)\nthen ((lookup1.always_on) union (lookup1.optional))\nelse (lookup1.always_on)), lrud_thr:set of (ThrusterPosition) \u003d (if ((rot(Command`PITCH) \u003d \u003cZero\u003e) and (rot(Command`YAW) \u003d \u003cZero\u003e))\nthen ((lookup2.optional) union (lookup2.always_on))\nelse (lookup2.always_on)) in selected :\u003d (bf_thr union lrud_thr)\npublic  SignalThrusters() (() \u003d\u003d\u003e ())\n\tSignalThrusters()() \u003d\u003d\nvda.UpdateThrusters(selected)\nprivate  InitializeTables() (() \u003d\u003d\u003e ())\n\tInitializeTables()() \u003d\u003d\n(\n\ntslogic1.MakeTable(bf_thrusters);\ntslogic2.MakeTable(lrud_thrusters)\n)\nend ThrusterControl\n","class ThrusterSelectionTable\npublic static  ThrSelMap \u003d ThrSelMap\nprivate  selections:ThrSelMap :\u003d {|-\u003e}\npublic  Lookup(Direction, Direction, Direction) (Direction * Direction * Direction \u003d\u003d\u003e ThrSel)\n\tLookup(Direction, Direction, Direction)(dir1, dir2, dir3) \u003d\u003d\nreturn (selections(mk_(dir1, dir2, dir3)))\npublic  MakeTable(ThrSelMap) (ThrSelMap \u003d\u003d\u003e ())\n\tMakeTable(ThrSelMap)(m) \u003d\u003d\nselections :\u003d m\nend ThrusterSelectionTable\n","class TranslationCommand is subclass of [Command]\npublic  Prioritize() (() \u003d\u003d\u003e ())\n\tPrioritize()() \u003d\u003d\naxesdir :\u003d (if (axesdir(X) \u003c\u003e \u003cZero\u003e)\nthen (axesdir ++ {Y |-\u003e \u003cZero\u003e, Z |-\u003e \u003cZero\u003e})\nelseif (axesdir(Y) \u003c\u003e \u003cZero\u003e)\nthen (axesdir ++ {Z |-\u003e \u003cZero\u003e})\nelse axesdir)\nend TranslationCommand\n","class ValveDriveAssembly\nprivate  thrusters:map (ThrusterPosition) to (Thruster) :\u003d {thr |-\u003e new Thruster() | thr in set ThrusterControl`ThrusterSet}\npublic  UpdateThrusters(set of (ThrusterPosition)) (set of (ThrusterPosition) \u003d\u003d\u003e ())\n\tUpdateThrusters(set of (ThrusterPosition))(selected) \u003d\u003d\n(\n\nfor all a in set selected do\nthrusters(a).SetOn();\nfor all a in set (ThrusterControl`ThrusterSet \\ selected) do\nthrusters(a).SetOff()\n)\npublic  ThrustersOn() (() \u003d\u003d\u003e set of (ThrusterPosition))\n\tThrustersOn()() \u003d\u003d\nreturn ({thr | thr in set ThrusterControl`ThrusterSet \u0026 ((thrusters(thr).GetState)() \u003d \u003cOn\u003e)})\nend ValveDriveAssembly\n","class WorkSpace\nprivate static  check:bool \u003d true\nprivate  hcu:HandControlUnit :\u003d new HandControlUnit()\nprivate  aah:AAH :\u003d new AAH()\nprivate  intcmd:IntegratedCommand :\u003d new IntegratedCommand()\nprivate  thrcontrol:ThrusterControl :\u003d new ThrusterControl()\nprivate  vda:ValveDriveAssembly :\u003d new ValveDriveAssembly()\nprivate  clock:Clock :\u003d new Clock()\npublic  SetupTopology()()\npublic  ControlCycle(Direction, Direction, Direction, Direction, Mode, Button, AxisMap) (Direction * Direction * Direction * Direction * Mode * Button * AxisMap \u003d\u003d\u003e set of (ThrusterPosition))\n\tControlCycle(Direction, Direction, Direction, Direction, Mode, Button, AxisMap)(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd) \u003d\u003d\n(\n\nclock.IncrTime();\nhcu.SetAAH(aahbutton);\nhcu.SetGrip(x, pitch, yaw_y, roll_z);\nhcu.SetMode(modeswitch);\naah.SetRotcmd(aahcmd);\nintcmd.ConvertGrip();\naah.Update();\nintcmd.IntegrateCmds();\nthrcontrol.SelectThrusters();\nthrcontrol.SignalThrusters();\nvda.ThrustersOn()\n)\n\tpost (((card RESULT) \u003c\u003d 4) and ThrusterConsistency(RESULT))\nprivate  ThrusterConsistency(set of (ThrusterPosition)) (set of (ThrusterPosition) \u003d\u003d\u003e bool)\n\tThrusterConsistency(set of (ThrusterPosition))(thrusters) \u003d\u003d\nreturn (((not ({\u003cB1\u003e, \u003cF1\u003e} subset thrusters)) and ((not ({\u003cB2\u003e, \u003cF2\u003e} subset thrusters)) and ((not ({\u003cB3\u003e, \u003cF3\u003e} subset thrusters)) and ((not ({\u003cB4\u003e, \u003cF4\u003e} subset thrusters)) and ((not (((thrusters inter {\u003cL1R\u003e, \u003cL1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR2R\u003e, \u003cR2F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cL3R\u003e, \u003cL3F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cR4R\u003e, \u003cR4F\u003e}) \u003c\u003e {}))) and ((not (((thrusters inter {\u003cD1R\u003e, \u003cD1F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU3R\u003e, \u003cU3F\u003e}) \u003c\u003e {}))) and (not (((thrusters inter {\u003cD2R\u003e, \u003cD2F\u003e}) \u003c\u003e {}) and ((thrusters inter {\u003cU4R\u003e, \u003cU4F\u003e}) \u003c\u003e {})))))))))))\nend WorkSpace\n"]