
\begin{vdm_al}
class UmlAssociation is subclass of IUmlAssociation
operations
  public identity: () ==> seq of char
  identity () == return "Association";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAssociation(self);

  public UmlAssociation:
    (set of IUmlProperty) *
    (set of IUmlProperty) *
    [seq of char] *
    (seq of char) ==> UmlAssociation
  UmlAssociation (p1,p2,p3,p4) == 
    ( setOwnedEnds(p1);
      setOwnedNavigableEnds(p2);
      setName(p3);
      setId(p4) );

  public UmlAssociation:
    (set of IUmlProperty) *
    (set of IUmlProperty) *
    [seq of char] *
    (seq of char) *
    nat *
    nat ==> UmlAssociation
  UmlAssociation (p1,p2,p3,p4,line,column) == 
    ( setOwnedEnds(p1);
      setOwnedNavigableEnds(p2);
      setName(p3);
      setId(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "ownedEnds" in
        if fname in set dom data
        then setOwnedEnds(data(fname));
      let fname = "ownedNavigableEnds" in
        if fname in set dom data
        then setOwnedNavigableEnds(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "id" in
        if fname in set dom data
        then setId(data(fname)) );

instance variables
  private ivOwnedEnds : set of IUmlProperty := {}

operations
  public getOwnedEnds: () ==> set of IUmlProperty
  getOwnedEnds() == return ivOwnedEnds;

  public setOwnedEnds: set of IUmlProperty ==> ()
  setOwnedEnds(parg) == ivOwnedEnds := parg;

  public addOwnedEnds: IUmlNode ==> ()
  addOwnedEnds (parg) == ivOwnedEnds := ivOwnedEnds union {parg};

instance variables
  private ivOwnedNavigableEnds : set of IUmlProperty := {}

operations
  public getOwnedNavigableEnds: () ==> set of IUmlProperty
  getOwnedNavigableEnds() == return ivOwnedNavigableEnds;

  public setOwnedNavigableEnds: set of IUmlProperty ==> ()
  setOwnedNavigableEnds(parg) == ivOwnedNavigableEnds := parg;

  public addOwnedNavigableEnds: IUmlNode ==> ()
  addOwnedNavigableEnds (parg) == ivOwnedNavigableEnds := ivOwnedNavigableEnds union {parg};

instance variables
  private ivName : [seq of char] := nil

operations
  public getName: () ==> seq of char
  getName() == return ivName
    pre hasName();

  public hasName: () ==> bool
  hasName () == return ivName <> nil;

  public setName: [ seq of char ] ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivId : seq of char := []

operations
  public getId: () ==> seq of char
  getId() == return ivId;

  public setId: seq of char ==> ()
  setId(parg) == ivId := parg;

end UmlAssociation
\end{vdm_al}


\begin{vdm_al}
class UmlBes is subclass of IUmlBes
operations
  public identity: () ==> seq of char
  identity () == return "Bes";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBes(self);

  public UmlBes:
    (seq of char) *
    (IUmlMos) *
    (IUmlMos) *
    (set of IUmlLifeLine) ==> UmlBes
  UmlBes (p1,p2,p3,p4) == 
    ( setName(p1);
      setStartOs(p2);
      setFinishOs(p3);
      setCovered(p4) );

  public UmlBes:
    (seq of char) *
    (IUmlMos) *
    (IUmlMos) *
    (set of IUmlLifeLine) *
    nat *
    nat ==> UmlBes
  UmlBes (p1,p2,p3,p4,line,column) == 
    ( setName(p1);
      setStartOs(p2);
      setFinishOs(p3);
      setCovered(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "startOs" in
        if fname in set dom data
        then setStartOs(data(fname));
      let fname = "finishOs" in
        if fname in set dom data
        then setFinishOs(data(fname));
      let fname = "covered" in
        if fname in set dom data
        then setCovered(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivStartOs : [IUmlMos] := nil

operations
  public getStartOs: () ==> IUmlMos
  getStartOs() == return ivStartOs;

  public setStartOs: IUmlMos ==> ()
  setStartOs(parg) == ivStartOs := parg;

instance variables
  private ivFinishOs : [IUmlMos] := nil

operations
  public getFinishOs: () ==> IUmlMos
  getFinishOs() == return ivFinishOs;

  public setFinishOs: IUmlMos ==> ()
  setFinishOs(parg) == ivFinishOs := parg;

instance variables
  private ivCovered : set of IUmlLifeLine := {}

operations
  public getCovered: () ==> set of IUmlLifeLine
  getCovered() == return ivCovered;

  public setCovered: set of IUmlLifeLine ==> ()
  setCovered(parg) == ivCovered := parg;

  public addCovered: IUmlNode ==> ()
  addCovered (parg) == ivCovered := ivCovered union {parg};

end UmlBes
\end{vdm_al}


\begin{vdm_al}
class UmlBoolType is subclass of IUmlBoolType
operations
  public identity: () ==> seq of char
  identity () == return "BoolType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBoolType(self);

  public UmlBoolType:
    () ==> UmlBoolType
  UmlBoolType () == 
    skip;

  public UmlBoolType:
    nat *
    nat ==> UmlBoolType
  UmlBoolType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlBoolType
\end{vdm_al}


\begin{vdm_al}
class UmlCallEvent is subclass of IUmlCallEvent
operations
  public identity: () ==> seq of char
  identity () == return "CallEvent";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCallEvent(self);

  public UmlCallEvent:
    (IUmlOperation) ==> UmlCallEvent
  UmlCallEvent (p1) == 
    ( setOperation(p1) );

  public UmlCallEvent:
    (IUmlOperation) *
    nat *
    nat ==> UmlCallEvent
  UmlCallEvent (p1,line,column) == 
    ( setOperation(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operation" in
        if fname in set dom data
        then setOperation(data(fname)) );

instance variables
  private ivOperation : [IUmlOperation] := nil

operations
  public getOperation: () ==> IUmlOperation
  getOperation() == return ivOperation;

  public setOperation: IUmlOperation ==> ()
  setOperation(parg) == ivOperation := parg;

end UmlCallEvent
\end{vdm_al}


\begin{vdm_al}
class UmlCharType is subclass of IUmlCharType
operations
  public identity: () ==> seq of char
  identity () == return "CharType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCharType(self);

  public UmlCharType:
    () ==> UmlCharType
  UmlCharType () == 
    skip;

  public UmlCharType:
    nat *
    nat ==> UmlCharType
  UmlCharType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlCharType
\end{vdm_al}


\begin{vdm_al}
class UmlClass is subclass of IUmlClass
operations
  public identity: () ==> seq of char
  identity () == return "Class";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClass(self);

  public UmlClass:
    (seq of char) *
    (set of IUmlDefinitionBlock) *
    (bool) *
    (seq of IUmlClassNameType) *
    (IUmlVisibilityKind) *
    (bool) *
    (bool) *
    [IUmlTemplateSignature] ==> UmlClass
  UmlClass (p1,p2,p3,p4,p5,p6,p7,p8) == 
    ( setName(p1);
      setClassBody(p2);
      setIsAbstract(p3);
      setSuperClass(p4);
      setVisibility(p5);
      setIsStatic(p6);
      setIsActive(p7);
      setTemplatesignature(p8) );

  public UmlClass:
    (seq of char) *
    (set of IUmlDefinitionBlock) *
    (bool) *
    (seq of IUmlClassNameType) *
    (IUmlVisibilityKind) *
    (bool) *
    (bool) *
    [IUmlTemplateSignature] *
    nat *
    nat ==> UmlClass
  UmlClass (p1,p2,p3,p4,p5,p6,p7,p8,line,column) == 
    ( setName(p1);
      setClassBody(p2);
      setIsAbstract(p3);
      setSuperClass(p4);
      setVisibility(p5);
      setIsStatic(p6);
      setIsActive(p7);
      setTemplatesignature(p8);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "classBody" in
        if fname in set dom data
        then setClassBody(data(fname));
      let fname = "isAbstract" in
        if fname in set dom data
        then setIsAbstract(data(fname));
      let fname = "superClass" in
        if fname in set dom data
        then setSuperClass(data(fname));
      let fname = "visibility" in
        if fname in set dom data
        then setVisibility(data(fname));
      let fname = "isStatic" in
        if fname in set dom data
        then setIsStatic(data(fname));
      let fname = "isActive" in
        if fname in set dom data
        then setIsActive(data(fname));
      let fname = "templatesignature" in
        if fname in set dom data
        then setTemplatesignature(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivClassBody : set of IUmlDefinitionBlock := {}

operations
  public getClassBody: () ==> set of IUmlDefinitionBlock
  getClassBody() == return ivClassBody;

  public setClassBody: set of IUmlDefinitionBlock ==> ()
  setClassBody(parg) == ivClassBody := parg;

  public addClassBody: IUmlNode ==> ()
  addClassBody (parg) == ivClassBody := ivClassBody union {parg};

instance variables
  private ivIsAbstract : [bool] := nil

operations
  public getIsAbstract: () ==> bool
  getIsAbstract() == return ivIsAbstract;

  public setIsAbstract: bool ==> ()
  setIsAbstract(parg) == ivIsAbstract := parg;

instance variables
  private ivSuperClass : seq of IUmlClassNameType := []

operations
  public getSuperClass: () ==> seq of IUmlClassNameType
  getSuperClass() == return ivSuperClass;

  public setSuperClass: seq of IUmlClassNameType ==> ()
  setSuperClass(parg) == ivSuperClass := parg;

  public addSuperClass: IUmlNode ==> ()
  addSuperClass (parg) == ivSuperClass := ivSuperClass ^ [parg];

instance variables
  private ivVisibility : [IUmlVisibilityKind] := nil

operations
  public getVisibility: () ==> IUmlVisibilityKind
  getVisibility() == return ivVisibility;

  public setVisibility: IUmlVisibilityKind ==> ()
  setVisibility(parg) == ivVisibility := parg;

instance variables
  private ivIsStatic : [bool] := nil

operations
  public getIsStatic: () ==> bool
  getIsStatic() == return ivIsStatic;

  public setIsStatic: bool ==> ()
  setIsStatic(parg) == ivIsStatic := parg;

instance variables
  private ivIsActive : [bool] := nil

operations
  public getIsActive: () ==> bool
  getIsActive() == return ivIsActive;

  public setIsActive: bool ==> ()
  setIsActive(parg) == ivIsActive := parg;

instance variables
  private ivTemplatesignature : [IUmlTemplateSignature] := nil

operations
  public getTemplatesignature: () ==> IUmlTemplateSignature
  getTemplatesignature() == return ivTemplatesignature
    pre hasTemplatesignature();

  public hasTemplatesignature: () ==> bool
  hasTemplatesignature () == return ivTemplatesignature <> nil;

  public setTemplatesignature: [ IUmlTemplateSignature ] ==> ()
  setTemplatesignature(parg) == ivTemplatesignature := parg;

end UmlClass
\end{vdm_al}


\begin{vdm_al}
class UmlClassNameType is subclass of IUmlClassNameType
operations
  public identity: () ==> seq of char
  identity () == return "ClassNameType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClassNameType(self);

  public UmlClassNameType:
    (seq of char) ==> UmlClassNameType
  UmlClassNameType (p1) == 
    ( setName(p1) );

  public UmlClassNameType:
    (seq of char) *
    nat *
    nat ==> UmlClassNameType
  UmlClassNameType (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

end UmlClassNameType
\end{vdm_al}


\begin{vdm_al}
class UmlCollaboration is subclass of IUmlCollaboration
operations
  public identity: () ==> seq of char
  identity () == return "Collaboration";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCollaboration(self);

  public UmlCollaboration:
    (set of IUmlInteraction) ==> UmlCollaboration
  UmlCollaboration (p1) == 
    ( setOwnedBehavior(p1) );

  public UmlCollaboration:
    (set of IUmlInteraction) *
    nat *
    nat ==> UmlCollaboration
  UmlCollaboration (p1,line,column) == 
    ( setOwnedBehavior(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "ownedBehavior" in
        if fname in set dom data
        then setOwnedBehavior(data(fname)) );

instance variables
  private ivOwnedBehavior : set of IUmlInteraction := {}

operations
  public getOwnedBehavior: () ==> set of IUmlInteraction
  getOwnedBehavior() == return ivOwnedBehavior;

  public setOwnedBehavior: set of IUmlInteraction ==> ()
  setOwnedBehavior(parg) == ivOwnedBehavior := parg;

  public addOwnedBehavior: IUmlNode ==> ()
  addOwnedBehavior (parg) == ivOwnedBehavior := ivOwnedBehavior union {parg};

end UmlCollaboration
\end{vdm_al}


\begin{vdm_al}
class UmlCombinedFragment is subclass of IUmlCombinedFragment
operations
  public identity: () ==> seq of char
  identity () == return "CombinedFragment";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCombinedFragment(self);

  public UmlCombinedFragment:
    (seq of char) *
    (IUmlInteractionOperatorKind) *
    (seq of IUmlInteractionOperand) *
    (set of IUmlLifeLine) ==> UmlCombinedFragment
  UmlCombinedFragment (p1,p2,p3,p4) == 
    ( setName(p1);
      setInteractionOperator(p2);
      setOperand(p3);
      setCovered(p4) );

  public UmlCombinedFragment:
    (seq of char) *
    (IUmlInteractionOperatorKind) *
    (seq of IUmlInteractionOperand) *
    (set of IUmlLifeLine) *
    nat *
    nat ==> UmlCombinedFragment
  UmlCombinedFragment (p1,p2,p3,p4,line,column) == 
    ( setName(p1);
      setInteractionOperator(p2);
      setOperand(p3);
      setCovered(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "interactionOperator" in
        if fname in set dom data
        then setInteractionOperator(data(fname));
      let fname = "operand" in
        if fname in set dom data
        then setOperand(data(fname));
      let fname = "covered" in
        if fname in set dom data
        then setCovered(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivInteractionOperator : [IUmlInteractionOperatorKind] := nil

operations
  public getInteractionOperator: () ==> IUmlInteractionOperatorKind
  getInteractionOperator() == return ivInteractionOperator;

  public setInteractionOperator: IUmlInteractionOperatorKind ==> ()
  setInteractionOperator(parg) == ivInteractionOperator := parg;

instance variables
  private ivOperand : seq of IUmlInteractionOperand := []

operations
  public getOperand: () ==> seq of IUmlInteractionOperand
  getOperand() == return ivOperand;

  public setOperand: seq of IUmlInteractionOperand ==> ()
  setOperand(parg) == ivOperand := parg;

  public addOperand: IUmlNode ==> ()
  addOperand (parg) == ivOperand := ivOperand ^ [parg];

instance variables
  private ivCovered : set of IUmlLifeLine := {}

operations
  public getCovered: () ==> set of IUmlLifeLine
  getCovered() == return ivCovered;

  public setCovered: set of IUmlLifeLine ==> ()
  setCovered(parg) == ivCovered := parg;

  public addCovered: IUmlNode ==> ()
  addCovered (parg) == ivCovered := ivCovered union {parg};

end UmlCombinedFragment
\end{vdm_al}


\begin{vdm_al}
class UmlConstraint is subclass of IUmlConstraint
operations
  public identity: () ==> seq of char
  identity () == return "Constraint";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitConstraint(self);

  public UmlConstraint:
    (set of seq of char) *
    (IUmlValueSpecification) ==> UmlConstraint
  UmlConstraint (p1,p2) == 
    ( setConstraintElements(p1);
      setSpecification(p2) );

  public UmlConstraint:
    (set of seq of char) *
    (IUmlValueSpecification) *
    nat *
    nat ==> UmlConstraint
  UmlConstraint (p1,p2,line,column) == 
    ( setConstraintElements(p1);
      setSpecification(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "constraintElements" in
        if fname in set dom data
        then setConstraintElements(data(fname));
      let fname = "specification" in
        if fname in set dom data
        then setSpecification(data(fname)) );

instance variables
  private ivConstraintElements : set of seq of char := {}

operations
  public getConstraintElements: () ==> set of seq of char
  getConstraintElements() == return ivConstraintElements;

  public setConstraintElements: set of seq of char ==> ()
  setConstraintElements(parg) == ivConstraintElements := parg;

  public addConstraintElements: seq of char ==> ()
  addConstraintElements (parg) == ivConstraintElements := ivConstraintElements union {parg};

instance variables
  private ivSpecification : [IUmlValueSpecification] := nil

operations
  public getSpecification: () ==> IUmlValueSpecification
  getSpecification() == return ivSpecification;

  public setSpecification: IUmlValueSpecification ==> ()
  setSpecification(parg) == ivSpecification := parg;

end UmlConstraint
\end{vdm_al}


\begin{vdm_al}
class UmlDefinitionBlock is subclass of IUmlDefinitionBlock
operations
  public identity: () ==> seq of char
  identity () == return "DefinitionBlock";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefinitionBlock(self);

end UmlDefinitionBlock
\end{vdm_al}

\begin{vdm_al}
class UmlDocument is subclass of IUmlDocument

instance variables
  private ivFilename : seq of char := []

operations
  public getFilename: () ==> seq of char
  getFilename () == return ivFilename;

  public setFilename: seq of char ==> ()
  setFilename (pfilename) == ivFilename := pfilename;

instance variables
  private ivTopNode : [ IUmlNode ] := nil

operations
  public hasModel: () ==> bool
  hasModel () == return isofclass(IUmlModel,ivTopNode);

  public getModel: () ==> IUmlModel
  getModel () == return ivTopNode
    pre hasModel();

  public setModel: IUmlModel ==> ()
  setModel (pNode) == ivTopNode := pNode
    pre ivTopNode = nil;

instance variables
  private ivLexems : seq of IUmlLexem := []

operations
  public getLexems : () ==> seq of IUmlLexem
  getLexems () == return ivLexems;

  public setLexems : seq of IUmlLexem ==> ()
  setLexems (plexems) == ivLexems := plexems;

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDocument(self);



  public UmlDocument: seq of char * IUmlNode * seq of IUmlLexem ==> UmlDocument
  UmlDocument (pfilename, pnode, plexems) ==
    ( setFilename(pfilename);
      ivTopNode := pnode;
      setLexems(plexems) )
    pre isofclass(IUmlModel,pnode)

end UmlDocument
\end{vdm_al}

\begin{vdm_al}
class UmlIntegerType is subclass of IUmlIntegerType
operations
  public identity: () ==> seq of char
  identity () == return "IntegerType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIntegerType(self);

  public UmlIntegerType:
    () ==> UmlIntegerType
  UmlIntegerType () == 
    skip;

  public UmlIntegerType:
    nat *
    nat ==> UmlIntegerType
  UmlIntegerType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlIntegerType
\end{vdm_al}


\begin{vdm_al}
class UmlInteraction is subclass of IUmlInteraction
operations
  public identity: () ==> seq of char
  identity () == return "Interaction";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInteraction(self);

  public UmlInteraction:
    (seq of char) *
    (set of IUmlLifeLine) *
    (set of IUmlInteractionFragment) *
    (seq of IUmlMessage) ==> UmlInteraction
  UmlInteraction (p1,p2,p3,p4) == 
    ( setName(p1);
      setLifeLines(p2);
      setFragments(p3);
      setMessages(p4) );

  public UmlInteraction:
    (seq of char) *
    (set of IUmlLifeLine) *
    (set of IUmlInteractionFragment) *
    (seq of IUmlMessage) *
    nat *
    nat ==> UmlInteraction
  UmlInteraction (p1,p2,p3,p4,line,column) == 
    ( setName(p1);
      setLifeLines(p2);
      setFragments(p3);
      setMessages(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "lifeLines" in
        if fname in set dom data
        then setLifeLines(data(fname));
      let fname = "fragments" in
        if fname in set dom data
        then setFragments(data(fname));
      let fname = "messages" in
        if fname in set dom data
        then setMessages(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivLifeLines : set of IUmlLifeLine := {}

operations
  public getLifeLines: () ==> set of IUmlLifeLine
  getLifeLines() == return ivLifeLines;

  public setLifeLines: set of IUmlLifeLine ==> ()
  setLifeLines(parg) == ivLifeLines := parg;

  public addLifeLines: IUmlNode ==> ()
  addLifeLines (parg) == ivLifeLines := ivLifeLines union {parg};

instance variables
  private ivFragments : set of IUmlInteractionFragment := {}

operations
  public getFragments: () ==> set of IUmlInteractionFragment
  getFragments() == return ivFragments;

  public setFragments: set of IUmlInteractionFragment ==> ()
  setFragments(parg) == ivFragments := parg;

  public addFragments: IUmlNode ==> ()
  addFragments (parg) == ivFragments := ivFragments union {parg};

instance variables
  private ivMessages : seq of IUmlMessage := []

operations
  public getMessages: () ==> seq of IUmlMessage
  getMessages() == return ivMessages;

  public setMessages: seq of IUmlMessage ==> ()
  setMessages(parg) == ivMessages := parg;

  public addMessages: IUmlNode ==> ()
  addMessages (parg) == ivMessages := ivMessages ^ [parg];

end UmlInteraction
\end{vdm_al}


\begin{vdm_al}
class UmlInteractionConstraint is subclass of IUmlInteractionConstraint
operations
  public identity: () ==> seq of char
  identity () == return "InteractionConstraint";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInteractionConstraint(self);

  public UmlInteractionConstraint:
    [IUmlValueSpecification] *
    [IUmlValueSpecification] ==> UmlInteractionConstraint
  UmlInteractionConstraint (p1,p2) == 
    ( setMinint(p1);
      setMaxint(p2) );

  public UmlInteractionConstraint:
    [IUmlValueSpecification] *
    [IUmlValueSpecification] *
    nat *
    nat ==> UmlInteractionConstraint
  UmlInteractionConstraint (p1,p2,line,column) == 
    ( setMinint(p1);
      setMaxint(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "minint" in
        if fname in set dom data
        then setMinint(data(fname));
      let fname = "maxint" in
        if fname in set dom data
        then setMaxint(data(fname)) );

instance variables
  private ivMinint : [IUmlValueSpecification] := nil

operations
  public getMinint: () ==> IUmlValueSpecification
  getMinint() == return ivMinint
    pre hasMinint();

  public hasMinint: () ==> bool
  hasMinint () == return ivMinint <> nil;

  public setMinint: [ IUmlValueSpecification ] ==> ()
  setMinint(parg) == ivMinint := parg;

instance variables
  private ivMaxint : [IUmlValueSpecification] := nil

operations
  public getMaxint: () ==> IUmlValueSpecification
  getMaxint() == return ivMaxint
    pre hasMaxint();

  public hasMaxint: () ==> bool
  hasMaxint () == return ivMaxint <> nil;

  public setMaxint: [ IUmlValueSpecification ] ==> ()
  setMaxint(parg) == ivMaxint := parg;

end UmlInteractionConstraint
\end{vdm_al}


\begin{vdm_al}
class UmlInteractionFragment is subclass of IUmlInteractionFragment
operations
  public identity: () ==> seq of char
  identity () == return "InteractionFragment";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInteractionFragment(self);

end UmlInteractionFragment
\end{vdm_al}

\begin{vdm_al}
class UmlInteractionOperand is subclass of IUmlInteractionOperand
operations
  public identity: () ==> seq of char
  identity () == return "InteractionOperand";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInteractionOperand(self);

  public UmlInteractionOperand:
    (seq of char) *
    (seq of IUmlInteractionFragment) *
    (set of IUmlMos) *
    [IUmlInteractionConstraint] ==> UmlInteractionOperand
  UmlInteractionOperand (p1,p2,p3,p4) == 
    ( setName(p1);
      setFragments(p2);
      setCovered(p3);
      setGuard(p4) );

  public UmlInteractionOperand:
    (seq of char) *
    (seq of IUmlInteractionFragment) *
    (set of IUmlMos) *
    [IUmlInteractionConstraint] *
    nat *
    nat ==> UmlInteractionOperand
  UmlInteractionOperand (p1,p2,p3,p4,line,column) == 
    ( setName(p1);
      setFragments(p2);
      setCovered(p3);
      setGuard(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "fragments" in
        if fname in set dom data
        then setFragments(data(fname));
      let fname = "covered" in
        if fname in set dom data
        then setCovered(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivFragments : seq of IUmlInteractionFragment := []

operations
  public getFragments: () ==> seq of IUmlInteractionFragment
  getFragments() == return ivFragments;

  public setFragments: seq of IUmlInteractionFragment ==> ()
  setFragments(parg) == ivFragments := parg;

  public addFragments: IUmlNode ==> ()
  addFragments (parg) == ivFragments := ivFragments ^ [parg];

instance variables
  private ivCovered : set of IUmlMos := {}

operations
  public getCovered: () ==> set of IUmlMos
  getCovered() == return ivCovered;

  public setCovered: set of IUmlMos ==> ()
  setCovered(parg) == ivCovered := parg;

  public addCovered: IUmlNode ==> ()
  addCovered (parg) == ivCovered := ivCovered union {parg};

instance variables
  private ivGuard : [IUmlInteractionConstraint] := nil

operations
  public getGuard: () ==> IUmlInteractionConstraint
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IUmlInteractionConstraint ] ==> ()
  setGuard(parg) == ivGuard := parg;

end UmlInteractionOperand
\end{vdm_al}


\begin{vdm_al}
class UmlInteractionOperatorKind is subclass of IUmlInteractionOperatorKind
operations
  public identity: () ==> seq of char
  identity () == return "InteractionOperatorKind";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInteractionOperatorKind(self);

  public UmlInteractionOperatorKind: nat ==> UmlInteractionOperatorKind
  UmlInteractionOperatorKind (pv) == setValue(pv);

  public UmlInteractionOperatorKind: nat * nat * nat ==> UmlInteractionOperatorKind
  UmlInteractionOperatorKind (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and UmlInteractionOperatorKindQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return UmlInteractionOperatorKindQuotes`getQuoteName(val)
    pre val <> nil;

end UmlInteractionOperatorKind
\end{vdm_al}

\begin{vdm_al}
class UmlInteractionOperatorKindQuotes
instance variables
values -- Temp fix static access to instance variables are not allowed
  static public IQALT : nat = 0;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQLOOP : nat = 1;
instance variables


  static private qmap : map nat to seq of char :=
    { IQALT |-> "<ALT>",
      IQLOOP |-> "<LOOP>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end UmlInteractionOperatorKindQuotes
\end{vdm_al}

\begin{vdm_al}
class UmlLexem is subclass of IUmlLexem

instance variables
  private ivLine : nat := 0

operations
  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLexem(self);

  public getLine: () ==> nat
  getLine () == return ivLine;

  public setLine: nat ==> ()
  setLine (pline) == ivLine := pline

instance variables
  private ivColumn : nat := 0

operations
  public getColumn: () ==> nat
  getColumn () == return ivColumn;

  public setColumn: nat ==> ()
  setColumn (pcolumn) == ivColumn := pcolumn

instance variables
  private ivLexval : nat := 0

operations
  public getLexval: () ==> nat
  getLexval () == return ivLexval;

  public setLexval: nat ==> ()
  setLexval (plexval) == ivLexval := plexval

instance variables
  private ivText : seq of char := []

operations
  public getText: () ==> seq of char
  getText () == return ivText;

  public setText: seq of char ==> ()
  setText (ptext) == ivText := ptext

instance variables
  private ivType : nat := ILEXEMUNKNOWN

operations
  public getType: () ==> nat
  getType () == return ivType;

  public isKeyword: () ==> bool
  isKeyword () == return ivType = ILEXEMKEYWORD;

  public isIdentifier: () ==> bool
  isIdentifier () == return ivType = ILEXEMIDENTIFIER;

  public isComment: () ==> bool
  isComment () == return (ivType = ILEXEMLINECOMMENT) or (ivType = ILEXEMBLOCKCOMMENT);

  public isLineComment: () ==> bool
  isLineComment () == return ivType = ILEXEMLINECOMMENT;

  public isBlockComment: () ==> bool
  isBlockComment () == return ivType = ILEXEMBLOCKCOMMENT;

  public UmlLexem: nat * nat * nat * seq of char * nat ==> UmlLexem
  UmlLexem (pline, pcolumn, plexval, ptext, ptype) ==
    ( ivLine := pline;
      ivColumn := pcolumn;
      ivLexval := plexval;
      ivText := ptext;
      ivType := ptype )

end UmlLexem
\end{vdm_al}

\begin{vdm_al}
class UmlLifeLine is subclass of IUmlLifeLine
operations
  public identity: () ==> seq of char
  identity () == return "LifeLine";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLifeLine(self);

  public UmlLifeLine:
    (seq of char) *
    [IUmlType] ==> UmlLifeLine
  UmlLifeLine (p1,p2) == 
    ( setName(p1);
      setRepresents(p2) );

  public UmlLifeLine:
    (seq of char) *
    [IUmlType] *
    nat *
    nat ==> UmlLifeLine
  UmlLifeLine (p1,p2,line,column) == 
    ( setName(p1);
      setRepresents(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "represents" in
        if fname in set dom data
        then setRepresents(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivRepresents : [IUmlType] := nil

operations
  public getRepresents: () ==> IUmlType
  getRepresents() == return ivRepresents
    pre hasRepresents();

  public hasRepresents: () ==> bool
  hasRepresents () == return ivRepresents <> nil;

  public setRepresents: [ IUmlType ] ==> ()
  setRepresents(parg) == ivRepresents := parg;

end UmlLifeLine
\end{vdm_al}


\begin{vdm_al}
class UmlLiteralInteger is subclass of IUmlLiteralInteger
operations
  public identity: () ==> seq of char
  identity () == return "LiteralInteger";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLiteralInteger(self);

  public UmlLiteralInteger:
    (nat) ==> UmlLiteralInteger
  UmlLiteralInteger (p1) == 
    ( setValue(p1) );

  public UmlLiteralInteger:
    (nat) *
    nat *
    nat ==> UmlLiteralInteger
  UmlLiteralInteger (p1,line,column) == 
    ( setValue(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "value" in
        if fname in set dom data
        then setValue(data(fname)) );

instance variables
  private ivValue : [nat] := nil

operations
  public getValue: () ==> nat
  getValue() == return ivValue;

  public setValue: nat ==> ()
  setValue(parg) == ivValue := parg;

end UmlLiteralInteger
\end{vdm_al}


\begin{vdm_al}
class UmlLiteralString is subclass of IUmlLiteralString
operations
  public identity: () ==> seq of char
  identity () == return "LiteralString";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLiteralString(self);

  public UmlLiteralString:
    (seq of char) ==> UmlLiteralString
  UmlLiteralString (p1) == 
    ( setValue(p1) );

  public UmlLiteralString:
    (seq of char) *
    nat *
    nat ==> UmlLiteralString
  UmlLiteralString (p1,line,column) == 
    ( setValue(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "value" in
        if fname in set dom data
        then setValue(data(fname)) );

instance variables
  private ivValue : seq of char := []

operations
  public getValue: () ==> seq of char
  getValue() == return ivValue;

  public setValue: seq of char ==> ()
  setValue(parg) == ivValue := parg;

end UmlLiteralString
\end{vdm_al}


\begin{vdm_al}
class UmlMessage is subclass of IUmlMessage
operations
  public identity: () ==> seq of char
  identity () == return "Message";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMessage(self);

  public UmlMessage:
    (seq of char) *
    (IUmlMessageKind) *
    (IUmlMessageSort) *
    (IUmlMos) *
    (IUmlMos) *
    (seq of IUmlValueSpecification) ==> UmlMessage
  UmlMessage (p1,p2,p3,p4,p5,p6) == 
    ( setName(p1);
      setMessageKind(p2);
      setMessageSort(p3);
      setSendEvent(p4);
      setSendReceive(p5);
      setArgument(p6) );

  public UmlMessage:
    (seq of char) *
    (IUmlMessageKind) *
    (IUmlMessageSort) *
    (IUmlMos) *
    (IUmlMos) *
    (seq of IUmlValueSpecification) *
    nat *
    nat ==> UmlMessage
  UmlMessage (p1,p2,p3,p4,p5,p6,line,column) == 
    ( setName(p1);
      setMessageKind(p2);
      setMessageSort(p3);
      setSendEvent(p4);
      setSendReceive(p5);
      setArgument(p6);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "messageKind" in
        if fname in set dom data
        then setMessageKind(data(fname));
      let fname = "messageSort" in
        if fname in set dom data
        then setMessageSort(data(fname));
      let fname = "sendEvent" in
        if fname in set dom data
        then setSendEvent(data(fname));
      let fname = "sendReceive" in
        if fname in set dom data
        then setSendReceive(data(fname));
      let fname = "argument" in
        if fname in set dom data
        then setArgument(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivMessageKind : [IUmlMessageKind] := nil

operations
  public getMessageKind: () ==> IUmlMessageKind
  getMessageKind() == return ivMessageKind;

  public setMessageKind: IUmlMessageKind ==> ()
  setMessageKind(parg) == ivMessageKind := parg;

instance variables
  private ivMessageSort : [IUmlMessageSort] := nil

operations
  public getMessageSort: () ==> IUmlMessageSort
  getMessageSort() == return ivMessageSort;

  public setMessageSort: IUmlMessageSort ==> ()
  setMessageSort(parg) == ivMessageSort := parg;

instance variables
  private ivSendEvent : [IUmlMos] := nil

operations
  public getSendEvent: () ==> IUmlMos
  getSendEvent() == return ivSendEvent;

  public setSendEvent: IUmlMos ==> ()
  setSendEvent(parg) == ivSendEvent := parg;

instance variables
  private ivSendReceive : [IUmlMos] := nil

operations
  public getSendReceive: () ==> IUmlMos
  getSendReceive() == return ivSendReceive;

  public setSendReceive: IUmlMos ==> ()
  setSendReceive(parg) == ivSendReceive := parg;

instance variables
  private ivArgument : seq of IUmlValueSpecification := []

operations
  public getArgument: () ==> seq of IUmlValueSpecification
  getArgument() == return ivArgument;

  public setArgument: seq of IUmlValueSpecification ==> ()
  setArgument(parg) == ivArgument := parg;

  public addArgument: IUmlNode ==> ()
  addArgument (parg) == ivArgument := ivArgument ^ [parg];

end UmlMessage
\end{vdm_al}


\begin{vdm_al}
class UmlMessageKind is subclass of IUmlMessageKind
operations
  public identity: () ==> seq of char
  identity () == return "MessageKind";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMessageKind(self);

  public UmlMessageKind: nat ==> UmlMessageKind
  UmlMessageKind (pv) == setValue(pv);

  public UmlMessageKind: nat * nat * nat ==> UmlMessageKind
  UmlMessageKind (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and UmlMessageKindQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return UmlMessageKindQuotes`getQuoteName(val)
    pre val <> nil;

end UmlMessageKind
\end{vdm_al}

\begin{vdm_al}
class UmlMessageKindQuotes
instance variables
values -- Temp fix static access to instance variables are not allowed
  static public IQUNKNOWN : nat = 0;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQCOMPLETE : nat = 1;
instance variables


  static private qmap : map nat to seq of char :=
    { IQUNKNOWN |-> "<UNKNOWN>",
      IQCOMPLETE |-> "<COMPLETE>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end UmlMessageKindQuotes
\end{vdm_al}

\begin{vdm_al}
class UmlMessageSort is subclass of IUmlMessageSort
operations
  public identity: () ==> seq of char
  identity () == return "MessageSort";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMessageSort(self);

  public UmlMessageSort: nat ==> UmlMessageSort
  UmlMessageSort (pv) == setValue(pv);

  public UmlMessageSort: nat * nat * nat ==> UmlMessageSort
  UmlMessageSort (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and UmlMessageSortQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return UmlMessageSortQuotes`getQuoteName(val)
    pre val <> nil;

end UmlMessageSort
\end{vdm_al}

\begin{vdm_al}
class UmlMessageSortQuotes
instance variables
values -- Temp fix static access to instance variables are not allowed
  static public IQSYNCHCALL : nat = 0;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQASYNCHCALL : nat = 1;
instance variables


  static private qmap : map nat to seq of char :=
    { IQSYNCHCALL |-> "<SYNCHCALL>",
      IQASYNCHCALL |-> "<ASYNCHCALL>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end UmlMessageSortQuotes
\end{vdm_al}

\begin{vdm_al}
class UmlModel is subclass of IUmlModel
operations
  public identity: () ==> seq of char
  identity () == return "Model";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitModel(self);

  public UmlModel:
    (seq of char) *
    (set of IUmlModelElement) ==> UmlModel
  UmlModel (p1,p2) == 
    ( setName(p1);
      setDefinitions(p2) );

  public UmlModel:
    (seq of char) *
    (set of IUmlModelElement) *
    nat *
    nat ==> UmlModel
  UmlModel (p1,p2,line,column) == 
    ( setName(p1);
      setDefinitions(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "definitions" in
        if fname in set dom data
        then setDefinitions(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivDefinitions : set of IUmlModelElement := {}

operations
  public getDefinitions: () ==> set of IUmlModelElement
  getDefinitions() == return ivDefinitions;

  public setDefinitions: set of IUmlModelElement ==> ()
  setDefinitions(parg) == ivDefinitions := parg;

  public addDefinitions: IUmlNode ==> ()
  addDefinitions (parg) == ivDefinitions := ivDefinitions union {parg};

end UmlModel
\end{vdm_al}


\begin{vdm_al}
class UmlModelElement is subclass of IUmlModelElement
operations
  public identity: () ==> seq of char
  identity () == return "ModelElement";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitModelElement(self);

end UmlModelElement
\end{vdm_al}

\begin{vdm_al}
class UmlMos is subclass of IUmlMos
operations
  public identity: () ==> seq of char
  identity () == return "Mos";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMos(self);

  public UmlMos:
    (seq of char) *
    [IUmlMessage] *
    (IUmlLifeLine) *
    [IUmlCallEvent] ==> UmlMos
  UmlMos (p1,p2,p3,p4) == 
    ( setName(p1);
      setMessage(p2);
      setCovered(p3);
      setEvent(p4) );

  public UmlMos:
    (seq of char) *
    [IUmlMessage] *
    (IUmlLifeLine) *
    [IUmlCallEvent] *
    nat *
    nat ==> UmlMos
  UmlMos (p1,p2,p3,p4,line,column) == 
    ( setName(p1);
      setMessage(p2);
      setCovered(p3);
      setEvent(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "message" in
        if fname in set dom data
        then setMessage(data(fname));
      let fname = "covered" in
        if fname in set dom data
        then setCovered(data(fname));
      let fname = "event" in
        if fname in set dom data
        then setEvent(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivMessage : [IUmlMessage] := nil

operations
  public getMessage: () ==> IUmlMessage
  getMessage() == return ivMessage
    pre hasMessage();

  public hasMessage: () ==> bool
  hasMessage () == return ivMessage <> nil;

  public setMessage: [ IUmlMessage ] ==> ()
  setMessage(parg) == ivMessage := parg;

instance variables
  private ivCovered : [IUmlLifeLine] := nil

operations
  public getCovered: () ==> IUmlLifeLine
  getCovered() == return ivCovered;

  public setCovered: IUmlLifeLine ==> ()
  setCovered(parg) == ivCovered := parg;

instance variables
  private ivEvent : [IUmlCallEvent] := nil

operations
  public getEvent: () ==> IUmlCallEvent
  getEvent() == return ivEvent
    pre hasEvent();

  public hasEvent: () ==> bool
  hasEvent () == return ivEvent <> nil;

  public setEvent: [ IUmlCallEvent ] ==> ()
  setEvent(parg) == ivEvent := parg;

end UmlMos
\end{vdm_al}


\begin{vdm_al}
class UmlMultiplicityElement is subclass of IUmlMultiplicityElement
operations
  public identity: () ==> seq of char
  identity () == return "MultiplicityElement";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMultiplicityElement(self);

  public UmlMultiplicityElement:
    (bool) *
    (bool) *
    (nat) *
    [nat] ==> UmlMultiplicityElement
  UmlMultiplicityElement (p1,p2,p3,p4) == 
    ( setIsOrdered(p1);
      setIsUnique(p2);
      setLower(p3);
      setUpper(p4) );

  public UmlMultiplicityElement:
    (bool) *
    (bool) *
    (nat) *
    [nat] *
    nat *
    nat ==> UmlMultiplicityElement
  UmlMultiplicityElement (p1,p2,p3,p4,line,column) == 
    ( setIsOrdered(p1);
      setIsUnique(p2);
      setLower(p3);
      setUpper(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "isOrdered" in
        if fname in set dom data
        then setIsOrdered(data(fname));
      let fname = "isUnique" in
        if fname in set dom data
        then setIsUnique(data(fname));
      let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivIsOrdered : [bool] := nil

operations
  public getIsOrdered: () ==> bool
  getIsOrdered() == return ivIsOrdered;

  public setIsOrdered: bool ==> ()
  setIsOrdered(parg) == ivIsOrdered := parg;

instance variables
  private ivIsUnique : [bool] := nil

operations
  public getIsUnique: () ==> bool
  getIsUnique() == return ivIsUnique;

  public setIsUnique: bool ==> ()
  setIsUnique(parg) == ivIsUnique := parg;

instance variables
  private ivLower : [nat] := nil

operations
  public getLower: () ==> nat
  getLower() == return ivLower;

  public setLower: nat ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [nat] := nil

operations
  public getUpper: () ==> nat
  getUpper() == return ivUpper
    pre hasUpper();

  public hasUpper: () ==> bool
  hasUpper () == return ivUpper <> nil;

  public setUpper: [ nat ] ==> ()
  setUpper(parg) == ivUpper := parg;

end UmlMultiplicityElement
\end{vdm_al}


\begin{vdm_al}
class UmlNestedClassifiers is subclass of IUmlNestedClassifiers
operations
  public identity: () ==> seq of char
  identity () == return "NestedClassifiers";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNestedClassifiers(self);

  public UmlNestedClassifiers:
    (set of IUmlType) ==> UmlNestedClassifiers
  UmlNestedClassifiers (p1) == 
    ( setTypeList(p1) );

  public UmlNestedClassifiers:
    (set of IUmlType) *
    nat *
    nat ==> UmlNestedClassifiers
  UmlNestedClassifiers (p1,line,column) == 
    ( setTypeList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "typeList" in
        if fname in set dom data
        then setTypeList(data(fname)) );

instance variables
  private ivTypeList : set of IUmlType := {}

operations
  public getTypeList: () ==> set of IUmlType
  getTypeList() == return ivTypeList;

  public setTypeList: set of IUmlType ==> ()
  setTypeList(parg) == ivTypeList := parg;

  public addTypeList: IUmlNode ==> ()
  addTypeList (parg) == ivTypeList := ivTypeList union {parg};

end UmlNestedClassifiers
\end{vdm_al}


\begin{vdm_al}
class IUmlContextInfo

operations
  public accept: IUmlVisitor ==> ()
  accept (-) == is subclass responsibility

end IUmlContextInfo
\end{vdm_al}

\begin{vdm_al}
-- important note: this class is renamed to UmlNode by the patch script!
class IUmlNode

values
  public static prefix : seq of char = "Uml"

types
  public FieldValue = 
    bool | char | nat | real | IUmlNode | 
    seq of FieldValue |
    set of FieldValue |
    map FieldValue to FieldValue

instance variables
  private ivInfo : map nat to IUmlContextInfo := {|->}

operations
  public identity: () ==> seq of char
  identity () == return "Node";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNode(self);

  public getContextInfo: nat ==> IUmlContextInfo
  getContextInfo (pci) == return ivInfo(pci)
    pre pci in set dom ivInfo;

  public getContextInfoCount: () ==> nat
  getContextInfoCount () == return card dom ivInfo;

  public addContextInfo: IUmlContextInfo ==> nat
  addContextInfo (pci) ==
    ( dcl res : nat := card dom ivInfo + 1;
      ivInfo := ivInfo munion {res |-> pci};
      return res )

instance variables
  private ivLine : nat := 0;
  private ivColumn : nat := 0;

operations
  public getLine : () ==> nat
  getLine () == return ivLine;

  public setLine : nat ==> ()
  setLine (pl) == ivLine := pl;

  public getColumn : () ==> nat
  getColumn () == return ivColumn;

  public setColumn : nat ==> ()
  setColumn (pc) == ivColumn := pc;

  public setPosition : nat * nat ==> ()
  setPosition (pl, pc) ==
    ( setLine(pl); setColumn(pc) );

  public setPosLexem : IUmlLexem ==> ()
  setPosLexem (pol) ==
    ( setLine(pol.getLine());
      setColumn(pol.getColumn()) );

  public setPosNode : IUmlNode ==> ()
  setPosNode (pnd) ==
    ( setLine(pnd.getLine());
      setColumn(pnd.getColumn()) )

end IUmlNode
\end{vdm_al}


\begin{vdm_al}
class UmlOperation is subclass of IUmlOperation
operations
  public identity: () ==> seq of char
  identity () == return "Operation";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperation(self);

  public UmlOperation:
    (seq of char) *
    (IUmlVisibilityKind) *
    (IUmlMultiplicityElement) *
    (bool) *
    [IUmlType] *
    (bool) *
    [IUmlParameters] ==> UmlOperation
  UmlOperation (p1,p2,p3,p4,p5,p6,p7) == 
    ( setName(p1);
      setVisibility(p2);
      setMultiplicity(p3);
      setIsQuery(p4);
      setType(p5);
      setIsStatic(p6);
      setOwnedParameters(p7) );

  public UmlOperation:
    (seq of char) *
    (IUmlVisibilityKind) *
    (IUmlMultiplicityElement) *
    (bool) *
    [IUmlType] *
    (bool) *
    [IUmlParameters] *
    nat *
    nat ==> UmlOperation
  UmlOperation (p1,p2,p3,p4,p5,p6,p7,line,column) == 
    ( setName(p1);
      setVisibility(p2);
      setMultiplicity(p3);
      setIsQuery(p4);
      setType(p5);
      setIsStatic(p6);
      setOwnedParameters(p7);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "visibility" in
        if fname in set dom data
        then setVisibility(data(fname));
      let fname = "multiplicity" in
        if fname in set dom data
        then setMultiplicity(data(fname));
      let fname = "isQuery" in
        if fname in set dom data
        then setIsQuery(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "isStatic" in
        if fname in set dom data
        then setIsStatic(data(fname));
      let fname = "ownedParameters" in
        if fname in set dom data
        then setOwnedParameters(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivVisibility : [IUmlVisibilityKind] := nil

operations
  public getVisibility: () ==> IUmlVisibilityKind
  getVisibility() == return ivVisibility;

  public setVisibility: IUmlVisibilityKind ==> ()
  setVisibility(parg) == ivVisibility := parg;

instance variables
  private ivMultiplicity : [IUmlMultiplicityElement] := nil

operations
  public getMultiplicity: () ==> IUmlMultiplicityElement
  getMultiplicity() == return ivMultiplicity;

  public setMultiplicity: IUmlMultiplicityElement ==> ()
  setMultiplicity(parg) == ivMultiplicity := parg;

instance variables
  private ivIsQuery : [bool] := nil

operations
  public getIsQuery: () ==> bool
  getIsQuery() == return ivIsQuery;

  public setIsQuery: bool ==> ()
  setIsQuery(parg) == ivIsQuery := parg;

instance variables
  private ivType : [IUmlType] := nil

operations
  public getType: () ==> IUmlType
  getType() == return ivType
    pre hasType();

  public hasType: () ==> bool
  hasType () == return ivType <> nil;

  public setType: [ IUmlType ] ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivIsStatic : [bool] := nil

operations
  public getIsStatic: () ==> bool
  getIsStatic() == return ivIsStatic;

  public setIsStatic: bool ==> ()
  setIsStatic(parg) == ivIsStatic := parg;

instance variables
  private ivOwnedParameters : [IUmlParameters] := nil

operations
  public getOwnedParameters: () ==> IUmlParameters
  getOwnedParameters() == return ivOwnedParameters
    pre hasOwnedParameters();

  public hasOwnedParameters: () ==> bool
  hasOwnedParameters () == return ivOwnedParameters <> nil;

  public setOwnedParameters: [ IUmlParameters ] ==> ()
  setOwnedParameters(parg) == ivOwnedParameters := parg;

end UmlOperation
\end{vdm_al}


\begin{vdm_al}
class UmlOwnedOperations is subclass of IUmlOwnedOperations
operations
  public identity: () ==> seq of char
  identity () == return "OwnedOperations";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOwnedOperations(self);

  public UmlOwnedOperations:
    (set of IUmlOperation) ==> UmlOwnedOperations
  UmlOwnedOperations (p1) == 
    ( setOperationList(p1) );

  public UmlOwnedOperations:
    (set of IUmlOperation) *
    nat *
    nat ==> UmlOwnedOperations
  UmlOwnedOperations (p1,line,column) == 
    ( setOperationList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operationList" in
        if fname in set dom data
        then setOperationList(data(fname)) );

instance variables
  private ivOperationList : set of IUmlOperation := {}

operations
  public getOperationList: () ==> set of IUmlOperation
  getOperationList() == return ivOperationList;

  public setOperationList: set of IUmlOperation ==> ()
  setOperationList(parg) == ivOperationList := parg;

  public addOperationList: IUmlNode ==> ()
  addOperationList (parg) == ivOperationList := ivOperationList union {parg};

end UmlOwnedOperations
\end{vdm_al}


\begin{vdm_al}
class UmlOwnedProperties is subclass of IUmlOwnedProperties
operations
  public identity: () ==> seq of char
  identity () == return "OwnedProperties";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOwnedProperties(self);

  public UmlOwnedProperties:
    (set of IUmlProperty) ==> UmlOwnedProperties
  UmlOwnedProperties (p1) == 
    ( setPropetityList(p1) );

  public UmlOwnedProperties:
    (set of IUmlProperty) *
    nat *
    nat ==> UmlOwnedProperties
  UmlOwnedProperties (p1,line,column) == 
    ( setPropetityList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "propetityList" in
        if fname in set dom data
        then setPropetityList(data(fname)) );

instance variables
  private ivPropetityList : set of IUmlProperty := {}

operations
  public getPropetityList: () ==> set of IUmlProperty
  getPropetityList() == return ivPropetityList;

  public setPropetityList: set of IUmlProperty ==> ()
  setPropetityList(parg) == ivPropetityList := parg;

  public addPropetityList: IUmlNode ==> ()
  addPropetityList (parg) == ivPropetityList := ivPropetityList union {parg};

end UmlOwnedProperties
\end{vdm_al}


\begin{vdm_al}
class UmlParameter is subclass of IUmlParameter
operations
  public identity: () ==> seq of char
  identity () == return "Parameter";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitParameter(self);

  public UmlParameter:
    (seq of char) *
    (IUmlType) *
    (IUmlMultiplicityElement) *
    (seq of char) *
    (IUmlParameterDirectionKind) ==> UmlParameter
  UmlParameter (p1,p2,p3,p4,p5) == 
    ( setName(p1);
      setType(p2);
      setMultiplicity(p3);
      setDefault(p4);
      setDirection(p5) );

  public UmlParameter:
    (seq of char) *
    (IUmlType) *
    (IUmlMultiplicityElement) *
    (seq of char) *
    (IUmlParameterDirectionKind) *
    nat *
    nat ==> UmlParameter
  UmlParameter (p1,p2,p3,p4,p5,line,column) == 
    ( setName(p1);
      setType(p2);
      setMultiplicity(p3);
      setDefault(p4);
      setDirection(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "multiplicity" in
        if fname in set dom data
        then setMultiplicity(data(fname));
      let fname = "default" in
        if fname in set dom data
        then setDefault(data(fname));
      let fname = "direction" in
        if fname in set dom data
        then setDirection(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivType : [IUmlType] := nil

operations
  public getType: () ==> IUmlType
  getType() == return ivType;

  public setType: IUmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivMultiplicity : [IUmlMultiplicityElement] := nil

operations
  public getMultiplicity: () ==> IUmlMultiplicityElement
  getMultiplicity() == return ivMultiplicity;

  public setMultiplicity: IUmlMultiplicityElement ==> ()
  setMultiplicity(parg) == ivMultiplicity := parg;

instance variables
  private ivDefault : seq of char := []

operations
  public getDefault: () ==> seq of char
  getDefault() == return ivDefault;

  public setDefault: seq of char ==> ()
  setDefault(parg) == ivDefault := parg;

instance variables
  private ivDirection : [IUmlParameterDirectionKind] := nil

operations
  public getDirection: () ==> IUmlParameterDirectionKind
  getDirection() == return ivDirection;

  public setDirection: IUmlParameterDirectionKind ==> ()
  setDirection(parg) == ivDirection := parg;

end UmlParameter
\end{vdm_al}


\begin{vdm_al}
class UmlParameterDirectionKind is subclass of IUmlParameterDirectionKind
operations
  public identity: () ==> seq of char
  identity () == return "ParameterDirectionKind";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitParameterDirectionKind(self);

  public UmlParameterDirectionKind: nat ==> UmlParameterDirectionKind
  UmlParameterDirectionKind (pv) == setValue(pv);

  public UmlParameterDirectionKind: nat * nat * nat ==> UmlParameterDirectionKind
  UmlParameterDirectionKind (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and UmlParameterDirectionKindQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return UmlParameterDirectionKindQuotes`getQuoteName(val)
    pre val <> nil;

end UmlParameterDirectionKind
\end{vdm_al}

\begin{vdm_al}
class UmlParameterDirectionKindQuotes
instance variables
values -- Temp fix static access to instance variables are not allowed
  static public IQIN : nat = 0;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQOUT : nat = 1;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQINOUT : nat = 2;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQRETURN : nat = 3;
instance variables


  static private qmap : map nat to seq of char :=
    { IQIN |-> "<IN>",
      IQOUT |-> "<OUT>",
      IQINOUT |-> "<INOUT>",
      IQRETURN |-> "<RETURN>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end UmlParameterDirectionKindQuotes
\end{vdm_al}

\begin{vdm_al}
class UmlParameters is subclass of IUmlParameters
operations
  public identity: () ==> seq of char
  identity () == return "Parameters";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitParameters(self);

  public UmlParameters:
    (seq of IUmlParameter) ==> UmlParameters
  UmlParameters (p1) == 
    ( setParameterList(p1) );

  public UmlParameters:
    (seq of IUmlParameter) *
    nat *
    nat ==> UmlParameters
  UmlParameters (p1,line,column) == 
    ( setParameterList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "parameterList" in
        if fname in set dom data
        then setParameterList(data(fname)) );

instance variables
  private ivParameterList : seq of IUmlParameter := []

operations
  public getParameterList: () ==> seq of IUmlParameter
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IUmlParameter ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IUmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

end UmlParameters
\end{vdm_al}


\begin{vdm_al}
class UmlProperty is subclass of IUmlProperty
operations
  public identity: () ==> seq of char
  identity () == return "Property";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitProperty(self);

  public UmlProperty:
    (seq of char) *
    (IUmlVisibilityKind) *
    [IUmlMultiplicityElement] *
    (IUmlType) *
    [bool] *
    [IUmlValueSpecification] *
    (bool) *
    [bool] *
    [bool] *
    (seq of char) *
    [IUmlType] ==> UmlProperty
  UmlProperty (p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11) == 
    ( setName(p1);
      setVisibility(p2);
      setMultiplicity(p3);
      setType(p4);
      setIsReadOnly(p5);
      setDefault(p6);
      setIsComposite(p7);
      setIsDerived(p8);
      setIsStatic(p9);
      setOwnerClass(p10);
      setQualifier(p11) );

  public UmlProperty:
    (seq of char) *
    (IUmlVisibilityKind) *
    [IUmlMultiplicityElement] *
    (IUmlType) *
    [bool] *
    [IUmlValueSpecification] *
    (bool) *
    [bool] *
    [bool] *
    (seq of char) *
    [IUmlType] *
    nat *
    nat ==> UmlProperty
  UmlProperty (p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,line,column) == 
    ( setName(p1);
      setVisibility(p2);
      setMultiplicity(p3);
      setType(p4);
      setIsReadOnly(p5);
      setDefault(p6);
      setIsComposite(p7);
      setIsDerived(p8);
      setIsStatic(p9);
      setOwnerClass(p10);
      setQualifier(p11);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "visibility" in
        if fname in set dom data
        then setVisibility(data(fname));
      let fname = "multiplicity" in
        if fname in set dom data
        then setMultiplicity(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "isReadOnly" in
        if fname in set dom data
        then setIsReadOnly(data(fname));
      let fname = "default" in
        if fname in set dom data
        then setDefault(data(fname));
      let fname = "isComposite" in
        if fname in set dom data
        then setIsComposite(data(fname));
      let fname = "isDerived" in
        if fname in set dom data
        then setIsDerived(data(fname));
      let fname = "isStatic" in
        if fname in set dom data
        then setIsStatic(data(fname));
      let fname = "ownerClass" in
        if fname in set dom data
        then setOwnerClass(data(fname));
      let fname = "qualifier" in
        if fname in set dom data
        then setQualifier(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivVisibility : [IUmlVisibilityKind] := nil

operations
  public getVisibility: () ==> IUmlVisibilityKind
  getVisibility() == return ivVisibility;

  public setVisibility: IUmlVisibilityKind ==> ()
  setVisibility(parg) == ivVisibility := parg;

instance variables
  private ivMultiplicity : [IUmlMultiplicityElement] := nil

operations
  public getMultiplicity: () ==> IUmlMultiplicityElement
  getMultiplicity() == return ivMultiplicity
    pre hasMultiplicity();

  public hasMultiplicity: () ==> bool
  hasMultiplicity () == return ivMultiplicity <> nil;

  public setMultiplicity: [ IUmlMultiplicityElement ] ==> ()
  setMultiplicity(parg) == ivMultiplicity := parg;

instance variables
  private ivType : [IUmlType] := nil

operations
  public getType: () ==> IUmlType
  getType() == return ivType;

  public setType: IUmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivIsReadOnly : [bool] := nil

operations
  public getIsReadOnly: () ==> bool
  getIsReadOnly() == return ivIsReadOnly
    pre hasIsReadOnly();

  public hasIsReadOnly: () ==> bool
  hasIsReadOnly () == return ivIsReadOnly <> nil;

  public setIsReadOnly: [ bool ] ==> ()
  setIsReadOnly(parg) == ivIsReadOnly := parg;

instance variables
  private ivDefault : [IUmlValueSpecification] := nil

operations
  public getDefault: () ==> IUmlValueSpecification
  getDefault() == return ivDefault
    pre hasDefault();

  public hasDefault: () ==> bool
  hasDefault () == return ivDefault <> nil;

  public setDefault: [ IUmlValueSpecification ] ==> ()
  setDefault(parg) == ivDefault := parg;

instance variables
  private ivIsComposite : [bool] := nil

operations
  public getIsComposite: () ==> bool
  getIsComposite() == return ivIsComposite;

  public setIsComposite: bool ==> ()
  setIsComposite(parg) == ivIsComposite := parg;

instance variables
  private ivIsDerived : [bool] := nil

operations
  public getIsDerived: () ==> bool
  getIsDerived() == return ivIsDerived
    pre hasIsDerived();

  public hasIsDerived: () ==> bool
  hasIsDerived () == return ivIsDerived <> nil;

  public setIsDerived: [ bool ] ==> ()
  setIsDerived(parg) == ivIsDerived := parg;

instance variables
  private ivIsStatic : [bool] := nil

operations
  public getIsStatic: () ==> bool
  getIsStatic() == return ivIsStatic
    pre hasIsStatic();

  public hasIsStatic: () ==> bool
  hasIsStatic () == return ivIsStatic <> nil;

  public setIsStatic: [ bool ] ==> ()
  setIsStatic(parg) == ivIsStatic := parg;

instance variables
  private ivOwnerClass : seq of char := []

operations
  public getOwnerClass: () ==> seq of char
  getOwnerClass() == return ivOwnerClass;

  public setOwnerClass: seq of char ==> ()
  setOwnerClass(parg) == ivOwnerClass := parg;

instance variables
  private ivQualifier : [IUmlType] := nil

operations
  public getQualifier: () ==> IUmlType
  getQualifier() == return ivQualifier
    pre hasQualifier();

  public hasQualifier: () ==> bool
  hasQualifier () == return ivQualifier <> nil;

  public setQualifier: [ IUmlType ] ==> ()
  setQualifier(parg) == ivQualifier := parg;

end UmlProperty
\end{vdm_al}


\begin{vdm_al}
class UmlStringType is subclass of IUmlStringType
operations
  public identity: () ==> seq of char
  identity () == return "StringType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStringType(self);

  public UmlStringType:
    () ==> UmlStringType
  UmlStringType () == 
    skip;

  public UmlStringType:
    nat *
    nat ==> UmlStringType
  UmlStringType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlStringType
\end{vdm_al}


\begin{vdm_al}
class UmlTemplateParameter is subclass of IUmlTemplateParameter
operations
  public identity: () ==> seq of char
  identity () == return "TemplateParameter";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTemplateParameter(self);

  public UmlTemplateParameter:
    (seq of char) ==> UmlTemplateParameter
  UmlTemplateParameter (p1) == 
    ( setName(p1) );

  public UmlTemplateParameter:
    (seq of char) *
    nat *
    nat ==> UmlTemplateParameter
  UmlTemplateParameter (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

end UmlTemplateParameter
\end{vdm_al}


\begin{vdm_al}
class UmlTemplateSignature is subclass of IUmlTemplateSignature
operations
  public identity: () ==> seq of char
  identity () == return "TemplateSignature";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTemplateSignature(self);

  public UmlTemplateSignature:
    (set of IUmlTemplateParameter) ==> UmlTemplateSignature
  UmlTemplateSignature (p1) == 
    ( setTemplateParameters(p1) );

  public UmlTemplateSignature:
    (set of IUmlTemplateParameter) *
    nat *
    nat ==> UmlTemplateSignature
  UmlTemplateSignature (p1,line,column) == 
    ( setTemplateParameters(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "templateParameters" in
        if fname in set dom data
        then setTemplateParameters(data(fname)) );

instance variables
  private ivTemplateParameters : set of IUmlTemplateParameter := {}

operations
  public getTemplateParameters: () ==> set of IUmlTemplateParameter
  getTemplateParameters() == return ivTemplateParameters;

  public setTemplateParameters: set of IUmlTemplateParameter ==> ()
  setTemplateParameters(parg) == ivTemplateParameters := parg;

  public addTemplateParameters: IUmlNode ==> ()
  addTemplateParameters (parg) == ivTemplateParameters := ivTemplateParameters union {parg};

end UmlTemplateSignature
\end{vdm_al}


\begin{vdm_al}
class UmlType is subclass of IUmlType
operations
  public identity: () ==> seq of char
  identity () == return "Type";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitType(self);

end UmlType
\end{vdm_al}

\begin{vdm_al}
class UmlUnlimitedNatural is subclass of IUmlUnlimitedNatural
operations
  public identity: () ==> seq of char
  identity () == return "UnlimitedNatural";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnlimitedNatural(self);

  public UmlUnlimitedNatural:
    () ==> UmlUnlimitedNatural
  UmlUnlimitedNatural () == 
    skip;

  public UmlUnlimitedNatural:
    nat *
    nat ==> UmlUnlimitedNatural
  UmlUnlimitedNatural (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlUnlimitedNatural
\end{vdm_al}


\begin{vdm_al}
class UmlValueSpecification is subclass of IUmlValueSpecification
operations
  public identity: () ==> seq of char
  identity () == return "ValueSpecification";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueSpecification(self);

end UmlValueSpecification
\end{vdm_al}

\begin{vdm_al}
class UmlVisibilityKind is subclass of IUmlVisibilityKind
operations
  public identity: () ==> seq of char
  identity () == return "VisibilityKind";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitVisibilityKind(self);

  public UmlVisibilityKind: nat ==> UmlVisibilityKind
  UmlVisibilityKind (pv) == setValue(pv);

  public UmlVisibilityKind: nat * nat * nat ==> UmlVisibilityKind
  UmlVisibilityKind (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and UmlVisibilityKindQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return UmlVisibilityKindQuotes`getQuoteName(val)
    pre val <> nil;

end UmlVisibilityKind
\end{vdm_al}

\begin{vdm_al}
class UmlVisibilityKindQuotes
instance variables
values -- Temp fix static access to instance variables are not allowed
  static public IQPROTECTED : nat = 0;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQPUBLIC : nat = 1;
instance variables

values -- Temp fix static access to instance variables are not allowed
  static public IQPRIVATE : nat = 2;
instance variables


  static private qmap : map nat to seq of char :=
    { IQPROTECTED |-> "<PROTECTED>",
      IQPUBLIC |-> "<PUBLIC>",
      IQPRIVATE |-> "<PRIVATE>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end UmlVisibilityKindQuotes
\end{vdm_al}

\begin{vdm_al}
class UmlVisitor is subclass of IUmlVisitor
operations
  public visitDocument: IUmlDocument ==> ()
  visitDocument (-) == skip;

  public visitLexem: IUmlLexem ==> ()
  visitLexem (-) == skip;

  public visitParameters: IUmlParameters ==> ()
  visitParameters (-) == skip;

  public visitOperation: IUmlOperation ==> ()
  visitOperation (-) == skip;

  public visitModel: IUmlModel ==> ()
  visitModel (-) == skip;

  public visitAssociation: IUmlAssociation ==> ()
  visitAssociation (-) == skip;

  public visitLifeLine: IUmlLifeLine ==> ()
  visitLifeLine (-) == skip;

  public visitNestedClassifiers: IUmlNestedClassifiers ==> ()
  visitNestedClassifiers (-) == skip;

  public visitIntegerType: IUmlIntegerType ==> ()
  visitIntegerType (-) == skip;

  public visitConstraint: IUmlConstraint ==> ()
  visitConstraint (-) == skip;

  public visitCallEvent: IUmlCallEvent ==> ()
  visitCallEvent (-) == skip;

  public visitProperty: IUmlProperty ==> ()
  visitProperty (-) == skip;

  public visitOwnedOperations: IUmlOwnedOperations ==> ()
  visitOwnedOperations (-) == skip;

  public visitCombinedFragment: IUmlCombinedFragment ==> ()
  visitCombinedFragment (-) == skip;

  public visitClassNameType: IUmlClassNameType ==> ()
  visitClassNameType (-) == skip;

  public visitMos: IUmlMos ==> ()
  visitMos (-) == skip;

  public visitInteractionConstraint: IUmlInteractionConstraint ==> ()
  visitInteractionConstraint (-) == skip;

  public visitBoolType: IUmlBoolType ==> ()
  visitBoolType (-) == skip;

  public visitTemplateSignature: IUmlTemplateSignature ==> ()
  visitTemplateSignature (-) == skip;

  public visitParameter: IUmlParameter ==> ()
  visitParameter (-) == skip;

  public visitInteraction: IUmlInteraction ==> ()
  visitInteraction (-) == skip;

  public visitTemplateParameter: IUmlTemplateParameter ==> ()
  visitTemplateParameter (-) == skip;

  public visitLiteralInteger: IUmlLiteralInteger ==> ()
  visitLiteralInteger (-) == skip;

  public visitCharType: IUmlCharType ==> ()
  visitCharType (-) == skip;

  public visitMessage: IUmlMessage ==> ()
  visitMessage (-) == skip;

  public visitMultiplicityElement: IUmlMultiplicityElement ==> ()
  visitMultiplicityElement (-) == skip;

  public visitStringType: IUmlStringType ==> ()
  visitStringType (-) == skip;

  public visitBes: IUmlBes ==> ()
  visitBes (-) == skip;

  public visitVoidType: IUmlVoidType ==> ()
  visitVoidType (-) == skip;

  public visitInteractionOperand: IUmlInteractionOperand ==> ()
  visitInteractionOperand (-) == skip;

  public visitClass: IUmlClass ==> ()
  visitClass (-) == skip;

  public visitCollaboration: IUmlCollaboration ==> ()
  visitCollaboration (-) == skip;

  public visitLiteralString: IUmlLiteralString ==> ()
  visitLiteralString (-) == skip;

  public visitOwnedProperties: IUmlOwnedProperties ==> ()
  visitOwnedProperties (-) == skip;

  public visitUnlimitedNatural: IUmlUnlimitedNatural ==> ()
  visitUnlimitedNatural (-) == skip;

  public visitContextInfo: IUmlContextInfo ==> ()
  visitContextInfo (-) == skip;

  public visitNode: IUmlNode ==> ()
  visitNode (pNode) ==
    ( if isofclass(IUmlParameters,pNode) then visitParameters(pNode)
      elseif isofclass(IUmlOperation,pNode) then visitOperation(pNode)
      elseif isofclass(IUmlModel,pNode) then visitModel(pNode)
      elseif isofclass(IUmlAssociation,pNode) then visitAssociation(pNode)
      elseif isofclass(IUmlType,pNode) then visitType(pNode)
      elseif isofclass(IUmlLifeLine,pNode) then visitLifeLine(pNode)
      elseif isofclass(IUmlNestedClassifiers,pNode) then visitNestedClassifiers(pNode)
      elseif isofclass(IUmlConstraint,pNode) then visitConstraint(pNode)
      elseif isofclass(IUmlIntegerType,pNode) then visitIntegerType(pNode)
      elseif isofclass(IUmlCallEvent,pNode) then visitCallEvent(pNode)
      elseif isofclass(IUmlOwnedOperations,pNode) then visitOwnedOperations(pNode)
      elseif isofclass(IUmlProperty,pNode) then visitProperty(pNode)
      elseif isofclass(IUmlCombinedFragment,pNode) then visitCombinedFragment(pNode)
      elseif isofclass(IUmlClassNameType,pNode) then visitClassNameType(pNode)
      elseif isofclass(IUmlInteractionConstraint,pNode) then visitInteractionConstraint(pNode)
      elseif isofclass(IUmlMos,pNode) then visitMos(pNode)
      elseif isofclass(IUmlBoolType,pNode) then visitBoolType(pNode)
      elseif isofclass(IUmlInteractionFragment,pNode) then visitInteractionFragment(pNode)
      elseif isofclass(IUmlTemplateSignature,pNode) then visitTemplateSignature(pNode)
      elseif isofclass(IUmlParameter,pNode) then visitParameter(pNode)
      elseif isofclass(IUmlVisibilityKind,pNode) then visitVisibilityKind(pNode)
      elseif isofclass(IUmlModelElement,pNode) then visitModelElement(pNode)
      elseif isofclass(IUmlParameterDirectionKind,pNode) then visitParameterDirectionKind(pNode)
      elseif isofclass(IUmlInteraction,pNode) then visitInteraction(pNode)
      elseif isofclass(IUmlTemplateParameter,pNode) then visitTemplateParameter(pNode)
      elseif isofclass(IUmlMessageKind,pNode) then visitMessageKind(pNode)
      elseif isofclass(IUmlLiteralInteger,pNode) then visitLiteralInteger(pNode)
      elseif isofclass(IUmlMessage,pNode) then visitMessage(pNode)
      elseif isofclass(IUmlCharType,pNode) then visitCharType(pNode)
      elseif isofclass(IUmlMultiplicityElement,pNode) then visitMultiplicityElement(pNode)
      elseif isofclass(IUmlValueSpecification,pNode) then visitValueSpecification(pNode)
      elseif isofclass(IUmlMessageSort,pNode) then visitMessageSort(pNode)
      elseif isofclass(IUmlDefinitionBlock,pNode) then visitDefinitionBlock(pNode)
      elseif isofclass(IUmlStringType,pNode) then visitStringType(pNode)
      elseif isofclass(IUmlInteractionOperatorKind,pNode) then visitInteractionOperatorKind(pNode)
      elseif isofclass(IUmlBes,pNode) then visitBes(pNode)
      elseif isofclass(IUmlVoidType,pNode) then visitVoidType(pNode)
      elseif isofclass(IUmlInteractionOperand,pNode) then visitInteractionOperand(pNode)
      elseif isofclass(IUmlCollaboration,pNode) then visitCollaboration(pNode)
      elseif isofclass(IUmlClass,pNode) then visitClass(pNode)
      elseif isofclass(IUmlLiteralString,pNode) then visitLiteralString(pNode)
      elseif isofclass(IUmlOwnedProperties,pNode) then visitOwnedProperties(pNode)
      elseif isofclass(IUmlUnlimitedNatural,pNode) then visitUnlimitedNatural(pNode)
      else error );

  public visitParameterDirectionKind: IUmlParameterDirectionKind ==> ()
  visitParameterDirectionKind (-) == skip;

  public visitMessageKind: IUmlMessageKind ==> ()
  visitMessageKind (-) == skip;

  public visitType: IUmlType ==> ()
  visitType (pNode) ==
    ( if isofclass(IUmlVoidType,pNode) then visitVoidType(pNode)
      elseif isofclass(IUmlBoolType,pNode) then visitBoolType(pNode)
      elseif isofclass(IUmlCharType,pNode) then visitCharType(pNode)
      elseif isofclass(IUmlIntegerType,pNode) then visitIntegerType(pNode)
      elseif isofclass(IUmlStringType,pNode) then visitStringType(pNode)
      elseif isofclass(IUmlUnlimitedNatural,pNode) then visitUnlimitedNatural(pNode)
      elseif isofclass(IUmlClassNameType,pNode) then visitClassNameType(pNode)
      else error );

  public visitValueSpecification: IUmlValueSpecification ==> ()
  visitValueSpecification (pNode) ==
    ( if isofclass(IUmlLiteralInteger,pNode) then visitLiteralInteger(pNode)
      elseif isofclass(IUmlLiteralString,pNode) then visitLiteralString(pNode)
      else error );

  public visitMessageSort: IUmlMessageSort ==> ()
  visitMessageSort (-) == skip;

  public visitDefinitionBlock: IUmlDefinitionBlock ==> ()
  visitDefinitionBlock (pNode) ==
    ( if isofclass(IUmlNestedClassifiers,pNode) then visitNestedClassifiers(pNode)
      elseif isofclass(IUmlOwnedOperations,pNode) then visitOwnedOperations(pNode)
      elseif isofclass(IUmlOwnedProperties,pNode) then visitOwnedProperties(pNode)
      else error );

  public visitInteractionOperatorKind: IUmlInteractionOperatorKind ==> ()
  visitInteractionOperatorKind (-) == skip;

  public visitInteractionFragment: IUmlInteractionFragment ==> ()
  visitInteractionFragment (pNode) ==
    ( if isofclass(IUmlMos,pNode) then visitMos(pNode)
      elseif isofclass(IUmlInteractionOperand,pNode) then visitInteractionOperand(pNode)
      elseif isofclass(IUmlCombinedFragment,pNode) then visitCombinedFragment(pNode)
      elseif isofclass(IUmlBes,pNode) then visitBes(pNode)
      else error );

  public visitVisibilityKind: IUmlVisibilityKind ==> ()
  visitVisibilityKind (-) == skip;

  public visitModelElement: IUmlModelElement ==> ()
  visitModelElement (pNode) ==
    ( if isofclass(IUmlAssociation,pNode) then visitAssociation(pNode)
      elseif isofclass(IUmlClass,pNode) then visitClass(pNode)
      elseif isofclass(IUmlCollaboration,pNode) then visitCollaboration(pNode)
      elseif isofclass(IUmlConstraint,pNode) then visitConstraint(pNode)
      else error );

end UmlVisitor
\end{vdm_al}

\begin{vdm_al}
class UmlVoidType is subclass of IUmlVoidType
operations
  public identity: () ==> seq of char
  identity () == return "VoidType";

  public accept: IUmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitVoidType(self);

  public UmlVoidType:
    () ==> UmlVoidType
  UmlVoidType () == 
    skip;

  public UmlVoidType:
    nat *
    nat ==> UmlVoidType
  UmlVoidType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end UmlVoidType
\end{vdm_al}

