


\begin{vdm_al}
class Xml2UmlModel is subclass of XmlVisitor
   
types

public String = seq of char;
public QualifierInfo ::
                       classId : String
                       qualifier : String;
                       
values

eaTypePrefixes : set of String = {
"EAJava_", 
"EAVisual Basic_", 
"EAActionScript_", 
"EAnone_", 
"EAC_", 
"EAVBNet_", 
"EAC++_", 
"EAPHP_", 
"EAPython_", 
"EAC#_"};


instance variables

public result : [IUmlModel] := nil;

primiticeTypes    : set of String :={"char","int","bool","String","unlimitedNatural"};--,"NotSupportedType"
classes           : set of IUmlClass                   := {};
associations      : set of IUmlAssociation             := {};
constraints       : set of IUmlConstraint              := {};
classesTypeMap    : map String to String               := {|->};
collaborations    : set of IUmlCollaboration           := {};

idToclassesMap    : map String to IUmlClass            := {|->};
idToOperationMap  : map String to IUmlOperation        := {|->};
idToClallEventMap : map String to IUmlCallEvent        := {|->};

lifeLineMap       : map String to IUmlLifeLine         := {|->};
mosMap            : map String to IUmlMos              := {|->};
besMap            : map String to IUmlBes              := {|->};
combiMap          : map String to IUmlCombinedFragment := {|->};

associationToQualifier 
                  : map String to QualifierInfo        := {|->};

log               : StatusLog                          := new StatusLog();
operations

public Xml2UmlModel : StatusLog ==> Xml2UmlModel
Xml2UmlModel(l) == log := l;

-- Create UML model form document
-- If a valid document is passed the result variable
--  will contain the result parsed document
public VisitXmlDocument: XmlDocument ==> ()
VisitXmlDocument (doc) == 
(
  dcl root : XmlEntity := hd doc.entities.entities;
  dcl firstPackageAndRoot : seq of XmlEntity := root.entities.entities ^ [root]; --compatibility EX and EUML
  dcl model : XmlEntity := hd [firstPackageAndRoot(i) 
                              | i in set inds firstPackageAndRoot 
                              & firstPackageAndRoot(i).name ="uml:Model"];
                              
  dcl extention : XmlEntity := hd [firstPackageAndRoot(i) 
                                  | i in set inds firstPackageAndRoot 
                                  & hasAttributeValue(firstPackageAndRoot(i),"extender","Enterprise Architect") 
                                  and hasAttributeValue(firstPackageAndRoot(i),"extenderID","6.5") ];
                                    
  dcl package : XmlEntity := hd [model.entities.entities(i) 
                                | i in set inds model.entities.entities 
                                & isAttributeType(model.entities.entities(i),"uml:Package")];
  
  let pes = package.entities.entities
  in
  (
    classesTypeMap := classesTypeMap ++ {getAttribute(pes(i),"xmi:id").val |-> getNameAttribute(pes(i)) | i in set inds pes & 
                   isAttributeType(pes(i),"uml:Class") };
    
    classes := classes union {exstractClass(pes(i)) | i in set inds pes & 
                   isAttributeType(pes(i),"uml:Class") and
                   (getNameAttribute(pes(i)) not in set primiticeTypes)};
                   
    let connectors : set of XmlEntity =
                              dunion 
                              { elems e.entities.entities 
                              | e in set elems extention.entities.entities 
                              & e.name = "connectors" }
                              --getElement(pes(i),"connectors") | i in set inds pes & 
                              --hasAttributeValue(pes(i),"extender","Enterprise Architect") and
                              --hasAttributeValue(pes(i),"extenderID","6.5") and 
                              --getElement(pes(i),"connectors") <> nil}
                              in 
                              for all v in set connectors
                              do
                                build_AssociationQualifier(v);
                   
    associations := associations union 
                    {build_Association(pes(i)) 
                    | i in set inds pes 
                    & isAttributeType(pes(i),"uml:Association") or
                      isAttributeType(pes(i),"uml:Connector")};
                   
    constraints := constraints union {build_Constraint(pes(i)) | i in set inds pes & 
                   isAttributeType(pes(i),"uml:Constraint")};
    -- requires operatios to be populated first               
    idToClallEventMap := buildCallEventMap({(pes(i)) | i in set inds pes & 
                   isAttributeType(pes(i),"uml:CallEvent")});
                   
    collaborations := collaborations union {build_Collobration(pes(i)) | i in set inds pes & 
                   isAttributeType(pes(i),"uml:Collaboration")};
  );
    
  result := new UmlModel(getNameAttribute(package),
                         classes union associations union constraints union collaborations);

);
-- Exstract UML class from XML element
private exstractClass : XmlEntity ==> IUmlClass
exstractClass(e) ==
  let name       : seq of char  = getNameAttribute(e),
      
      dBlocks    : (set of IUmlDefinitionBlock) =build_defBlock(e,name),
      abstract   : bool = if hasAttribute(e,"isAbstract") then StdLib`StringToBool(getAttribute(e,"isAbstract").val) else false,
      supers     : seq of IUmlClassNameType = let eg = e.entities.entities in
        [exstractGeneralization(eg(i)) 
         | i in set inds eg  
         & isAttributeType(eg(i),"uml:Generalization")],
      visibility : (IUmlVisibilityKind) = 
        new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPUBLIC), -- dont care VDM has only public
      isStatic   : (bool) = false,
      active     : (bool) = if hasAttribute(e,"isActive") 
                            then let a = getAttribute(e,"isActive") in 
                                   if a <> nil 
                                   then StdLib`StringToBool(a.val) 
                                   else false
                            else false,
      template   : [IUmlTemplateSignature] = nil,
      id         : String = getAttribute(e,"xmi:id").val,
      cls        : IUmlClass = 
       new UmlClass(name,
                 dBlocks,
                 abstract,
                 supers,
                 visibility, 
                 isStatic,
                 active,
                 template)
  in
  (
    idToclassesMap := idToclassesMap ++ {id |-> cls};
    log.addNewClassInfo(name,id);
    return cls;
  )    
pre isAttributeType(e,"uml:Class");

-- Create super class references
private exstractGeneralization : XmlEntity ==> IUmlClassNameType
exstractGeneralization(e) ==
  let super = getAttribute(e,"general").val
  --look up the class id in the class it to class map
  in return new UmlClassNameType(classesTypeMap(super))
pre isAttributeType(e,"uml:Generalization");

-- Create property definitions form XML property element
-- Attribute type is property
private build_defBlock : XmlEntity * String ==> (set of IUmlDefinitionBlock)
build_defBlock(e,name) ==
  let eList = e.entities.entities, 
      props = { build_Property(eList(i),name,nil)| 
            i in set inds eList & isAttributeType(eList(i),"uml:Property")},
      ops   = { build_Operation(p)| 
            p in set elems eList & isAttributeType(p,"uml:Operation") or p.name = "ownedOperation"}
  in
    return {new UmlOwnedProperties(props)} union {new UmlOwnedOperations(ops)};
           
-- Create property from property element
private build_Property : XmlEntity * String * [String] ==> IUmlProperty
build_Property(e,ownerClass,associationId) ==
  let name         : seq of char = if hasAttribute(e,"name")
                                   then getNameAttribute(e)
                                   else "",
      visibility   : (IUmlVisibilityKind) = if hasAttribute(e,"visibility") 
                                            then GetVisibility(getAttribute(e,"visibility")) 
                                            else
                                              new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE), 
      multiplicity : [IUmlMultiplicityElement] = getMultiplicity(e),
      typeId : String = getTypeId(e),
      type         : (IUmlType) = findType(typeId),-- | i in set inds e.entities.entities & e.entities.entities(i).name = "type"}),
      isReadOnly   : [bool] = if hasAttribute(e,"isReadOnly") 
                                            then StdLib`StringToBool(getAttribute(e,"isReadOnly").val) 
                                            else false,
      default      : [IUmlValueSpecification] = let dValue = { el 
                                                             | el in set elems e.entities.entities 
                                                             & el.name = "defaultValue"} 
                                                in if card dValue > 0
                                                   then getDefaultValue(let d in set dValue in d)
                                                   else nil,
      isComposite  : (bool) = false,
      isDerived    : [bool] = false,
      isStatic     : [bool] = false, 
      --ownerClass   : [seq of char] = ,
      qualifier    : [IUmlType] = if associationId <> nil 
                                     and associationId in set dom associationToQualifier
                                     and associationToQualifier(associationId).classId = typeId
                                  then 
                                    let qInfo = associationToQualifier(associationId)
                                    in findType(qInfo.qualifier)
                                  else 
                                    nil 
  in
    return new UmlProperty(name,
                    visibility,
                    multiplicity,
                    type,
                    isReadOnly,
                    default,
                    isComposite,
                    isDerived,
                    isStatic,
                    ownerClass,
                    qualifier)
pre isAttributeType(e,"uml:Property");

-- Get default value. Initial value
private getDefaultValue : XmlEntity ==> [IUmlValueSpecification]
getDefaultValue(e) ==
let --eList = e.entities.entities,
  --tmp  = --{getAttribute(el,"value").val | el in set elems eList & el.name = "defaultValue"},
  val  = getAttribute(e,"value").val,--let t in set tmp in t,
  --tmp1 = {getAttribute(el,"xmi:type").val | el in set elems eList & el.name = "defaultValue"},
  typ  = getAttribute(e,"xmi:type").val --let t in set tmp1 in t
in
  return cases typ:
   ("uml:LiteralString") -> new UmlLiteralString(val),
   ("uml:LiteralInteger") -> new UmlLiteralInteger(StdLib`StringToInt(val)),
   others -> nil
  end
pre e.name ="defaultValue";
  
-- Get multiplicity
private getMultiplicity : XmlEntity ==> [IUmlMultiplicityElement]
getMultiplicity(e) ==
let eList = e.entities.entities,
    lowerSet =  {getAttribute(el,"value").val | el in set elems eList & el.name = "lowerValue" and hasAttribute(el,"value")},
    upperSet =  {getAttribute(el,"value").val | el in set elems eList & el.name = "upperValue" and hasAttribute(el,"value")}
in
  if card upperSet = 0 and card lowerSet = 0 then
    return nil
  else
    let lower : nat = if card lowerSet = 0 then 0 else let p in set lowerSet in StdLib`StringToInt(p),
        upVal : nat = let p in set upperSet in StdLib`StringToInt(p),
        upper : [nat] = if card upperSet = 0 or upVal < 0 then nil else upVal
    in
      return new UmlMultiplicityElement(false,false,lower,upper);


-- Create operation from xml element element
private build_Operation : XmlEntity ==> IUmlOperation
build_Operation(e) ==
  let name         : seq of char = getNameAttribute(e),
      visibility   : (IUmlVisibilityKind) = GetVisibility(getAttribute(e,"visibility")), 
      multiplicity : IUmlMultiplicityElement = new UmlMultiplicityElement(false,false,0,0), --FIXME this is added since the static model isend implemented with this yet
      isQuery      : bool = if hasAttribute(e,"isQuery") then StdLib`StringToBool(getAttribute(e,"isQuery").val) else false,
      type         : [IUmlType] = nil,
      isStatic     : bool = if hasAttribute(e,"isStatic") then StdLib`StringToBool(getAttribute(e,"isStatic").val) else false,
      id           : String = getAttribute(e,"xmi:id").val,
      params = CreateOperstionParameters(e),
      parameters = if params = nil then nil else new UmlParameters(params),
      operation    : IUmlOperation = new UmlOperation(name,
                                                      visibility,
                                                      multiplicity,
                                                      isQuery,
                                                      type,
                                                      isStatic,
                                                      parameters)
  in
  (
    idToOperationMap := idToOperationMap ++ {id |-> operation};
      return operation;
  )
pre isAttributeType(e,"uml:Operation");

-- Create operation parameter to XML model
protected CreateOperstionParameters : XmlEntity ==> [seq of IUmlParameter]
CreateOperstionParameters(e) ==
  let elist = e.entities.entities,
      parms = [new UmlParameter(getNameAttribute(elist(i)),
                             lookUpType(elist(i)),-- getAttribute(p,"xmi:type").val
                             new UmlMultiplicityElement(false,false,1,1),
                             "",
                             ConvertParameterDirectionKind(
                               getAttribute(elist(i),"direction").val))
           | i in set inds elist 
           & elist(i).name = "ownedParameter"]
  in 
    return if len parms = 0 then nil else parms
pre isAttributeType(e,"uml:Operation");

functions
-- Convert parameter direction kind to AST type
ConvertParameterDirectionKind : String -> IUmlParameterDirectionKind
ConvertParameterDirectionKind(val) ==
cases val:
  ("in")    -> 
    new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQIN),
  ("out")   -> 
    new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQOUT),
  ("return") -> 
    new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQRETURN),
  ("inout") -> 
    new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQINOUT)
end;

-- Create constraint from constraint elements
private build_Constraint : XmlEntity -> IUmlConstraint
build_Constraint(e) ==
  let elist = e.entities.entities,
      ids = { getAttribute(p,"xmi:idref").val | p in set elems elist & hasAttribute(p,"xmi:idref")},
      specification : String = hd Util`SetToSeq[seq of char]({p.data.data | p in set elems elist & p.name = "body"})
  in
    new UmlConstraint(ids,new UmlLiteralString(specification))
pre isAttributeType(e,"uml:Constraint");

operations
-- Create association from association element
private build_Association : XmlEntity ==> IUmlAssociation
build_Association(e) ==
  let elist = e.entities.entities,
      associationId : [String] = if hasAttribute(e,"xmi:id") then getAttribute(e,"xmi:id").val else nil, 
      props = {elist(i) | i in set inds elist & isAttributeType(elist(i),"uml:Property")},
      ownedNavivableEnds : (set of IUmlProperty) = 
                           { build_Property(p,"",associationId) 
                           | p in set props & not hasAttribute(p,"name") or
                                              hasAttributeValue(p,"name","")},
      one = Util`SetToSeq[IUmlProperty](ownedNavivableEnds),
      ownerClassType = hd [ one(i).getType() | i in set inds one],
      ownerClass = let ct : IUmlClassNameType = ownerClassType in ct.getName(),
      ownedEnds : (set of IUmlProperty) = 
                  {build_Property(p,ownerClass,associationId) 
                  | p in set props 
                  & hasAttribute(p,"name") and 
                    len getAttribute(p,"name").val>0},
      name : seq of char = if hasAttribute(e,"name")
                           then getNameAttribute(e)
                           else "",
      id : String = getAttribute(e,"xmi:id").val
  in
    return new UmlAssociation(ownedEnds,ownedNavivableEnds,name,id)
pre isAttributeType(e,"uml:Association");

--build qualifier info
private build_AssociationQualifier : XmlEntity ==> ()
build_AssociationQualifier(e) ==
  let list = [ e.entities.entities(i) 
             | i in set inds e.entities.entities 
             & e.entities.entities(i).name = "source" 
             or e.entities.entities(i).name = "target"],
      qualifiers : set of [QualifierInfo] =
        {getQualifierInfo(sOrT) | sOrT in set elems list}
      --  , 
     -- qualifiersTarget : set of [QualifierInfo] =
       -- {getQualifierInfo(getElement(list(i),"target")) 
         --                                   | i in set inds list 
           --                                 & getElement(list(i),"target") <> nil
             --                               }                                             
  in
  (
    associationToQualifier := associationToQualifier 
                                 munion
                                 { let id : String = getAttribute(e,"xmi:idref").val in id 
                                   |-> q
                                 | q in set qualifiers & q <> nil
                                 };
 --   associationToQualifier := associationToQualifier 
 --                                munion {let id : String = getAttribute(e,"xmi:idref").val in id 
   --                                     |-> let a in set 
--                                            {getQualifierInfo(getElement(list(i),"source")) 
--                                            | i in set inds list 
--                                            & getElement(list(i),"source") <> nil
--                                            } 
--                                            in a};
--    associationToQualifier := associationToQualifier 
--                                 munion {let id : String = getAttribute(e,"xmi:idref").val in id 
--                                        |-> let a in set 
--                                            {getQualifierInfo(getElement(list(i),"target")) 
--                                            | i in set inds list 
--                                            & getElement(list(i),"target") <> nil
--                                            } 
--                                            in a};   
  
  
  );
 
private getQualifierInfo : XmlEntity ==> [QualifierInfo]
getQualifierInfo(e) == 
  let ec  = getElement(e,"constraints")
  in
    if ec <> nil then
      let a   : [String] = if hasAttribute(ec,"qualifier") then getAttribute(ec,"qualifier").val else nil,
          id  : [String] = if hasAttribute(e,"xmi:idref") then getAttribute(e,"xmi:idref").val else nil
      in
      (
        if a <> nil then 
          return mk_QualifierInfo(id,a)
        else
          return nil;
      )
    else 
      return nil;

-- Get UmlType from  XML type name
private lookUpType : XmlEntity ==> IUmlType
lookUpType(e) ==
  return findType(getTypeId(e));

private getTypeId : XmlEntity ==> String
getTypeId(e) ==
  let elist = e.entities.entities,
  typeOption1 = if hasAttribute(e,"type") 
                then {getAttribute(e,"type").val} 
                else { getAttribute(elist(i),"xmi:idref").val  | i in set inds elist & elist(i).name = "type"}--,
  --typeOption2 =  union
   --    {a.val | a in set {getAttribute(e,"type")} & a <> nil}
  in 
    let id in set typeOption1-- union typeOption2 
      in
        return id;


private findType : String ==> IUmlType
findType(name) ==
      let typeName = if name in set dom classesTypeMap 
                     then classesTypeMap(name) 
                     else nil 
      in
        cases typeName:
        (nil) -> (log.warn("Issuing unknown type: "^name);return new UmlClassNameType(removeEaPrefix(name))),
        -- (nil)-> return new UmlIntegerType(),
         ("String")-> return new UmlStringType(),
         ("int")-> return new UmlIntegerType(),
         ("bool")-> return new UmlBoolType(),
         ("char")-> return new UmlCharType(),
         ("unlimitedNatural")-> return new UmlUnlimitedNatural(),
         others -> return new UmlClassNameType(typeName)
        end;
        
--private tryFindType : String ==> IUmlType
--tryFindType(id) ==
--  let t : IUmlType = findType(id),
--      typeNameOnFailure : String = t
--  in
--     cases true:
--    (isofclass(IUmlClassNameType,t))-> 
--      let nct : IUmlClassNameType = t
--      in if nct.getName() = nil
--         then return new UmlClassNameType(typeNameOnFailure)
--         else return nct
--    others -> return t
--  end;

-- Visit element and build classes or association dependet on
--  the element type attribute
public VisitXmlEntity: XmlEntity ==> ()
VisitXmlEntity (e) == 
( 
  classes := classes union {exstractClass(entity) | entity in set {e} & 
                   isAttributeType(entity,"uml:Class") and
                   (getNameAttribute(entity) not in set primiticeTypes)};
                   
  associations := associations union {build_Association(entity) | entity in set {e} & 
                   isAttributeType(entity,"uml:Association")};

);

functions
-- Test if a element has an attribute with a specific name
private hasAttribute : XmlEntity * String -> bool
hasAttribute(e,name) ==
  let list = e.attributes.attributes
  in
   exists i in set inds list & list(i).name=name;

-- Test if a element has a specific element with a specific name and type
private hasAttributeValue : XmlEntity * String * String -> bool
hasAttributeValue(e,name,val) ==
  let list = e.attributes.attributes
  in
   exists i in set inds list & list(i).name=name and list(i).val = val;
 
-- Test if a element has a specific type
--  By looking up the type attribute
private isAttributeType : XmlEntity * String -> bool
isAttributeType(e,val) == 
  hasAttributeValue(e,"xmi:type",val);

-- Get the UML type attribute value or the name of the element if no such attribute exists
private getElementType : XmlEntity -> String
getElementType(e) == 
  if getAttribute(e,"xmi:type") <> nil 
  then getAttribute(e,"xmi:type").val
  else e.name;

-- Get XML element from name. If unknown return nil
private getElement : XmlEntity * String -> [XmlEntity]
getElement(e,name) ==
  let list = e.entities.entities,
      allList = [ list(i) | i in set inds list & list(i).name=name ]
  in 
    if len allList > 0 then 
      hd allList
    else
      nil;

-- Get XML attribute from name. If unknown return nil
private getAttribute : XmlEntity * String -> [XmlAttribute]
getAttribute(e,name) ==
  let list = e.attributes.attributes,
      attList = [ list(i) | i in set inds list & list(i).name=name ]
  in 
    if len attList > 0 then 
      hd attList
    else
      nil;
    
-- Convert visibility name to UmlVisibility type
private static GetVisibility : [XmlAttribute] -> IUmlVisibilityKind
GetVisibility(v) ==
  if v <> nil then
  cases v.val:
    ("private") -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE),
    ("public") -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPUBLIC),
--    ("package") -> return new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPACKAGE),
    ("protected") -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPROTECTED)
  end
  else 
    new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE);
operations
------------------------------------------------
-- Dynamic model
------------------------------------------------ 
    
-- Create a Collaboration from a XML node
private build_Collobration : XmlEntity ==> IUmlCollaboration
build_Collobration(e) ==
  let elist = e.entities.entities,
      interactions = { build_Interaction(p) | p in set elems elist & isAttributeType(p,"uml:Interaction")}
  in
    return new UmlCollaboration(interactions)
pre isAttributeType(e,"uml:Collaboration");

-- Create a Collaboration from a XML node
private build_Interaction : XmlEntity ==> IUmlInteraction
build_Interaction(e) ==
  let elist = e.entities.entities,
      props : map String to IUmlProperty = { getAttribute(p,"xmi:id").val |-> build_Property(p,"",nil) | p in set elems elist & isAttributeType(p,"uml:Property")}
  in
  (
      
      lifeLineMap := lifeLineMap ++ {getAttribute(p,"xmi:id").val |-> 
                                       new UmlLifeLine(getNameAttribute(p),
                                           props(getAttribute(p,"represents").val).getType()) 
                                     | p in set elems elist 
                                     & p.name = "lifeline"};

      let
      name : seq of char = getNameAttribute(e),
      lifeLines : set of IUmlLifeLine = rng lifeLineMap,
      mosfragments : set of IUmlInteractionFragment = 
        {build_Fragment(f) | f in set elems elist 
                           & isAttributeType(f,"uml:MessageOccurrenceSpecification")},
      besfragments : set of IUmlInteractionFragment = 
        {build_Fragment(f) | f in set elems elist 
                           & isAttributeType(f,"uml:BehaviorExecutionSpecification")},
      combifragments : set of IUmlInteractionFragment = 
        {build_Fragment(f) | f in set elems elist 
                           & isAttributeType(f,"uml:CombinedFragment")},
      messages : seq of IUmlMessage = 
        [build_Message(elist(i)) | i in set inds elist 
                                 & elist(i).name = "message"]--,
     -- mm =dunion {{let moss : UmlMos = mos in mk_( moss,m) | mos in set mosfragments & isofclass(UmlMos,mos) and mos in set {m.getSendEvent(), m.getSendReceive()}} | m in set elems messages}
      
      in
   --   (for all t in set mm do (let - = t.#1.SetMessage(t.#2)in skip);
        return new UmlInteraction(name,
                                  lifeLines,
                                  mosfragments union besfragments union combifragments,
                                  messages)
     --                             )
  )
pre isAttributeType(e,"uml:Interaction");



-- Create a Collaboration from a XML node
private build_Message : XmlEntity ==> IUmlMessage
build_Message(e) ==
  let --name = getAttribute(e,"name").val,
      messageKind : IUmlMessageKind = new UmlMessageKind(UmlMessageKindQuotes`IQCOMPLETE),
      messageSort : IUmlMessageSort = new UmlMessageSort(UmlMessageSortQuotes`IQSYNCHCALL),
      mosSend : IUmlMos = mosMap(getAttribute(e,"sendEvent").val),
      mosRecive : IUmlMos = mosMap(getAttribute(e,"receiveEvent").val), 
      args : (seq of IUmlValueSpecification)= [],
      name : String = mosRecive.getEvent().getOperation().getName()
  in
    return new UmlMessage(name,
                          messageKind,
                          messageSort,
                          mosSend,
                          mosRecive,
                          args)
pre e.name ="message";


-- Delegating the creation of a fragment to the responsible operation
--  only needed because limitation in Java Code Gen
private build_Fragment : XmlEntity ==> IUmlInteractionFragment
build_Fragment(e) ==
  cases getElementType(e):
    ("uml:MessageOccurrenceSpecification") ->
      return build_Mos(e),
    ("uml:BehaviorExecutionSpecification") ->
      return build_Bes(e),
    ("uml:CombinedFragment") -> 
      return build_Combi(e),
    others -> error
  end
pre isAttributeType(e,"uml:MessageOccurrenceSpecification") or
    isAttributeType(e,"uml:BehaviorExecutionSpecification") or
    isAttributeType(e,"uml:CombinedFragment");

-- Create MOS from XmlElement
private build_Mos : XmlEntity ==> IUmlMos
build_Mos(e) ==
  let name = getNameAttribute(e),
      message : [IUmlMessage] = nil,
      lifeLines : IUmlLifeLine = let l in set {lifeLineMap(c) | c in set elems GetCovered(e)} in l,
      id = getAttribute(e,"xmi:id").val,
      event :IUmlCallEvent = idToClallEventMap(getAttribute(e,"event").val),
      mos = new UmlMos(name,
                       message,
                       lifeLines,
                       event) 
  in
  (
    mosMap := mosMap ++ {id |-> mos};
    return mos
  )
pre isAttributeType(e,"uml:MessageOccurrenceSpecification");

-- Create BES from XmlElement
private build_Bes : XmlEntity ==> IUmlBes
build_Bes(e) ==
  let name               = getNameAttribute(e),
      startOc : IUmlMos  = mosMap(getAttribute(e,"start").val),
      finishOc : IUmlMos = mosMap(getAttribute(e,"finish").val),
      covered : set of IUmlLifeLine = {lifeLineMap(c) | c in set elems GetCovered(e)},
      id = getAttribute(e,"xmi:id").val,
      bes = new UmlBes(name,
                       startOc,
                       finishOc,
                       covered) 
  in
  (
    besMap := besMap ++ {id |-> bes};
    return bes
  )
pre isAttributeType(e,"uml:BehaviorExecutionSpecification");

-- Create CombinedFragment from XmlElement
private build_Combi : XmlEntity ==> IUmlCombinedFragment
build_Combi(e) ==
  let elist = e.entities.entities,
      name               = getNameAttribute(e),
      interactionOperatorKind : IUmlInteractionOperatorKind = GetIntOperationKind(getAttribute(e,"interactionOperator").val),
      operands : seq of IUmlInteractionOperand = [build_Operand(elist(i)) | i in set inds elist & elist(i).name ="operand"  ],
      covered : set of IUmlLifeLine = {lifeLineMap(c) | c in set elems GetCovered(e)},
      id = getAttribute(e,"xmi:id").val,
      combi = new UmlCombinedFragment(name,
                                    interactionOperatorKind,
                                    operands,
                                    covered) 
  in
  (
    combiMap := combiMap ++ {id |-> combi};
    return combi
  )
pre isAttributeType(e,"uml:CombinedFragment");
functions
-- Get interaction kind from a string
private GetIntOperationKind : String -> IUmlInteractionOperatorKind
GetIntOperationKind(text) ==
  cases text:
    ("alt")-> new UmlInteractionOperatorKind(UmlInteractionOperatorKindQuotes`IQALT),
    ("loop")-> new UmlInteractionOperatorKind(UmlInteractionOperatorKindQuotes`IQLOOP)
  end
pre text = "alt" or text = "loop";

operations
-- Create Operand from XmlElement
private build_Operand : XmlEntity ==> IUmlInteractionOperand
build_Operand(e) ==
  let elist = e.entities.entities,
      name : seq of char              = "",
      fragments :  seq of IUmlInteractionFragment = [],
      covered : set of IUmlMos = {mosMap(c) | c in set elems StdLib`Split( conc
                                   [GetCoveredExtension(elist(i)) | i in set inds elist 
                                                           & hasAttributeValue(elist(i),"extender","umltrans")],' ') },
      guard : [IUmlInteractionConstraint] = if exists gu in set elems elist & gu.name ="guard" 
                                            then GetGuard(let g in set {p | p in set elems elist & p.name ="guard"} in g) 
                                            else nil
  in
     return new UmlInteractionOperand(name,
                       fragments,
                       covered,
                       guard) 

pre e.name = "operand";

-- remove EA prefix from name
public removeEaPrefix : String ==> String
removeEaPrefix(name) == return name;
/*
* if(name !=null && name.startsWith("EA") && name.contains("_") && name.indexOf('_')+1 < name.length())
*	  {
*		  log.warn("Removing: " + name.substring(0,name.indexOf('_')+1)+" from: "+ name + " => "+name.substring(name.indexOf('_')+1));
*		  return name.substring(name.indexOf('_')+1);
*	  }
 *   return name;
*/

-- gets the name attribyte but removes EA prefixes first
public getNameAttribute : XmlEntity ==> String
getNameAttribute(e) == return removeEaPrefix(getAttribute(e,"name").val)

functions
-- Get covered extension. Exstracts covered string
private GetCoveredExtension : XmlEntity -> seq of char
GetCoveredExtension(e) ==
  let elist = e.entities.entities in
      let p in set {co.data.data | co in set elems elist & co.name ="covered"}
      in p
pre hasAttributeValue(e,"extender","umltrans") and 
    exists el in set elems e.entities.entities & el.data <> nil and el.name = "covered";

-- Get covered seq of ids
private GetCovered : XmlEntity -> seq of String
GetCovered(e)==
let text : String = getAttribute(e,"covered").val
  in
    StdLib`Split(text,' ')
pre hasAttribute(e,"covered");

-- Get guard from entity
private GetGuard : XmlEntity -> IUmlInteractionConstraint
GetGuard(e)==
let elist = e.entities.entities,
    minint = let tmp in set {getGuardConstraintValue(p) 
                             | p in set elems elist 
                             & p.name = "minint"} in tmp, 
    maxint = let tmp in set {getGuardConstraintValue(p) 
                             | p in set elems elist 
                             & p.name = "maxint"} in tmp
  in
    new UmlInteractionConstraint(minint,maxint)
pre e.name="guard";

-- Get value of constraint on a guard
private getGuardConstraintValue : XmlEntity -> [IUmlValueSpecification]
getGuardConstraintValue(e) ==
  if hasAttribute(e,"value") and isAttributeType(e,"uml:LiteralInteger") 
  then new UmlLiteralInteger(StdLib`StringToInt(getAttribute(e,"value").val))
  else nil; 

operations
-- Build id to callEvent map
private buildCallEventMap : set of XmlEntity ==> map String to IUmlCallEvent
buildCallEventMap(elist) ==
  let m = { getAttribute(e,"xmi:id").val |-> new UmlCallEvent(idToOperationMap(getAttribute(e,"operation").val)) |  
            e in set elist}
  in
    return m
pre forall e in set elist & isAttributeType(e,"uml:CallEvent");


--private GetClassFromId : String ==> [IUmlClass]
--GetClassFromId(id) ==
--  if id in set dom idToclassesMap 
--  then return idToclassesMap(id)
--  else return nil; 

-- Not used
public VisitXmlAttribute: XmlAttribute ==> ()
VisitXmlAttribute (-) == skip;
-- not used
public VisitXmlData: XmlData ==> ()
VisitXmlData (-) == skip;
  
public setEncoding : seq of char ==>()
setEncoding(encodingType) == skip;
  
end Xml2UmlModel
\end{vdm_al}


\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[Xml2UmlModel]

\end{rtinfo}