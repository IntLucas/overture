 


\begin{vdm_al}

class Vdm2Uml
types
public String = seq of char;

instance variables
associations : set of IUmlAssociation := {};
constraints : set of IUmlConstraint := {};
runningId : nat :=0;
log : StatusLog := new StatusLog();
classFilter : seq of String := [];
nestedClasses : set of IUmlClass := {};
operations

public getLog : () ==> StatusLog
getLog() == return log;
------------------------------------------------
------------------------------------------------
--                 Mapper
--
--              VDM++ TO UML 
------------------------------------------------
------------------------------------------------
-- Convert a OmlSpecification to a UML Model
public init : IOmlSpecifications ==> IUmlModel
init(specs) ==
(
  let model = build_uml(specs)
  in 
  (
    model.setDefinitions(model.getDefinitions()  
          union associations 
          union constraints);
    return model;
  );
);

public addFilterClass : String ==> ()
addFilterClass(className) == classFilter := classFilter ^ className;

-- Create the main UML model from a OML specification
public build_uml : IOmlSpecifications ==> UmlModel
build_uml(specs) == 
  let classes = specs.getClassList(),
	  uml_classes = [ build_Class(classes(i)) 
	                | i in set inds classes & classes(i).getIdentifier() not in set elems classFilter] ^ StdLib`SetToSeq[IUmlClass]( nestedClasses)
  in return new UmlModel("Root",elems uml_classes);

-- Convert a OML class to a UML class
-- This includes the creation of properties and associations				
public build_Class : IOmlClass ==> IUmlClass
build_Class(c) ==
(
  log.addNewClassInfo(c.getIdentifier());
  let name       = c.getIdentifier(),
      inh : [IOmlInheritanceClause]  = if c.hasInheritanceClause() 
                                       then c.getInheritanceClause() 
                                       else nil,
      body       = c.getClassBody(),
      isStatic   = false,
      isActive   = card {body(i) 
                        | i in set inds body 
                        & isofclass(IOmlThreadDefinition,body(i))} 
                        > 0,
      dBlock     = [ let dbs : IOmlDefinitionBlock = body(i) 
                     in 
                       build_def_b(dbs,name) 
                   | i in set inds body
                   & not isofclass(IOmlTraceDefinitions,body(i))],         
      dBlockSet  = { d | d in set elems dBlock & d <> nil},
      isAbstract = hasSubclassResponsibilityDefinition(body),
      supers     = getSuperClasses(inh),
      visibility = 
        new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPUBLIC),
      templateParameters = getGenericTypes(c.getGenericTypes())	    
  in 
    return new UmlClass(name,
                        dBlockSet, 
                        isAbstract, 
                        supers, 
                        visibility,
                        isStatic,
                        isActive,
                        templateParameters);
);                       
-- Get template signature from OML types
--  Finds the template parameters                        
public getGenericTypes : seq of IOmlType ==> [IUmlTemplateSignature]
getGenericTypes(genericTypes) ==
  if len genericTypes > 0 
  then return
	new UmlTemplateSignature(
	{ 
     let tn : IOmlTypeName = t in 
      new UmlTemplateParameter(tn.getName().getIdentifier()) 
     | t in set elems genericTypes
     }) 
  else return nil;
  
-- Get super classes from a OML inheritance class.
-- Returns nil if no super classes are found
public getSuperClasses : [IOmlInheritanceClause] ==> seq of IUmlClassNameType
getSuperClasses(inh) == 
  if inh = nil then 
    return [] 
  else
    let list = inh.getIdentifierList()
      in 
        return [new UmlClassNameType(list(i)) | i in set inds list];


-- Test if a OML Class is abstract in UML
-- Checks for a is sub class responsibility operation
-- True if found
public hasSubclassResponsibilityDefinition : seq of IOmlDefinitionBlock ==> bool
hasSubclassResponsibilityDefinition(dBlock) == 
  let opList = conc [ let op : IOmlOperationDefinitions = dBlock(i) 
                in op.getOperationList() | 
                  i in set inds dBlock & isofclass(IOmlOperationDefinitions,dBlock(i))],
                    hasIsSubClassResp = 
                      {let  explicitOp : IOmlExplicitOperation = opList(i).getShape()
                       in explicitOp.getBody().getSubclassResponsibility() | 
                       i in set inds opList & isofclass(IOmlExplicitOperation,opList(i).getShape()) }
  in 
   return exists e in set hasIsSubClassResp & e=true; 

-- Proxy operation. Used to explicit set the type before redirecting operation call
-- This is introduced because of VDM Java gen limitation of type cast in Java
private build_def_b : IOmlDefinitionBlock * String ==> [IUmlDefinitionBlock]
build_def_b(block,owner) ==
  cases(true):
    (isofclass(IOmlInstanceVariableDefinitions,block))-> 
      let tmp : IOmlInstanceVariableDefinitions = block in build_def_block(tmp,owner),
    (isofclass(IOmlValueDefinitions,block))-> 
      let tmp : IOmlValueDefinitions = block in build_def_block(tmp,owner),
    (isofclass(IOmlTypeDefinitions,block))-> 
      let tmp : IOmlTypeDefinitions = block in build_def_block(tmp,owner),
    (isofclass(IOmlOperationDefinitions,block))-> 
      let tmp : IOmlOperationDefinitions = block in build_def_block(tmp,owner),
    (isofclass(IOmlFunctionDefinitions,block))-> 
      let tmp : IOmlFunctionDefinitions = block in build_def_block(tmp,owner),
    
    --(isofclass(IOmlTraceDefinitions,block))-> 
    --let tmp : IOmlTraceDefinitions = block in build_def_block(tmp,owner),
    others -> return nil
  end;
    
 
-----------------------------------------------------
-- Instance variables -------------------------------
-----------------------------------------------------
-- Create properties from OML instanca variables
public build_def_block : IOmlInstanceVariableDefinitions * String ==> 
  IUmlOwnedProperties
build_def_block(v,owner) == 
  let q = v.getVariablesList(),
      props = [ buildVariable(q(i),owner) 
              | i in set inds q 
              & isofclass(IOmlInstanceVariable,q(i)) ]
  in
    return new UmlOwnedProperties({p | p in set elems props 
                                     & p <> nil});

-- Create a UML property from a OML instance variable definition
-- If the instance variable isent mapped to a UML property nil is returned
--  This is the case if the property should be represented as an Association
public buildVariable : IOmlInstanceVariable * String ==> [IUmlProperty]
buildVariable(var,owner) == 
  let
    access       = var.getAccess(),
    scope        = access.getScope(),
    assign       = var.getAssignmentDefinition(),
    isStatic     = access.getStaticAccess(),
    name         = assign.getIdentifier(),
    visibility   = convertScopeToVisibility(scope),
    omlType      = assign.getType(),
    multiplicity = Vdm2UmlType`extractMultiplicity(omlType),
    type         = Vdm2UmlType`convertPropertyType(omlType,owner),
    isReadOnly   = false,
    default      = if assign.hasExpression() 
                   then getDefaultValue(assign.getExpression()) 
                   else nil, 
    isComposite  = isSimpleType(omlType),
    isDerived    = false,
    qualifier : [IUmlType] = Vdm2UmlType`getQualifier(omlType)
  in 
  (
    dcl property : IUmlProperty := new UmlProperty(name, 
                                                visibility, 
                                                multiplicity, 
                                                type, 
                                                isReadOnly, 
                                                default, 
                                                isComposite, 
                                                isDerived, 
                                                isStatic,
                                                owner,
                                                qualifier);
   
    if not isSimpleType(omlType) 
    then 
    (
       CreateAssociationFromProperty(property,omlType);       
       return nil
     )
    else
      return property;
  ); 
 
-- If a default value is defined for a instance variable it is returned
--  as a string else nil
public getDefaultValue : IOmlExpression ==> [IUmlValueSpecification]
getDefaultValue(expression) ==
  cases true:
    (isofclass(IOmlSymbolicLiteralExpression,expression)) -> 
      (let se: IOmlSymbolicLiteralExpression =expression  
       in 
         cases true:
           (isofclass(IOmlTextLiteral,se.getLiteral())) -> 
             (let tx : IOmlTextLiteral =se.getLiteral() in 
               return new UmlLiteralString(tx.getVal())),
           (isofclass(IOmlNumericLiteral,se.getLiteral())) -> 
             (let tx : IOmlNumericLiteral =se.getLiteral() in 
               return new UmlLiteralInteger(tx.getVal())),
           others -> return nil
         end),
    others -> return nil
  end;
  
functions
-- Convert OML visibility to UML visibility
public convertScopeToVisibility : IOmlScope -> IUmlVisibilityKind
convertScopeToVisibility(sc) ==
  let val : nat =sc.getValue() in
  cases val: 
    (OmlScopeQuotes`IQPUBLIC) -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPUBLIC),
    (OmlScopeQuotes`IQPRIVATE),
    (OmlScopeQuotes`IQDEFAULT) -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE),
    (OmlScopeQuotes`IQPROTECTED) -> 
      new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPROTECTED),
    others -> undefined
  end;

operations
-----------------------------------------------------
-- Values 
-----------------------------------------------------
-- Create UML properties from a value definition
public build_def_block : IOmlValueDefinitions * String ==> IUmlOwnedProperties
build_def_block(v,owner) == 
  let q = v.getValueList(),
      props = [ buildValue(q(i),owner) | 
     		 i in set inds q ],
      propsNoNil = {p | p in set elems props 
                      & p <> nil}
  in 
    return new UmlOwnedProperties((propsNoNil));

-- Create a UML property from a Value definition
-- If the value isent presented as a UML property nil is returned
--   Would be the case if mapped as an Assocition
public buildValue : IOmlValueDefinition * String ==> [IUmlProperty]
buildValue(var,owner) == 
  let
    access       = var.getAccess(),
    scope        = access.getScope(),
    shape        = var.getShape()
  in
  (
    if not shape.hasType() then
    (
      log.mappingNotSupported(var);
      return nil;
    )
    else
    (
    let
      isStatic     = access.getStaticAccess(),
      patternIdent : IOmlPatternIdentifier = shape.getPattern(),
      name         = patternIdent.getIdentifier(),
      visibility   = convertScopeToVisibility(scope),
      multiplicity = Vdm2UmlType`extractMultiplicity(shape.getType()),
      type         = Vdm2UmlType`convertType(shape.getType()),
      isReadOnly   = true,
      default      = getDefaultValue(shape.getExpression()),
      isComposite  = isSimpleType(shape.getType()),
      isDerived    = false,
      qualifier : [IUmlType] = Vdm2UmlType`getQualifier(shape.getType()),
      omlType      = shape.getType()
  in 
  (
    dcl property : IUmlProperty := new UmlProperty(name, 
                                                visibility, 
                                                multiplicity, 
                                                type, 
                                                isReadOnly, 
                                                default, 
                                                isComposite, 
                                                isDerived, 
                                                isStatic,
                                                owner,
                                                qualifier);
   
    if not isSimpleType(omlType) 
    then 
    ( 
      CreateAssociationFromProperty(property,omlType);
      return nil
    )
    else
      return property;
  );
  ); 
  );                            

-----------------------------------------------------
-- Types 
-----------------------------------------------------
-- Convert OML type definitions to a UML owned type
public build_def_block : IOmlTypeDefinitions * String ==> IUmlNestedClassifiers
build_def_block(td,-) == 
  let q = td.getTypeList(),
      tps = [ buildType(q(i).getShape(),q(i).getAccess()) 
            | i in set inds q 
            & isofclass(IOmlSimpleType,q(i).getShape()) ]
  in return new UmlNestedClassifiers(elems tps);

-- Convert simple type to UML type
public buildType : IOmlSimpleType * IOmlAccessDefinition ==> IUmlType
buildType(var,access) ==
( 
  if isofclass(IOmlUnionType,var.getType()) then
  (
    nestedClasses := nestedClasses union {buildClassFromType(var,access.getScope())};
    return new UmlClassNameType(var.getIdentifier()); -- return a class ref to the new nested class.
  );
  if isofclass(IOmlSeq0Type,var.getType()) then
  (
    let seqT : IOmlSeq0Type = var.getType()
    in
      if isofclass(IOmlCharType,seqT.getType()) then
      (
         nestedClasses := nestedClasses union {buildClassFromType(var,access.getScope())};
         return new UmlClassNameType(var.getIdentifier()); -- return a class ref to the new nested class.
      );
   );


  return Vdm2UmlType`convertType(var.getType()); 
);

private buildClassFromType : IOmlSimpleType * IOmlScope ==> IUmlClass
buildClassFromType(t,scope) ==
  let name : String                            = t.getIdentifier(),
      classBody  : set of IUmlDefinitionBlock  = {buildTypeDefinitionBlocks(name,t.getType())},
      isAbstract : bool                        = false,
      superClass : seq of IUmlClassNameType    = [],
      visibility : IUmlVisibilityKind          = convertScopeToVisibility(scope),
      isStatic   : bool                        = false,
      isActive   : bool                        = false,
      templatesignature : [IUmlTemplateSignature] = nil
  in
    return new UmlClass(name,classBody,isAbstract,superClass,visibility,isStatic,isActive,templatesignature);
    
private buildTypeDefinitionBlocks : String * IOmlType ==> IUmlDefinitionBlock
buildTypeDefinitionBlocks(ownerName,t) ==
(
  if isofclass(IOmlUnionType,t) then
    let ut : IOmlUnionType = t
    in
      let lhs : IUmlOwnedProperties = buildTypeDefinitionBlocks(ownerName,ut.getLhsType()),
          rhs : IUmlOwnedProperties = buildTypeDefinitionBlocks(ownerName,ut.getRhsType())
      in
        return new UmlOwnedProperties( lhs.getPropetityList()union rhs.getPropetityList());
        
  if isofclass(IOmlQuoteType,t) then
    let qt : IOmlQuoteType = t
    in
      let props : set of IUmlProperty = { buildValueFromQuoteType(ownerName,qt) }
      in
        return new UmlOwnedProperties(props);
        
 return new UmlOwnedProperties({});
);

buildValueFromQuoteType : String * IOmlQuoteType ==> IUmlProperty
buildValueFromQuoteType(ownerName,q) ==
let
      isStatic : bool    = true,
      name     : seq of char    = q.getQuoteLiteral().getVal(),
      visibility : IUmlVisibilityKind  = new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPUBLIC),
      multiplicity : IUmlMultiplicityElement= new UmlMultiplicityElement(true, false, 0, nil),--new UmlMultiplicityElement(isOrdered, isUnique, lower, upper);
      type : IUmlType        = new UmlIntegerType(),--Vdm2UmlType`convertType(shape.getType()),
      isReadOnly   = true,
      default  : [IUmlValueSpecification]    = nil,
      isComposite  = isSimpleType(q),
      isDerived    = false,
      qualifier : [IUmlType] = nil--Vdm2UmlType`getQualifier(shape.getType()),
      
  in 
  return new UmlProperty(name, 
                         visibility, 
                         multiplicity, 
                         type, 
                         isReadOnly, 
                         default, 
                         isComposite, 
                         isDerived, 
                         isStatic,
                         ownerName,
                         qualifier);

-----------------------------------------------------
-- Operations 
-----------------------------------------------------
-- Convert OML operations to UML owwned operations
public build_def_block : IOmlOperationDefinitions * String ==> IUmlOwnedOperations
build_def_block(opDef,owner) == 
  let ops: seq of IOmlOperationDefinition = opDef.getOperationList() 
  in 
    return 
      new UmlOwnedOperations({buildOperation(ops(i),owner) 
                             | i in set inds ops});
  
-- Convert a OML operation definition to a UML definition
-- All parameters are ignored - Project time limitation
public buildOperation : IOmlOperationDefinition * String ==> IUmlOperation
buildOperation(op,-) ==
  let
    access       = op.getAccess(),
    scope        = access.getScope(),
    shape : IOmlExplicitOperation = op.getShape(),
    
    isStatic     = access.getStaticAccess(),
    name         = shape.getIdentifier(),
    visibility   = convertScopeToVisibility(scope),
    multiplicity = new UmlMultiplicityElement(false, false, 1, 1),
    type         = Vdm2UmlType`convertType(shape.getType()),
    pars         = buildParameters(shape.getParameterList(),shape.getType())
  in return new UmlOperation(name, 
                            visibility, 
                            multiplicity, 
                            false,
                            type, 
                            isStatic,
                            new UmlParameters(pars)
                            ); 

-- Converts a sequence of IOmlPattern and the coresponding IOmlType to
-- UmlParameters. It exstracts the return first and then the rest
-- of parameters afterwards
private buildParameters : seq of IOmlPattern * IOmlType ==> seq of IUmlParameter
buildParameters(parms, type) ==
let names = [let p : IOmlPatternIdentifier = parms(i) in p.getIdentifier() 
            | i in set inds parms
            & isofclass(IOmlPatternIdentifier,parms(i))],
    tps   = buildParameterTypes(type),
    ret : [IUmlParameter]  = let t = if isofclass(IOmlOperationType,type) 
                    then let tmp : IOmlOperationType  = type in tmp
                    else
                    ( if isofclass(IOmlPartialFunctionType,type) then 
                      let tmp : IOmlPartialFunctionType  = type in tmp
                      else nil)
            in new UmlParameter("return", 
                             let tmpType: IUmlType = Vdm2UmlType`convertType(t.getRngType()) in tmpType
                             ,
                             Vdm2UmlType`extractMultiplicity(t.getRngType()) ,
                             "",
                             new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQRETURN)
                             ),
    ps    = [new UmlParameter(names(i), 
                             Vdm2UmlType`convertType(tps(i)),
                             Vdm2UmlType`extractMultiplicity(tps(i)),
                             "",
                             new UmlParameterDirectionKind(UmlParameterDirectionKindQuotes`IQIN)
                             )
            | i in set inds names ]
in
   if ret <> nil then 
   return ps ^ [ret]
    else
    ( 
    log.mappingNotSupported(parms,type);
  return  ps;
    
    );
    

-- Converts a IOmlType used in parameters to a sequence of IOmlTypes
-- Which is consistent with the parameters
private buildParameterTypes : IOmlType ==> seq of IOmlType
buildParameterTypes(t) ==
cases true:
	(isofclass(IOmlProductType,t))		-> 
	let type : IOmlProductType = t
            in 
	  return buildParameterTypes(type.getLhsType()) ^
	         buildParameterTypes(type.getRhsType()), 
	(isofclass(IOmlOperationType,t))		->  
	let type : IOmlOperationType = t
            in
	  return buildParameterTypes(type.getDomType()),
	(isofclass(IOmlPartialFunctionType,t))		->  
	let type : IOmlPartialFunctionType = t
            in
	  return buildParameterTypes(type.getDomType()),
others -> return [t]
end;


-----------------------------------------------------
-- Functions 
-----------------------------------------------------
-- Convert OML functions to UML owhed operations
public build_def_block : IOmlFunctionDefinitions * String ==> IUmlOwnedOperations
build_def_block(opDef,owner) == 
  let ops: seq of IOmlFunctionDefinition = opDef.getFunctionList() 
  in return new UmlOwnedOperations({buildFunction(ops(i),owner) 
                                   | i in set inds ops});
  
-- Convert a OML functions definition to a UML definition
-- All parameters are ignored - Project time limitation
public buildFunction : IOmlFunctionDefinition * String ==> IUmlOperation
buildFunction(op,-) ==
  let
    access       = op.getAccess(),
    scope        = access.getScope(),
    shape : IOmlExplicitFunction = op.getShape(),
    isStatic     = access.getStaticAccess(),
    name         = shape.getIdentifier(),
    visibility   = convertScopeToVisibility(scope),
    multiplicity = new UmlMultiplicityElement(false, false, 1, 1),
    type         = Vdm2UmlType`convertType(shape.getType()),
    pnames :  [IOmlParameter]       = if len shape.getParameterList() = 0 
                                      then nil 
                                      else let p in set elems shape.getParameterList() 
                                           in p,
    pars         = buildParameters(if pnames<>nil 
                                   then pnames.getPatternList() 
                                   else [],shape.getType())
  in return new UmlOperation(name, 
                            visibility, 
                            multiplicity, 
                            true,
                            type, 
                            isStatic,
                            new UmlParameters(pars)); 
-----------------------------------------------------
-- Association 
-----------------------------------------------------
functions
-- Check if a OML type is mapped to a UML simple type                  
public isSimpleType : IOmlType -> bool
isSimpleType(t) ==
  cases true:
    (isofclass(IOmlInjectiveMapType,t)),
    (isofclass(IOmlGeneralMapType,t)),
    (isofclass(IOmlTypeName,t)),
    (isofclass(IOmlProductType,t)),
    (isofclass(IOmlUnionType,t)) -> false,
    (isofclass(IOmlSetType,t)) -> 
      let t1: IOmlSetType = t 
        in isSimpleType(t1.getType()),
	(isofclass(IOmlSeq0Type,t)) -> 
	  let t1: IOmlSeq0Type = t 
	    in isSimpleType(t1.getType()),
	(isofclass(IOmlSeq1Type,t)) -> 
	  let t1: IOmlSeq1Type = t 
	    in isSimpleType(t1.getType()),
	(isofclass(IOmlOptionalType,t)) -> 
	  let t1 : IOmlOptionalType = t 
	    in isSimpleType(t1.getType()),
	    
    others -> true
  end;
  
-- Get a simple type name
private GetSimpleTypeName : IUmlType -> String
GetSimpleTypeName(t) ==
  cases true:
	(isofclass(IUmlBoolType,t))		-> ("bool"),
	(isofclass(IUmlIntegerType,t))	-> ("int"),
	(isofclass(IUmlCharType,t))		-> ("char"),
	others 							-> ("String")
  end;

operations
-- Create an Association from a UML property and a OML type
-- The association is store in instance variable in the class
public CreateAssociationFromProperty : IUmlProperty * IOmlType ==> ()
CreateAssociationFromProperty(property,omlType) ==
  cases true:
    (isofclass(IOmlProductType,omlType)) ->  
      CreateAssociationFromPropertyProductType(property,omlType),
    (isofclass(IOmlUnionType,omlType)) ->  
      CreateAssociationFromPropertyUnionType(property,omlType),
    others ->  
      CreateAssociationFromPropertyGeneral(property,omlType)
  end;

-- Create a UML association from a UML property where the OML type contains a OML type name
public CreateAssociationFromPropertyGeneral : IUmlProperty * IOmlType ==> ()
CreateAssociationFromPropertyGeneral(property,-) ==
   let ownerClassName = if isofclass(IUmlClassNameType,property.getType()) 
                        then let pcn : IUmlClassNameType = property.getType() 
                             in pcn.getName() 
                        else GetSimpleTypeName(property.getType()),
       propOtherEnd = {new UmlProperty("",
               new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE),
               nil,
               new UmlClassNameType(property.getOwnerClass()), --
               nil,
               nil,
               false,
               nil,
               nil,
               ownerClassName,
               nil)
          } in
        associations := associations union 
          {new UmlAssociation(propOtherEnd, {property},nil,GetNextId())};
          
-- Create a UML association from a UML property where the OML type is a product type
public CreateAssociationFromPropertyProductType : IUmlProperty * IOmlType ==> ()
CreateAssociationFromPropertyProductType(property,omlType) == 
let name : String = property.getName() , 
    prop : UmlProperty = property,
    props : set of IUmlProperty = dunion {CreateEndProperty(p,name)
                                              | p in set {omlType} 
                                              & isofclass(IOmlProductType,p)}
  in
  (
    prop.setName("");
    if card props > 1 then -- props <= 1 This is not an association => it was not a product type       
      associations := associations union 
        {new UmlAssociation(props,  {prop},nil,GetNextId())};
     ); 
-- Create a UML association from a UML property where the OML type is a union type
public CreateAssociationFromPropertyUnionType : IUmlProperty * IOmlType ==> ()
CreateAssociationFromPropertyUnionType(property,omlType) == 
let name : String = property.getName(), 
    prop : UmlProperty = property,
    props : set of IUmlProperty = dunion {CreateEndProperty(p,name)
                                              | p in set {omlType} 
                                              & isofclass(IOmlUnionType,p)}
  in
  (
      prop.setName("");
      if card props > 1 then
      (
        dcl assoc : set of IUmlAssociation := 
          {new UmlAssociation({p}, {prop},nil,GetNextId()) 
          | p in set props};
        associations := associations union assoc; 
        --create constraint
        constraints := constraints union 
          { new UmlConstraint({a.getId() | a in set assoc},new UmlLiteralString("xor"))};
       );
    );

-- Create Association ends from a OML type
--  Ends constructed from Product and Union type and the anonymus end at the 
--   property owner end of a assocation
public CreateEndProperty : IOmlType * String ==> set of IUmlProperty
CreateEndProperty(t,name) ==
(
  if (isofclass(IOmlProductType,t)) then
  (
    let typedType : IOmlProductType = t 
    in
    return CreateEndProperty(typedType.getLhsType(),name) 
      union CreateEndProperty(typedType.getRhsType(),name);
  ) 
  else if (isofclass(IOmlUnionType,t)) then
  (
    let typedType : IOmlUnionType = t 
    in
    return CreateEndProperty(typedType.getLhsType(),name) 
      union CreateEndProperty(typedType.getRhsType(),name);
  )
  else
    return {new UmlProperty(name,
                new UmlVisibilityKind(UmlVisibilityKindQuotes`IQPRIVATE),
                Vdm2UmlType`extractMultiplicity(t),
                Vdm2UmlType`convertType(t),
                nil,
                nil,
                false,
                nil,
                nil,
                "Implementation prosponed",
                Vdm2UmlType`getQualifier(t))};

);

-----------------------------------------------------
-- Other constructs 
-----------------------------------------------------
--public build_def_block : IOmlSynchronizationDefinitions * String ==> IUmlOtherDefinitions
--build_def_block(-,-) == return new UmlOtherDefinitions();

--public build_def_block : IOmlThreadDefinition * String ==> IUmlOtherDefinitions
--build_def_block(-,-) == return new UmlOtherDefinitions();

--public build_def_block : IOmlTraceDefinitions * String ==> IUmlOtherDefinitions
--build_def_block(-,-) == return new UmlOtherDefinitions();


---------------------------------------------------------
---- Others
---------------------------------------------------------
-- Get a new Id
private GetNextId : () ==> String
GetNextId() ==
(
  runningId := runningId +1;
  return Util`ToString[nat](runningId);
);


end Vdm2Uml

\end{vdm_al}


\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[Vdm2Uml]

\end{rtinfo}