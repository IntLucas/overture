-- TCErrors: PROOFOBLIGATION: fDExNSBGaW5kQWxsUmVmZXJlbmNlc1RvRW50aXR5LCBwYXJtcyxlaW4gaW4gc2V0IGRvbSAoaW5fbW9kZWwuZGF0YXNlYykKLG1hcCBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDEyOSBGaW5kQWxsSW5zdGFuY2VzLCByZWMsZWluIGluIHNldCBkb20gKGluX21vZGVsLmRhdGFzZWMpCixtYXAgYXBwbHksbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE0MSBMb29rVXBFbnRpdHlJbnN0YW5jZSwgcmVjLGVpbiBpbiBzZXQgZG9tIChpbl9tb2RlbC5kYXRhc2VjKQosbWFwIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1MCBUcmFuc2Zvcm1SbVZlcnRleCwgY3BudF9pZCw1IGluIHNldCBpbmRzIHBhcm1zCixzZXF1ZW5jZSBhcHBseSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDE1MCBUcmFuc2Zvcm1SbVZlcnRleCwgY3BudF9pZCxleGlzdHMgbWtfRW50aXR5SW5zdGFuY2VOYW1lKGNwbnRfaWQpOlBhcmFtZXRlciAmIG1rX0VudGl0eUluc3RhbmNlTmFtZShjcG50X2lkKSA9IHBhcm1zKDUpCix2YWx1ZSBiaW5kaW5nLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1MCBUcmFuc2Zvcm1SbVZlcnRleCwgY3BudF9pZCxpc18ocGFybXMoNSksIEVudGl0eUluc3RhbmNlTmFtZSkKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE1OCBUcmFuc2Zvcm1SbUVkZ2UsIHJtZWVzLDMgaW4gc2V0IGluZHMgcGFybXMKLHNlcXVlbmNlIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1OCBUcmFuc2Zvcm1SbUVkZ2UsIHJtZWVzLGV4aXN0cyBta19MaXN0UGFyYW1ldGVyKHJtZWVzKTpQYXJhbWV0ZXIgJiBta19MaXN0UGFyYW1ldGVyKHJtZWVzKSA9IHBhcm1zKDMpCix2YWx1ZSBiaW5kaW5nLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE1OCBUcmFuc2Zvcm1SbUVkZ2UsIHJtZWVzLGlzXyhwYXJtcygzKSwgTGlzdFBhcmFtZXRlcikKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE2MiBUcmFuc2Zvcm1SbUVkZ2UsIHJtZWVfaWQsZXhpc3RzIG1rX0VudGl0eUluc3RhbmNlTmFtZShybWVlX2lkKTpQYXJhbWV0ZXIgJiBta19FbnRpdHlJbnN0YW5jZU5hbWUocm1lZV9pZCkgPSBybWVlCix2YWx1ZSBiaW5kaW5nLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE2MiBUcmFuc2Zvcm1SbUVkZ2UsIHJtZWVfaWQsaXNfKHJtZWUsIEVudGl0eUluc3RhbmNlTmFtZSkKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE3MyBUcmFuc2Zvcm1SbUxvb3AsIHJtZXNzLDIgaW4gc2V0IGluZHMgcGFybXMKLHNlcXVlbmNlIGFwcGx5LG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE3MyBUcmFuc2Zvcm1SbUxvb3AsIHJtZXNzLGV4aXN0cyBta19MaXN0UGFyYW1ldGVyKHJtZXNzKTpQYXJhbWV0ZXIgJiBta19MaXN0UGFyYW1ldGVyKHJtZXNzKSA9IHBhcm1zKDIpCix2YWx1ZSBiaW5kaW5nLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE3MyBUcmFuc2Zvcm1SbUxvb3AsIHJtZXNzLGlzXyhwYXJtcygyKSwgTGlzdFBhcmFtZXRlcikKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE3NiBUcmFuc2Zvcm1SbUxvb3AsIHJtZXNfaWQsZXhpc3RzIG1rX0VudGl0eUluc3RhbmNlTmFtZShybWVzX2lkKTpQYXJhbWV0ZXIgJiBta19FbnRpdHlJbnN0YW5jZU5hbWUocm1lc19pZCkgPSBybWVzCix2YWx1ZSBiaW5kaW5nLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDE3NiBUcmFuc2Zvcm1SbUxvb3AsIHJtZXNfaWQsaXNfKHJtZXMsIEVudGl0eUluc3RhbmNlTmFtZSkKLHN1YnR5cGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDE5OSBDcmVhdGUsZm9yYWxsIGxkb20xIGluIHNldCBkb20gTG9va1VwVGFibGUsIHJkb20yIGluIHNldCBkb20ge2VudCB8LT4gbGFzdF9pZH0gJgpsZG9tMSA9IHJkb20yID0+IExvb2tVcFRhYmxlKGxkb20xKSA9IHtlbnQgfC0+IGxhc3RfaWR9KHJkb20yKQosbWFwIGNvbXBhdGlibGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDIwMiBDcmVhdGUsMyBpbiBzZXQgaW5kcyBwYXJtcwosc2VxdWVuY2UgYXBwbHksbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDIwMSBDcmVhdGUsZm9yYWxsIGxkb20xIGluIHNldCBkb20gZHMsIHJkb20yIGluIHNldCBkb20ge2xhc3RfaWQgfC0+IG1rXyhuaWwsIG1rX1NpbXBsZVJlY29yZCgiVkVSVEVYIiwgW3Bhcm1zKDMpXSkpfSAmCmxkb20xID0gcmRvbTIgPT4gZHMobGRvbTEpID0ge2xhc3RfaWQgfC0+IG1rXyhuaWwsIG1rX1NpbXBsZVJlY29yZCgiVkVSVEVYIiwgW3Bhcm1zKDMpXSkpfShyZG9tMikKLG1hcCBjb21wYXRpYmxlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDIwNiBDcmVhdGUsZm9yYWxsIGxkb20xIGluIHNldCBkb20gZHMsIHJkb20yIGluIHNldCBkb20ge2xhc3RfaWQgfC0+IG1rXyhuaWwsIG1rX1NpbXBsZVJlY29yZCgiUE9MWUxJTkUiLCBbbWtfTGlzdFBhcmFtZXRlcihNYXBJblRvT3V0KHBvbHksIExvb2tVcFRhYmxlKSldKSl9ICYKbGRvbTEgPSByZG9tMiA9PiBkcyhsZG9tMSkgPSB7bGFzdF9pZCB8LT4gbWtfKG5pbCwgbWtfU2ltcGxlUmVjb3JkKCJQT0xZTElORSIsIFtta19MaXN0UGFyYW1ldGVyKE1hcEluVG9PdXQocG9seSwgTG9va1VwVGFibGUpKV0pKX0ocmRvbTIpCixtYXAgY29tcGF0aWJsZSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDIxMSBDcmVhdGUsZm9yYWxsIGxkb20xIGluIHNldCBkb20gZHMsIHJkb20yIGluIHNldCBkb20geyhsYXN0X2lkICsgMSkgfC0+IG1rXyhuaWwsIG1rX1NpbXBsZVJlY29yZCgiRFJBV0lORyIsIFtta19MaXN0UGFyYW1ldGVyKHBvbHlsaXN0KV0pKX0gJgpsZG9tMSA9IHJkb20yID0+IGRzKGxkb20xKSA9IHsobGFzdF9pZCArIDEpIHwtPiBta18obmlsLCBta19TaW1wbGVSZWNvcmQoIkRSQVdJTkciLCBbbWtfTGlzdFBhcmFtZXRlcihwb2x5bGlzdCldKSl9KHJkb20yKQosbWFwIGNvbXBhdGlibGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDIxNCBDcmVhdGUsZm9yYWxsIG0xLCBtMiBpbiBzZXQge3siRklMRV9OQU1FIiB8LT4gW21rX1Vua25vd25QYXJhbWV0ZXIoKV19LCB7IkZJTEVfREVTQ1JJUFRJT04iIHwtPiBbbWtfVW5rbm93blBhcmFtZXRlcigpXX0sIHsiRklMRV9TQ0hFTUEiIHwtPiBbbWtfVW5rbm93blBhcmFtZXRlcigpXX19ICYKICBmb3JhbGwgZDMgaW4gc2V0IGRvbSBtMSwgZDQgaW4gc2V0IGRvbSBtMiAmCiAgICBkMyA9IGQ0ID0+IG0xKGQzKSA9IG0yKGQ0KQosbWFwIHNlcXVlbmNlIGNvbXBhdGlibGUsbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDIzMyBNYXBJblRvT3V0LChmb3JhbGwgaW5zOnNlcSBvZiAobmF0KSwgbHV0Om1hcCAobmF0KSB0byAobmF0KSAmCiAgKG5vdCAoaW5zID0gW10pID0+CiAgICAoaGQgaW5zKSBpbiBzZXQgZG9tIGx1dCkpCixtYXAgYXBwbHksbnVsbCxVbnByb3ZlZHw= PROOFOBLIGATION: fDIzMyBNYXBJblRvT3V0LChmb3JhbGwgaW5zOnNlcSBvZiAobmF0KSwgbHV0Om1hcCAobmF0KSB0byAobmF0KSAmCiAgKG5vdCAoaW5zID0gW10pID0+CiAgICBpbnMgPD4gW10pKQosbm9uLWVtcHR5IHNlcXVlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDIyOCBNYXBJblRvT3V0LChmb3JhbGwgaW5zOnNlcSBvZiAobmF0KSwgbHV0Om1hcCAobmF0KSB0byAobmF0KSAmCiAgKG5vdCAoaW5zID0gW10pID0+CiAgICBMZW5QYXIxKGlucywgbHV0KSA+IExlblBhcjEoKHRsIGlucyksIGx1dCkpKQoscmVjdXJzaXZlIGZ1bmN0aW9uLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDIzMyBNYXBJblRvT3V0LChmb3JhbGwgaW5zOnNlcSBvZiAobmF0KSwgbHV0Om1hcCAobmF0KSB0byAobmF0KSAmCiAgKG5vdCAoaW5zID0gW10pID0+CiAgICBpbnMgPD4gW10pKQosbm9uLWVtcHR5IHNlcXVlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDI0NCBDb2xsZWN0LChmb3JhbGwgdGhlU2V0OnNldCBvZiAoc2VxIG9mIChuYXQpKSAmCiAgKG5vdCB7fSA9IHRoZVNldCA9PgogICAgZXhpc3RzIGUgaW4gc2V0IHRoZVNldCkpCixsZXQgYmUgc3QgZXhpc3RlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDI0MCBDb2xsZWN0LChmb3JhbGwgdGhlU2V0OnNldCBvZiAoc2VxIG9mIChuYXQpKSAmCiAgKG5vdCB7fSA9IHRoZVNldCA9PgogICAgKGZvcmFsbCBlIGluIHNldCB0aGVTZXQgJgogICAgICBTZXRDYXJkKHRoZVNldCkgPiBTZXRDYXJkKCh0aGVTZXQgXCB7ZX0pKSkpKQoscmVjdXJzaXZlIGZ1bmN0aW9uLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDI1NSBJc0EsIG5hbWUsKGZvcmFsbCByZWM6UmVjb3JkLCBubTpzZXEgb2YgKGNoYXIpICYKICAoaXNfKHJlYywgU2ltcGxlUmVjb3JkKSA9PgogICAgZXhpc3RzIG1rX1NpbXBsZVJlY29yZChuYW1lLCAtKTpSZWNvcmQgJiBta19TaW1wbGVSZWNvcmQobmFtZSwgLSkgPSByZWMpKQosdmFsdWUgYmluZGluZyxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDI1NSBJc0EsIG5hbWUsKGZvcmFsbCByZWM6UmVjb3JkLCBubTpzZXEgb2YgKGNoYXIpICYKICAoaXNfKHJlYywgU2ltcGxlUmVjb3JkKSA9PgogICAgaXNfKHJlYywgU2ltcGxlUmVjb3JkKSkpCixzdWJ0eXBlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDI2NSBTb3J0SW5uZXJMZWZ0LChmb3JhbGwgdGhlU2V0OnNldCBvZiAoKG5hdCAqIG5hdCkpLCBnb2FsOm5hdCAmCiAgKG5vdCB7fSA9IHRoZVNldCA9PgogICAgZXhpc3RzIG1rXyhhLCBiKSBpbiBzZXQgdGhlU2V0ICYgKGEgPSBnb2FsKSkpCixsZXQgYmUgc3QgZXhpc3RlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDI3NCBTb3J0SW5uZXJSaWdodCwoZm9yYWxsIHRoZVNldDpzZXQgb2YgKChuYXQgKiBuYXQpKSwgZ29hbDpuYXQgJgogIChub3Qge30gPSB0aGVTZXQgPT4KICAgIGV4aXN0cyBta18oYSwgYikgaW4gc2V0IHRoZVNldCAmIChiID0gZ29hbCkpKQosbGV0IGJlIHN0IGV4aXN0ZW5jZSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDI4MCBTb3J0UG9pbnRzLChmb3JhbGwgdGhlU2V0OnNldCBvZiAoKG5hdCAqIG5hdCkpICYKICBleGlzdHMgbWtfKGEsIGIpIGluIHNldCB0aGVTZXQpCixsZXQgYmUgc3QgZXhpc3RlbmNlLG51bGwsVW5wcm92ZWR8


--express.vdmsl

\documentclass{article}
\usepackage{a4}
\usepackage{makeidx}
\usepackage{vdmsl-2e}

\newcommand{\StateDef}[1]{{\bf #1}}
\newcommand{\TypeDef}[1]{{\bf #1}}
\newcommand{\TypeOcc}[1]{{\it #1}}
\newcommand{\FuncDef}[1]{{\bf #1}}
\newcommand{\FuncOcc}[1]{#1}
\newcommand{\ModDef}[1]{{\tiny #1}}

\makeindex

\begin{document}

\title{Mapping between EXPRESS representations}
\author{Submitted by Marcel Verhoef}
\maketitle

\begin{vdm_al}
module Database

exports all

definitions

types
  
PhysicalFile ::
  headersec : map seq of char to seq of Parameter
  datasec   : map nat to ([Scope] * Record);

HeaderEntity ::
  name  : seq of char
  parms : seq of Parameter;

Scope :: ;

Record = SimpleRecord | SuperRecord ;

SuperRecord ::
  rec_list : seq of SimpleRecord;

SimpleRecord ::
  name  : seq of char
  parms : seq of Parameter;

Parameter = StringParameter |
            RealParameter |
            IntegerParameter |
            EntityInstanceName |
            EnumerationParameter |
            BinaryParameter |
            ListParameter |
            TypedParameter |
            OmittedParameter |
            UnknownParameter ;

StringParameter ::
  data : seq of char;

RealParameter ::
  data : real;

IntegerParameter ::
  data : int;

EntityInstanceName ::
  data : nat;

EnumerationParameter ::
  data : seq of char;

BinaryParameter ::
  data : bool;

ListParameter ::
  data : seq of Parameter;

TypedParameter::
  name : seq of char
  data : Parameter;

OmittedParameter:: ;

UnknownParameter::

operations

CheckReferences: Parameter ==> set of nat
CheckReferences(parm) ==
  cases parm:
    mk_EntityInstanceName(id) -> return {id},
    mk_ListParameter(parms) ->
        ( dcl res : set of nat := {};
          for subparm in parms do
            res := res union CheckReferences(subparm);
          return res),
    others -> return {}
  end;

FindAllReferencesToEntity: nat ==> set of nat
FindAllReferencesToEntity (eid) ==
  let eins = dom in_model.datasec \ {eid} 
  in
  ( dcl res : set of nat := {};
    for all ein in set eins do
      let mk_(-,mk_SimpleRecord(-,parms)) = 
          in_model.datasec(ein) 
      in
        if eid in set CheckReferences(
                       mk_ListParameter(parms)) 
        then res := res union {ein};
    return res
  );

FindAllInstances: seq of char ==> set of nat
FindAllInstances(nm) ==
  let eins = dom in_model.datasec 
  in
  ( dcl res : set of nat := {};
    for all ein in set eins do
      let mk_(-,rec) = in_model.datasec(ein) 
      in
        if IsA (rec, nm) 
        then res := res union {ein};
    return res
  );
 
LookUpEntityInstance: nat ==> [Record]
LookUpEntityInstance (ein) ==
  let eins = dom in_model.datasec 
  in
    if ein in set eins 
    then let mk_(-,rec) = in_model.datasec(ein) 
         in
           return rec
    else return nil;

TransformRmVertex: nat ==> nat
TransformRmVertex(rmv_id) ==
  let mk_SimpleRecord(-,parms) = LookUpEntityInstance (rmv_id) 
  in
    let mk_EntityInstanceName(cpnt_id) = parms(5) 
    in
      return cpnt_id;

TransformRmEdge: nat ==> set of (nat * nat)
TransformRmEdge (rme_id) ==
  let mk_SimpleRecord(-,parms) = LookUpEntityInstance(rme_id) 
  in
    let mk_ListParameter(rmees) = parms(3) 
    in
    ( dcl res : set of (nat * nat) := {};
      for rmee in rmees do
        let mk_EntityInstanceName(rmee_id) = rmee 
        in
          let {rmee_ref} = FindAllReferencesToEntity(rmee_id)\{rme_id} 
          in
            res := res union {mk_(rme_id, TransformRmVertex(rmee_ref))};
      return res
    );

       TransformRmLoop: nat ==> seq of nat
       TransformRmLoop (rml_id) ==
          let mk_SimpleRecord(-,parms) = LookUpEntityInstance (rml_id) in
          let mk_ListParameter(rmess) = parms(2) in
            ( dcl res : set of (nat * nat) := {};
              for rmes in rmess do
                let mk_EntityInstanceName(rmes_id) = rmes in
                let rme_ref = FindAllReferencesToEntity(rmes_id) \ {rml_id} in
                   for all rme_id in set rme_ref do
                     res := res union TransformRmEdge(rme_id);
              return SortPoints(res)
            );

       Transform: () ==> set of seq of nat
       Transform () ==
          let rmls = FindAllInstances("RM_LOOP") in
            ( dcl res : set of seq of nat := {};
              for all rml in set rmls do
                 res := res union {TransformRmLoop(rml)};
              return res
            );

      Create: set of seq of nat ==> ()
      Create (AbstrMod) ==
         ( dcl ds : map nat to ([Scope] * Record) := {|->},
               LookUpTable : map nat to nat := {|->},
               polylist : seq of EntityInstanceName := [];
           for all ent in set Collect(AbstrMod) do
             ( last_id := last_id + 1;
               LookUpTable := LookUpTable munion { ent |-> last_id };
               let mk_SimpleRecord(-,parms) = LookUpEntityInstance(ent) in
                 ds := ds munion { last_id |-> mk_(nil, 
                   mk_SimpleRecord("VERTEX",[parms(3)]))}
             );
           for all poly in set AbstrMod do
             ( last_id := last_id + 1;
               ds := ds munion { last_id |-> mk_(nil,
                 mk_SimpleRecord("POLYLINE",[mk_ListParameter(
                   MapInToOut(poly,LookUpTable))]))};
               polylist := polylist ^ [mk_EntityInstanceName(last_id)]
             );
           ds := ds munion { last_id + 1 |-> mk_(nil,
             mk_SimpleRecord("DRAWING",[mk_ListParameter(polylist)]))};
           out_model := mk_PhysicalFile (
             { "FILE_NAME" |-> [mk_UnknownParameter()],
               "FILE_DESCRIPTION" |-> [mk_UnknownParameter()],
               "FILE_SCHEMA" |-> [mk_UnknownParameter()] }
             , ds )
        );

       DoMapping: PhysicalFile ==> PhysicalFile
       DoMapping (pf) ==
         ( in_model := pf;
           Create(Transform());
           return out_model
         )

    functions
      MapInToOut : seq of nat * map nat to nat -> seq of EntityInstanceName
      MapInToOut (ins, lut) ==
         if ins = [] then
           []
         else
           [mk_EntityInstanceName(lut(hd ins))] ^ MapInToOut(tl ins, lut)
      measure LenPar1;
      
      LenPar1: seq of nat * map nat to nat -> nat
      LenPar1(list,-) ==
        len list;

      Collect : set of seq of nat -> set of nat
      Collect (theSet) ==
        cases theSet:
          {} -> {},
          others -> let e in set theSet in elems e union Collect(theSet\{e})
        end
      measure SetCard;
      
      SetCard: set of seq of nat -> nat
      SetCard(s) ==
        card s;

      IsA: Record * seq of char -> bool
      IsA(rec,nm) ==
        if is_SimpleRecord(rec) then
          let mk_SimpleRecord (name,-) = rec in
             nm = name
        else
          false;

      SortInnerLeft: set of (nat * nat) * nat -> seq of nat
      SortInnerLeft (theSet, goal) ==
         cases theSet:
           {} -> [],
           others ->
             let mk_(a,b) in set theSet be st a = goal in
                SortInnerRight(theSet\{mk_(a,b)}, b)
         end;

      SortInnerRight: set of (nat * nat) * nat -> seq of nat
      SortInnerRight (theSet,goal) ==
         cases theSet:
           {} -> [],
           others ->
             let mk_(a,b) in set theSet be st b = goal in
                [b] ^ SortInnerLeft(theSet\{mk_(a,b)}, a)
         end;

      SortPoints : set of (nat * nat) -> seq of nat
      SortPoints (theSet) ==
         let mk_(a,b) in set theSet in
           SortInnerRight(theSet\{mk_(a,b)},b)

    state Kernel of
      in_model : PhysicalFile
      out_model : PhysicalFile
      last_id : nat
    init
      k == k = mk_Kernel(
                 mk_PhysicalFile({|->},{|->}),
                 mk_PhysicalFile({|->},{|->}),
                 0
               )
    end

end Database
\end{vdm_al}


\printindex
\end{document}