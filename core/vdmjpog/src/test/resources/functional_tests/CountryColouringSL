-- TCErrors: WARNING:5000:52,3 WARNING:5000:90,3 PROOFOBLIGATION: fDUyIGNvbE1hcCwoZm9yYWxsIHI6UmVsYXRpb24gJgogIHByZV9jb2xNYXAocikgPT4gZXhpc3RzIGNvbHM6Q29sb3VyaW5nICYgcG9zdF9jb2xNYXAociwgY29scykpCixmdW5jdGlvbiBzYXRpc2ZpYWJpbGl0eSxudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDY2IGV4dG5kQ29sLChmb3JhbGwgY29sczpDb2xvdXJpbmcsIGM6Q291bnRyeSwgcjpSZWxhdGlvbiAmCiAgKG5vdCAoY29scyA9IHt9KSA9PgogICAgZXhpc3RzIGNvbCBpbiBzZXQgY29scykpCixsZXQgYmUgc3QgZXhpc3RlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDYyIGV4dG5kQ29sLChmb3JhbGwgY29sczpDb2xvdXJpbmcsIGM6Q291bnRyeSwgcjpSZWxhdGlvbiAmCiAgKG5vdCAoY29scyA9IHt9KSA9PgogICAgKGZvcmFsbCBjb2wgaW4gc2V0IGNvbHMgJgogICAgICAobm90IGNhbkJlRXh0QnkoY29sLCBjLCByKSA9PgogICAgICAgIENhcmRDb2xvdXJpbmcoY29scywgYywgcikgPiBDYXJkQ29sb3VyaW5nKChjb2xzIFwge2NvbH0pLCBjLCByKSkpKSkKLHJlY3Vyc2l2ZSBmdW5jdGlvbixudWxsLFVucHJvdmVkfA== PROOFOBLIGATION: fDgxIGNvbENudHJzLChmb3JhbGwgY3M6c2V0IG9mIChDb3VudHJ5KSwgcjpSZWxhdGlvbiAmCiAgKG5vdCAoY3MgPSB7fSkgPT4KICAgIGV4aXN0cyBjIGluIHNldCBjcykpCixsZXQgYmUgc3QgZXhpc3RlbmNlLG51bGwsVW5wcm92ZWR8 PROOFOBLIGATION: fDc3IGNvbENudHJzLChmb3JhbGwgY3M6c2V0IG9mIChDb3VudHJ5KSwgcjpSZWxhdGlvbiAmCiAgKG5vdCAoY3MgPSB7fSkgPT4KICAgIChmb3JhbGwgYyBpbiBzZXQgY3MgJgogICAgICBDYXJkQ291bnRyeShjcywgcikgPiBDYXJkQ291bnRyeSgoY3MgXCB7Y30pLCByKSkpKQoscmVjdXJzaXZlIGZ1bmN0aW9uLG51bGwsVW5wcm92ZWR8


--CountryColouring.vdmsl

\begin{vdm_al}
types

  Country = seq of char;

  Relation = set of (Country * Country);

  Colour = set of Country;

  Colouring = set of Colour;

functions

  isRelation: Relation -> bool
  isRelation(r) ==
    forall mk_(c1,c2) in set r & c1 <> c2;

  areNb: Country * Country * Relation -> bool
  areNb(cn1,cn2,r) ==
    mk_(cn1,cn2) in set r or mk_(cn2,cn1) in set r;

  CountriesRel: Relation -> set of Country
  CountriesRel(r) ==
    dunion {{c1,c2} | mk_(c1,c2) in set r};

  sameColour: Country * Country * Colouring -> bool
  sameColour(cn1,cn2,cols) ==
    exists col in set cols & cn1 in set col and cn2 in set col;

  CountriesCol: Colouring -> set of Country
  CountriesCol(cols) ==
    dunion cols;

  isColouring: Colouring -> bool
  isColouring(cols) ==
    forall col1,col2 in set cols & col1 <> col2 => col1 inter col2 = {};

  isColouringOf: Colouring * set of Country -> bool
  isColouringOf(cols,cns) ==
    CountriesCol(cols) = cns;

  nbDistinctColours: Colouring * Relation -> bool
  nbDistinctColours(cols,r) ==
    forall cn1, cn2 in set CountriesRel(r) &
           areNb(cn1,cn2,r) => not sameColour(cn1,cn2,cols);

  colMap(r: Relation) cols : Colouring 
  pre isRelation(r)
  post isColouring(cols) and
       isColouringOf(cols, CountriesRel(r)) and
       nbDistinctColours(cols, r);

  canBeExtBy: Colour * Country * Relation -> bool 
  canBeExtBy(col, c, r) ==
    forall c1 in set col & not areNb(c1, c, r);

  extndCol: Colouring * Country * Relation -> Colouring
  extndCol(cols,c,r) ==
    if cols = {} 
    then {{c}}
    else let col in set cols 
         in
           if canBeExtBy(col,c,r)
           then { {c} union col } union cols \ {col}
           else { col } union extndCol(cols \ {col}, c, r)
  measure CardColouring;

  CardColouring: Colouring * Country * Relation -> nat
  CardColouring(cols,-,-) ==
    card cols;

  colCntrs: set of Country * Relation -> Colouring
  colCntrs(cs, r) ==
    if cs = {} 
    then  {}
    else let c in set cs 
         in 
           extndCol(colCntrs(cs\{c}, r), c, r)
  measure CardCountry;

  CardCountry: set of Country * Relation -> nat
  CardCountry(cs,-) ==
    card cs;

  colMapExpl: Relation -> Colouring
  colMapExpl(r) ==
    colCntrs(CountriesRel(r), r)
   pre isRelation(r)
\end{vdm_al}