// this file is automatically generated by treegen. do not modify!

package org.overturetool.VDM2JavaCG.ast.java.imp;

// import the abstract tree interfaces
import org.overturetool.VDM2JavaCG.ast.java.itf.*;

// import java collection types
import java.util.*;

public class JavaMethodBody extends JavaNode implements IJavaMethodBody
{
	// private member variable (precondition)
	private IJavaExpression m_precondition = null;

	// public operation to check optional type status
	public boolean hasPrecondition() { return (m_precondition != null); };

	// public operation to retrieve the embedded private field value
	public IJavaExpression getPrecondition()
	{
		return m_precondition;
	}

	// public operation to set the embedded private field value
	public void setPrecondition(IJavaExpression p_precondition)
	{
		// instantiate the member variable
		m_precondition = p_precondition;

		// set the parent of the parameter passed
		p_precondition.setParent(this);
	}

	// private member variable (statement)
	private List<IJavaStatement> m_statement = null;

	// public operation to check optional type status
	public boolean hasStatement() { return (m_statement != null); };

	// public operation to retrieve the embedded private field value
	public List<IJavaStatement> getStatement()
	{
		return m_statement;
	}

	// public operation to set the embedded private field value
	public void setStatement(List<IJavaStatement> p_statement)
	{
		// instantiate the member variable
		m_statement = p_statement;

		// set the parent of each element in the sequence parameter passed
		for (IJavaNode lnode: p_statement) lnode.setParent(this);
	}

	// private member variable (subclass_responsibility)
	private Boolean m_subclass_responsibility = new Boolean(false);

	// public operation to retrieve the embedded private field value
	public Boolean getSubclassResponsibility()
	{
		return m_subclass_responsibility;
	}

	// public operation to set the embedded private field value
	public void setSubclassResponsibility(Boolean p_subclass_responsibility)
	{
		// consistency check (field must be non null!)
		assert(p_subclass_responsibility != null);

		// instantiate the member variable
		m_subclass_responsibility = p_subclass_responsibility;
	}

	// private member variable (Implicit)
	private Boolean m_Implicit = new Boolean(false);

	// public operation to retrieve the embedded private field value
	public Boolean getImplicit()
	{
		return m_Implicit;
	}

	// public operation to set the embedded private field value
	public void setImplicit(Boolean p_Implicit)
	{
		// consistency check (field must be non null!)
		assert(p_Implicit != null);

		// instantiate the member variable
		m_Implicit = p_Implicit;
	}

	// private member variable (postcondition)
	private String m_postcondition = null;

	// public operation to check optional type status
	public boolean hasPostcondition() { return (m_postcondition != null); };

	// public operation to retrieve the embedded private field value
	public String getPostcondition()
	{
		return m_postcondition;
	}

	// public operation to set the embedded private field value
	public void setPostcondition(String p_postcondition)
	{
		// instantiate the member variable
		m_postcondition = p_postcondition;
	}

	// default constructor
	public JavaMethodBody()
	{
		super();
		m_precondition = null;
		m_statement = null;
		m_subclass_responsibility = null;
		m_Implicit = null;
		m_postcondition = null;
	}

	// auxiliary constructor
	public JavaMethodBody(
		IJavaExpression p_precondition,
		List<IJavaStatement> p_statement,
		Boolean p_subclass_responsibility,
		Boolean p_Implicit,
		String p_postcondition
	) {
		super();
		setPrecondition(p_precondition);
		setStatement(p_statement);
		setSubclassResponsibility(p_subclass_responsibility);
		setImplicit(p_Implicit);
		setPostcondition(p_postcondition);
	}

	// visitor support
	public void accept(IJavaVisitor pVisitor) { pVisitor.visitMethodBody(this); }

	// the identity function
	public String identify() { return "JavaMethodBody"; }
}
