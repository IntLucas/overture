-- TCErrors: WARNING:5000:52,3 WARNING:5000:90,3 PROOFOBLIGATION: Y29sTWFwLDAsKGZvcmFsbCByOlJlbGF0aW9uICYKICBwcmVfY29sTWFwKHIpID0+IGV4aXN0cyBjb2xzOkNvbG91cmluZyAmIHBvc3RfY29sTWFwKHIsIGNvbHMpKQosZnVuY3Rpb24gc2F0aXNmaWFiaWxpdHksbnVsbCxVbnByb3ZlZCw= PROOFOBLIGATION: ZXh0bmRDb2wsMCwoZm9yYWxsIGNvbHM6Q29sb3VyaW5nLCBjOkNvdW50cnksIHI6UmVsYXRpb24gJgogIChub3QgKGNvbHMgPSB7fSkgPT4KICAgIGV4aXN0cyBjb2wgaW4gc2V0IGNvbHMpKQosbGV0IGJlIHN0IGV4aXN0ZW5jZSxudWxsLFVucHJvdmVkLA== PROOFOBLIGATION: ZXh0bmRDb2wsMCwoZm9yYWxsIGNvbHM6Q29sb3VyaW5nLCBjOkNvdW50cnksIHI6UmVsYXRpb24gJgogIChub3QgKGNvbHMgPSB7fSkgPT4KICAgIChmb3JhbGwgY29sIGluIHNldCBjb2xzICYKICAgICAgKG5vdCBjYW5CZUV4dEJ5KGNvbCwgYywgcikgPT4KICAgICAgICBDYXJkQ29sb3VyaW5nKGNvbHMsIGMsIHIpID4gQ2FyZENvbG91cmluZygoY29scyBcIHtjb2x9KSwgYywgcikpKSkpCixyZWN1cnNpdmUgZnVuY3Rpb24sbnVsbCxVbnByb3ZlZCw= PROOFOBLIGATION: Y29sQ250cnMsMCwoZm9yYWxsIGNzOnNldCBvZiAoQ291bnRyeSksIHI6UmVsYXRpb24gJgogIChub3QgKGNzID0ge30pID0+CiAgICBleGlzdHMgYyBpbiBzZXQgY3MpKQosbGV0IGJlIHN0IGV4aXN0ZW5jZSxudWxsLFVucHJvdmVkLA== PROOFOBLIGATION: Y29sQ250cnMsMCwoZm9yYWxsIGNzOnNldCBvZiAoQ291bnRyeSksIHI6UmVsYXRpb24gJgogIChub3QgKGNzID0ge30pID0+CiAgICAoZm9yYWxsIGMgaW4gc2V0IGNzICYKICAgICAgQ2FyZENvdW50cnkoY3MsIHIpID4gQ2FyZENvdW50cnkoKGNzIFwge2N9KSwgcikpKSkKLHJlY3Vyc2l2ZSBmdW5jdGlvbixudWxsLFVucHJvdmVkLA==


--CountryColouring.vdmsl

\begin{vdm_al}
types

  Country = seq of char;

  Relation = set of (Country * Country);

  Colour = set of Country;

  Colouring = set of Colour;

functions

  isRelation: Relation -> bool
  isRelation(r) ==
    forall mk_(c1,c2) in set r & c1 <> c2;

  areNb: Country * Country * Relation -> bool
  areNb(cn1,cn2,r) ==
    mk_(cn1,cn2) in set r or mk_(cn2,cn1) in set r;

  CountriesRel: Relation -> set of Country
  CountriesRel(r) ==
    dunion {{c1,c2} | mk_(c1,c2) in set r};

  sameColour: Country * Country * Colouring -> bool
  sameColour(cn1,cn2,cols) ==
    exists col in set cols & cn1 in set col and cn2 in set col;

  CountriesCol: Colouring -> set of Country
  CountriesCol(cols) ==
    dunion cols;

  isColouring: Colouring -> bool
  isColouring(cols) ==
    forall col1,col2 in set cols & col1 <> col2 => col1 inter col2 = {};

  isColouringOf: Colouring * set of Country -> bool
  isColouringOf(cols,cns) ==
    CountriesCol(cols) = cns;

  nbDistinctColours: Colouring * Relation -> bool
  nbDistinctColours(cols,r) ==
    forall cn1, cn2 in set CountriesRel(r) &
           areNb(cn1,cn2,r) => not sameColour(cn1,cn2,cols);

  colMap(r: Relation) cols : Colouring 
  pre isRelation(r)
  post isColouring(cols) and
       isColouringOf(cols, CountriesRel(r)) and
       nbDistinctColours(cols, r);

  canBeExtBy: Colour * Country * Relation -> bool 
  canBeExtBy(col, c, r) ==
    forall c1 in set col & not areNb(c1, c, r);

  extndCol: Colouring * Country * Relation -> Colouring
  extndCol(cols,c,r) ==
    if cols = {} 
    then {{c}}
    else let col in set cols 
         in
           if canBeExtBy(col,c,r)
           then { {c} union col } union cols \ {col}
           else { col } union extndCol(cols \ {col}, c, r)
  measure CardColouring;

  CardColouring: Colouring * Country * Relation -> nat
  CardColouring(cols,-,-) ==
    card cols;

  colCntrs: set of Country * Relation -> Colouring
  colCntrs(cs, r) ==
    if cs = {} 
    then  {}
    else let c in set cs 
         in 
           extndCol(colCntrs(cs\{c}, r), c, r)
  measure CardCountry;

  CardCountry: set of Country * Relation -> nat
  CardCountry(cs,-) ==
    card cs;

  colMapExpl: Relation -> Colouring
  colMapExpl(r) ==
    colCntrs(CountriesRel(r), r)
   pre isRelation(r)
\end{vdm_al}