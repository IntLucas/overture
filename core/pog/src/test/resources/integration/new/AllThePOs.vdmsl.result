["non-zero obligation:(forall p1:nat, p2:nat, p3:bool \u0026 (p3 \u003d\u003e (p2 \u003c\u003e 0)))","non-zero obligation:(forall p1:nat, p2:nat, p3:bool \u0026 ((p3 \u003d\u003e ((p1 / p2) \u003e 0)) \u003d\u003e (exists result:nat \u0026 (p2 \u003c\u003e 0))))","function postcondition satisfiable obligation:(forall p1:nat, p2:nat, p3:bool \u0026 (pre_impF1(p1, p2, p3) \u003d\u003e (exists result:nat \u0026 post_impF1(p1, p2, p3, result))))","function establishes postcondition obligation:(forall n:nat, m:MapT \u0026 (pre_expF1(n, m) \u003d\u003e post_expF1(n, m, m(n))))","legal map application obligation:(forall n:nat, m:MapT \u0026 ((n in set (dom m)) \u003d\u003e (n in set (dom m))))","map compatible obligation:(forall m1:MapT, m2:MapT \u0026 (forall ldom1 in set (dom m1), rdom2 in set (dom m2) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m1(ldom1) \u003d m2(rdom2)))))","non-zero obligation:(forall n:nat, s:SeqT \u0026 (((len s) \u003e n) \u003d\u003e (n \u003c\u003e 0)))","non-zero obligation:(forall n:nat, s:SeqT \u0026 ((((len s) \u003e n) and (((len s) / n) \u003e 4)) \u003d\u003e (n \u003c\u003e 0)))","legal sequence application obligation:(forall n:nat, s:SeqT \u0026 ((((len s) \u003e n) and (((len s) / n) \u003e 4)) \u003d\u003e ((((len s) / n) \u003e 4) \u003d\u003e (n in set (inds s)))))","sequence modification obligation:(forall s:SeqT, m:MapT \u0026 ((dom m) subset (inds s)))","legal function application obligation:(forall n:nat \u0026 pre_expF3(n, []))","map iteration obligation:(forall m:MapT, n:nat \u0026 (((m ** n) \u003d 0) null (((m ** n) \u003d 1) null ((rng m) null (dom m)))))","non-empty sequence obligation:(forall s:SeqT \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e [])))","non-empty set obligation:(forall setn:set of (set of (nat)) \u0026 (setn \u003c\u003e {}))","cases exhaustive obligation:(forall e:EnumT \u0026 ((e \u003d \u003cA\u003e) or (e \u003d \u003cB\u003e)))","cases exhaustive obligation:(forall e:EnumT2 \u0026 ((exists mk_RecType(a, b, c):EnumT2 \u0026 (e \u003d mk_RecType(a, b, c))) or (exists mk_RecType2(a, c):EnumT2 \u0026 (e \u003d mk_RecType2(a, c)))))","let be st existence obligation:(forall s:SetT \u0026 (exists x in set s \u0026 (x \u003e 5)))","let be st existence obligation:(forall s:SetT \u0026 ((not let x in set s be st (x \u003e 5) in true) \u003d\u003e (exists x:SetT \u0026 true)))","map compose obligation:(forall m:MapT2, m2:MapT3 \u0026 ((rng m) null (dom m2)))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}, {4 |-\u003e 3}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","comprehension map injectivity obligation:(forall s:set of (MapT) \u0026 (forall m1, m2 in set s \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e b} | a:nat, b:nat \u0026 auxFunc(a, b)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","finite map obligation:(exists finmap1:map (nat) to (map (nat) to (nat)) \u0026 (forall a:nat, b:nat \u0026 (auxFunc(a, b) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d {a |-\u003e b})))))","finite set obligation:(exists finmap1:map (nat) to (nat) \u0026 (forall a:nat \u0026 (auxFunc2(a) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d a)))))","legal function application obligation:(forall n:nat \u0026 pre_((auxFunc3 ** n)0))","function iteration obligation:(forall n:nat \u0026 ((n \u003e 1) \u003d\u003e (forall arg1:nat \u0026 (pre_auxFunc3(arg1) \u003d\u003e pre_auxFunc3(arg1)(auxFunc3(arg1))))))","legal function application obligation:(forall n:nat \u0026 pre_((auxFunc4a comp auxFunc4b)n))","function compose obligation:(forall n:nat \u0026 (forall arg1:nat \u0026 (pre_auxFunc4b(arg1) \u003d\u003e pre_auxFunc4a(auxFunc4b(arg1)))))","function postcondition satisfiable obligation:(forall n:nat \u0026 (pre_auxFunc4a(n) \u003d\u003e (exists rs:nat \u0026 post_auxFunc4a(n, rs))))","function postcondition satisfiable obligation:(forall n:nat \u0026 (pre_auxFunc4b(n) \u003d\u003e (exists rs:nat \u0026 post_auxFunc4b(n, rs))))","tuple selection obligation:(forall x:UT1 \u0026 (not is_(x, int)))","legal sequence application obligation:(1 in set (inds sq1))","value binding obligation:(exists mk_(x, y):((nat1 * nat1) | nat1) \u0026 (mk_(x, y) \u003d sq1(1)))","type compatibility obligation:is_(sq1(1), (nat1 * nat1))","state invariant satisfiable obligation:(exists n2:nat \u0026 ((s.n2) \u003e 4))","non-empty sequence obligation:((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e []))","operation postcondition satisfiable obligation:(forall s:SeqT, oldstate:S \u0026 (pre_impOp1(s, oldstate) \u003d\u003e (exists r:nat \u0026 post_impOp1(s, oldstate, r, oldstate, newstate))))","non-empty sequence obligation:(forall s:SeqT, oldstate:S \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e [])))","non-empty sequence obligation:(forall s:SeqT, oldstate:S \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e [])))","operation establishes postcondition obligation:(forall s:SeqT, oldstate:S \u0026 ((s \u003c\u003e []) \u003d\u003e (RESULT \u003d (hd s))))","while loop termination obligation:...","state invariant holds obligation:(forall seqT:SeqT, oldstate:S \u0026 let s \u003d S in ((s.n2) \u003e 4))","non-empty sequence obligation:(forall seqT:SeqT, oldstate:S \u0026 (s \u003c\u003e []))","state invariant holds obligation:(forall seqT:SeqT, oldstate:S \u0026 let s \u003d S in ((s.n2) \u003e 4))","non-empty sequence obligation:(forall seqT:SeqT, oldstate:S \u0026 (s \u003c\u003e []))","unique existence binding obligation:(forall setT:SetT, oldstate:S \u0026 (exists1 x in set setT \u0026 (x \u003e 1)))","state invariant holds obligation:(forall n:nat, oldstate:S \u0026 let s \u003d S in ((s.n2) \u003e 4))"]