["non-empty sequence obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 53:50: (forall source:(unresolved VCParser`SOURCE) \u0026 ((not ([] \u003d source)) \u003d\u003e (source \u003c\u003e [])))","non-empty sequence obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 53:63: (forall source:(unresolved VCParser`SOURCE) \u0026 ((not ([] \u003d source)) \u003d\u003e (source \u003c\u003e [])))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 56:39: is_([takeChar(\"0123456789\"(index)) | index in set {1, ... ,10}], seq1 of (PARSER))","legal sequence application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 56:49: (forall index in set {1, ... ,10} \u0026 (index in set (inds \"0123456789\")))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 57:55: is_([takeChar(\"abcdefghijklmnopqrstuvwxyz\"(index)) | index in set {1, ... ,26}], seq1 of (PARSER))","legal sequence application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 57:65: (forall index in set {1, ... ,26} \u0026 (index in set (inds \"abcdefghijklmnopqrstuvwxyz\")))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 58:55: is_([takeChar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"(index)) | index in set {1, ... ,26}], seq1 of (PARSER))","legal sequence application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 58:65: (forall index in set {1, ... ,26} \u0026 (index in set (inds \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))","non-empty sequence obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 76:28: (forall c:char \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((not ([] \u003d source)) \u003d\u003e (source \u003c\u003e []))))","non-empty sequence obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 76:76: (forall c:char \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((not ([] \u003d source)) \u003d\u003e (((hd source) \u003d c) \u003d\u003e (source \u003c\u003e [])))))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 81:23: (forall string:seq1 of (char) \u0026 is_([takeChar(string(index)) | index in set (inds string)], seq1 of (PARSER)))","legal sequence application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 81:33: (forall string:seq1 of (char) \u0026 (forall index in set (inds string) \u0026 (index in set (inds string))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 88:42: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 pre_((hd parsers)source)))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 91:54: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in ((not (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(mk_ERROR(msg), any1) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e (exists mk_(-, []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 ((mk_(any1, []) \u003d mk_(tree1, (tl parsers))) \u003d\u003e let mk_(-, []) \u003d mk_(tree1, (tl parsers)) in is_([tree1], seq of (TREE)))))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 93:53: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in ((not (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(mk_ERROR(msg), any1) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e ((not (exists mk_(-, []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(any1, []) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e (exists mk_(-, rest):((ERROR | TREE) * seq1 of (PARSER)) \u0026 ((mk_(any1, rest) \u003d mk_(tree1, (tl parsers))) \u003d\u003e let mk_(-, rest) \u003d mk_(tree1, (tl parsers)) in pre_(series(rest)source1)))))))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 95:81: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in ((not (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(mk_ERROR(msg), any1) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e ((not (exists mk_(-, []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(any1, []) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e (exists mk_(-, rest):((ERROR | TREE) * seq1 of (PARSER)) \u0026 ((mk_(any1, rest) \u003d mk_(tree1, (tl parsers))) \u003d\u003e let mk_(-, rest) \u003d mk_(tree1, (tl parsers)) in let mk_PARSED(tree2, source2):PARSED \u003d series(rest)(source1) in (exists mk_TREE(-, trees2):(ERROR | TREE) \u0026 ((mk_TREE(any1, trees2) \u003d tree2) \u003d\u003e let mk_TREE(-, trees2) \u003d tree2 in (is_(([tree1] ^ trees2), seq of (TREE)) or is_(([tree1] ^ trees2), seq of (char)))))))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 94:25: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in ((not (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(mk_ERROR(msg), any1) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e ((not (exists mk_(-, []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(any1, []) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e (exists mk_(-, rest):((ERROR | TREE) * seq1 of (PARSER)) \u0026 ((mk_(any1, rest) \u003d mk_(tree1, (tl parsers))) \u003d\u003e let mk_(-, rest) \u003d mk_(tree1, (tl parsers)) in let mk_PARSED(tree2, source2):PARSED \u003d series(rest)(source1) in ((exists mk_TREE(-, trees2):(ERROR | TREE) \u0026 (tree2 \u003d mk_TREE(any1, trees2))) or (exists mk_ERROR(message):(ERROR | TREE) \u0026 (tree2 \u003d mk_ERROR(message))))))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 89:13: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in (((exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(mk_ERROR(msg), any1))) or (exists mk_(-, []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(any2, [])))) or (exists mk_(-, rest):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(any3, rest))))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 102:42: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 pre_((hd parsers)source)))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 105:42: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in ((not (exists mk_(mk_ERROR(msg), []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(mk_ERROR(msg), []) \u003d mk_(tree1, (tl parsers))))) \u003d\u003e (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 ((mk_(mk_ERROR(msg), any1) \u003d mk_(tree1, (tl parsers))) \u003d\u003e let mk_(mk_ERROR(msg), -) \u003d mk_(tree1, (tl parsers)) in pre_(either((tl parsers))source))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 103:13: (forall parsers:seq1 of (PARSER) \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d (hd parsers)(source) in (((exists mk_(mk_ERROR(msg), []):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(mk_ERROR(msg), []))) or (exists mk_(mk_ERROR(msg), -):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(mk_ERROR(msg), any1)))) or (exists mk_(tree, rest):((ERROR | TREE) * seq1 of (PARSER)) \u0026 (mk_(tree1, (tl parsers)) \u003d mk_(tree, rest))))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 114:61: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((not (exists mk_PARSED(mk_ERROR(-), -):PARSED \u0026 (mk_PARSED(mk_ERROR(any1), any2) \u003d parser(source)))) \u003d\u003e (exists mk_PARSED(tree, rest):PARSED \u0026 ((mk_PARSED(tree, rest) \u003d parser(source)) \u003d\u003e let mk_PARSED(tree, rest) \u003d parser(source) in pre_(star(parser)rest))))))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 115:50: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((not (exists mk_PARSED(mk_ERROR(-), -):PARSED \u0026 (mk_PARSED(mk_ERROR(any1), any2) \u003d parser(source)))) \u003d\u003e (exists mk_PARSED(tree, rest):PARSED \u0026 ((mk_PARSED(tree, rest) \u003d parser(source)) \u003d\u003e let mk_PARSED(tree, rest) \u003d parser(source) in let mk_PARSED(mk_TREE(-, trees), source2):PARSED \u003d star(parser)(rest) in (is_(([tree] ^ trees), seq of (TREE)) or is_(([tree] ^ trees), seq of (char))))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 111:9: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((exists mk_PARSED(mk_ERROR(-), -):PARSED \u0026 (parser(source) \u003d mk_PARSED(mk_ERROR(any1), any2))) or (exists mk_PARSED(tree, rest):PARSED \u0026 (parser(source) \u003d mk_PARSED(tree, rest))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 120:9: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((exists mk_PARSED(mk_ERROR(-), -):PARSED \u0026 (parser(source) \u003d mk_PARSED(mk_ERROR(any1), any2))) or (exists success:PARSED \u0026 (parser(source) \u003d success)))))","function compose obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 134:9: (forall parser:PARSER \u0026 (forall arg1:PARSED \u0026 (pre_(series([star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)])), parser, star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)]))])arg1) \u003d\u003e pre_((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_ERROR(-), -) -\u003e parsed,\nmk_PARSED(mk_TREE(-, contents), rest) -\u003e mk_PARSED(contents(2), rest)\n end))series([star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)])), parser, star(either([takeChar(\u0027 \u0027), takeChar(\u0027\t\u0027)]))])(arg1)))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 142:41: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 pre_(parsersource)))","legal sequence application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 146:42: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d parser(source) in ((not (exists mk_ERROR(-):(ERROR | TREE) \u0026 (mk_ERROR(any1) \u003d tree1))) \u003d\u003e (exists mk_TREE(-, -):(ERROR | TREE) \u0026 ((mk_TREE(any1, any2) \u003d tree1) \u003d\u003e let mk_TREE(-, -) \u003d tree1 in (forall index in set {1, ... ,((len source) - (len source1))} \u0026 (index in set (inds source))))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 143:13: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 let mk_PARSED(tree1, source1):PARSED \u003d parser(source) in ((exists mk_ERROR(-):(ERROR | TREE) \u0026 (tree1 \u003d mk_ERROR(any1))) or (exists mk_TREE(-, -):(ERROR | TREE) \u0026 (tree1 \u003d mk_TREE(any2, any3))))))","function compose obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 159:14: (forall parser:PARSER \u0026 (forall arg1:PARSED \u0026 (pre_(parserarg1) \u003d\u003e pre_((lambda [p:(unresolved VCParser`PARSED)] \u0026 (cases p :\nmk_PARSED(mk_ERROR(message), rest) -\u003e p,\nmk_PARSED(mk_TREE(label, contents), rest) -\u003e (if (contents \u003d [])\nthen mk_PARSED(mk_TREE(nil, contents), rest)\nelseif is_(contents, seq of (char))\nthen mk_PARSED(mk_TREE(nil, contents), rest)\nelse mk_PARSED(mk_TREE(nil, (conc [let mk_TREE(-, subcontent):(TREE | char) \u003d contents(index) in subcontent | index in set (inds contents)])), rest))\n end))parser(arg1)))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 163:9: (forall parser:PARSER \u0026 (forall source:(unresolved VCParser`SOURCE) \u0026 ((exists mk_PARSED(mk_TREE(label, contents), rest):PARSED \u0026 (parser(source) \u003d mk_PARSED(mk_TREE(label, contents), rest))) or (exists err:PARSED \u0026 (parser(source) \u003d err)))))","function compose obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 173:14: (forall newLabel:LABEL, parser:PARSER \u0026 (forall arg1:PARSED \u0026 (pre_(parserarg1) \u003d\u003e pre_((lambda [parsed:(unresolved VCParser`PARSED)] \u0026 (cases parsed :\nmk_PARSED(mk_TREE(-, contents), source) -\u003e mk_PARSED(mk_TREE(newLabel, contents), source)\nothers parsed\n end))parser(arg1)))))","function compose obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 176:41: (forall modifier:(PARSED -\u003e PARSED), parser:PARSER \u0026 (forall arg1:PARSED \u0026 (pre_(parserarg1) \u003d\u003e pre_(modifierparser(arg1)))))","legal function application obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 182:48: (forall modifier:(TREE -\u003e TREE), parser:PARSER \u0026 (forall parsed:(unresolved VCParser`PARSED) \u0026 ((not (exists mk_PARSED(mk_ERROR(message), rest):PARSED \u0026 (mk_PARSED(mk_ERROR(message), rest) \u003d parsed))) \u003d\u003e (exists mk_PARSED(tree, rest):PARSED \u0026 ((mk_PARSED(tree, rest) \u003d parsed) \u003d\u003e let mk_PARSED(tree, rest) \u003d parsed in pre_(modifiertree))))))","type compatibility obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 182:57: (forall modifier:(TREE -\u003e TREE), parser:PARSER \u0026 (forall parsed:(unresolved VCParser`PARSED) \u0026 ((not (exists mk_PARSED(mk_ERROR(message), rest):PARSED \u0026 (mk_PARSED(mk_ERROR(message), rest) \u003d parsed))) \u003d\u003e (exists mk_PARSED(tree, rest):PARSED \u0026 ((mk_PARSED(tree, rest) \u003d parsed) \u003d\u003e let mk_PARSED(tree, rest) \u003d parsed in is_(tree, TREE))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 180:33: (forall modifier:(TREE -\u003e TREE), parser:PARSER \u0026 (forall parsed:(unresolved VCParser`PARSED) \u0026 ((exists mk_PARSED(mk_ERROR(message), rest):PARSED \u0026 (parsed \u003d mk_PARSED(mk_ERROR(message), rest))) or (exists mk_PARSED(tree, rest):PARSED \u0026 (parsed \u003d mk_PARSED(tree, rest))))))","cases exhaustive obligation in \u0027VCParser\u0027 (VCParser.vdmsl) at line 188:13: (forall message:seq of (char), parser:PARSER \u0026 (forall parsed:(unresolved VCParser`PARSED) \u0026 ((exists mk_PARSED(mk_ERROR(-), rest):PARSED \u0026 (parsed \u003d mk_PARSED(mk_ERROR(any1), rest))) or (exists mk_PARSED(mk_TREE(-, -), -):PARSED \u0026 (parsed \u003d mk_PARSED(mk_TREE(any2, any3), any4))))))","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 46:16: pre_(trimBlanksinteger)","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 47:16: pre_(series[takeChar(\u0027*\u0027), parseInt])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 47:24: pre_(takeChar\u0027*\u0027)","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 48:16: pre_(series[takeChar(\u0027/\u0027), parseInt])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 48:24: pre_(takeChar\u0027/\u0027)","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 49:17: pre_(transtreeliftOperator, series([parseInt, star(either([parseMul, parseDiv]))]))","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 49:41: pre_(series[parseInt, star(either([parseMul, parseDiv]))])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 51:9: pre_(stareither([parseMul, parseDiv]))","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 51:14: pre_(either[parseMul, parseDiv])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 52:16: pre_(series[takeChar(\u0027+\u0027), parseTerm])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 52:24: pre_(takeChar\u0027+\u0027)","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 53:16: pre_(series[takeChar(\u0027-\u0027), parseTerm])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 53:24: pre_(takeChar\u0027-\u0027)","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 54:23: pre_(transtreeliftOperator, series([parseTerm, star(either([parseAdd, parseSub]))]))","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 54:47: pre_(series[parseTerm, star(either([parseAdd, parseSub]))])","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 56:9: pre_(stareither([parseAdd, parseSub]))","legal function application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 56:14: pre_(either[parseAdd, parseSub])","value binding obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 60:13: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in (exists mk_TREE(-, rights):(TREE | char) \u0026 (mk_TREE(any1, rights) \u003d right)))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 60:43: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in is_(right, TREE))","legal map application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 63:17: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in ((not ([] \u003d rights)) \u003d\u003e (exists [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest:(seq of (TREE) | seq of (char)) \u0026 ((([mk_TREE(any1, [mk_TREE(any2, operator), operand])] ^ rest) \u003d rights) \u003d\u003e let [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest \u003d rights in (mk_VCParser`TREE(nil, [mk_VCParser`TREE(operator, [left, operand]), mk_VCParser`TREE(nil, rest)]) in set (dom liftOperator))))))","legal sequence application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 63:17: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in ((not ([] \u003d rights)) \u003d\u003e (exists [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest:(seq of (TREE) | seq of (char)) \u0026 ((([mk_TREE(any1, [mk_TREE(any2, operator), operand])] ^ rest) \u003d rights) \u003d\u003e let [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest \u003d rights in (mk_VCParser`TREE(nil, [mk_VCParser`TREE(operator, [left, operand]), mk_VCParser`TREE(nil, rest)]) in set (inds liftOperator))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 64:38: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in ((not ([] \u003d rights)) \u003d\u003e (exists [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest:(seq of (TREE) | seq of (char)) \u0026 ((([mk_TREE(any1, [mk_TREE(any2, operator), operand])] ^ rest) \u003d rights) \u003d\u003e let [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest \u003d rights in is_(operator, [seq of (char)])))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 64:48: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in ((not ([] \u003d rights)) \u003d\u003e (exists [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest:(seq of (TREE) | seq of (char)) \u0026 ((([mk_TREE(any1, [mk_TREE(any2, operator), operand])] ^ rest) \u003d rights) \u003d\u003e let [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest \u003d rights in ((is_([left, operand], seq of (TREE)) and (is_(left, TREE) and is_(operand, TREE))) or (is_([left, operand], seq of (char)) and (is_(left, char) and is_(operand, char))))))))","cases exhaustive obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 60:52: (forall tree:(unresolved VCParser`TREE) \u0026 let mk_TREE(-, [left, right]):TREE \u003d tree in let mk_TREE(-, rights):(TREE | char) \u003d right in ((rights \u003d []) or (exists [mk_TREE(-, [mk_TREE(-, operator), operand])] ^ rest:(seq of (TREE) | seq of (char)) \u0026 (rights \u003d ([mk_TREE(any1, [mk_TREE(any2, operator), operand])] ^ rest)))))","legal sequence application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 73:28: (forall string:seq of (char) \u0026 ((not (exists \"-\" ^ rest:seq of (char) \u0026 ((\"-\" ^ rest) \u003d string))) \u003d\u003e ((not ([] \u003d string)) \u003d\u003e (forall i in set {1, ... ,((len string) - 1)} \u0026 (i in set (inds string))))))","legal map application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 74:18: (forall string:seq of (char) \u0026 ((not (exists \"-\" ^ rest:seq of (char) \u0026 ((\"-\" ^ rest) \u003d string))) \u003d\u003e ((not ([] \u003d string)) \u003d\u003e (string((len string)) in set (dom {\u00270\u0027 |-\u003e 0, \u00271\u0027 |-\u003e 1, \u00272\u0027 |-\u003e 2, \u00273\u0027 |-\u003e 3, \u00274\u0027 |-\u003e 4, \u00275\u0027 |-\u003e 5, \u00276\u0027 |-\u003e 6, \u00277\u0027 |-\u003e 7, \u00278\u0027 |-\u003e 8, \u00279\u0027 |-\u003e 9})))))","enumeration map injectivity obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 74:18: (forall string:seq of (char) \u0026 ((not (exists \"-\" ^ rest:seq of (char) \u0026 ((\"-\" ^ rest) \u003d string))) \u003d\u003e ((not ([] \u003d string)) \u003d\u003e (forall m1, m2 in set {{\u00270\u0027 |-\u003e 0}, {\u00271\u0027 |-\u003e 1}, {\u00272\u0027 |-\u003e 2}, {\u00273\u0027 |-\u003e 3}, {\u00274\u0027 |-\u003e 4}, {\u00275\u0027 |-\u003e 5}, {\u00276\u0027 |-\u003e 6}, {\u00277\u0027 |-\u003e 7}, {\u00278\u0027 |-\u003e 8}, {\u00279\u0027 |-\u003e 9}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))))","legal sequence application obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 75:62: (forall string:seq of (char) \u0026 ((not (exists \"-\" ^ rest:seq of (char) \u0026 ((\"-\" ^ rest) \u003d string))) \u003d\u003e ((not ([] \u003d string)) \u003d\u003e ((len string) in set (inds string)))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 79:54: (forall tree:TREE \u0026 (exists mk_TREE(\"int\", contents):TREE \u0026 ((mk_TREE(\"int\", contents) \u003d tree) \u003d\u003e let mk_TREE(\"int\", contents) \u003d tree in is_(contents, seq of (char)))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 80:51: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 ((mk_TREE(\"*\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"*\", [e1, e2]) \u003d tree in is_(e1, TREE)))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 80:66: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 ((mk_TREE(\"*\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"*\", [e1, e2]) \u003d tree in is_(e2, TREE)))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 81:51: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 ((mk_TREE(\"/\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"/\", [e1, e2]) \u003d tree in is_(e1, TREE))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 81:66: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 ((mk_TREE(\"/\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"/\", [e1, e2]) \u003d tree in is_(e2, TREE))))))","non-zero obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 81:55: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 ((mk_TREE(\"/\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"/\", [e1, e2]) \u003d tree in (evalTree(e2) \u003c\u003e 0))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 82:51: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 (mk_TREE(\"/\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"+\", [e1, e2]):TREE \u0026 ((mk_TREE(\"+\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"+\", [e1, e2]) \u003d tree in is_(e1, TREE)))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 82:66: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 (mk_TREE(\"/\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"+\", [e1, e2]):TREE \u0026 ((mk_TREE(\"+\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"+\", [e1, e2]) \u003d tree in is_(e2, TREE)))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 83:51: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 (mk_TREE(\"/\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"+\", [e1, e2]):TREE \u0026 (mk_TREE(\"+\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"-\", [e1, e2]):TREE \u0026 ((mk_TREE(\"-\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"-\", [e1, e2]) \u003d tree in is_(e1, TREE))))))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 83:66: (forall tree:TREE \u0026 ((not (exists mk_TREE(\"int\", contents):TREE \u0026 (mk_TREE(\"int\", contents) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (mk_TREE(\"*\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 (mk_TREE(\"/\", [e1, e2]) \u003d tree))) \u003d\u003e ((not (exists mk_TREE(\"+\", [e1, e2]):TREE \u0026 (mk_TREE(\"+\", [e1, e2]) \u003d tree))) \u003d\u003e (exists mk_TREE(\"-\", [e1, e2]):TREE \u0026 ((mk_TREE(\"-\", [e1, e2]) \u003d tree) \u003d\u003e let mk_TREE(\"-\", [e1, e2]) \u003d tree in is_(e2, TREE))))))))","cases exhaustive obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 78:23: (forall tree:TREE \u0026 (((((exists mk_TREE(\"int\", contents):TREE \u0026 (tree \u003d mk_TREE(\"int\", contents))) or (exists mk_TREE(\"*\", [e1, e2]):TREE \u0026 (tree \u003d mk_TREE(\"*\", [e1, e2])))) or (exists mk_TREE(\"/\", [e1, e2]):TREE \u0026 (tree \u003d mk_TREE(\"/\", [e1, e2])))) or (exists mk_TREE(\"+\", [e1, e2]):TREE \u0026 (tree \u003d mk_TREE(\"+\", [e1, e2])))) or (exists mk_TREE(\"-\", [e1, e2]):TREE \u0026 (tree \u003d mk_TREE(\"-\", [e1, e2])))))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 77:5: (forall tree:TREE \u0026 is_((cases tree :\nmk_TREE(\"int\", contents) -\u003e evalInt(contents),\nmk_TREE(\"*\", [e1, e2]) -\u003e (evalTree(e1) * evalTree(e2)),\nmk_TREE(\"/\", [e1, e2]) -\u003e (evalTree(e1) / evalTree(e2)),\nmk_TREE(\"+\", [e1, e2]) -\u003e (evalTree(e1) + evalTree(e2)),\nmk_TREE(\"-\", [e1, e2]) -\u003e (evalTree(e1) - evalTree(e2))\n end), int))","type compatibility obligation in \u0027MMParser\u0027 (MMParser.vdmsl) at line 88:54: (forall string:seq of (char) \u0026 (exists mk_PARSED(tree, []):PARSED \u0026 ((mk_PARSED(tree, []) \u003d parseExpression(string)) \u003d\u003e let mk_PARSED(tree, []) \u003d parseExpression(string) in is_(tree, TREE))))"]