["legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 70:17: (forall decls:seq of (Declaration) \u0026 (forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e (i1 in set (inds decls)))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 70:33: (forall decls:seq of (Declaration) \u0026 (forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e (i2 in set (inds decls)))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 72:5: (forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (i in set (inds decls)))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 73:22: (forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e (i in set (inds decls))))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 73:40: (forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e (is_((decls(i).val), AST`BoolVal) \u003d\u003e (i in set (inds decls)))))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 74:21: (forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e ((not (is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) \u003d \u003cBoolType\u003e))) \u003d\u003e (i in set (inds decls)))))))","legal sequence application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 74:39: (forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e ((not (is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) \u003d \u003cBoolType\u003e))) \u003d\u003e (is_((decls(i).val), AST`IntVal) \u003d\u003e (i in set (inds decls))))))))","comprehension map injectivity obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 78:3: (forall decls:seq of (Declaration) \u0026 (forall m1, m2 in set {{id |-\u003e tp} | mk_Declaration(id, tp, -) in set (elems decls)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 87:47: (forall stmt:Stmt, senv:StatEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e is_(stmt, BlockStmt)))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 89:52: (forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e is_(stmt, AssignStmt))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 91:46: (forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e is_(stmt, CondStmt)))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 92:45: (forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e is_(stmt, ForStmt))))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 93:48: (forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e is_(stmt, RepeatStmt)))))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 158:44: (forall ex:Expr, senv:StatEnv \u0026 ((not (is_(ex, AST`BoolVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`IntVal) \u003d true)) \u003d\u003e ((is_(ex, AST`Variable) \u003d true) \u003d\u003e is_(ex, Variable)))))","type compatibility obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 159:46: (forall ex:Expr, senv:StatEnv \u0026 ((not (is_(ex, AST`BoolVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`IntVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`Variable) \u003d true)) \u003d\u003e ((is_(ex, AST`BinaryExpr) \u003d true) \u003d\u003e is_(ex, BinaryExpr))))))","legal map application obligation in \u0027STATSEM\u0027 (statsem.vdmsl) at line 166:18: (forall mk_Variable(id):Variable, senv:StatEnv \u0026 ((id in set (dom senv)) \u003d\u003e (id in set (dom senv))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 42:5: (forall mk_Program(decls, stmt):Program \u0026 ((STATSEM`wf_Program(mk_AST`Program(decls, stmt)) and pre_EvalStmt(stmt, EvalDeclarations(decls))) \u003d\u003e pre_EvalStmt(stmt, EvalDeclarations(decls))))","comprehension map injectivity obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 52:5: (forall decls:seq of (Declaration) \u0026 (forall m1, m2 in set {{id |-\u003e (if (val \u003c\u003e nil)\nthen val\nelseif (tp \u003d \u003cBoolType\u003e)\nthen mk_AST`BoolVal(false)\nelse mk_AST`IntVal(0))} | mk_Declaration(id, tp, val) in set (elems decls)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 50:3: (forall decls:seq of (Declaration) \u0026 is_({id |-\u003e (if (val \u003c\u003e nil)\nthen val\nelseif (tp \u003d \u003cBoolType\u003e)\nthen mk_AST`BoolVal(false)\nelse mk_AST`IntVal(0)) | mk_Declaration(id, tp, val) in set (elems decls)}, map (Identifier) to (Value)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 75:54: (forall stmt:Stmt, denv:DynEnv \u0026 (is_(stmt, AST`BlockStmt) \u003d\u003e is_(stmt, BlockStmt)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 76:55: (forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`AssignStmt) \u003d\u003e is_(stmt, AssignStmt))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 77:53: (forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`CondStmt) \u003d\u003e is_(stmt, CondStmt)))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 78:52: (forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`ForStmt) \u003d\u003e is_(stmt, ForStmt))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 79:55: (forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`RepeatStmt) \u003d\u003e is_(stmt, RepeatStmt)))))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 69:36: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e pre_EvalBlockStmt(stmt, denv))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 69:50: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e is_(stmt, BlockStmt))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 70:36: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e pre_EvalAssignStmt(stmt, denv)))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 70:51: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e is_(stmt, AssignStmt)))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 71:36: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e pre_EvalCondStmt(stmt, denv))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 71:49: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e is_(stmt, CondStmt))))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 72:36: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e pre_EvalForStmt(stmt, denv)))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 72:48: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e is_(stmt, ForStmt)))))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 73:36: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e pre_EvalRepeatStmt(stmt, denv))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 73:51: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e is_(stmt, RepeatStmt))))))))","cases exhaustive obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 68:5: (forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e (((((true \u003d is_(stmt, AST`BlockStmt)) or (true \u003d is_(stmt, AST`AssignStmt))) or (true \u003d is_(stmt, AST`CondStmt))) or (true \u003d is_(stmt, AST`ForStmt))) or (true \u003d is_(stmt, AST`RepeatStmt)))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 84:19: (forall mk_BlockStmt(decls, stmts):BlockStmt, denv:DynEnv \u0026 (let ldenv:DynEnv \u003d EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv)) \u003d\u003e let ldenv:DynEnv \u003d EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv))))","non-empty sequence obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 95:38: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 ((stmts \u003c\u003e []) \u003d\u003e (stmts \u003c\u003e [])))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 93:17: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e pre_EvalStmts((tl stmts), EvalStmt((hd stmts), denv)))))","recursive function obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 93:17: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (LenStmt(stmts, denv) \u003e LenStmt((tl stmts), EvalStmt((hd stmts), denv))))))","non-empty sequence obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 93:30: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (stmts \u003c\u003e []))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 93:37: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e pre_EvalStmt((hd stmts), denv))))","non-empty sequence obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 93:49: (forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (stmts \u003c\u003e []))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 104:25: (forall mk_AssignStmt(lhs, rhs):AssignStmt, denv:DynEnv \u0026 (pre_EvalExpr(rhs, denv) \u003d\u003e pre_EvalExpr(rhs, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 113:10: (forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 (pre_EvalExpr(guard, denv) \u003d\u003e pre_EvalExpr(guard, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 109:8: (forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e pre_EvalExpr(guard, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 110:10: (forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e ((EvalExpr(guard, denv).val) \u003d\u003e pre_EvalStmt(thenst, denv))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 111:10: (forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e ((not (EvalExpr(guard, denv).val)) \u003d\u003e pre_EvalStmt(elsest, denv))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 124:27: (forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 (pre_EvalStmt(repeat, denv) \u003d\u003e pre_EvalStmt(repeat, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 119:17: (forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e pre_EvalStmt(repeat, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 120:8: (forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(repeat, denv) in pre_EvalExpr(until, denv\u0027)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 122:12: (forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(repeat, denv) in ((not (EvalExpr(until, denv\u0027).val)) \u003d\u003e pre_EvalRepeatStmt(mk_AST`RepeatStmt(repeat, until), denv\u0027))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 188:26: (forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 (pre_EvalAssignStmt(start, denv) \u003d\u003e pre_EvalAssignStmt(start, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 185:17: (forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e pre_EvalAssignStmt(start, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 186:5: (forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalAssignStmt(start, denv) in pre_EvalForLoop((start.lhs), EvalExpr(stop, denv\u0027), stmt, denv\u0027)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 186:28: (forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalAssignStmt(start, denv) in pre_EvalExpr(stop, denv\u0027)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 192:8: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e is_((denv(id).val), real)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 192:24: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e is_((val.val), real)))","legal map application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 192:8: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (id in set (dom denv))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 193:24: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e pre_EvalStmt(stmt, denv))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 194:15: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in pre_EvalForLoop(mk_AST`Variable(id), val, stmt, (denv\u0027 ++ {id |-\u003e mk_AST`IntVal(((denv\u0027(id).val) + 1))})))))","recursive function obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 194:15: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in (LoopParInc(mk_Variable(id), val, stmt, denv) \u003e LoopParInc(mk_AST`Variable(id), val, stmt, (denv\u0027 ++ {id |-\u003e mk_AST`IntVal(((denv\u0027(id).val) + 1))}))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 195:58: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in is_((denv\u0027(id).val), real))))","legal map application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 195:58: (forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in (id in set (dom denv\u0027)))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 202:5: (forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 is_((val.val), real))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 202:15: (forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 is_((denv(id).val), real))","legal map application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 202:15: (forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 (id in set (dom denv)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 200:3: (forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 (((val.val) - (denv(id).val)) \u003e\u003d 0))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 220:51: (forall ex:Expr, denv:DynEnv \u0026 (is_(ex, AST`BinaryExpr) \u003d\u003e is_(ex, BinaryExpr)))","legal map application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 217:35: (forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e (exists mk_Variable(id):Expr \u0026 ((mk_Variable(id) \u003d ex) \u003d\u003e let mk_Variable(id) \u003d ex in (id in set (dom denv))))))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 218:35: (forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_Variable(id):Expr \u0026 (mk_Variable(id) \u003d ex))) \u003d\u003e (exists mk_BinaryExpr(-, -, -):Expr \u0026 ((mk_BinaryExpr(any1, any2, any3) \u003d ex) \u003d\u003e let mk_BinaryExpr(-, -, -) \u003d ex in pre_EvalBinaryExpr(ex, denv))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 218:50: (forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_Variable(id):Expr \u0026 (mk_Variable(id) \u003d ex))) \u003d\u003e (exists mk_BinaryExpr(-, -, -):Expr \u0026 ((mk_BinaryExpr(any1, any2, any3) \u003d ex) \u003d\u003e let mk_BinaryExpr(-, -, -) \u003d ex in is_(ex, BinaryExpr))))))))","cases exhaustive obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 214:5: (forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((((exists mk_BoolVal(-):Expr \u0026 (ex \u003d mk_BoolVal(any1))) or (exists mk_IntVal(-):Expr \u0026 (ex \u003d mk_IntVal(any2)))) or (exists mk_Variable(id):Expr \u0026 (ex \u003d mk_Variable(id)))) or (exists mk_BinaryExpr(-, -, -):Expr \u0026 (ex \u003d mk_BinaryExpr(any3, any4, any5))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 212:3: (forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e (is_((cases ex :\nmk_BoolVal(-) -\u003e ex,\nmk_IntVal(-) -\u003e ex,\nmk_Variable(id) -\u003e denv(id),\nmk_BinaryExpr(-, -, -) -\u003e EvalBinaryExpr(ex, denv)\n end), BoolVal) or is_((cases ex :\nmk_BoolVal(-) -\u003e ex,\nmk_IntVal(-) -\u003e ex,\nmk_Variable(id) -\u003e denv(id),\nmk_BinaryExpr(-, -, -) -\u003e EvalBinaryExpr(ex, denv)\n end), IntVal))))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 237:21: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 ((op \u003d \u003cDiv\u003e) \u003d\u003e pre_EvalExpr(rhs, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 224:14: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e pre_EvalExpr(lhs, denv)))","legal function application obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 225:14: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e pre_EvalExpr(rhs, denv)))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 227:31: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((\u003cAdd\u003e \u003d op) \u003d\u003e is_(v1, real))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 227:36: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((\u003cAdd\u003e \u003d op) \u003d\u003e is_(v2, real))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 228:31: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((\u003cSub\u003e \u003d op) \u003d\u003e is_(v1, real)))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 228:36: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((\u003cSub\u003e \u003d op) \u003d\u003e is_(v2, real)))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 229:31: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e is_(v1, real))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 229:38: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e is_(v2, real))))))","non-zero obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 229:34: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e (v2 \u003c\u003e 0))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 230:31: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((\u003cMul\u003e \u003d op) \u003d\u003e is_(v1, real)))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 230:36: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((\u003cMul\u003e \u003d op) \u003d\u003e is_(v2, real)))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 231:32: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((\u003cLt\u003e \u003d op) \u003d\u003e is_(v1, real))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 231:37: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((\u003cLt\u003e \u003d op) \u003d\u003e is_(v2, real))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 232:32: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((\u003cGt\u003e \u003d op) \u003d\u003e is_(v1, real)))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 232:37: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((\u003cGt\u003e \u003d op) \u003d\u003e is_(v2, real)))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 234:32: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((\u003cAnd\u003e \u003d op) \u003d\u003e is_(v1, bool)))))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 234:39: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((\u003cAnd\u003e \u003d op) \u003d\u003e (v1 \u003d\u003e is_(v2, bool))))))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 235:32: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((not (\u003cAnd\u003e \u003d op)) \u003d\u003e ((\u003cOr\u003e \u003d op) \u003d\u003e is_(v1, bool))))))))))))","type compatibility obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 235:38: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((not (\u003cAnd\u003e \u003d op)) \u003d\u003e ((\u003cOr\u003e \u003d op) \u003d\u003e ((not v1) \u003d\u003e is_(v2, bool)))))))))))))","cases exhaustive obligation in \u0027DYNSEM\u0027 (dynsem.vdmsl) at line 226:8: (forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in (((((((((op \u003d \u003cAdd\u003e) or (op \u003d \u003cSub\u003e)) or (op \u003d \u003cDiv\u003e)) or (op \u003d \u003cMul\u003e)) or (op \u003d \u003cLt\u003e)) or (op \u003d \u003cGt\u003e)) or (op \u003d \u003cEq\u003e)) or (op \u003d \u003cAnd\u003e)) or (op \u003d \u003cOr\u003e))))","legal function application obligation in \u0027Test\u0027 (Test.vdmsl) at line 28:3: pre_EvalExpr(binexpr, {|-\u003e})"]