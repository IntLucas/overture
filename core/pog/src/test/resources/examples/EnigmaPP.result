["state invariant holds obligation in \u0027Reflector\u0027 (Reflector.vdmpp) at line 16:10: (forall psp:nat, pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((psp in set (pa.GetIndices)()) and ReflectorInv(next, pcfg, pa)) \u003d\u003e ReflectorInv(next, {(pa.Shift)(i, (psp - 1)) |-\u003e (pa.Shift)(pcfg(i), (psp - 1)) | i in set (dom pcfg)}, pa)))","enumeration map injectivity obligation in \u0027SimpleEnigma\u0027 (SimpleEnigma.vdmpp) at line 6:6: (forall m1, m2 in set {{1 |-\u003e 3}, {2 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027SimpleEnigma\u0027 (SimpleEnigma.vdmpp) at line 8:6: (forall m1, m2 in set {{1 |-\u003e 2}, {2 |-\u003e 4}, {3 |-\u003e 3}, {4 |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation in \u0027Configuration\u0027 (Configuration.vdmpp) at line 11:17: (forall penc:nat \u0026 (penc in set (dom config)))","map inverse obligation in \u0027Configuration\u0027 (Configuration.vdmpp) at line 16:18: (forall pdec:nat \u0026 is_(config, inmap (nat) to (nat)))","legal map application obligation in \u0027Configuration\u0027 (Configuration.vdmpp) at line 18:19: (forall pdec:nat \u0026 (pdec in set (dom invcfg)))","legal map application obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 17:42: (forall platch_pos:nat, pconfig:inmap (nat) to (nat), palph:Alphabet \u0026 let ainds:set of (nat) \u003d (palph.GetIndices)() in ((platch_pos in set ainds) \u003d\u003e (((dom pconfig) \u003d ainds) \u003d\u003e (((rng pconfig) \u003d ainds) \u003d\u003e (forall x in set (dom pconfig) \u0026 (x in set (dom pconfig)))))))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 20:10: (forall psp:nat, plp:nat, pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((psp in set (pa.GetIndices)()) and RotorInv(plp, pcfg, pa)) \u003d\u003e RotorInv((pa.Shift)(plp, (psp - 1)), {(pa.Shift)(i, (psp - 1)) |-\u003e (pa.Shift)(pcfg(i), (psp - 1)) | i in set (dom pcfg)}, pa)))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 39:11: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(1, config, alph)))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 40:11: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(1, config, alph) \u003d\u003e RotorInv((1 + 1), config, alph)))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 43:6: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv((1 + 1), config, alph) \u003d\u003e RotorInv((1 + 1), {(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)}, alph)))","comprehension map injectivity obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 43:16: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (forall m1, m2 in set {{(alph.Shift)(i) |-\u003e (alph.Shift)(config(i))} | i in set (dom config)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 44:28: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (forall i in set (dom config) \u0026 (i in set (dom config))))","type compatibility obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 43:16: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e is_({(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)}, inmap (nat) to (nat)))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 47:6: ((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv((1 + 1), {(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)}, alph) \u003d\u003e RotorInv((1 + 1), {(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)}, alph)))","operation call obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 56:10: (forall ppos:nat \u0026 ((ppos in set (alph.GetIndices)()) \u003d\u003e (isofclass(Rotor,next) or isofclass(Reflector,next))))","state invariant holds obligation in \u0027Rotor\u0027 (Rotor.vdmpp) at line 58:10: (forall ppos:nat \u0026 ((ppos in set (alph.GetIndices)()) \u003d\u003e (forall latch_pos1:nat, latch_lock2:bool \u0026 (RotorInv(latch_pos1, config, alph) \u003d\u003e (RotorInv(latch_pos1, config, alph) \u003d\u003e RotorInv(latch_pos1, config, alph))))))","state invariant holds obligation in \u0027Plugboard\u0027 (Plugboard.vdmpp) at line 13:10: (forall pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((((dom pcfg) inter (rng pcfg)) \u003d {}) and PlugboardInv(pcfg, pa)) \u003d\u003e PlugboardInv((pcfg munion (inverse pcfg)), pa)))","operation call obligation in \u0027Plugboard\u0027 (Plugboard.vdmpp) at line 24:6: (forall pidx:nat \u0026 (((pidx in set (alph.GetIndices)()) and (isofclass(Rotor,next) or isofclass(Reflector,next))) \u003d\u003e (next \u003c\u003e nil)))","enumeration map injectivity obligation in \u0027ReflectorTest\u0027 (ReflectorTest.vdmpp) at line 7:5: (forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027ConfigurationTest\u0027 (ConfigurationTest.vdmpp) at line 7:5: (forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","state invariant holds obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 15:10: (forall pa:seq of (char) \u0026 (AlphabetInv(pa) \u003d\u003e AlphabetInv(pa)))","legal sequence application obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 20:28: (forall pidx:nat \u0026 ((pidx in set (inds alph)) \u003d\u003e (pidx in set (inds alph))))","let be st existence obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 25:9: (forall pch:char \u0026 ((pch in set (elems alph)) \u003d\u003e (exists pidx in set {i | i in set (inds alph) \u0026 (alph(i) \u003d pch)} \u0026 true)))","legal sequence application obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 26:26: (forall pch:char \u0026 ((pch in set (elems alph)) \u003d\u003e (forall i in set (inds alph) \u0026 (i in set (inds alph)))))","type compatibility obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 36:10: (forall pidx:nat, poffset:nat \u0026 (((pidx in set (inds alph)) and (poffset \u003c\u003d (len alph))) \u003d\u003e (RESULT \u003e\u003d 0)))","operation call obligation in \u0027Alphabet\u0027 (Alphabet.vdmpp) at line 45:19: (forall pidx:nat \u0026 ((pidx in set (inds alph)) and (pidx \u003c\u003d (len alph))))","legal sequence application obligation in \u0027AlphabetTest\u0027 (AlphabetTest.vdmpp) at line 19:38: (i in set (inds str))","legal sequence application obligation in \u0027AlphabetTest\u0027 (AlphabetTest.vdmpp) at line 20:34: (i in set (inds str))","enumeration map injectivity obligation in \u0027PlugboardTest\u0027 (PlugboardTest.vdmpp) at line 6:5: (forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027PlugboardTest\u0027 (PlugboardTest.vdmpp) at line 9:5: (forall m1, m2 in set {{1 |-\u003e 2}, {2 |-\u003e 1}, {3 |-\u003e 4}, {4 |-\u003e 3}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027RotorTest\u0027 (RotorTest.vdmpp) at line 7:5: (forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027RotorTest\u0027 (RotorTest.vdmpp) at line 10:5: (forall m1, m2 in set {{1 |-\u003e 1}, {2 |-\u003e 3}, {3 |-\u003e 2}, {4 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","operation call obligation in \u0027IO\u0027 (IO.vdmpp) at line 80:3: (forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]