["type invariant satisfiable obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 5:3: (exists d:Digit \u0026 (d \u003c 10))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 9:3: (forall data:seq1 of (Digit) \u0026 (inv_Digit(((total(data) * 9) mod 10)) and is_(((total(data) * 9) mod 10), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 21:10: (forall number:nat \u0026 is_(natToSeq(number), seq1 of (Digit)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 30:22: (forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e (data \u003c\u003e [])))","recursive function obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 32:9: (forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (slen(data) \u003e slen((tl data)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 32:18: (forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (data \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 23:3: (forall data:seq of (Digit) \u0026 ((if (data \u003d [])\nthen 0\nelse let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (total((tl data)) + (if (product \u003c 10)\nthen product\nelse ((product mod 10) + 1)))) \u003e\u003d 0))","cases exhaustive obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 44:7: (forall s:seq1 of (char) \u0026 (forall i in set (inds s) \u0026 ((((((((((s(i) \u003d \u00270\u0027) or (s(i) \u003d \u00271\u0027)) or (s(i) \u003d \u00272\u0027)) or (s(i) \u003d \u00273\u0027)) or (s(i) \u003d \u00274\u0027)) or (s(i) \u003d \u00275\u0027)) or (s(i) \u003d \u00276\u0027)) or (s(i) \u003d \u00277\u0027)) or (s(i) \u003d \u00278\u0027)) or (s(i) \u003d \u00279\u0027))))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 42:3: (forall s:seq1 of (char) \u0026 is_([(cases s(i) :\nchar value [0] -\u003e 0,\nchar value [1] -\u003e 1,\nchar value [2] -\u003e 2,\nchar value [3] -\u003e 3,\nchar value [4] -\u003e 4,\nchar value [5] -\u003e 5,\nchar value [6] -\u003e 6,\nchar value [7] -\u003e 7,\nchar value [8] -\u003e 8,\nchar value [9] -\u003e 9\n end) | i in set (inds s)], seq1 of (Digit)))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 53:21: (forall n:nat \u0026 ((not (n \u003c 10)) \u003d\u003e ((n div 10) \u003e\u003d 0)))","recursive function obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 53:10: (forall n:nat \u0026 ((not (n \u003c 10)) \u003d\u003e (id(n) \u003e id((n div 10)))))","type compatibility obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 49:3: (forall n:nat \u0026 is_((if (n \u003c 10)\nthen [n]\nelse (natToSeq((n div 10)) ^ [(n rem 10)])), seq of (Digit)))","operation establishes postcondition obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 135:3: (forall data:seq1 of (Digit), expected:Digit \u0026 (RESULT \u003d true))","operation establishes postcondition obligation in \u0027DEFAULT\u0027 (LUHN.vdmsl) at line 140:3: (forall data:seq1 of (Digit), expected:Digit \u0026 (RESULT \u003d true))"]