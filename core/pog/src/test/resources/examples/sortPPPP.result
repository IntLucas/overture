["recursive function obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 19:20: (forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e (Len(l) \u003e Len((tl l)))))","non-empty sequence obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 19:34: (forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e (l \u003c\u003e [])))","non-empty sequence obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 20:26: (forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e let sorted:seq of (int) \u003d DoSorting((tl l)) in (l \u003c\u003e [])))","non-empty sequence obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 28:26: (forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (l \u003c\u003e []))))","recursive function obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 28:31: (forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (Len(i, l) \u003e Len(i, (tl l))))))","non-empty sequence obligation in \u0027DoSort\u0027 (dosort.vdmpp) at line 28:49: (forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (l \u003c\u003e []))))","function postcondition satisfiable obligation in \u0027ImplSort\u0027 (implsort.vdmpp) at line 19:10: (forall l:seq of (int) \u0026 (exists r:seq of (int) \u0026 post_ImplSorter(l, r)))","legal sequence application obligation in \u0027ImplSort\u0027 (implsort.vdmpp) at line 25:36: (forall l1:seq of (int), l2:seq of (int) \u0026 (forall e in set ((elems l1) union (elems l2)) \u0026 (forall i in set (inds l1) \u0026 (i in set (inds l1)))))","legal sequence application obligation in \u0027ImplSort\u0027 (implsort.vdmpp) at line 26:36: (forall l1:seq of (int), l2:seq of (int) \u0026 (forall e in set ((elems l1) union (elems l2)) \u0026 (forall i in set (inds l2) \u0026 (i in set (inds l2)))))","legal sequence application obligation in \u0027ImplSort\u0027 (implsort.vdmpp) at line 30:41: (forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds l)))))","legal sequence application obligation in \u0027ImplSort\u0027 (implsort.vdmpp) at line 30:49: (forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (j in set (inds l)))))","type compatibility obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 9:10: (forall l:seq of (int) \u0026 is_(RESULT, seq of (int)))","let be st existence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 20:24: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (exists l1 ^ l2 in set {l} \u0026 ((abs ((len l1) - (len l2))) \u003c 2)))))","recursive function obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 22:30: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e (Len(l) \u003e Len(l1)))))))","recursive function obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 23:30: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e (Len(l) \u003e Len(l2)))))))","legal function application obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 24:21: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in pre_Merge(l_l, l_r))))))","type compatibility obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 24:27: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in is_(l_l, seq of (int)))))))","type compatibility obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 24:32: (forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in is_(l_r, seq of (int)))))))","legal sequence application obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 48:33: (forall l1:seq of (int), l2:seq of (int) \u0026 (forall i in set (inds l1) \u0026 (i in set (inds l1))))","legal sequence application obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 49:33: (forall l1:seq of (int), l2:seq of (int) \u0026 (forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) \u003d\u003e (forall i in set (inds l2) \u0026 (i in set (inds l2))))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 43:36: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (l1 \u003c\u003e [])))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 43:45: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (l2 \u003c\u003e [])))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 44:36: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (l1 \u003c\u003e []))))))","legal function application obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 44:42: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e pre_Merge((tl l1), l2))))))","recursive function obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 44:42: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (Len(l1, l2) \u003e Len((tl l1), l2)))))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 44:51: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (l1 \u003c\u003e []))))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 46:36: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (l2 \u003c\u003e []))))))","legal function application obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 46:42: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e pre_Merge(l1, (tl l2)))))))","recursive function obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 46:42: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (Len(l1, l2) \u003e Len(l1, (tl l2))))))))","non-empty sequence obligation in \u0027MergeSort\u0027 (mergesort.vdmpp) at line 46:55: (forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (l2 \u003c\u003e []))))))","let be st existence obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 14:9: (forall l:seq of (int) \u0026 (exists r in set Permutations(l) \u0026 IsOrdered(r)))","legal sequence application obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 23:27: (forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (forall j in set Permutations(RestSeq(l, i)) \u0026 (i in set (inds l)))))))","recursive function obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 24:35: (forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (Len(l) \u003e Len(RestSeq(l, i)))))))","legal function application obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 24:48: (forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 pre_RestSeq(l, i)))))","function establishes postcondition obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 29:3: (forall l:seq of (int), i:nat \u0026 (pre_RestSeq(l, i) \u003d\u003e post_RestSeq(l, i, [l(j) | j in set ((inds l) \\ {i})])))","legal sequence application obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 31:6: (forall l:seq of (int), i:nat \u0026 ((i in set (inds l)) \u003d\u003e (forall j in set ((inds l) \\ {i}) \u0026 (j in set (inds l)))))","legal sequence application obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 38:41: (forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds l)))))","legal sequence application obligation in \u0027ExplSort\u0027 (explsort.vdmpp) at line 38:49: (forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (j in set (inds l)))))"]