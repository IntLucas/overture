["function establishes postcondition obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 43:5: (forall p:Point \u0026 post_around(p, {mk_Point(((p.x) + x), ((p.y) + y)) | x, y in set {-1, 0, (+ 1)} \u0026 ((x \u003c\u003e 0) or (y \u003c\u003e 0))}))","function establishes postcondition obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 50:5: (forall pop:Population, p:Point \u0026 post_neighbourCount(pop, p, (card {q | q in set around(p) \u0026 (q in set pop)})))","function establishes postcondition obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 56:5: (forall pop:Population \u0026 post_newCells(pop, (dunion {{q | q in set around(p) \u0026 ((q not in set pop) and (neighbourCount(pop, q) \u003d GENERATE))} | p in set pop})))","function establishes postcondition obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 67:5: (forall pop:Population \u0026 post_deadCells(pop, {p | p in set pop \u0026 (neighbourCount(pop, p) not in set SURVIVE)}))","type compatibility obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 85:41: (forall n:nat1, pop:Population \u0026 let new_p:Population \u003d generation(pop) in ((not (n \u003d 1)) \u003d\u003e ((n - 1) \u003e 0)))","recursive function obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 85:28: (forall n:nat1, pop:Population \u0026 let new_p:Population \u003d generation(pop) in ((not (n \u003d 1)) \u003d\u003e (measureGenerations(n, pop) \u003e measureGenerations((n - 1), new_p))))","legal function application obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 104:36: (forall pop:Population, n:nat1 \u0026 pre_((generation ** n)pop))","legal function application obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 109:21: (forall pop:Population, n:nat1 \u0026 pre_((generation ** n)pop))","legal function application obligation in \u0027Conway\u0027 (Conway.vdmsl) at line 114:35: (forall pop:Population, n:nat1, max:nat1 \u0026 pre_((generation ** n)pop))","type compatibility obligation in \u0027gui_Graphics\u0027 (Graphics.vdmsl) at line 17:28: (forall n:nat1, conf:Configuration \u0026 ((conf.gridSide) \u003e 0))","type compatibility obligation in \u0027gui_Graphics\u0027 (Graphics.vdmsl) at line 17:43: (forall n:nat1, conf:Configuration \u0026 ((conf.sleepTime) \u003e 0))","non-empty sequence obligation in \u0027gui_Graphics\u0027 (Graphics.vdmsl) at line 28:68: (forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e (pop \u003c\u003e [])))","recursive function obligation in \u0027gui_Graphics\u0027 (Graphics.vdmsl) at line 32:17: (forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e let -:set of (int) \u003d {newLivingCell((cell.x), (cell.y)) | cell in set (hd pop)} in let -:int \u003d newRound() in (measure_animate_step(pop) \u003e measure_animate_step((tl pop)))))","non-empty sequence obligation in \u0027gui_Graphics\u0027 (Graphics.vdmsl) at line 32:33: (forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e let -:set of (int) \u003d {newLivingCell((cell.x), (cell.y)) | cell in set (hd pop)} in let -:int \u003d newRound() in (pop \u003c\u003e [])))"]