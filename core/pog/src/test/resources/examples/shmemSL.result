["type invariant satisfiable obligation in \u0027M\u0027 (shmem.vdmsl) at line 13:1: (exists mk_M(-, a, b):M \u0026 (b \u003e\u003d a))","state invariant satisfiable obligation in \u0027M\u0027 (shmem.vdmsl) at line 19:7: (exists rseed:nat, Q3:Quadrant, Q4:Quadrant \u0026 (((len q3) \u003e 0) and ((len q4) \u003e 0)))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 38:1: (forall m:M \u0026 ((((m.stop) - (m.start)) + 1) \u003e 0))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 54:24: (forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","cases exhaustive obligation in \u0027M\u0027 (shmem.vdmsl) at line 50:3: (forall size:nat1, Q:Quadrant \u0026 ((Q \u003d []) or (exists [h] ^ tail:Quadrant \u0026 (Q \u003d ([h] ^ tail)))))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 68:41: (forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size)) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 69:24: (forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","cases exhaustive obligation in \u0027M\u0027 (shmem.vdmsl) at line 64:3: (forall size:nat1, Q:Quadrant \u0026 ((Q \u003d []) or (exists [h] ^ tail:Quadrant \u0026 (Q \u003d ([h] ^ tail)))))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 78:31: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((hole \u003d size) \u003d\u003e inv_M(mk_M(\u003cUSED\u003e, (h.start), (h.stop)))))))))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 79:68: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e ((((h.start) + size) - 1) \u003e\u003d 0)))))))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 79:31: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e (inv_M(mk_M(\u003cUSED\u003e, (h.start), (((h.start) + size) - 1))) and ((((h.start) + size) - 1) \u003e\u003d 0))))))))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 80:31: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, ((h.start) + size), (h.stop)))))))))","legal function application obligation in \u0027M\u0027 (shmem.vdmsl) at line 81:31: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole))) \u003d\u003e pre_add(size, hole, tail))))))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 81:31: (forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole))) \u003d\u003e (QuadrantLen2(size, hole, Q) \u003e QuadrantLen2(size, hole, tail)))))))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 96:13: (forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e)) \u003d\u003e (QuadrantLen0(Q) \u003e QuadrantLen0(([mk_M(\u003cFREE\u003e, (h1.start), (h2.stop))] ^ tail)))))))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 96:22: (forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e)) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, (h1.start), (h2.stop)))))))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 97:20: (forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((not (((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e))) \u003d\u003e (QuadrantLen0(Q) \u003e QuadrantLen0((tl Q)))))))","non-empty sequence obligation in \u0027M\u0027 (shmem.vdmsl) at line 97:31: (forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((not (((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e))) \u003d\u003e (Q \u003c\u003e [])))))","non-empty sequence obligation in \u0027M\u0027 (shmem.vdmsl) at line 108:9: (forall item:M, Q:Quadrant \u0026 (Q \u003c\u003e []))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 109:17: (forall item:M, Q:Quadrant \u0026 (((hd Q) \u003d item) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, (item.start), (item.stop)))))","non-empty sequence obligation in \u0027M\u0027 (shmem.vdmsl) at line 109:59: (forall item:M, Q:Quadrant \u0026 (((hd Q) \u003d item) \u003d\u003e (Q \u003c\u003e [])))","non-empty sequence obligation in \u0027M\u0027 (shmem.vdmsl) at line 110:12: (forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (Q \u003c\u003e [])))","recursive function obligation in \u0027M\u0027 (shmem.vdmsl) at line 110:17: (forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (MQuadrantLen(item, Q) \u003e MQuadrantLen(item, (tl Q)))))","non-empty sequence obligation in \u0027M\u0027 (shmem.vdmsl) at line 110:33: (forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (Q \u003c\u003e [])))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 117:1: (forall Q:Quadrant \u0026 (((card {x | x in set (elems Q) \u0026 ((x.type) \u003d \u003cFREE\u003e)}) - 1) \u003e\u003d 0))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 125:3: (forall n:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 131:5: let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 131:34: ((((rseed * 69069) + 5) mod 4294967296) \u003e\u003d 0)","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 133:1: (forall n:nat1, oldstate:Memory \u0026 (true \u003d\u003e (RESULT \u003e 0)))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 144:10: (forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation in \u0027M\u0027 (shmem.vdmsl) at line 144:16: (forall size:nat1, oldstate:Memory \u0026 pre_add(size, q4, Q4))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 148:17: (forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation in \u0027M\u0027 (shmem.vdmsl) at line 148:23: (forall size:nat1, oldstate:Memory \u0026 pre_add(size, q3, Q3))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 158:10: (forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation in \u0027M\u0027 (shmem.vdmsl) at line 158:16: (forall size:nat1, oldstate:Memory \u0026 pre_add(size, q4, Q4))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 162:17: (forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation in \u0027M\u0027 (shmem.vdmsl) at line 162:23: (forall size:nat1, oldstate:Memory \u0026 pre_add(size, q3, Q3))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 169:3: let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 169:32: ((MAXMEM - 1) \u003e\u003d 0)","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 169:10: (inv_M(mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))) and ((MAXMEM - 1) \u003e\u003d 0))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 170:3: let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 170:32: ((MAXMEM - 1) \u003e\u003d 0)","type compatibility obligation in \u0027M\u0027 (shmem.vdmsl) at line 170:10: (inv_M(mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))) and ((MAXMEM - 1) \u003e\u003d 0))","legal sequence application obligation in \u0027M\u0027 (shmem.vdmsl) at line 178:13: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (i in set (inds Q3)))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 179:15: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal sequence application obligation in \u0027M\u0027 (shmem.vdmsl) at line 179:28: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (i in set (inds Q3)))","operation call obligation in \u0027M\u0027 (shmem.vdmsl) at line 180:15: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","legal sequence application obligation in \u0027M\u0027 (shmem.vdmsl) at line 183:13: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e (i in set (inds Q4))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 184:15: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","legal sequence application obligation in \u0027M\u0027 (shmem.vdmsl) at line 184:28: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e (i in set (inds Q4))))","operation call obligation in \u0027M\u0027 (shmem.vdmsl) at line 185:15: (((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e)))))","while loop termination obligation in \u0027M\u0027 (shmem.vdmsl) at line 194:3: ...","operation call obligation in \u0027M\u0027 (shmem.vdmsl) at line 197:11: (forall loops:nat, oldstate:Memory \u0026 ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 198:6: (forall loops:nat, oldstate:Memory \u0026 (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","while loop termination obligation in \u0027M\u0027 (shmem.vdmsl) at line 209:3: ...","operation call obligation in \u0027M\u0027 (shmem.vdmsl) at line 212:11: (forall loops:nat, oldstate:Memory \u0026 ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 213:6: (forall loops:nat, oldstate:Memory \u0026 (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 230:6: (forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 234:6: (forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 237:11: (forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 239:11: (forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation in \u0027M\u0027 (shmem.vdmsl) at line 240:11: (forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))"]