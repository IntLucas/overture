["enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 10:1: (forall m1, m2 in set {{\u003cAdam\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}, {\u003cCharlie\u003e |-\u003e 3}, {\u003cFrank\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 11:1: (forall m1, m2 in set {{\u003cBill\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}, {\u003cCharlie\u003e |-\u003e 3}, {\u003cGeorge\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 12:1: (forall m1, m2 in set {{\u003cAdam\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}, {\u003cBill\u003e |-\u003e 3}, {\u003cHarry\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 13:1: (forall m1, m2 in set {{\u003cBill\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}, {\u003cAdam\u003e |-\u003e 3}, {\u003cIan\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 14:1: (forall m1, m2 in set {{\u003cCharlie\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}, {\u003cBill\u003e |-\u003e 3}, {\u003cJohn\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 15:1: (forall m1, m2 in set {{\u003cCharlie\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}, {\u003cAdam\u003e |-\u003e 3}, {\u003cDonald\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 16:1: (forall m1, m2 in set {{\u003cDonald\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 17:1: (forall m1, m2 in set {{\u003cFrank\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 18:1: (forall m1, m2 in set {{\u003cGeorge\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 19:1: (forall m1, m2 in set {{\u003cHarry\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 20:1: (forall m1, m2 in set {{\u003cIan\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 21:1: (forall m1, m2 in set {{\u003cJohn\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 9:9: (forall m1, m2 in set {{{\u003cAdam\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cFrank\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cBill\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cGeorge\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cAdam\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cHarry\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cBill\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cIan\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cCharlie\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cJohn\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cCharlie\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cDonald\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cDonald\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cFrank\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cGeorge\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cHarry\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cIan\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cJohn\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 30:43: (forall v:map (Candidate_names) to (nat1) \u0026 (forall name:Candidate_names \u0026 (name in set (dom v))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 29:1: (exists v:Voting_paper \u0026 (exists1 name:Candidate_names \u0026 (v(name) \u003d 1)))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 40:19: (forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (i in set (inds s)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 40:33: (forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (j in set (inds s)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 42:18: (forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e (i in set (inds s))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 42:31: (forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e (j in set (inds s))))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 37:1: (exists s:Stage \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e ((s(i).name) \u003c\u003e (s(j).name))))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 44:1: (exists v:Value \u0026 (v \u003e\u003d 0))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 50:1: (exists candidate:Candidate \u0026 ((forall ov in set (dom (candidate.original_votes)) \u0026 (((ov :\u003e {1}) \u003d {(candidate.name) |-\u003e 1}) and (({(candidate.name)} \u003c: ov) \u003d {(candidate.name) |-\u003e 1}))) and (forall sub_parcel in set (elems (candidate.transferred_votes)) \u0026 (forall tv in set (dom (sub_parcel.votes)) \u0026 ((candidate.name) in set (dom tv))))))","state invariant satisfiable obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 80:7: (exists elected:set of (Candidate), excluded:set of (Candidate), continuing:set of (Candidate), stages:seq of (Stage), quota:real, record:seq of (Record_entry), next_choice:seq of (Candidate_names) \u0026 (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 109:18: (forall s:set of ((nat * Parcel)) \u0026 ((not (s \u003d {})) \u003d\u003e (exists mk_(m, pa) in set s \u0026 true)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 128:8: (forall votes:Parcel, names:set of (Candidate_names) \u0026 (forall name in set names \u0026 inv_Candidate(mk_Candidate(name, vote_res(votes, {v | v in set (dom votes) \u0026 ((v :\u003e {1}) \u003d {name |-\u003e 1})}), []))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 139:3: (forall s:seq of (Score) \u0026 ((s \u003c\u003e []) \u003d\u003e ((len s) in set (inds s))))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 144:30: (forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e pre_stage_bk(stage)))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 145:36: (forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e (((len stage) - 1) in set (inds stage))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 146:15: (forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e let lowest_value:real \u003d (stage_bk(stage).count), second_lowest_value:real \u003d (stage(((len stage) - 1)).count) in (forall i in set (inds stage) \u0026 (((stage(i).count) \u003e quota) \u003d\u003e (i in set (inds stage))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 147:17: (forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e let lowest_value:real \u003d (stage_bk(stage).count), second_lowest_value:real \u003d (stage(((len stage) - 1)).count) in (forall i in set (inds stage) \u0026 (i in set (inds stage)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 153:11: (forall s:seq of (real) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 153:22: (forall s:seq of (real) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 157:14: (forall stage:Stage, name:Candidate_names, leaders:set of (Candidate_names) \u0026 (exists1 c in set (elems stage) \u0026 ((c.name) \u003d name)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 164:59: (forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (all_stages \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 165:48: (forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (forall score in set (elems (hd all_stages)) \u0026 (all_stages \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 165:45: (forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (forall score in set (elems (hd all_stages)) \u0026 ((hd all_stages) \u003c\u003e [])))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 167:24: (forall name:Candidate_names, all_stages:seq of (Stage) \u0026 let leaders:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d ((hd (hd all_stages)).count))} in (forall i in set (inds all_stages) \u0026 (i in set (inds all_stages))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 171:34: (forall name:Candidate_names, all_stages:seq of (Stage) \u0026 let leaders:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d ((hd (hd all_stages)).count))} in (forall i in set (inds all_stages) \u0026 (sole_leader(all_stages(i), name, leaders) \u003d\u003e (forall j in set {(i + 1), ... ,(len all_stages)}, other_leader in set leaders \u0026 (j in set (inds all_stages))))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 184:23: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall m1, m2 in set {{n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val)} | n in set names} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 184:45: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall n in set names \u0026 (forall m1, m2 in set {{v |-\u003e parcel(v)} | v in set (dom parcel) \u0026 next_preference(n, v, names)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 184:53: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall n in set names \u0026 (forall v in set (dom parcel) \u0026 (next_preference(n, v, names) \u003d\u003e (v in set (dom parcel))))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 187:33: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall m1, m2 in set {{n |-\u003e sub_parcel_map(n)} | n in set (dom sub_parcel_map) \u0026 ((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e})} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 187:41: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall n in set (dom sub_parcel_map) \u0026 (((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e}) \u003d\u003e (n in set (dom sub_parcel_map)))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 188:34: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall n in set (dom sub_parcel_map) \u0026 (n in set (dom sub_parcel_map))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 191:65: (forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in let non_empty_sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e sub_parcel_map(n) | n in set (dom sub_parcel_map) \u0026 ((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e})} in inv_Value(1.0))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 205:18: (forall name:Candidate_names, vote:Voting_paper, continuing:set of (Candidate_names) \u0026 ((name in set (dom vote)) \u003d\u003e (forall i in set (rng vote) \u0026 (name in set (dom vote)))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 214:50: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 inv_Value(1.0))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 219:49: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in inv_Value(total_val_trans_votes))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 220:50: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in (total_no_of_trans_votes \u003e\u003d 0))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 221:24: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (forall m1, m2 in set {{n |-\u003e mk_Sub_parcel(((new_sub_parcels.sub_parcels)(n).votes), transf_val)} | n in set (dom (new_sub_parcels.sub_parcels))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 222:25: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (forall n in set (dom (new_sub_parcels.sub_parcels)) \u0026 (n in set (dom (new_sub_parcels.sub_parcels)))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 225:21: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in inv_Value(total_val_trans_votes))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 225:43: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (total_no_of_trans_votes \u003e\u003d 0))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 227:41: (forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in inv_Value(total_val_trans_votes))","non-zero obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 237:34: (forall surplus:real, total_value:Value, old_value:Value, total_no:nat \u0026 ((surplus \u003c total_value) \u003d\u003e (total_no \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 234:1: (forall surplus:real, total_value:Value, old_value:Value, total_no:nat \u0026 inv_Value((if (surplus \u003c total_value)\nthen ((floor ((100 * surplus) / total_no)) / 100)\nelse old_value)))","non-zero obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 243:22: (forall surplus:real, total_value:Value, total_number:nat, old_value:Value \u0026 ((surplus \u003c total_value) \u003d\u003e (total_number \u003c\u003e 0)))","non-zero obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 244:45: (forall surplus:real, total_value:Value, total_number:nat, old_value:Value \u0026 ((surplus \u003c total_value) \u003d\u003e (total_value \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 247:1: (forall surplus:real, total_value:Value \u0026 inv_Value((if (surplus \u003e total_value)\nthen (surplus - total_value)\nelse 0)))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 256:18: (forall previous_collection:Candset, bundle:Sub_parcel_bundle \u0026 (((dom (bundle.sub_parcels)) subset {(candidate.name) | candidate in set previous_collection}) \u003d\u003e (forall candidate in set previous_collection, n in set (dom (bundle.sub_parcels)) \u0026 (((candidate.name) \u003d n) \u003d\u003e (n in set (dom (bundle.sub_parcels)))))))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 273:26: (forall sta:Stage \u0026 ((not ([] \u003d sta)) \u003d\u003e ((not (exists [e]:Stage \u0026 ([e] \u003d sta))) \u003d\u003e (exists sta1 ^ sta2 in set {sta} \u0026 ((abs ((len sta1) - (len sta2))) \u003c 2)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 284:37: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e (sta1 \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 284:56: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e (sta2 \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 285:36: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((((hd sta1).count) \u003e\u003d ((hd sta2).count)) \u003d\u003e (sta1 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 285:59: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((((hd sta1).count) \u003e\u003d ((hd sta2).count)) \u003d\u003e (sta1 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 287:36: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (((hd sta1).count) \u003e\u003d ((hd sta2).count))) \u003d\u003e (sta2 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 287:65: (forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (((hd sta1).count) \u003e\u003d ((hd sta2).count))) \u003d\u003e (sta2 \u003c\u003e [])))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 280:3: (forall sta1:Stage, sta2:Stage \u0026 inv_Stage((cases mk_(sta1, sta2) :\nmk_([], sta) -\u003e sta,\nmk_(sta, []) -\u003e sta\nothers (if (((hd sta1).count) \u003e\u003d ((hd sta2).count))\nthen ([(hd sta1)] ^ score_merge((tl sta1), sta2))\nelse ([(hd sta2)] ^ score_merge(sta1, (tl sta2))))\n end)))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 293:12: (forall s:set of (Score) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 290:1: (forall s:set of (Score) \u0026 inv_Stage((if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ set_seq((s \\ {e}))))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 305:39: (forall old_stage:Stage, discontinuing:Candidate_names, bundle:Sub_parcel_bundle \u0026 let cands_with_more_votes:set of (Candidate_names) \u003d (dom (bundle.sub_parcels)) in (forall mk_Score(name, old_count) in set (elems old_stage) \u0026 ((name in set cands_with_more_votes) \u003d\u003e (name in set (dom (bundle.sub_parcels))))))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 306:33: (forall old_stage:Stage, discontinuing:Candidate_names, bundle:Sub_parcel_bundle \u0026 let cands_with_more_votes:set of (Candidate_names) \u003d (dom (bundle.sub_parcels)) in (forall mk_Score(name, old_count) in set (elems old_stage) \u0026 ((name in set cands_with_more_votes) \u003d\u003e (name in set (dom (bundle.sub_parcels))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 318:17: (forall stages:seq of (Stage), quota:real \u0026 (stages \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 318:14: (forall stages:seq of (Stage), quota:real \u0026 ((hd stages) \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 320:13: (forall stages:seq of (Stage), quota:real \u0026 ((((hd (hd stages)).count) \u003e\u003d quota) \u003d\u003e pre_defer_transfer_of_surplus(quota, (hd stages))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 320:49: (forall stages:seq of (Stage), quota:real \u0026 ((((hd (hd stages)).count) \u003e\u003d quota) \u003d\u003e (stages \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 324:31: (forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 pre_stage_bk((hd all_stages)))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 328:25: (forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 let trailing_count:real \u003d (stage_bk((hd all_stages)).count) in let lowest:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d trailing_count)} in (forall i in set (inds all_stages) \u0026 (i in set (inds all_stages))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 330:35: (forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 let trailing_count:real \u003d (stage_bk((hd all_stages)).count) in let lowest:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d trailing_count)} in (forall i in set (inds all_stages) \u0026 (sole_trailer(all_stages(i), name, lowest) \u003d\u003e (forall j in set {(i + 1), ... ,(len all_stages)}, other in set lowest \u0026 (j in set (inds all_stages))))))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 334:16: (forall stage:Stage, name:Candidate_names, lowest:set of (Candidate_names) \u0026 (exists1 c in set (elems stage) \u0026 ((c.name) \u003d name)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 344:1: (forall cands:set of (Candidate_names) \u0026 ((Number_of_vacancies - (card cands)) \u003e\u003d 0))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 355:53: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 (stages \u003c\u003e []))","legal map application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 363:35: (forall paper:Voting_paper, discontinuing:Candidate_names, continuing_names:set of (Candidate_names) \u0026 ((not (((dom (paper :-\u003e {1})) inter continuing_names) \u003d {})) \u003d\u003e (discontinuing in set (dom paper))))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 365:16: (forall paper:Voting_paper, discontinuing:Candidate_names, continuing_names:set of (Candidate_names) \u0026 ((not (((dom (paper :-\u003e {1})) inter continuing_names) \u003d {})) \u003d\u003e let s:set of (nat1) \u003d (rng (paper :-\u003e {1, ... ,paper(discontinuing)})) in ((not (s \u003d {})) \u003d\u003e pre_min(s))))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 372:6: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 374:16: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_min((s \\ {m}))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 381:35: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) in set continuing_names) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 381:38: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) in set continuing_names) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 381:68: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (stages \u003c\u003e []))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 382:32: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 382:35: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 383:32: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).count) \u003e quota) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 383:35: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).count) \u003e quota) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 383:65: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (stages \u003c\u003e []))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 384:36: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 384:39: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 386:11: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (i in set (inds continuing_scores))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 387:18: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (forall j in set ((inds continuing_scores) \\ {i}) \u0026 (j in set (inds continuing_scores)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 389:18: (forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (forall j in set (inds surplus_scores) \u0026 (j in set (inds surplus_scores)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 398:25: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((i + 1) in set (inds stages))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 398:43: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (i in set (inds stages))))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 399:38: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (exists1 ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 401:51: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (forall ex in set Cand_names \u0026 ((i + 1) in set (inds stages))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 402:59: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (forall ex in set Cand_names \u0026 (forall sc in set (elems stages((i + 1))) \u0026 (i in set (inds stages)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 404:33: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e let excluded:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})) in ((i + 1) in set (inds record)))))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 405:41: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (exists1 tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 407:52: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (forall tf in set Cand_names \u0026 ((i + 1) in set (inds stages))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 408:68: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (forall tf in set Cand_names \u0026 (forall sc in set (elems stages((i + 1))) \u0026 (i in set (inds stages)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 410:33: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e let transferred:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})) in ((i + 1) in set (inds record)))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 411:38: (forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 let result: (nat1 -\u003e Result)\n\tresult(i) \u003d\u003d\n(if ((len stages((i + 1))) \u003e (len stages(i)))\nthen let excluded:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})) in mk_Result((record((i + 1)).scores), nil, excluded)\nelse let transferred:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})) in mk_Result((record((i + 1)).scores), transferred, nil)) in (forall j in set {1, ... ,((len record) - 1)} \u0026 (((len record) - j) \u003e 0)))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 417:12: (forall s:set of (Sub_parcel) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","let be st existence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 424:26: (forall sps:seq of (Sub_parcel) \u0026 ((not ([] \u003d sps)) \u003d\u003e ((not (exists [e]:seq of (Sub_parcel) \u0026 ([e] \u003d sps))) \u003d\u003e (exists sps1 ^ sps2 in set {sps} \u0026 ((abs ((len sps1) - (len sps2))) \u003c 2)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 435:48: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e (sps1 \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 435:71: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e (sps2 \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 436:39: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((total_value((hd sps1)) \u003e\u003d total_value((hd sps2))) \u003d\u003e (sps1 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 436:68: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((total_value((hd sps1)) \u003e\u003d total_value((hd sps2))) \u003d\u003e (sps1 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 437:39: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (total_value((hd sps1)) \u003e\u003d total_value((hd sps2)))) \u003d\u003e (sps2 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 437:74: (forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (total_value((hd sps1)) \u003e\u003d total_value((hd sps2)))) \u003d\u003e (sps2 \u003c\u003e [])))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 446:53: ((stages \u003c\u003e []) \u003d\u003e (stages \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 447:46: ((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 (stages \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 447:43: ((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 ((hd stages) \u003c\u003e [])))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 452:25: ((stages \u003c\u003e []) \u003d\u003e (exists1 name in set leaders \u0026 greatest_value_at_earliest_stage(name, stages)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 460:51: ((stages \u003c\u003e []) \u003d\u003e (stages \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 461:40: ((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 pre_stage_bk((hd stages))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 461:52: ((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 (stages \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 465:46: ((stages \u003c\u003e []) \u003d\u003e (forall n in set lowest \u0026 is_(stages, seq1 of (Stage))))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 466:25: ((stages \u003c\u003e []) \u003d\u003e (exists1 name in set lowest \u0026 trailing_candidate(name, stages)))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 467:46: ((stages \u003c\u003e []) \u003d\u003e (forall name in set lowest \u0026 is_(stages, seq1 of (Stage))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 474:32: (forall s:Candnset, oldstate:St \u0026 (next_choice \u003c\u003e []))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 475:4: (forall s:Candnset, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 475:22: (forall s:Candnset, oldstate:St \u0026 (next_choice \u003c\u003e []))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 481:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 482:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 483:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 484:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 485:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 486:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-zero obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 486:45: (forall votes:Parcel, oldstate:St \u0026 ((Number_of_vacancies + 1) \u003c\u003e 0))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 487:6: (forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 487:42: (forall votes:Parcel, oldstate:St \u0026 ([build_first_stage(curr_cont)] \u003c\u003e []))","operation call obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 491:7: (forall votes:Parcel, oldstate:St \u0026 (number_of_candidates_satisfying_quota(curr_cont, [build_first_stage(curr_cont)], two_decimal_places((size(votes) / (Number_of_vacancies + 1)))) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 497:4: let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 498:4: let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name))))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 506:55: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 inv_Value(0.0))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 508:31: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (stages \u003c\u003e []))","while loop termination obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 509:4: ...","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 510:11: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 511:7: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 512:37: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 512:58: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 514:11: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 515:9: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 516:11: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 516:28: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 pre_redistribute_parcels(new_candidates, construct_sub_parcels((sub_parcels((i + 1)).value), (sub_parcels((i + 1)).votes), ex_cand, new_candidates)))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 517:11: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 526:10: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 527:17: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 529:9: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 530:9: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 531:9: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 533:59: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (record \u003c\u003e []))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 539:9: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 539:20: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (forall i in set (inds new_stage) \u0026 (((new_stage(i).name) \u003c\u003e (ex_cand.name)) \u003d\u003e (i in set (inds new_stage)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 540:27: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (forall i in set (inds new_stage) \u0026 (i in set (inds new_stage))))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 540:62: (forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 is_(([[new_stage(i) | i in set (inds new_stage) \u0026 ((new_stage(i).name) \u003c\u003e (ex_cand.name))]] ^ stages), seq of (Stage)))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 545:37: (last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (exists1 leader in set continuing \u0026 ((leader.name) \u003d ((hd stages)(Number_of_vacancies).name))))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 546:25: (last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (forall leader in set continuing \u0026 (Number_of_vacancies in set (inds (hd stages)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 546:28: (last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (forall leader in set continuing \u0026 (stages \u003c\u003e [])))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 547:6: (last_vacancy_fillable(continuing, stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 548:6: (last_vacancy_fillable(continuing, stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 554:20: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (exists1 c in set elected \u0026 ((c.name) \u003d name)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 555:25: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (stages \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 555:22: (exists_non_deferable_surplus(stages, quota) \u003d\u003e ((hd stages) \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 557:65: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (surplus_from_original_votes(candidate) \u003d\u003e inv_Value(1.0)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 558:29: (exists_non_deferable_surplus(stages, quota) \u003d\u003e ((not surplus_from_original_votes(candidate)) \u003d\u003e ((candidate.transferred_votes) \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 563:35: (exists_non_deferable_surplus(stages, quota) \u003d\u003e inv_Stage(([mk_Score(name, quota)] ^ [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) \u003c\u003e name)])))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 564:15: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) \u003c\u003e name) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 564:18: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) \u003c\u003e name) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 564:49: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (stages \u003c\u003e []))","legal sequence application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 564:60: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 565:16: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 567:19: (exists_non_deferable_surplus(stages, quota) \u003d\u003e pre_redistribute_parcels((continuing \\ {candidate}), sub_parcel_bundle))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 569:6: (exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 570:6: (exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 572:42: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (record \u003c\u003e []))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 577:5: (exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","operation call obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 580:11: (exists_non_deferable_surplus(stages, quota) \u003d\u003e (number_of_candidates_satisfying_quota(curr_cont, ([new_stage] ^ stages), quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","unique existence binding obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 587:31: (exists1 c in set continuing \u0026 ((c.name) \u003d name))","type compatibility obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 593:70: inv_Value(1.0)","operation call obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 606:12: (true \u003d\u003e (number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","operation call obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 610:12: (true \u003d\u003e (true \u003d\u003e last_vacancy_fillable(continuing, stages, quota)))","operation call obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 612:12: (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e exists_non_deferable_surplus(stages, quota))))","while loop termination obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 618:6: ...","non-empty sequence obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 625:52: ((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e (stages \u003c\u003e []))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 629:7: ((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation in \u0027DEFAULT\u0027 (stv.vdmsl) at line 630:6: ((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))"]