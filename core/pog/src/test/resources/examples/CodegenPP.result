["state invariant initialized obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 12:5: ((card (dom {|-\u003e})) \u003d (card (rng {|-\u003e})))","state invariant satisfiable obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 12:5: (exists typeDefs:seq of (SimpleTypeDefinition), context:map (seq of (char)) to (seq of (char)), varDecls:seq of (GiraffeVariableDeclStatement), uid:nat1 \u0026 ((card (dom context)) \u003d (card (rng context))))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 22:21: (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))","legal function application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 23:30: pre_((util.iToS)res)","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 20:9: (RESULT not in set (rng context))","while loop termination obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 29:5: ...","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 26:9: (RESULT not in set (dom context))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 52:29: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (((len programName) \u003e 0) \u003d\u003e (1 in set (inds programName)))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 45:63: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (isofclass(SimpleFunctionDefinition,defs(i)) \u003d\u003e (i in set (inds defs))))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 47:92: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 50:10: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 50:23: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (isofclass(SimpleTypeDefinition,defs(i)) \u003d\u003e (i in set (inds defs))))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 50:86: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 50:22: (forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e is_([defs(i) | i in set (inds defs) \u0026 isofclass(SimpleTypeDefinition,defs(i))], seq of (SimpleTypeDefinition))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 58:53: (forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 60:30: (forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e is_(Compile(GetType((func.getBody)())), GiraffeType)))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 62:9: (forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))))","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 54:8: (forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (([] \u003d []) and (context \u003d {|-\u003e}))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 70:30: (forall param:SimpleParameter \u0026 is_(Compile((param.getType)()), GiraffeType))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 76:40: (forall type:SimpleType \u0026 is_(type, SimpleIdentifier))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 79:39: (forall type:SimpleType \u0026 is_(type, SimpleBasicType))","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 73:8: (forall type:SimpleType \u0026 (RESULT \u003c\u003e nil))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 90:102: (forall exp:SimpleExpression \u0026 is_(exp, SimpleIntegerLiteralExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 92:86: (forall exp:SimpleExpression \u0026 is_(exp, SimpleBinaryExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 94:84: (forall exp:SimpleExpression \u0026 is_(exp, SimpleCasesExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 96:92: (forall exp:SimpleExpression \u0026 is_(exp, SimpleVariableExpression))","legal map application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 98:128: (forall exp:SimpleExpression \u0026 ((name.getName)() in set (dom context)))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 99:83: (forall exp:SimpleExpression \u0026 is_(exp, SimpleLetExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 101:78: (forall exp:SimpleExpression \u0026 is_(exp, SimpleIfExpression))","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 87:8: (forall exp:SimpleExpression \u0026 (RESULT \u003c\u003e nil))","non-empty sequence obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 116:56: (forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e ((e.getAlts)() \u003c\u003e []))))","non-empty sequence obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 118:62: (forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e ((e.getAlts)() \u003c\u003e []))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 119:163: (forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e (forall i in set (inds rest) \u0026 (i in set (inds rest))))))","legal sequence application obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 119:183: (forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e (forall i in set (inds rest) \u0026 (i in set (inds rest))))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 107:8: (forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e is_(RESULT, GiraffeExpression)))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 133:39: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile(type), GiraffeType)))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 135:46: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile((x.getValue)()), GiraffeExpression)))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 137:17: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))))))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 138:17: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))) \u003d\u003e ((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 139:41: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile((letExp.getBody)()), GiraffeExpression)))","state invariant holds obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 140:13: (forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))) \u003d\u003e ((card (dom oldContext)) \u003d (card (rng oldContext))))))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 146:52: (forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(lhs), GiraffeExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 148:52: (forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(rhs), GiraffeExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 151:52: (forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(lhs), GiraffeExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 153:52: (forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(rhs), GiraffeExpression))","operation establishes postcondition obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 143:8: (forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 (RESULT \u003c\u003e nil))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 173:33: (forall selif:SimpleIfExpression \u0026 is_(Compile((selif.getTest)()), GiraffeExpression))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 174:33: (forall selif:SimpleIfExpression \u0026 is_(Compile((selif.getThn)()), GiraffeExpression))","non-empty sequence obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 184:48: (forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e (elsif \u003c\u003e [])))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 185:41: (forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e is_(Compile((head.getTest)()), GiraffeExpression)))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 186:41: (forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e is_(Compile((head.getThn)()), GiraffeExpression)))","non-empty sequence obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 187:54: (forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e (elsif \u003c\u003e [])))","type compatibility obligation in \u0027Compiler\u0027 (Compiler.vdmpp) at line 179:8: (forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 is_((if (elsif \u003d [])\nthen Compile(els)\nelse let head:SimpleElseIfExpression \u003d (hd elsif), gTest:GiraffeExpression \u003d Compile((head.getTest)()), gThen:GiraffeExpression \u003d Compile((head.getThn)()), gElse:GiraffeExpression \u003d deflatten((tl elsif), els) in new GiraffeIfExpressionImpl(gTest, gThen, gElse)), GiraffeExpression))","legal sequence application obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 21:55: (forall classDef:GiraffeClassDefinition \u0026 (forall i in set (inds mlist) \u0026 (i in set (inds mlist))))","legal sequence application obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 28:71: (forall method:GiraffeMethodDefinition \u0026 (forall i in set (inds params) \u0026 (i in set (inds params))))","legal sequence application obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 30:58: (forall method:GiraffeMethodDefinition \u0026 (forall i in set (inds body) \u0026 (i in set (inds body))))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 39:41: (forall type:GiraffeType \u0026 is_(type, GiraffeIdentifier))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 42:40: (forall type:GiraffeType \u0026 is_(type, GiraffeBasicType))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 55:56: (forall stm:GiraffeStatement \u0026 is_(stm, GiraffeVariableDeclStatement))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 57:90: (forall stm:GiraffeStatement \u0026 is_(stm, GiraffeReturnStatement))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 66:59: (forall exp:GiraffeExpression \u0026 is_(exp, GiraffeIntegerLiteralExpression))","legal function application obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 67:28: (forall exp:GiraffeExpression \u0026 pre_((new codegen_Util().iToS)(e.getValue)()))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 69:53: (forall exp:GiraffeExpression \u0026 is_(exp, GiraffeVariableExpression))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 72:51: (forall exp:GiraffeExpression \u0026 is_(exp, GiraffeBinaryExpression))","type compatibility obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 75:47: (forall exp:GiraffeExpression \u0026 is_(exp, GiraffeIfExpression))","non-empty sequence obligation in \u0027Codegen\u0027 (Codegen.vdmpp) at line 99:16: (forall x:seq of (seq of (char)) \u0026 ((not (x \u003d [])) \u003d\u003e (x \u003c\u003e [])))","non-empty sequence obligation in \u0027codegen_Util\u0027 (nativetest.vdmpp) at line 22:26: (forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","type compatibility obligation in \u0027codegen_Util\u0027 (nativetest.vdmpp) at line 32:75: (forall programs:seq of (seq of (char)) \u0026 is_(e, int))","non-empty sequence obligation in \u0027codegen_Util\u0027 (nativetest.vdmpp) at line 32:87: (forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","non-empty sequence obligation in \u0027codegen_Util\u0027 (nativetest.vdmpp) at line 34:66: (forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","type compatibility obligation in \u0027GiraffeCasesExpressionImpl\u0027 (GiraffeCasesExpressionImpl.vdmpp) at line 30:12: is_(RESULT, GiraffeExpression)","type compatibility obligation in \u0027SimpleCasesExpressionImpl\u0027 (SimpleCasesExpressionImpl.vdmpp) at line 30:12: is_(RESULT, SimpleExpression)","operation call obligation in \u0027IO\u0027 (IO.vdmpp) at line 80:3: (forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]