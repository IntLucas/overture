["legal function application obligation in \u0027ItemLoader\u0027 (ItemLoader.vdmpp) at line 48:39: (forall fname:seq1 of (char) \u0026 pre_(((io.freadval))[InputTP]fname))","type compatibility obligation in \u0027ItemLoader\u0027 (ItemLoader.vdmpp) at line 51:29: (forall fname:seq1 of (char) \u0026 (timeval \u003e\u003d 0))","type compatibility obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 42:47: inv_UID(0)","comprehension map injectivity obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 56:23: (forall e:SorterEnviroment \u0026 (forall m1, m2 in set {{num |-\u003e new Tray(num)} | num in set {1, ... ,NumOfTrays}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 56:23: (forall e:SorterEnviroment \u0026 is_({num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}}, inmap (UID) to (Tray)))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 53:12: (forall e:SorterEnviroment \u0026 ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len [new InductionController(self, num) | num in set {1, ... ,NumOfInductions}]) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom {num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}})) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom {num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}})))))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 70:9: (forall uid:UID, state:State \u0026 ((uid in set (dom sorterRing)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))))))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 76:9: (forall uid:UID, state:State \u0026 ((uid in set (dom sorterRing)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))))))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 90:22: (forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 91:22: (forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","state invariant holds obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 107:21: (forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","operation call obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 110:21: (forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (true \u003d\u003e ((item \u003c\u003e {}) and (forall t in set trays \u0026 (t.IsTrayEmpty)())))))","legal map application obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 127:50: (forall id in set (dom sorterRing) \u0026 (id in set (dom sorterRing)))","non-zero obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 144:51: (forall steps:nat, trays:set of (Tray), items:nat \u0026 ((trays \u003c\u003e {}) \u003d\u003e (SorterEnviroment`Speed \u003c\u003e 0)))","non-zero obligation in \u0027TrayAllocator\u0027 (TrayAllocator.vdmpp) at line 149:51: (forall steps:nat, trays:set of (Tray), items:nat \u0026 ((trays \u003c\u003e {}) \u003d\u003e (runTime \u003c\u003e 0)))","legal map application obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 24:20: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 25:20: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (((trayAllocator.sorterRing)(posTray).IsTrayEmpty)() \u003d\u003e (posTrayNext in set (dom (trayAllocator.sorterRing))))))","type compatibility obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 25:45: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (((trayAllocator.sorterRing)(posTray).IsTrayEmpty)() \u003d\u003e (inv_UID(posTrayNext) and is_(posTrayNext, nat)))))","legal map application obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 26:30: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 26:65: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTrayNext in set (dom (trayAllocator.sorterRing)))))","type compatibility obligation in \u0027AllocatorTwoTray\u0027 (AllocatorTwoTray.vdmpp) at line 26:90: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (inv_UID(posTrayNext) and is_(posTrayNext, nat))))","legal sequence application obligation in \u0027World\u0027 (World.vdmpp) at line 83:38: (test in set (inds testfiles))","legal sequence application obligation in \u0027World\u0027 (World.vdmpp) at line 87:85: (true \u003d\u003e (test in set (inds testfiles)))","while loop termination obligation in \u0027String\u0027 (String.vdmpp) at line 25:9: ...","type compatibility obligation in \u0027String\u0027 (String.vdmpp) at line 27:31: (forall val:nat \u0026 (((x1 mod 10) + 1) \u003e\u003d 0))","legal sequence application obligation in \u0027String\u0027 (String.vdmpp) at line 28:24: (forall val:nat \u0026 (((x1 mod 10) + 1) in set (inds numeric)))","type compatibility obligation in \u0027String\u0027 (String.vdmpp) at line 29:22: (forall val:nat \u0026 ((x1 div 10) \u003e\u003d 0))","type invariant satisfiable obligation in \u0027Tray\u0027 (Tray.vdmpp) at line 9:16: (exists u:UID \u0026 (u \u003c\u003d TrayAllocator`NumOfTrays))","state invariant holds obligation in \u0027Tray\u0027 (Tray.vdmpp) at line 30:12: (forall i:UID \u0026 ((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)))","state invariant holds obligation in \u0027Tray\u0027 (Tray.vdmpp) at line 62:13: (forall s:State \u0026 (((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((nil \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e))))","state invariant holds obligation in \u0027Tray\u0027 (Tray.vdmpp) at line 63:9: (forall s:State \u0026 (((nil \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((nil \u003c\u003e nil) \u003d\u003e (s \u003d \u003cFull\u003e))))","state invariant holds obligation in \u0027Tray\u0027 (Tray.vdmpp) at line 75:9: (((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((i \u003c\u003e nil) \u003d\u003e (\u003cFull\u003e \u003d \u003cFull\u003e)))","type invariant satisfiable obligation in \u0027Item\u0027 (Item.vdmpp) at line 8:16: (exists it:ItemTraySize \u0026 (it \u003c\u003d ItemMaxTrays))","non-zero obligation in \u0027Item\u0027 (Item.vdmpp) at line 35:29: (forall s:nat1, i:nat \u0026 (Tray`TraySize \u003c\u003e 0))","type compatibility obligation in \u0027Item\u0027 (Item.vdmpp) at line 35:47: (forall s:nat1, i:nat \u0026 (inv_ItemTraySize(((s div Tray`TraySize) + 1)) and is_(((size div Tray`TraySize) + 1), nat1)))","state invariant holds obligation in \u0027Item\u0027 (Item.vdmpp) at line 31:12: (forall s:nat1, i:nat \u0026 ((s \u003e\u003d ItemMinSize) and (s \u003c\u003d ItemMaxSize)))","state invariant holds obligation in \u0027Item\u0027 (Item.vdmpp) at line 57:9: (forall tray:Tray \u0026 (((size \u003e\u003d ItemMinSize) and (size \u003c\u003d ItemMaxSize)) \u003d\u003e ((size \u003e\u003d ItemMinSize) and (size \u003c\u003d ItemMaxSize))))","operation postcondition satisfiable obligation in \u0027Item\u0027 (Item.vdmpp) at line 60:12: (exists newself:Item \u0026 post_RemoveItemFromTray(oldself, newself))","type compatibility obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 29:15: (forall a:TrayAllocator, n:nat \u0026 (n \u003e 0))","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 25:12: (forall a:TrayAllocator, n:nat \u0026 ((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)))","non-empty sequence obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 54:27: (items \u003c\u003e [])","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 60:9: (forall i:Item \u0026 (((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((priority \u003e 0) \u003d\u003e ((len (items ^ [i])) \u003e 0))))","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 67:9: (((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)))","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 72:13: (forall priority6:nat, id7:nat1, allocator8:TrayAllocator, items9:seq of (Item), stepCount10:nat \u0026 (((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)) \u003d\u003e (((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)) \u003d\u003e ((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)))))","non-empty sequence obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 85:31: (items \u003c\u003e [])","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 90:25: (((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((0 \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)))","state invariant holds obligation in \u0027InductionController\u0027 (InductionController.vdmpp) at line 97:25: (((0 \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)) \u003d\u003e (((0 + 1) \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)))","type compatibility obligation in \u0027AllocatorStrategy\u0027 (AllocatorStrategy.vdmpp) at line 25:19: (forall trayAtCardReader:UID, icid:nat \u0026 (inv_UID((((trayAtCardReader + (icid * TrayAllocator`InductionSeperation)) mod TrayAllocator`NumOfTrays) + 1)) and is_((((trayAtCardReader + (icid * TrayAllocator`InductionSeperation)) mod TrayAllocator`NumOfTrays) + 1), nat)))","legal map application obligation in \u0027AllocatorOneTray\u0027 (AllocatorOneTray.vdmpp) at line 23:20: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation in \u0027AllocatorOneTray\u0027 (AllocatorOneTray.vdmpp) at line 24:30: (forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","operation call obligation in \u0027IO\u0027 (IO.vdmpp) at line 80:3: (forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]