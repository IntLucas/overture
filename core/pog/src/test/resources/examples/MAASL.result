["type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 38:4: (exists N:Number \u0026 (N \u003c Maximum_Number_Size_plus_1))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 41:4: (exists b:Bit \u0026 (b in set {0, 1}))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 47:18: (forall M:seq of (Bit) \u0026 ((((len M) mod Word_Length) \u003d 0) \u003d\u003e (Word_Length \u003c\u003e 0)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 49:17: (forall M:seq of (Bit) \u0026 ((not (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (Word_Length \u003c\u003e 0)))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 44:4: (exists M:Message_in_bits \u0026 (if (((len M) mod Word_Length) \u003d 0)\nthen ((((len M) div Word_Length) \u003c\u003d Maximum_No_of_Message_blocks) and ((len M) \u003e 0))\nelse ((((len M) div Word_Length) + 1) \u003c\u003d Maximum_No_of_Message_blocks)))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 51:4: (exists M:Message_in_blocks_plus_empty_Message \u0026 ((len M) \u003c\u003d Maximum_No_of_Message_blocks))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 54:4: (exists M:Message_in_blocks \u0026 (1 \u003c\u003d (len M)))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 63:4: (exists d:Double_Number \u0026 ((len d) \u003d 2))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 92:16: (forall M:Message_in_bits \u0026 let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in ((not (No_Extra_bits \u003d Word_Length)) \u003d\u003e pre_Get_Application_defined_bits(M, No_Extra_bits)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 92:47: (forall M:Message_in_bits \u0026 let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in ((not (No_Extra_bits \u003d Word_Length)) \u003d\u003e (No_Extra_bits \u003e\u003d 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 87:4: (forall M:Message_in_bits \u0026 inv_Message_in_bits(let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in (if (No_Extra_bits \u003d Word_Length)\nthen M\nelse (M ^ Get_Application_defined_bits(M, No_Extra_bits)))))","function postcondition satisfiable obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 94:4: (forall M:Message_in_bits, No_bits:nat \u0026 (pre_Get_Application_defined_bits(M, No_bits) \u003d\u003e (exists Extra:Message_in_bits \u0026 post_Get_Application_defined_bits(M, No_bits, Extra))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 102:11: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (((len M) \u003d Word_Length) \u003d\u003e pre_Form_Number(M))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 103:11: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Form_Number(Get_head_in_bits(M, Word_Length)))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 103:23: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Get_head_in_bits(M, Word_Length))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 104:10: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length)))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 104:35: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Get_tail_in_bits(M, Word_Length))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 99:4: (forall M:Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (inv_Message_in_blocks((if ((len M) \u003d Word_Length)\nthen [Form_Number(M)]\nelse ([Form_Number(Get_head_in_bits(M, Word_Length))] ^ Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length))))) and inv_Message_in_blocks_plus_empty_Message((if ((len M) \u003d Word_Length)\nthen [Form_Number(M)]\nelse ([Form_Number(Get_head_in_bits(M, Word_Length))] ^ Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length))))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 109:29: (forall M:Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 110:14: (forall M:Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 110:22: (forall M:Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e pre_Form_Number((tl M)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 110:38: (forall M:Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 107:4: (forall M:Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e inv_Number((if ((len M) \u003d 1)\nthen (hd M)\nelse ((hd M) + (2 * Form_Number((tl M))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 120:4: (forall X:Number \u0026 inv_Number((ADD(X, X) + CAR(X, X))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 128:40: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 128:48: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 124:4: (forall X:Number, Y:Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen 0\nelse ((((X mod 2) * Y) mod 2) + (2 * AND((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen 0\nelse ((((X mod 2) * Y) mod 2) + (2 * AND((X div 2), (Y div 2))))), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 134:42: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 134:50: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 130:4: (forall X:Number, Y:Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (max((X mod 2), (Y mod 2)) + (2 * OR((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (max((X mod 2), (Y mod 2)) + (2 * OR((X div 2), (Y div 2))))), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 146:36: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 146:44: (forall X:Number, Y:Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 142:4: (forall X:Number, Y:Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (((X + Y) mod 2) + (2 * XOR((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (((X + Y) mod 2) + (2 * XOR((X div 2), (Y div 2))))), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 148:4: (forall X:Number, Y:Number \u0026 (inv_Number(((X + Y) mod Maximum_Number_Size_plus_1)) and is_(((X + Y) mod Maximum_Number_Size_plus_1), nat)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 154:12: (forall X:Number, Y:Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 152:4: (forall X:Number, Y:Number \u0026 (inv_Number(((X + Y) div Maximum_Number_Size_plus_1)) and is_(((X + Y) div Maximum_Number_Size_plus_1), nat)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 165:14: (forall X:Number, Y:Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 166:16: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 166:18: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(L) and is_(L, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 167:12: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 167:14: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(L) and is_(L, nat)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 177:14: (forall X:Number, Y:Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 177:60: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 177:62: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 178:12: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 178:14: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 178:36: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U), E:Number \u003d CAR(U, U) in inv_Number((2 * E)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 178:58: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U), E:Number \u003d CAR(U, U) in let F:Number \u003d ADD(D, (2 * E)) in (inv_Number(L) and is_(L, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 179:14: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U), E:Number \u003d CAR(U, U) in let F:Number \u003d ADD(D, (2 * E)) in (inv_Number(L) and is_(L, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 179:28: (forall X:Number, Y:Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U), E:Number \u003d CAR(U, U) in let F:Number \u003d ADD(D, (2 * E)) in let S:Number \u003d ADD(F, L), C:Number \u003d CAR(F, L) in inv_Number((2 * C)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 194:11: (forall X:Number, Y:Number \u0026 (Maximum_Number_Size_plus_1_div_2 \u003c\u003e 0))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 195:11: (forall X:Number, Y:Number \u0026 ((not ((X div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e (Maximum_Number_Size_plus_1_div_2 \u003c\u003e 0)))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 190:14: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e (Maximum_Number_Size_plus_1 \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 191:16: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 191:18: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 192:18: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U) in (inv_Number(L) and is_(L, nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 193:14: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U) in (inv_Number(L) and is_(L, nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 193:28: (forall X:Number, Y:Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:Number \u003d ADD(U, U) in let S:Number \u003d ADD(D, L), C:Number \u003d CAR(D, L) in inv_Number((2 * C))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 204:16: (forall K:Double_Number \u0026 (K \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 205:20: (forall K:Double_Number \u0026 (K \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 205:17: (forall K:Double_Number \u0026 ((tl K) \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 206:14: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(X, 3))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 206:24: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(X, 2))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 206:34: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(X, 1))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 206:44: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(X, 0))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 207:14: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(Y, 3))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 207:24: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(Y, 2))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 207:34: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(Y, 1))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 207:44: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in pre_Byte(X, 0))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 210:33: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in (inv_Message_in_blocks(XY) and inv_Message_in_blocks_plus_empty_Message(XY)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 210:36: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in inv_Number(P))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 211:14: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:Message_in_blocks \u003d Condition_Sequence(XY, P) in pre_Get_head_in_blocks(XY\u0027, 4))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 212:14: (forall K:Double_Number \u0026 let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:Message_in_blocks \u003d Condition_Sequence(XY, P) in pre_Get_tail_in_blocks(XY\u0027, 4))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 202:4: (forall K:Double_Number \u0026 inv_Double_Number(let X:Number \u003d (hd K), Y:Number \u003d (hd (tl K)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:Message_in_blocks \u003d Condition_Sequence(XY, P) in let X\u0027\u0027:Message_in_blocks \u003d Get_head_in_blocks(XY\u0027, 4), Y\u0027\u0027:Message_in_blocks \u003d Get_tail_in_blocks(XY\u0027, 4) in ([Convert_Bytes_to_Number(X\u0027\u0027)] ^ [Convert_Bytes_to_Number(Y\u0027\u0027)])))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 219:10: (forall N:Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e pre_Byte((N div (2 ** 8)), (B - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 219:17: (forall N:Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e (inv_Number((N div (2 ** 8))) and is_((N div (2 ** 8)), nat)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 219:29: (forall N:Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e ((B - 1) \u003e\u003d 0))))","non-zero obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 219:17: (forall N:Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e ((2 ** 8) \u003c\u003e 0))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 215:4: (forall N:Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e (inv_Number((if (B \u003d 0)\nthen (N mod (2 ** 8))\nelse Byte((N div (2 ** 8)), (B - 1)))) and is_((if (B \u003d 0)\nthen (N mod (2 ** 8))\nelse Byte((N div (2 ** 8)), (B - 1))), nat))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 225:31: (forall M:Message_in_blocks, P:Number \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 226:31: (forall M:Message_in_blocks, P:Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 227:33: (forall M:Message_in_blocks, P:Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 227:47: (forall M:Message_in_blocks, P:Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 222:4: (forall M:Message_in_blocks, P:Number \u0026 (inv_Message_in_blocks((if ((len M) \u003d 1)\nthen [Condition_value((hd M), P)]\nelse ([Condition_value((hd M), P)] ^ Condition_Sequence((tl M), Changes((hd M), P))))) and inv_Message_in_blocks_plus_empty_Message((if ((len M) \u003d 1)\nthen [Condition_value((hd M), P)]\nelse ([Condition_value((hd M), P)] ^ Condition_Sequence((tl M), Changes((hd M), P)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 229:4: (forall B:Number, P:Number \u0026 (inv_Number(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if (B \u003d 0)\nthen P\u0027\u0027\nelse (if (B \u003d ((2 ** 8) - 1))\nthen (((2 ** 8) - 1) - P\u0027\u0027)\nelse B))) and is_(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if (B \u003d 0)\nthen P\u0027\u0027\nelse (if (B \u003d ((2 ** 8) - 1))\nthen (((2 ** 8) - 1) - P\u0027\u0027)\nelse B)), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 238:4: (forall B:Number, P:Number \u0026 inv_Number(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if ((B \u003d 0) or (B \u003d ((2 ** 8) - 1)))\nthen P\u0027\u0027\nelse P\u0027)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 249:14: (forall M:Message_in_blocks \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 250:38: (forall M:Message_in_blocks \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 250:47: (forall M:Message_in_blocks \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 246:4: (forall M:Message_in_blocks \u0026 inv_Number((if ((len M) \u003d 1)\nthen (hd M)\nelse (Convert_Bytes_to_Number((tl M)) + ((hd M) * (2 ** (8 * ((len M) - 1))))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 254:16: (forall D:Double_Number \u0026 (D \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 255:20: (forall D:Double_Number \u0026 (D \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 255:17: (forall D:Double_Number \u0026 ((tl D) \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 256:14: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(X, 3))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 256:24: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(X, 2))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 256:34: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 1))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 256:44: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 0))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 257:14: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 3))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 257:24: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 2))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 257:34: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 1))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 257:44: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in pre_Byte(Y, 0))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 260:19: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(Y, 1), Byte(Y, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(Y, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in (inv_Message_in_blocks(XY) and inv_Message_in_blocks_plus_empty_Message(XY)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 260:22: (forall D:Double_Number \u0026 let X:Number \u003d (hd D), Y:Number \u003d (hd (tl D)) in let X\u0027:seq1 of (Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(Y, 1), Byte(Y, 0)], Y\u0027:seq1 of (Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(Y, 0)] in let XY:seq1 of (Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in inv_Number(P))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 265:22: (forall M:Message_in_blocks, P:Number \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 266:29: (forall M:Message_in_blocks, P:Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 266:43: (forall M:Message_in_blocks, P:Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 278:17: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in (J1K1 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 279:21: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in (J1K1 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 279:18: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in ((tl J1K1) \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 304:21: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in inv_Number(Q))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 307:19: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in inv_Double_Number([H4, H5]))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 308:18: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in inv_Double_Number([H6, H7]))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 309:17: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in inv_Double_Number([H8, H9]))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:24: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (X0Y0 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:37: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (X0Y0 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:34: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in ((tl X0Y0) \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:46: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (V0W \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:58: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (V0W \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:55: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in ((tl V0W) \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:66: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (ST \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:77: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in (ST \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 310:74: (forall K:Key \u0026 let J1K1:Double_Number \u003d BYT(K) in let J1:Number \u003d (hd J1K1), K1:Number \u003d (hd (tl J1K1)), P:Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:Number \u003d MUL1(J1, J1), J22:Number \u003d MUL2(J1, J1) in let J14:Number \u003d MUL1(J12, J12), J24:Number \u003d MUL2(J22, J22) in let J16:Number \u003d MUL1(J12, J14), J26:Number \u003d MUL2(J22, J24) in let J18:Number \u003d MUL1(J12, J16), J28:Number \u003d MUL2(J22, J26) in let H4:Number \u003d XOR(J14, J28), H6:Number \u003d XOR(J16, J26), H8:Number \u003d XOR(J18, J28) in let K12:Number \u003d MUL1(K1, K1), K22:Number \u003d MUL2(K1, K1) in let K14:Number \u003d MUL1(K12, K12), K24:Number \u003d MUL2(K22, K22) in let K15:Number \u003d MUL1(K1, K14), K25:Number \u003d MUL2(K1, K24) in let K17:Number \u003d MUL1(K12, K15), K27:Number \u003d MUL2(K22, K25) in let K19:Number \u003d MUL1(K12, K17), K29:Number \u003d MUL2(K22, K27) in let H\u0027:Number \u003d XOR(K15, K25) in let H5:Number \u003d MUL2(H\u0027, Q), H7:Number \u003d XOR(K17, K27), H9:Number \u003d XOR(K19, K29) in let X0Y0:Double_Number \u003d BYT([H4, H5]), V0W:Double_Number \u003d BYT([H6, H7]), ST:Double_Number \u003d BYT([H8, H9]) in ((tl ST) \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 323:23: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 330:24: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in inv_Number(A)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 331:24: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in inv_Number(B)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 332:27: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in let F\u0027:Number \u003d OR(F, A), G\u0027:Number \u003d OR(G, B) in inv_Number(C)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 333:27: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in let F\u0027:Number \u003d OR(F, A), G\u0027:Number \u003d OR(G, B) in inv_Number(D)))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 335:20: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in let F\u0027:Number \u003d OR(F, A), G\u0027:Number \u003d OR(G, B) in let F\u0027\u0027:Number \u003d AND(F\u0027, C), G\u0027\u0027:Number \u003d AND(G\u0027, D) in pre_MUL2A(Y\u0027, G\u0027\u0027)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 336:18: (forall M:Message_in_blocks_plus_empty_Message, KC:Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:Number \u003d (hd M) in let V\u0027:Number \u003d CYC(V) in let E:Number \u003d XOR(V\u0027, W), X\u0027:Number \u003d XOR(X, Mi), Y\u0027:Number \u003d XOR(Y, Mi) in let F:Number \u003d ADD(E, Y\u0027), G:Number \u003d ADD(E, X\u0027) in let F\u0027:Number \u003d OR(F, A), G\u0027:Number \u003d OR(G, B) in let F\u0027\u0027:Number \u003d AND(F\u0027, C), G\u0027\u0027:Number \u003d AND(G\u0027, D) in let X\u0027\u0027:Number \u003d MUL1(X\u0027, F\u0027\u0027), Y\u0027\u0027:Number \u003d MUL2A(Y\u0027, G\u0027\u0027) in (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 350:14: (forall M:Message_in_blocks, K:Key \u0026 let KC:Key_Constant \u003d Prelude(K) in let S:Number \u003d (KC.S), T:Number \u003d (KC.T) in let M\u0027:seq1 of (Number) \u003d ((M ^ [S]) ^ [T]) in inv_Message_in_blocks_plus_empty_Message(M\u0027))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 360:14: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in pre_Form_Message_into_blocks(M\u0027))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 364:19: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e pre_Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 364:42: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e (Maximum_No_of_blocks_for_MAC \u003e\u003d 0)))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 365:21: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e pre_Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 365:44: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e (Maximum_No_of_blocks_for_MAC \u003e\u003d 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 366:17: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e let M\u0027\u0027\u0027:seq1 of (Number) \u003d ([Z(Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC), K)] ^ Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)) in (inv_Message_in_blocks(M\u0027\u0027\u0027) and inv_Message_in_blocks_plus_empty_Message(M\u0027\u0027\u0027))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 366:24: (forall M:Message_in_bits, K:Key \u0026 let M\u0027:Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e let M\u0027\u0027\u0027:seq1 of (Number) \u003d ([Z(Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC), K)] ^ Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)) in (Maximum_No_of_blocks_for_MAC_plus_1 \u003e\u003d 0)))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 372:22: (forall M:Message_in_blocks, K:Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e pre_Get_head_in_blocks(M, No_blocks)))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 373:16: (forall M:Message_in_blocks, K:Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e pre_Get_tail_in_blocks(M, No_blocks)))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 374:17: (forall M:Message_in_blocks, K:Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e let M\u0027:seq1 of (Number) \u003d ([Z(Get_head_in_blocks(M, No_blocks), K)] ^ Get_tail_in_blocks(M, No_blocks)) in (inv_Message_in_blocks(M\u0027) and inv_Message_in_blocks_plus_empty_Message(M\u0027))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 386:10: (forall M:Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e pre_Get_tail_in_bits((tl M), (No_bits - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 386:41: (forall M:Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e ((No_bits - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 386:31: (forall M:Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 392:15: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((No_bits \u003d 0) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 393:15: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 393:22: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e pre_Get_head_in_bits((tl M), (No_bits - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 393:53: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e ((No_bits - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 393:43: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 389:4: (forall M:Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e inv_Message_in_bits((if (No_bits \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_bits((tl M), (No_bits - 1)))))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 400:10: (forall M:Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e pre_Get_tail_in_blocks((tl M), (No_blocks - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 400:45: (forall M:Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e ((No_blocks - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 400:33: (forall M:Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 406:15: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((No_blocks \u003d 0) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 407:15: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 407:22: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e pre_Get_head_in_blocks((tl M), (No_blocks - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 407:57: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e ((No_blocks - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 407:45: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (maa.vdmsl) at line 403:4: (forall M:Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e (inv_Message_in_blocks((if (No_blocks \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_blocks((tl M), (No_blocks - 1))))) and inv_Message_in_blocks_plus_empty_Message((if (No_blocks \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_blocks((tl M), (No_blocks - 1))))))))"]