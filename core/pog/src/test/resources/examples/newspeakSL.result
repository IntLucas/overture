["cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 497:3: (forall tp:Expressible_type \u0026 (((((((exists mk_VoidType(t):Expressible_type \u0026 (tp \u003d mk_VoidType(t))) or (exists mk_TrType(range, fl):Expressible_type \u0026 (tp \u003d mk_TrType(range, fl)))) or (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (tp \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(range, abse, rele, fl):Expressible_type \u0026 (tp \u003d mk_Float(range, abse, rele, fl)))) or (exists mk_VectorType(lower, upper, tp, fl):Expressible_type \u0026 (tp \u003d mk_VectorType(lower, upper, tp, fl)))) or (exists mk_StructureType(tps, fl):Expressible_type \u0026 (tp \u003d mk_StructureType(tps, fl)))) or (exists mk_UnionType(tps, fl):Expressible_type \u0026 (tp \u003d mk_UnionType(tps, fl)))))","let be st existence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 552:7: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 554:17: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_min((s \\ {m}))))))","let be st existence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 560:7: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 562:17: (forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_max((s \\ {m}))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 568:3: (forall x:Int, y:Int, mk_NumOp(op):NumOp \u0026 (((((((op \u003d \u003cnumplus\u003e) or (op \u003d \u003cbinaryminus\u003e)) or (op \u003d \u003cnummult\u003e)) or (op \u003d \u003cnumdiv\u003e)) or (op \u003d \u003cnummod\u003e)) or (op \u003d \u003cnummax\u003e)) or (op \u003d \u003cnummin\u003e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 584:11: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 584:20: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 584:36: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 586:26: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 586:35: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 586:50: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 598:11: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 598:20: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 598:36: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 600:26: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 600:35: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 600:50: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 610:6: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))}))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 610:15: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 610:31: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 612:21: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 612:30: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 612:45: (forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range)))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 623:24: (forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 (j \u003c\u003e 0))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 625:11: (forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 625:20: (forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 625:36: (forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 629:26: (forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if (exists r in set range \u0026 ((abs r) \u003e\u003d bytemax))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in ((y.val) \u003c\u003e 0))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 646:21: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_max({i, j}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 648:15: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(x.val), (y.val)})))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 648:49: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(range, set of (int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 648:15: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(max({(x.val), (y.val)}), int)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 656:21: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_min({i, j}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 658:15: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min({(x.val), (y.val)})))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 658:49: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(range, set of (int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 658:15: (forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(min({(x.val), (y.val)}), int)))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 681:14: (forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall mk_(i, j):(int * int) \u0026 ((((op \u003d \u003cnumgt\u003e) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumge\u003e)) or (op \u003d \u003cnumle\u003e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 687:18: (forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((int * int) -\u003e bool) \u003d (lambda [mk_(i, j):(int * int)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j)\n end)) in pre_(pmk_((x.val), (y.val)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 688:21: (forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((int * int) -\u003e bool) \u003d (lambda [mk_(i, j):(int * int)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j)\n end)) in (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_(pmk_(i, j)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 697:39: (forall z:Int \u0026 pre_min(((z.type).range)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 697:57: (forall z:Int \u0026 pre_max(((z.type).range)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 697:39: (forall z:Int \u0026 is_(min(((z.type).range)), int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 697:57: (forall z:Int \u0026 is_(max(((z.type).range)), int))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 721:21: (forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 pre_min({(abs (range.lower)), (abs (range.upper))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 722:21: (forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 pre_max({(abs (range.lower)), (abs (range.upper))})))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 721:21: (forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 is_(min({(abs (range.lower)), (abs (range.upper))}), int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 722:21: (forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 is_(max({(abs (range.lower)), (abs (range.upper))}), int)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 749:19: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 751:19: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 753:20: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 754:11: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 754:16: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 769:19: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 771:19: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 773:20: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 774:11: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 774:16: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 787:14: (forall x:Real, y:Real \u0026 pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 789:14: (forall x:Real, y:Real \u0026 pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 791:15: (forall x:Real, y:Real \u0026 pre_max({Xmax, Ymax}))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 792:10: (forall x:Real, y:Real \u0026 let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 792:15: (forall x:Real, y:Real \u0026 let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 804:28: (forall x:Real, y:Real \u0026 pre_min({(range.lower) | range in set ((y.type).range)}))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 806:28: (forall x:Real, y:Real \u0026 (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) \u003d\u003e pre_max({(range.upper) | range in set ((y.type).range)})))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 809:53: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e (forall xrange in set ((x.type).range), yrange in set ((y.type).range) \u0026 ((yrange.upper) \u003c\u003e 0))))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 810:47: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e (forall xrange in set ((x.type).range), yrange in set ((y.type).range) \u0026 ((yrange.lower) \u003c\u003e 0))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 813:14: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 815:14: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 817:15: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 818:14: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 820:11: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 820:16: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 823:38: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)}))))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 825:23: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e ((Ymin ** 2) \u003c\u003e 0))))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 827:25: (forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e let As:real \u003d ((((((Xmax * Ymax) * max({((x.type).relerr), ((y.type).relerr)})) + (Ymax * ((x.type).abserr))) + (Xmax * ((y.type).abserr))) / (Ymin ** 2)) + (epsilon_t * XYmax)), fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)) in ((y.val) \u003c\u003e 0))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 834:18: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({(x.val), (y.val)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 835:21: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).abserr), ((y.type).abserr)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 836:21: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 837:34: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_max({(xr.lower), (yr.lower)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 838:23: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_max({(xr.upper), (yr.upper)}))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 837:34: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(max({(xr.lower), (yr.lower)}), int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 838:23: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(max({(xr.upper), (yr.upper)}), int))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 848:18: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_min({(x.val), (y.val)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 849:21: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).abserr), ((y.type).abserr)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 850:21: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)})))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 851:34: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_min({(xr.lower), (yr.lower)}))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 852:23: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_min({(xr.upper), (yr.upper)}))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 851:34: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(min({(xr.lower), (yr.lower)}), int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 852:23: (forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(min({(xr.upper), (yr.upper)}), int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 866:15: (forall r:Real \u0026 (is_((r.val), int) \u003d\u003e is_((r.val), int)))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 877:11: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall mk_(i, j):(real * real) \u0026 ((((op \u003d \u003cnumgt\u003e) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumle\u003e)) or (op \u003d \u003cnumge\u003e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 889:19: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_(pmk_((x.val), (y.val)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 890:24: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_max(xrange)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 890:38: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_min(yrange)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 891:27: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_(pmk_(max(xrange), min(yrange))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 891:33: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_max(xrange))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 891:45: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_min(yrange))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 893:27: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_(pmk_(max(yrange), min(xrange)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 893:33: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_max(yrange)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 893:45: (forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_min(xrange)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 899:11: (forall r:Real \u0026 pre_min({(range.lower) | range in set ((r.type).range)}))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 901:35: (forall r:Real \u0026 let m:real \u003d ((min({(range.lower) | range in set ((r.type).range)}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in is_(m, int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 901:37: (forall r:Real \u0026 let m:real \u003d ((min({(range.lower) | range in set ((r.type).range)}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in is_(m, int))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 905:11: (forall r:Real \u0026 pre_max({(range.upper) | range in set ((r.type).range)}))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 907:35: (forall r:Real \u0026 let m:real \u003d ((max({(range.upper) | range in set ((r.type).range)}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in is_(m, int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 907:37: (forall r:Real \u0026 let m:real \u003d ((max({(range.upper) | range in set ((r.type).range)}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in is_(m, int))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 917:37: (forall mk_Real(r, f):Real \u0026 ((not (r \u003d 0)) \u003d\u003e (r \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 923:29: (forall r:Real \u0026 is_(((r.type).abserr), int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 923:43: (forall r:Real \u0026 is_(((r.type).abserr), int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 928:29: (forall r:Real \u0026 is_(((r.type).relerr), int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 928:43: (forall r:Real \u0026 is_(((r.type).relerr), int))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 941:33: (forall v:Component, t:CompType \u0026 (is_(v, real) \u003d\u003e is_(t, Float)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 942:34: (forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e (is_(v, bool) \u003d\u003e is_(t, TrType))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 943:15: (forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e ((not is_(v, bool)) \u003d\u003e is_(v, int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 943:17: (forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e ((not is_(v, bool)) \u003d\u003e is_(t, IntType))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 947:45: (forall s:Structure, fl:Flavdom \u0026 (forall i in set (inds (s.val)) \u0026 (i in set (inds ((s.type).tps)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 951:18: (forall s:Structure, fl:Flavdom \u0026 let matches:set of (nat1) \u003d {i | i in set (inds (s.val)) \u0026 ((((s.type).tps)(i).fl) \u003d fl)} in ((not ((card matches) \u003c\u003e 1)) \u003d\u003e let {i}:set of (nat1) \u003d matches in (i in set (inds (s.val)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 951:27: (forall s:Structure, fl:Flavdom \u0026 let matches:set of (nat1) \u003d {i | i in set (inds (s.val)) \u0026 ((((s.type).tps)(i).fl) \u003d fl)} in ((not ((card matches) \u003c\u003e 1)) \u003d\u003e let {i}:set of (nat1) \u003d matches in (i in set (inds ((s.type).tps)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 959:3: (forall v:Vector, i:int \u0026 (((i - ((v.type).lower)) + 1) in set (inds (v.val))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 957:1: (forall v:Vector, i:int \u0026 (((((((is_((v.val)(((i - ((v.type).lower)) + 1)), Errvalue) or is_((v.val)(((i - ((v.type).lower)) + 1)), Int)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Real)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Structure)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Tr)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Union)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Vector)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 965:1: (forall v:VectorType \u0026 (((((v.type).upper) - ((v.type).lower)) + 1) \u003e\u003d 0))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 969:1: (forall vs:VectorValue \u0026 ((((((is_((conc vs), seq1 of (Errvalue)) or is_((conc vs), seq1 of (Int))) or is_((conc vs), seq1 of (Real))) or is_((conc vs), seq1 of (StructValue))) or is_((conc vs), seq1 of (Tr))) or is_((conc vs), seq1 of (VectorValue))) or is_((conc vs), seq1 of (Void))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 981:19: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 981:24: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 982:18: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 982:23: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 973:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 992:19: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 992:24: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 993:18: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 993:23: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 984:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1003:20: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_all((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_((hd v), Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1003:25: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_all((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_(b, Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 996:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1012:19: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_some((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_((hd v), Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1012:24: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_some((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_(b, Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1005:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1022:21: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1022:26: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1023:20: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1023:25: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1014:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1033:21: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1033:26: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1034:20: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1034:25: (forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1025:1: (forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Void)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1046:17: (forall v1:Vector, v2:Vector \u0026 let type:Expressible_type \u003d (if tleq(((v1.type).type), ((v2.type).type))\nthen ((v2.type).type)\nelse ((v1.type).type)), lower:int \u003d ((v1.type).lower), upper:int \u003d (((((v1.type).upper) + ((v2.type).upper)) - ((v2.type).lower)) + 1), fl:Flavdom \u003d ((v1.type).fl), vec:seq of ((Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d ((v1.val) ^ (v2.val)) in let new_type:VectorType \u003d mk_VectorType(lower, upper, type, fl) in ((((((is_(vec, seq1 of (Errvalue)) or is_(vec, seq1 of (Int))) or is_(vec, seq1 of (Real))) or is_(vec, seq1 of (StructValue))) or is_(vec, seq1 of (Tr))) or is_(vec, seq1 of (VectorValue))) or is_(vec, seq1 of (Void))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1063:22: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e is_([const_type((v.val)(i)) | i in set (inds (v.val))], seq1 of (Expressible_type)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1063:34: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (((((((is_((v.val)(i), Errvalue) or is_((v.val)(i), Int)) or is_((v.val)(i), Real)) or is_((v.val)(i), Structure)) or is_((v.val)(i), Tr)) or is_((v.val)(i), Union)) or is_((v.val)(i), Vector)) or is_((v.val)(i), Void))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1063:34: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds (v.val)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1063:15: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e ((((((is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), Float) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), IntType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), StructureType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), TrType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), UnionType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), VectorType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), VoidType)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1065:52: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds (v.val))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1065:61: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds ((v.type).tps))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1065:27: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e is_([const_type(construct_ev((v.val)(i), ((v.type).tps)(i))) | i in set (inds (v.val))], seq1 of (CompType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1072:45: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e ((not is_(v, Structure)) \u003d\u003e ((not is_(v, Union)) \u003d\u003e ((not (v \u003d \u003cerr\u003e)) \u003d\u003e (is_(v, Real) \u003d\u003e is_((if is_((v.val), int)\nthen (v.val)\nelse (floor ((v.val) + 0.5))), int))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1077:18: (forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e ((not is_(v, Structure)) \u003d\u003e ((not is_(v, Union)) \u003d\u003e ((not (v \u003d \u003cerr\u003e)) \u003d\u003e ((not is_(v, Real)) \u003d\u003e ((not is_(v, Int)) \u003d\u003e (is_((v.val), bool) and is_({(v.val)}, set of (bool)))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1088:3: (forall type:Expressible_type, flav:Flavdom \u0026 (((((((exists mk_VoidType(fl):Expressible_type \u0026 (type \u003d mk_VoidType(fl))) or (exists mk_TrType(r, f):Expressible_type \u0026 (type \u003d mk_TrType(r, f)))) or (exists mk_Float(r, a, re, f):Expressible_type \u0026 (type \u003d mk_Float(r, a, re, f)))) or (exists mk_IntType(rep, r, f):Expressible_type \u0026 (type \u003d mk_IntType(rep, r, f)))) or (exists mk_VectorType(l, u, t, f):Expressible_type \u0026 (type \u003d mk_VectorType(l, u, t, f)))) or (exists mk_UnionType(tps, fl):Expressible_type \u0026 (type \u003d mk_UnionType(tps, fl)))) or (exists mk_StructureType(tps, fl):Expressible_type \u0026 (type \u003d mk_StructureType(tps, fl)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1124:37: (forall t1:Float, t2:Float \u0026 pre_max({(t1.abserr), (t2.abserr)}))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1125:12: (forall t1:Float, t2:Float \u0026 pre_max({(t1.relerr), (t2.relerr)}))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1140:40: (forall t1:VectorType, t2:VectorType \u0026 ((not (((t1.lower) \u003c\u003e (t2.lower)) or (((t1.upper) \u003c\u003e (t2.upper)) or (lub((t1.type), (t2.type)) \u003d \u003cerr\u003e)))) \u003d\u003e ((((((is_(lub((t1.type), (t2.type)), Float) or is_(lub((t1.type), (t2.type)), IntType)) or is_(lub((t1.type), (t2.type)), StructureType)) or is_(lub((t1.type), (t2.type)), TrType)) or is_(lub((t1.type), (t2.type)), UnionType)) or is_(lub((t1.type), (t2.type)), VectorType)) or is_(lub((t1.type), (t2.type)), VoidType))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1148:30: (forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e (forall i in set (inds (t1.tps)) \u0026 (i in set (inds (t1.tps)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1148:40: (forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e (forall i in set (inds (t1.tps)) \u0026 (i in set (inds (t2.tps)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1148:25: (forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e is_([lub((t1.tps)(i), (t2.tps)(i)) | i in set (inds (t1.tps))], seq1 of (CompType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1160:26: (forall t1:UnionType, t2:UnionType \u0026 ((not ((card (t1.tps)) \u003c\u003e (card (t2.tps)))) \u003d\u003e let lub:(Errvalue | Expressible_type) \u003d setlub(((t1.tps) union (t2.tps))) in ((not (lub \u003d \u003cerr\u003e)) \u003d\u003e ((not is_(lub, UnionType)) \u003d\u003e ((((is_(lub, Float) or is_(lub, IntType)) or is_(lub, TrType)) or is_(lub, VoidType)) and is_({lub}, set of ((Float | IntType | TrType | VoidType))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1168:12: (forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(lub(tps(1), tps(2)), Float) or is_(lub(tps(1), tps(2)), IntType)) or is_(lub(tps(1), tps(2)), StructureType)) or is_(lub(tps(1), tps(2)), TrType)) or is_(lub(tps(1), tps(2)), UnionType)) or is_(lub(tps(1), tps(2)), VectorType)) or is_(lub(tps(1), tps(2)), VoidType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1168:31: (forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(seqlub((tl tps)), Float) or is_(seqlub((tl tps)), IntType)) or is_(seqlub((tl tps)), StructureType)) or is_(seqlub((tl tps)), TrType)) or is_(seqlub((tl tps)), UnionType)) or is_(seqlub((tl tps)), VectorType)) or is_(seqlub((tl tps)), VoidType)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1168:16: (forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e (1 in set (inds tps)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1168:23: (forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e (2 in set (inds tps)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1188:52: (forall s:set of (Expressible_type) \u0026 ((exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e)) \u003d\u003e ((forall t in set s \u0026 (is_(t, TrType) or (is_(t, IntType) or (is_(t, Float) or is_(t, VoidType))))) \u003d\u003e let t1:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, TrType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, TrType)}, t2:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, IntType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, IntType)}, t3:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, Float) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, Float)}, t4:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, VoidType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, VoidType)} in ((not ((exists t, t\u0027 in set (dunion {t1, t2, t3, t4}) \u0026 ((t.fl) \u003d (t\u0027.fl))) or (exists t in set (dunion {t1, t2, t3}), mk_VoidType(f) in set t4 \u0026 ((t.fl) \u003d f)))) \u003d\u003e is_((((t1 union t2) union t3) union t4), set of ((Float | IntType | TrType | VoidType)))))))","let be st existence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1190:12: (forall s:set of (Expressible_type) \u0026 ((not (exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e))) \u003d\u003e (exists t in set s \u0026 true)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1193:19: (forall s:set of (Expressible_type) \u0026 ((not (exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e))) \u003d\u003e (forall t in set s \u0026 ((not (s \u003d {t})) \u003d\u003e ((((((is_(setlub((s \\ {t})), Float) or is_(setlub((s \\ {t})), IntType)) or is_(setlub((s \\ {t})), StructureType)) or is_(setlub((s \\ {t})), TrType)) or is_(setlub((s \\ {t})), UnionType)) or is_(setlub((s \\ {t})), VectorType)) or is_(setlub((s \\ {t})), VoidType))))))","let be st existence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1200:30: (forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e (is_(t2, TrType) \u003d\u003e (exists z in set (power {0, 1}) \u0026 ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1222:36: (forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e pre_max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t2.range)}))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1222:46: (forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e (forall mk_Floatrng(lower, upper) in set (t2.range) \u0026 pre_max({lower, upper})))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1224:26: (forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e pre_max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t1.range)}))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1224:36: (forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e (forall mk_Floatrng(lower, upper) in set (t1.range) \u0026 pre_max({lower, upper})))))))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1245:4: (forall l:Location, s:Store \u0026 (l in set (dom s)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:8: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_(multi_update((tl ls))((tl vs))(s ++ {(hd ls) |-\u003e (hd vs)})))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:8: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_(multi_update((tl ls))(tl vs)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:8: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_multi_update((tl ls)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:24: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (ls \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:31: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (vs \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:45: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (ls \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1255:55: (forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (vs \u003c\u003e []))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1264:3: (forall i:Id, mk_(m, l):Env \u0026 (i in set (dom m)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1278:27: (forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1279:5: (forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(multi_update_env((tl s))update_env(id)(v)(e))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1279:26: (forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in (s \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1279:29: (forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(update_env(id)(v)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1279:29: (forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(update_env(id)v)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1290:28: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds formals)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1290:45: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds params)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1291:18: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds formals)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1294:29: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 (i in set (inds formals))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1295:31: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 (((formals(i).fl) \u003d {}) \u003d\u003e (i in set (inds params)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1296:42: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (((((((is_((params(i).val), Errvalue) or is_((params(i).val), Int)) or is_((params(i).val), Real)) or is_((params(i).val), Structure)) or is_((params(i).val), Tr)) or is_((params(i).val), Union)) or is_((params(i).val), Vector)) or is_((params(i).val), Void)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1297:33: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e ((((((is_(replace_flavour((params(i).type), (formals(i).fl)), Float) or is_(replace_flavour((params(i).type), (formals(i).fl)), IntType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), StructureType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), TrType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), UnionType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), VectorType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), VoidType)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1296:42: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds params)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1297:49: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds params)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1298:33: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds formals)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1299:13: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in pre_(multi_update_env([mk_((formals(i).id), vals(i)) | i in set (inds vals)])e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1299:30: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in is_([mk_((formals(i).id), vals(i)) | i in set (inds vals)], seq of ((Id * Denotable_value))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1299:35: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in (forall i in set (inds vals) \u0026 (i in set (inds formals))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1299:49: (forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1316:17: (forall ts:seq of (Time) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1316:31: (forall ts:seq of (Time) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","let be st existence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1356:7: (forall tp:Expressible_type \u0026 (exists val:Expressible_value \u0026 (lub(const_type(val), tp) \u003d tp)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1357:9: (forall tp:Expressible_type \u0026 (forall val:Expressible_value \u0026 ((((((is_(const_type(val), Float) or is_(const_type(val), IntType)) or is_(const_type(val), StructureType)) or is_(const_type(val), TrType)) or is_(const_type(val), UnionType)) or is_(const_type(val), VectorType)) or is_(const_type(val), VoidType))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1358:14: (forall tp:Expressible_type \u0026 (forall val:Expressible_value \u0026 ((lub(const_type(val), tp) \u003d tp) \u003d\u003e (((((((is_(const_type(val), Errvalue) or is_(const_type(val), Int)) or is_(const_type(val), Real)) or is_(const_type(val), Structure)) or is_(const_type(val), Tr)) or is_(const_type(val), Union)) or is_(const_type(val), Vector)) or is_(const_type(val), Void)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1363:3: (forall mk_Program(expr):Program, l:Location, sto:Store \u0026 pre_(eval_Expression(expr)(empty_env(l))mk_PState(sto, zerot)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1363:3: (forall mk_Program(expr):Program, l:Location, sto:Store \u0026 pre_(eval_Expression(expr)empty_env(l)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1368:24: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in pre_(eval_Operation(expr)(env)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1368:24: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in pre_(eval_Operation(expr)env))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1368:39: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in is_(expr, Operation))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1369:23: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in pre_(eval_InnerLoop(expr)(env)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1369:23: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in pre_(eval_InnerLoop(expr)env)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1369:38: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in is_(expr, InnerLoop)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1370:24: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in pre_(eval_Assignment(expr)(env)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1370:24: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in pre_(eval_Assignment(expr)env))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1370:40: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in is_(expr, Assignment))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1371:19: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in pre_(eval_Scope(expr)(env)ps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1371:19: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in pre_(eval_Scope(expr)env)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1371:30: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in is_(expr, Scope)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1372:30: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in pre_(eval_GuardedScope(expr)(env)ps))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1372:30: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in pre_(eval_GuardedScope(expr)env))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1372:48: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in is_(expr, GuardedScope))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1373:28: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in pre_(eval_Assertion(expr)(env)ps)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1373:28: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in pre_(eval_Assertion(expr)env)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1373:43: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in is_(expr, Assertion)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1374:29: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in pre_(eval_TimedExpression(expr)(env)ps))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1374:29: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in pre_(eval_TimedExpression(expr)env))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1374:50: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in is_(expr, TimedExpression))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1367:3: (forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (((((((exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Operation(op))) or (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_InnerLoop(l)))) or (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Assignment(a)))) or (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Scope(s)))) or (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_GuardedScope(d, i, o)))) or (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Assertion(exp, tp)))) or (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_TimedExpression(t)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1380:28: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in pre_(eval_MonOperation(op)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1380:28: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in pre_(eval_MonOperation(op)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1380:46: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in is_(op, MonOperation))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1381:35: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in pre_(eval_BinaryOperation(op)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1381:35: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in pre_(eval_BinaryOperation(op)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1381:56: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in is_(op, BinaryOperation)))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1379:3: (forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (op \u003d mk_MonOperation(mo))) or (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 (op \u003d mk_BinaryOperation(l, bo, r)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1388:12: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_MonOpMonOperand(opr, opnd) \u003d mo) \u003d\u003e let mk_MonOpMonOperand(opr, opnd) \u003d mo in pre_(eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1388:12: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_MonOpMonOperand(opr, opnd) \u003d mo) \u003d\u003e let mk_MonOpMonOperand(opr, opnd) \u003d mo in pre_(eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1390:12: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_VectorOperation(v, m, op) \u003d mo) \u003d\u003e let mk_VectorOperation(v, m, op) \u003d mo in pre_(eval_VectorOperation(mk_VectorOperation(v, m, op))(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1390:12: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_VectorOperation(v, m, op) \u003d mo) \u003d\u003e let mk_VectorOperation(v, m, op) \u003d mo in pre_(eval_VectorOperation(mk_VectorOperation(v, m, op))e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1391:20: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e ((not (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_VectorOperation(v, m, op) \u003d mo))) \u003d\u003e (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_Value(v) \u003d mo) \u003d\u003e let mk_Value(v) \u003d mo in pre_(eval_Value(mk_Value(v))(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1391:20: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e ((not (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_VectorOperation(v, m, op) \u003d mo))) \u003d\u003e (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_Value(v) \u003d mo) \u003d\u003e let mk_Value(v) \u003d mo in pre_(eval_Value(mk_Value(v))e))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1386:3: (forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (((exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_MonOpMonOperand(opr, opnd))) or (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_VectorOperation(v, m, op)))) or (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_Value(v)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1396:11: (forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 pre_(eval_MonOperation(opnd)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1396:11: (forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 pre_(eval_MonOperation(opnd)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1403:32: (forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (\u003cnumabs\u003e \u003d opr)) \u003d\u003e ((not (\u003cunaryminus\u003e \u003d opr)) \u003d\u003e ((not (\u003cnot\u003e \u003d opr)) \u003d\u003e (exists mk_CompileTimeOp(o):MonOp \u0026 ((mk_CompileTimeOp(o) \u003d opr) \u003d\u003e let mk_CompileTimeOp(o) \u003d opr in pre_(eval_CompileTimeOp(opr)x))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1403:51: (forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (\u003cnumabs\u003e \u003d opr)) \u003d\u003e ((not (\u003cunaryminus\u003e \u003d opr)) \u003d\u003e ((not (\u003cnot\u003e \u003d opr)) \u003d\u003e (exists mk_CompileTimeOp(o):MonOp \u0026 ((mk_CompileTimeOp(o) \u003d opr) \u003d\u003e let mk_CompileTimeOp(o) \u003d opr in is_(opr, CompileTimeOp))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1399:8: (forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((((((((((opr \u003d \u003cnumabs\u003e) or (opr \u003d \u003cunaryminus\u003e)) or (opr \u003d \u003cnot\u003e)) or (exists mk_CompileTimeOp(o):MonOp \u0026 (opr \u003d mk_CompileTimeOp(o)))) or (opr \u003d \u003cdiscard\u003e)) or (opr \u003d \u003cround\u003e)) or (opr \u003d \u003codd\u003e)) or (opr \u003d \u003cfloat\u003e)) or (opr \u003d \u003cmantissa\u003e)) or (opr \u003d \u003cexponent\u003e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1432:28: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Tr))) \u003d\u003e is_(val, Tr)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1439:35: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((\u003cinf\u003e \u003d op) \u003d\u003e is_(val, Real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1440:35: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((\u003csup\u003e \u003d op) \u003d\u003e is_(val, Real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1441:43: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((\u003cabsonly\u003e \u003d op) \u003d\u003e is_(val, Real))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1442:43: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((\u003crelonly\u003e \u003d op) \u003d\u003e is_(val, Real)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1443:41: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((not (\u003crelonly\u003e \u003d op)) \u003d\u003e ((\u003cabserr\u003e \u003d op) \u003d\u003e is_(val, Real))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1444:41: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((not (\u003crelonly\u003e \u003d op)) \u003d\u003e ((not (\u003cabserr\u003e \u003d op)) \u003d\u003e ((\u003crelerr\u003e \u003d op) \u003d\u003e is_(val, Real)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1438:8: (forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((((((op \u003d \u003cinf\u003e) or (op \u003d \u003csup\u003e)) or (op \u003d \u003cabsonly\u003e)) or (op \u003d \u003crelonly\u003e)) or (op \u003d \u003cabserr\u003e)) or (op \u003d \u003crelerr\u003e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1451:29: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1457:27: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1463:30: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1469:30: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1475:25: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1481:27: (forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Int)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1485:11: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(mo)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1485:11: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(mo)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1489:21: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e pre_(eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))(mult)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1489:21: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e pre_(eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))mult))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1489:59: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e is_(mult, Multiple))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1492:13: (forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let v:EST_value \u003d (if (mult \u003d nil)\nthen x\nelse eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))(mult)(e)) in ((not ((v.val) \u003d \u003cerr\u003e)) \u003d\u003e (((((((vo \u003d \u003csum\u003e) or (vo \u003d \u003cproduct\u003e)) or (vo \u003d \u003cvecmax\u003e)) or (vo \u003d \u003cvecmin\u003e)) or (vo \u003d \u003call\u003e)) or (vo \u003d \u003csome\u003e)) or (vo \u003d \u003cflatten\u003e)))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1506:7: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 (exists mk_Vector(val, type):Expressible_value \u0026 (mk_Vector(val, type) \u003d est_val)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1506:29: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 is_(est_val, Vector))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1507:12: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in pre_(eval_Operation(op)(e)mk_PState(sto, time)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1507:12: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in pre_(eval_Operation(op)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1508:12: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in pre_(eval_Operation(to_p)(e)mk_PState(sto, (b1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1508:12: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in pre_(eval_Operation(to_p)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1513:20: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e pre_min({((b1.val).val), ((b2.val).val)}))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1513:24: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e ((is_(((b1.val).val), real) and is_(((b2.val).val), real)) and is_({((b1.val).val), ((b2.val).val)}, set of (real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1514:20: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e pre_max({((b1.val).val), ((b2.val).val)}))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1514:24: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e ((is_(((b1.val).val), real) and is_(((b2.val).val), real)) and is_({((b1.val).val), ((b2.val).val)}, set of (real))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1517:43: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(lower, int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1517:49: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(upper, int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1518:42: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(lower, int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1518:48: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(upper, int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1520:65: (forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e let new_val:VectorValue \u003d vector_subv(val, lower, upper), new_type:VectorType \u003d mk_VectorType(lower, upper, (type.type), (type.fl)) in is_((upper - lower), int)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1585:22: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 ((mk_NumOp(opr) \u003d op) \u003d\u003e let mk_NumOp(opr) \u003d op in pre_(eval_NumOp(bo)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1585:22: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 ((mk_NumOp(opr) \u003d op) \u003d\u003e let mk_NumOp(opr) \u003d op in pre_(eval_NumOp(bo)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((\u003cnumgt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((\u003cnumgt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((\u003cnumlt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((\u003cnumlt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((\u003cnumge\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((\u003cnumge\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((\u003cnumle\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1586:40: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((\u003cnumle\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1587:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)(e)ps))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1587:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)e))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1587:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)(e)ps)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1587:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)e)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1588:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((\u003cEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)(e)ps))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1588:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((\u003cEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)e))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1588:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((\u003cNEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)(e)ps)))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1588:19: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((\u003cNEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)e)))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1589:17: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((not (\u003cNEQ\u003e \u003d op)) \u003d\u003e ((\u003cconcat\u003e \u003d op) \u003d\u003e pre_(eval_Concat(bo)(e)ps))))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1589:17: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((not (\u003cNEQ\u003e \u003d op)) \u003d\u003e ((\u003cconcat\u003e \u003d op) \u003d\u003e pre_(eval_Concat(bo)e))))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1584:3: (forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((((((((((exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (op \u003d mk_NumOp(opr))) or (op \u003d \u003cnumgt\u003e)) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumge\u003e)) or (op \u003d \u003cnumle\u003e)) or (op \u003d \u003cand\u003e)) or (op \u003d \u003cor\u003e)) or (op \u003d \u003cEQ\u003e)) or (op \u003d \u003cNEQ\u003e)) or (op \u003d \u003cconcat\u003e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1594:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1594:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1595:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1595:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1617:31: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e (exists mk_VoidType(f):(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u0026 (mk_VoidType(f) \u003d ((a2.val).type)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1617:48: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e is_(((a2.val).type), VoidType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1619:31: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e let mk_VoidType(f):(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((a2.val).type) in ((((((is_(replace_flavour(((a1.val).type), f), Float) or is_(replace_flavour(((a1.val).type), f), IntType)) or is_(replace_flavour(((a1.val).type), f), StructureType)) or is_(replace_flavour(((a1.val).type), f), TrType)) or is_(replace_flavour(((a1.val).type), f), UnionType)) or is_(replace_flavour(((a1.val).type), f), VectorType)) or is_(replace_flavour(((a1.val).type), f), VoidType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1627:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1627:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1628:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1628:12: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1630:29: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a1.val), Int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1630:36: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a2.val), Int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1630:43: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e (((is_(opr, \u003cnumge\u003e) or is_(opr, \u003cnumgt\u003e)) or is_(opr, \u003cnumle\u003e)) or is_(opr, \u003cnumlt\u003e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1633:30: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a1.val), Real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1633:37: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a2.val), Real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1633:44: (forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e (((is_(opr, \u003cnumge\u003e) or is_(opr, \u003cnumgt\u003e)) or is_(opr, \u003cnumle\u003e)) or is_(opr, \u003cnumlt\u003e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1639:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1639:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1640:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1640:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1642:29: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e is_((a1.val), Tr)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1642:36: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e is_((a2.val), Tr)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1642:43: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1645:31: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a1.val), Real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1645:38: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a2.val), Real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1645:45: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1648:30: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a1.val), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1648:37: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a2.val), Int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1648:44: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1651:31: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e is_((a1.val), Void))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1651:38: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e is_((a2.val), Void))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1651:45: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1657:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1657:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1658:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1658:14: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1662:41: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e is_((a1.val), Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1662:48: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e is_((a2.val), Tr))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1664:39: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e is_((a1.val), Tr)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1664:46: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e is_((a2.val), Tr)))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1661:10: (forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((op \u003d \u003cand\u003e) or (op \u003d \u003cor\u003e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1670:14: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1670:14: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1671:14: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1671:14: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1677:38: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_((a1.val), Vector))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1677:45: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_((a2.val), Vector))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1679:50: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_(((a1.val).type), VectorType))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1680:50: (forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_(((a2.val).type), VectorType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1686:28: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_ConstantValue(c) \u003d val) \u003d\u003e let mk_ConstantValue(c) \u003d val in pre_(eval_ConstantValue(mk_ConstantValue(c))ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1687:25: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_NamedValue(n) \u003d val) \u003d\u003e let mk_NamedValue(n) \u003d val in pre_(eval_NamedValue(mk_NamedValue(n))(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1687:25: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_NamedValue(n) \u003d val) \u003d\u003e let mk_NamedValue(n) \u003d val in pre_(eval_NamedValue(mk_NamedValue(n))e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1688:24: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_VectorVal(v) \u003d val) \u003d\u003e let mk_VectorVal(v) \u003d val in pre_(eval_VectorVal(mk_VectorVal(v))(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1688:24: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_VectorVal(v) \u003d val) \u003d\u003e let mk_VectorVal(v) \u003d val in pre_(eval_VectorVal(mk_VectorVal(v))e))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1689:29: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_StructureValue(s) \u003d val) \u003d\u003e let mk_StructureValue(s) \u003d val in pre_(eval_StructureValue(mk_StructureValue(s))(e)ps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1689:29: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_StructureValue(s) \u003d val) \u003d\u003e let mk_StructureValue(s) \u003d val in pre_(eval_StructureValue(mk_StructureValue(s))e)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1690:23: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Sequence(s) \u003d val) \u003d\u003e let mk_Sequence(s) \u003d val in pre_(eval_Sequence(mk_Sequence(s))(e)ps))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1690:23: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Sequence(s) \u003d val) \u003d\u003e let mk_Sequence(s) \u003d val in pre_(eval_Sequence(mk_Sequence(s))e))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1691:25: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Call(id, acts) \u003d val) \u003d\u003e let mk_Call(id, acts) \u003d val in pre_(eval_Call(mk_Call(id, acts))(e)ps)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1691:25: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Call(id, acts) \u003d val) \u003d\u003e let mk_Call(id, acts) \u003d val in pre_(eval_Call(mk_Call(id, acts))e)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1692:26: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in pre_(eval_Conditional(val)(e)ps))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1692:26: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in pre_(eval_Conditional(val)e))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1692:43: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in is_(val, Conditional))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1693:27: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in pre_(eval_Widening(val)(e)ps)))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1693:27: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in pre_(eval_Widening(val)e)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1693:41: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in is_(val, Widening)))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1694:24: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in pre_(eval_OuterLoop(val)(e)ps))))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1694:24: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in pre_(eval_OuterLoop(val)e))))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1694:39: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in is_(val, OuterLoop))))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1685:3: (forall mk_Value(val):Value, e:Env, ps:PState \u0026 (((((((((exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_ConstantValue(c))) or (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_NamedValue(n)))) or (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_VectorVal(v)))) or (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_StructureValue(s)))) or (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Sequence(s)))) or (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Call(id, acts)))) or (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Conditional(c)))) or (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Widening(exp, t)))) or (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_OuterLoop(l)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1713:46: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1714:65: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1716:52: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in is_([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)], seq1 of (Expressible_type)))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1717:28: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1716:45: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in ((((((is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), Float) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), IntType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), StructureType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), TrType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), UnionType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), VectorType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), VoidType)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1713:32: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in ((((((is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Errvalue)) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Int))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Real))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (StructValue))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Tr))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (VectorValue))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Void))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1719:59: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_string(s) \u003d cv))) \u003d\u003e (exists mk_Flavouring(fl):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Flavouring(fl) \u003d cv) \u003d\u003e let mk_Flavouring(fl) \u003d cv in is_(cv, Flavouring)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1699:3: (forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 (((((((exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_IntegerDenotation(z))) or (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_FloatingDenotation(r)))) or (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_BooleanDenotation(b)))) or (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Ascii_Char(c)))) or (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Ascii_string(s)))) or (exists mk_Flavouring(fl):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Flavouring(fl)))) or (cv \u003d \u003cskip\u003e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1727:32: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in pre_(eval_FlavourExtract(nv)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1727:32: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in pre_(eval_FlavourExtract(nv)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1727:52: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in is_(nv, FlavourExtract))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1728:30: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in pre_(eval_FlavourStrip(nv)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1728:30: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in pre_(eval_FlavourStrip(nv)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1728:48: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in is_(nv, FlavourStrip)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1729:30: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in pre_(eval_VectorExtract(nv)(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1729:30: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in pre_(eval_VectorExtract(nv)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1729:49: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in is_(nv, VectorExtract))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1730:33: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in pre_(eval_VectorTrimming(nv)(e)ps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1730:33: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in pre_(eval_VectorTrimming(nv)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1730:53: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in is_(nv, VectorTrimming)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1731:15: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e pre_(eval_Identifier(nv)(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1731:15: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e pre_(eval_Identifier(nv)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1731:31: (forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e is_(nv, token))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1740:32: (forall id:Id, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((id in set (dom m)) \u003d\u003e (exists mk_Location(l):Denotable_value \u0026 ((mk_Location(l) \u003d access_env(id)(mk_(m, l))) \u003d\u003e let mk_Location(l) \u003d access_env(id)(mk_(m, l)) in pre_(access(mk_Location(l))sto)))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1738:8: (forall id:Id, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((id in set (dom m)) \u003d\u003e ((exists mk_Location(l):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Location(l))) or (exists mk_Storable_value(v):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Storable_value(v))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1748:11: (forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1748:11: (forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1752:34: (forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e is_((n.val), Structure)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1759:25: (forall mk_Flavouring(fls):Flavouring \u0026 ((not (fls \u003d [])) \u003d\u003e (fls \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1759:70: (forall mk_Flavouring(fls):Flavouring \u0026 ((not (fls \u003d [])) \u003d\u003e (fls \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1763:18: (forall mk_Flavour(name, index):Flavour \u0026 is_(index, rat))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1767:11: (forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1767:11: (forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1771:30: (forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e is_((n.val), Structure)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1772:55: (forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e let n\u0027:Expressible_value \u003d comp_extract((n.val), f) in is_(((n\u0027.type).tps), seq1 of (CompType))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1772:31: (forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e let n\u0027:Expressible_value \u003d comp_extract((n.val), f) in is_((n\u0027.val), seq1 of (Component))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1777:11: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(n)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1777:11: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(n)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1780:20: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e pre_(eval_Operation(i)(e)mu(ps, time |-\u003e (x.time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1780:20: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e pre_(eval_Operation(i)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1787:41: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let index:EST_value \u003d eval_Operation(i)(e)(mu(ps, time |-\u003e (x.time))), length:int \u003d (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in ((not (not is_((index.val), Int))) \u003d\u003e ((not (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))) \u003d\u003e is_((x.val), Vector)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1787:47: (forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let index:EST_value \u003d eval_Operation(i)(e)(mu(ps, time |-\u003e (x.time))), length:int \u003d (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in ((not (not is_((index.val), Int))) \u003d\u003e ((not (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))) \u003d\u003e is_(((index.val).val), int)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1794:13: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 pre_(eval_NamedValue(name)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1794:13: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 pre_(eval_NamedValue(name)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1798:16: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e pre_(eval_CompileTimeValue(ctv)e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1803:31: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003e\u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1804:34: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((vec.val).val)(i), real))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1804:52: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((v.val).val), real))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1804:34: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1806:31: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003c\u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1807:34: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((vec.val).val)(i), real)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1807:52: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((v.val).val), real)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1807:34: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val)))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1809:31: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((not (\u003cltvalue\u003e \u003d to_p)) \u003d\u003e ((\u003catvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val)))))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1810:34: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((not (\u003cltvalue\u003e \u003d to_p)) \u003d\u003e ((\u003catvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1801:25: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e (((to_p \u003d \u003cgtvalue\u003e) or (to_p \u003d \u003cltvalue\u003e)) or (to_p \u003d \u003catvalue\u003e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1816:32: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e is_([const_type(new_v(i)) | i in set (inds new_v)], seq1 of (Expressible_type))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1816:44: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e (forall i in set (inds new_v) \u0026 (((((((is_(new_v(i), Errvalue) or is_(new_v(i), Int)) or is_(new_v(i), Real)) or is_(new_v(i), Structure)) or is_(new_v(i), Tr)) or is_(new_v(i), Union)) or is_(new_v(i), Vector)) or is_(new_v(i), Void)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1816:44: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e (forall i in set (inds new_v) \u0026 (i in set (inds new_v)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1818:74: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e let new_l:int \u003d (((vec.val).type).lower), new_u:int \u003d (((((vec.val).type).lower) + (len new_v)) - 1), new_t:(Errvalue | Expressible_type) \u003d seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl:Flavdom \u003d (((vec.val).type).fl) in ((((((is_(new_t, Float) or is_(new_t, IntType)) or is_(new_t, StructureType)) or is_(new_t, TrType)) or is_(new_t, UnionType)) or is_(new_t, VectorType)) or is_(new_t, VoidType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1818:42: (forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e let new_l:int \u003d (((vec.val).type).lower), new_u:int \u003d (((((vec.val).type).lower) + (len new_v)) - 1), new_t:(Errvalue | Expressible_type) \u003d seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl:Flavdom \u003d (((vec.val).type).fl) in ((((((is_(new_v, seq1 of (Errvalue)) or is_(new_v, seq1 of (Int))) or is_(new_v, seq1 of (Real))) or is_(new_v, seq1 of (StructValue))) or is_(new_v, seq1 of (Tr))) or is_(new_v, seq1 of (VectorValue))) or is_(new_v, seq1 of (Void)))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1826:50: (forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 (forall id in set (dom m) \u0026 (id in set (dom m))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1829:7: (forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 let locs:set of (Id) \u003d {id | id in set (dom m) \u0026 is_(m(id), Location)} in let new_m:map (Id) to (Denotable_value) \u003d (locs \u003c-: m) in let new_env:(map (Id) to (Denotable_value) * Location) \u003d mk_(new_m, l) in pre_(eval_Operation(op)(new_env)mk_PState({|-\u003e}, zerot)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1829:7: (forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 let locs:set of (Id) \u003d {id | id in set (dom m) \u0026 is_(m(id), Location)} in let new_m:map (Id) to (Denotable_value) \u003d (locs \u003c-: m) in let new_env:(map (Id) to (Denotable_value) * Location) \u003d mk_(new_m, l) in pre_(eval_Operation(op)new_env))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1833:16: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))(e)mk_PState((ps.sto), zerot))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1833:16: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1833:31: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 (i in set (inds ops))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1835:15: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1836:22: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1839:26: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e is_([(val(i).type) | i in set (inds val)], seq1 of (Expressible_type))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1839:27: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e (forall i in set (inds val) \u0026 (i in set (inds val)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1842:47: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([(val(i).type) | i in set (inds val)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1843:31: (forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([(val(i).type) | i in set (inds val)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let tp:VectorType \u003d mk_VectorType(1, (len val), type, {}) in ((((((is_(val, seq1 of (Errvalue)) or is_(val, seq1 of (Int))) or is_(val, seq1 of (Real))) or is_(val, seq1 of (StructValue))) or is_(val, seq1 of (Tr))) or is_(val, seq1 of (VectorValue))) or is_(val, seq1 of (Void))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1848:16: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))(e)mk_PState((ps.sto), zerot))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1848:16: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1848:31: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 (i in set (inds ops))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1855:19: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1856:27: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1857:21: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1858:36: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e let tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [((vals(i).val).type) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]), comps:seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) \u003d [((vals(i).val).val) | i in set (inds vals)] in is_(tps, seq1 of (CompType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1859:31: (forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e let tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [((vals(i).val).type) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]), comps:seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) \u003d [((vals(i).val).val) | i in set (inds vals)] in let type:StructureType \u003d mk_StructureType(tps, {}) in is_(comps, seq1 of (Component)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1864:11: (forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 pre_(eval_Expression((hd exprs))(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1864:11: (forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 pre_(eval_Expression((hd exprs))e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1868:8: (forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression((hd exprs))(e)(ps) in ((not ((len exprs) \u003d 1)) \u003d\u003e (is_((x.val), Void) \u003d\u003e pre_(eval_Sequence(mk_Sequence((tl exprs)))(e)mk_PState((x.sto), (x.time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1868:8: (forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression((hd exprs))(e)(ps) in ((not ((len exprs) \u003d 1)) \u003d\u003e (is_((x.val), Void) \u003d\u003e pre_(eval_Sequence(mk_Sequence((tl exprs)))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1875:17: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e pre_(access_env(id)mk_(m, l))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1878:17: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e (exists mk_Proc(p):Denotable_value \u0026 (mk_Proc(p) \u003d pp)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1878:30: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e is_(pp, Proc))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1879:27: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in pre_(eval_Acts(acts)(mk_(m, l))mk_PState(sto, time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1879:27: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in pre_(eval_Acts(acts)mk_(m, l)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1883:20: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e pre_(p([(params(i).val) | i in set (inds params)])mk_PState(sto, (params((len params)).time)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1883:20: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e pre_(p[(params(i).val) | i in set (inds params)])))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1883:23: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e (forall i in set (inds params) \u0026 (i in set (inds params)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1884:37: (forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e ((len params) in set (inds params))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1890:16: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e pre_(eval_Operation((hd ops))(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1890:16: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e pre_(eval_Operation((hd ops))e)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1890:34: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e (ops \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1891:12: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in pre_(eval_Acts((tl ops))(e)mk_PState((ps.sto), (x.time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1891:12: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in pre_(eval_Acts((tl ops))e)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1891:25: (forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in (ops \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1895:11: (forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1895:11: (forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1899:17: (forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Type(dest_type)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1902:34: (forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type), dt:(Errvalue | Expressible_type) \u003d eval_Type(dest_type)(e) in ((not (dt \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(dt, Float) or is_(dt, IntType)) or is_(dt, StructureType)) or is_(dt, TrType)) or is_(dt, UnionType)) or is_(dt, VectorType)) or is_(dt, VoidType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1910:28: (forall mk_Type(tp):Type, e:Env \u0026 (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_PrimitiveType(p) \u003d tp) \u003d\u003e let mk_PrimitiveType(p) \u003d tp in pre_(eval_PrimitiveType(tp)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1910:47: (forall mk_Type(tp):Type, e:Env \u0026 (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_PrimitiveType(p) \u003d tp) \u003d\u003e let mk_PrimitiveType(p) \u003d tp in is_(tp, PrimitiveType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1911:30: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_VecType(range, tpe) \u003d tp) \u003d\u003e let mk_VecType(range, tpe) \u003d tp in pre_(eval_VecType(tp)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1911:43: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_VecType(range, tpe) \u003d tp) \u003d\u003e let mk_VecType(range, tpe) \u003d tp in is_(tp, VecType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1912:26: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_StrucType(tps) \u003d tp) \u003d\u003e let mk_StrucType(tps) \u003d tp in pre_(eval_StrucType(tp)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1912:41: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_StrucType(tps) \u003d tp) \u003d\u003e let mk_StrucType(tps) \u003d tp in is_(tp, StrucType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1913:33: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_FlavouredType(fl, tpe) \u003d tp) \u003d\u003e let mk_FlavouredType(fl, tpe) \u003d tp in pre_(eval_FlavouredType(tp)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1913:52: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_FlavouredType(fl, tpe) \u003d tp) \u003d\u003e let mk_FlavouredType(fl, tpe) \u003d tp in is_(tp, FlavouredType)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1914:24: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_UnionTp(tps) \u003d tp) \u003d\u003e let mk_UnionTp(tps) \u003d tp in pre_(eval_UnionTp(tp)e))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1914:37: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_UnionTp(tps) \u003d tp) \u003d\u003e let mk_UnionTp(tps) \u003d tp in is_(tp, UnionTp))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1915:24: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_UnionTp(tps) \u003d tp))) \u003d\u003e (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_TypeName(id) \u003d tp) \u003d\u003e let mk_TypeName(id) \u003d tp in pre_(eval_TypeName(tp)e)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1915:38: (forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_UnionTp(tps) \u003d tp))) \u003d\u003e (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_TypeName(id) \u003d tp) \u003d\u003e let mk_TypeName(id) \u003d tp in is_(tp, TypeName)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1909:3: (forall mk_Type(tp):Type, e:Env \u0026 ((((((exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_PrimitiveType(p))) or (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_VecType(range, tpe)))) or (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_StrucType(tps)))) or (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_FlavouredType(fl, tpe)))) or (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_UnionTp(tps)))) or (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_TypeName(id)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1921:8: (forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 (is_(pt, Number) \u003d\u003e pre_(eval_Number(pt)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1923:8: (forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e (is_(pt, FloatType) \u003d\u003e pre_(eval_FloatType(pt)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1924:8: (forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e ((not is_(pt, FloatType)) \u003d\u003e pre_(eval_VoidValType(pt)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1924:25: (forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e ((not is_(pt, FloatType)) \u003d\u003e is_(pt, Flavouring))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1928:18: (forall mk_Number(rep, range):Number, e:Env \u0026 (forall r in set (elems range) \u0026 pre_(eval_Range(r)e)))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1934:21: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1935:24: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e let m:map (nat) to (bool) \u003d {0 |-\u003e false, 1 |-\u003e true} in (forall v in set (dunion ranges) \u0026 (v in set (dom m)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1935:26: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e let m:map (nat) to (bool) \u003d {0 |-\u003e false, 1 |-\u003e true} in (forall v in set (dunion ranges) \u0026 (v \u003e\u003d 0))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1939:24: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1939:28: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e is_((dunion ranges), set of (int)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1942:19: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1942:23: (forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e is_((dunion ranges), set of (int)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1947:36: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((lower \u003c\u003e nil) \u003d\u003e pre_(eval_CompileTimeValue(lower)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1947:58: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((lower \u003c\u003e nil) \u003d\u003e is_(lower, CompileTimeValue))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1948:36: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((not ((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int)))) \u003d\u003e ((upper \u003c\u003e nil) \u003d\u003e pre_(eval_CompileTimeValue(upper)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1948:58: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((not ((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int)))) \u003d\u003e ((upper \u003c\u003e nil) \u003d\u003e is_(upper, CompileTimeValue)))))","finite set obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1951:8: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((0 \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1951:40: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e is_(((eval_CompileTimeValue(upper)(e).val).val), real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1951:40: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e pre_(eval_CompileTimeValue(upper)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1951:62: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e is_(upper, CompileTimeValue))))))","finite set obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1953:8: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d maxint)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1953:24: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 is_(((eval_CompileTimeValue(lower)(e).val).val), real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1953:24: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 pre_(eval_CompileTimeValue(lower)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1953:46: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 is_(lower, CompileTimeValue))))))","finite set obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1955:8: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1955:24: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 is_(((eval_CompileTimeValue(lower)(e).val).val), real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1955:24: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 pre_(eval_CompileTimeValue(lower)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1955:46: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 is_(lower, CompileTimeValue))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1956:29: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e is_(((eval_CompileTimeValue(upper)(e).val).val), real)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1956:29: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e pre_(eval_CompileTimeValue(upper)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1956:51: (forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e is_(upper, CompileTimeValue)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1961:43: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not ((abserr \u003d nil) and (relerr \u003d nil))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1965:25: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (abserr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(abserr)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1965:47: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (abserr \u003d nil)) \u003d\u003e is_(abserr, CompileTimeValue))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1968:25: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (relerr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(relerr)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1968:47: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (relerr \u003d nil)) \u003d\u003e is_(relerr, CompileTimeValue))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1971:35: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_min(eval_Range(range)(e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1971:39: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(eval_Range(range)(e), set of (real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1971:39: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1972:35: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_max(eval_Range(range)(e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1972:39: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(eval_Range(range)(e), set of (real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1972:39: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1971:35: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(min(eval_Range(range)(e)), int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1972:35: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(max(eval_Range(range)(e)), int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1973:47: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e is_((abse.val), real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1973:56: (forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e is_((rele.val), real))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1981:16: (forall mk_StrucType(tps):StrucType, e:Env \u0026 (forall i in set (inds tps) \u0026 pre_(eval_Type(tps(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1981:26: (forall mk_StrucType(tps):StrucType, e:Env \u0026 (forall i in set (inds tps) \u0026 (i in set (inds tps))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1988:25: (forall mk_StrucType(tps):StrucType, e:Env \u0026 let typs:seq of ((Errvalue | Expressible_type)) \u003d [eval_Type(tps(i))(e) | i in set (inds tps)] in ((not (exists tp in set (elems typs) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))) \u003d\u003e ((not (exists tp1, tp2 in set (elems typs) \u0026 ((tp1 \u003c\u003e tp2) and ((tp1.fl) \u003d (tp2.fl))))) \u003d\u003e is_(typs, seq1 of (CompType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1992:13: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 pre_(eval_Type(tp)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1993:16: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 pre_(eval_Range(range)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:22: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_min(nrange))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:26: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:34: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_max(nrange))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:38: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:22: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(min(nrange), int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:34: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(max(nrange), int))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 1996:46: (forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e ((((((is_(typ, Float) or is_(typ, IntType)) or is_(typ, StructureType)) or is_(typ, TrType)) or is_(typ, UnionType)) or is_(typ, VectorType)) or is_(typ, VoidType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2001:13: (forall mk_FlavouredType(fl, tp):FlavouredType, e:Env \u0026 pre_(eval_Type(tp)e))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2004:10: (forall mk_FlavouredType(fl, tp):FlavouredType, e:Env \u0026 let flavour:Flavdom \u003d eval_Flavouring(fl), typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (typ \u003d \u003cerr\u003e)) \u003d\u003e (((((((exists mk_VoidType(t):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_VoidType(t))) or (exists mk_TrType(range, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_TrType(range, fl)))) or (exists mk_IntType(rep, range, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(range, abse, rele, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_Float(range, abse, rele, fl)))) or (exists mk_VectorType(lower, upper, tp, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_VectorType(lower, upper, tp, fl)))) or (exists mk_StructureType(tps, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_StructureType(tps, fl)))) or (exists mk_UnionType(tps, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_UnionType(tps, fl))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2017:15: (forall mk_UnionTp(tps):UnionTp, e:Env \u0026 (forall i in set (inds tps) \u0026 pre_(eval_Type(tps(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2017:25: (forall mk_UnionTp(tps):UnionTp, e:Env \u0026 (forall i in set (inds tps) \u0026 (i in set (inds tps))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2023:21: (forall mk_UnionTp(tps):UnionTp, e:Env \u0026 let typs:set of ((Errvalue | Expressible_type)) \u003d {eval_Type(tps(i))(e) | i in set (inds tps)} in ((not (exists tp in set typs \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))) \u003d\u003e ((not (exists t1, t2 in set typs \u0026 fleq(t1, t2))) \u003d\u003e is_(typs, set of ((Float | IntType | TrType | VoidType))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2028:8: (forall mk_TypeName(id):TypeName, mk_(m, l):Env \u0026 ((id in set (dom m)) \u003d\u003e (((((exists mk_Location(l):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Location(l))) or (exists mk_Storable_value(v):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Storable_value(v)))) or (exists mk_Proc(p):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Proc(p)))) or (access_env(id)(mk_(m, l)) \u003d \u003cerr\u003e)) or (exists t:Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d t)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2025:1: (forall mk_TypeName(id):TypeName, mk_(m, l):Env \u0026 (is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Errvalue) or (is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Expressible_type) and ((((((is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Float) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), IntType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), StructureType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), TrType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), UnionType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), VectorType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), VoidType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2039:8: (forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 (is_(s, SimpleScope) \u003d\u003e pre_(eval_SimpleScope(s)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2039:8: (forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 (is_(s, SimpleScope) \u003d\u003e pre_(eval_SimpleScope(s)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2040:8: (forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e pre_(eval_PackageScope(s)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2040:8: (forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e pre_(eval_PackageScope(s)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2040:26: (forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e is_(s, PackageScope)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2045:20: (forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in pre_(eval_Decls(decls)old_env_st))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2048:12: (forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(new_env, new_sto):EnvState \u0026 (mk_(new_env, new_sto) \u003d new_env_st))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2048:35: (forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(new_env_st, (Env * PState))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2049:8: (forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(new_env, new_sto):EnvState \u003d new_env_st in pre_(eval_Expression(expr)(new_env)new_sto)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2049:8: (forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(new_env, new_sto):EnvState \u003d new_env_st in pre_(eval_Expression(expr)new_env)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2057:8: (forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e pre_(eval_Decls((tl decls))eval_Declaration((hd decls))(env_st)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2057:22: (forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e (decls \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2057:29: (forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e pre_(eval_Declaration((hd decls))env_st))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2057:49: (forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e (decls \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2062:29: (forall decl:Declaration, env_st:EnvState \u0026 (exists mk_ImportDecl(id, tp):Declaration \u0026 ((mk_ImportDecl(id, tp) \u003d decl) \u003d\u003e let mk_ImportDecl(id, tp) \u003d decl in pre_(eval_ImportDecl(decl)env_st))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2062:45: (forall decl:Declaration, env_st:EnvState \u0026 (exists mk_ImportDecl(id, tp):Declaration \u0026 ((mk_ImportDecl(id, tp) \u003d decl) \u003d\u003e let mk_ImportDecl(id, tp) \u003d decl in is_(decl, ImportDecl))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2063:31: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e (exists mk_ExportDecl(id, expr):Declaration \u0026 ((mk_ExportDecl(id, expr) \u003d decl) \u003d\u003e let mk_ExportDecl(id, expr) \u003d decl in pre_(eval_ExportDecl(decl)env_st)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2063:47: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e (exists mk_ExportDecl(id, expr):Declaration \u0026 ((mk_ExportDecl(id, expr) \u003d decl) \u003d\u003e let mk_ExportDecl(id, expr) \u003d decl in is_(decl, ExportDecl)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2064:22: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_LetDecl(l):Declaration \u0026 ((mk_LetDecl(l) \u003d decl) \u003d\u003e let mk_LetDecl(l) \u003d decl in pre_(eval_LetDecl(decl)env_st))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2064:35: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_LetDecl(l):Declaration \u0026 ((mk_LetDecl(l) \u003d decl) \u003d\u003e let mk_LetDecl(l) \u003d decl in is_(decl, LetDecl))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2065:28: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e (exists mk_VarDecl(id, expr):Declaration \u0026 ((mk_VarDecl(id, expr) \u003d decl) \u003d\u003e let mk_VarDecl(id, expr) \u003d decl in pre_(eval_VarDecl(decl)env_st)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2065:41: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e (exists mk_VarDecl(id, expr):Declaration \u0026 ((mk_VarDecl(id, expr) \u003d decl) \u003d\u003e let mk_VarDecl(id, expr) \u003d decl in is_(decl, VarDecl)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2066:32: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 ((mk_ProcDec(nls, ph, expr) \u003d decl) \u003d\u003e let mk_ProcDec(nls, ph, expr) \u003d decl in pre_(eval_ProcDec(decl)env_st))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2066:45: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 ((mk_ProcDec(nls, ph, expr) \u003d decl) \u003d\u003e let mk_ProcDec(nls, ph, expr) \u003d decl in is_(decl, ProcDec))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2067:28: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (mk_ProcDec(nls, ph, expr) \u003d decl))) \u003d\u003e (exists mk_TypeDec(id, type):Declaration \u0026 ((mk_TypeDec(id, type) \u003d decl) \u003d\u003e let mk_TypeDec(id, type) \u003d decl in pre_(eval_TypeDec(decl)env_st)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2067:41: (forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (mk_ProcDec(nls, ph, expr) \u003d decl))) \u003d\u003e (exists mk_TypeDec(id, type):Declaration \u0026 ((mk_TypeDec(id, type) \u003d decl) \u003d\u003e let mk_TypeDec(id, type) \u003d decl in is_(decl, TypeDec)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2061:3: (forall decl:Declaration, env_st:EnvState \u0026 ((((((exists mk_ImportDecl(id, tp):Declaration \u0026 (decl \u003d mk_ImportDecl(id, tp))) or (exists mk_ExportDecl(id, expr):Declaration \u0026 (decl \u003d mk_ExportDecl(id, expr)))) or (exists mk_LetDecl(l):Declaration \u0026 (decl \u003d mk_LetDecl(l)))) or (exists mk_VarDecl(id, expr):Declaration \u0026 (decl \u003d mk_VarDecl(id, expr)))) or (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (decl \u003d mk_ProcDec(nls, ph, expr)))) or (exists mk_TypeDec(id, type):Declaration \u0026 (decl \u003d mk_TypeDec(id, type)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2072:14: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Type(tp)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2075:25: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2077:19: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2077:19: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2078:18: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value(val))(ps.sto))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2078:18: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value(val))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2078:46: (forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_(val, Int) or is_(val, Real)) or is_(val, Structure)) or is_(val, Tr)) or is_(val, Union)) or is_(val, Vector)) or is_(val, Void))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2084:11: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2084:11: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2088:19: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2088:19: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2089:18: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value((x.val)))(ps.sto))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2089:18: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value((x.val)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2089:46: (forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_((x.val), Int) or is_((x.val), Real)) or is_((x.val), Structure)) or is_((x.val), Tr)) or is_((x.val), Union)) or is_((x.val), Vector)) or is_((x.val), Void))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2096:8: (forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 (is_(decl, SimpleLetDecl) \u003d\u003e pre_(eval_SimpleLetDecl(decl)es)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2097:8: (forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 ((not is_(decl, SimpleLetDecl)) \u003d\u003e pre_(eval_StrucLetDecl(decl)es)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2097:26: (forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 ((not is_(decl, SimpleLetDecl)) \u003d\u003e is_(decl, StrucLetDecl)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2101:11: (forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2101:11: (forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2104:13: (forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)((x.val))e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2104:13: (forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)(x.val))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2104:28: (forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e is_((x.val), Errvalue)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2109:11: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2109:11: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2114:28: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds ids))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2115:40: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (is_(((x.val).val)(i), bool) or is_(((x.val).val)(i), real))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2115:40: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds ((x.val).val)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2115:53: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds (((x.val).type).tps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2117:22: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let id_vals:seq of ((Id * Expressible_value)) \u003d [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in pre_(multi_update_env(id_vals)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2117:39: (forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let id_vals:seq of ((Id * Expressible_value)) \u003d [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in is_(id_vals, seq of ((Id * Denotable_value))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2122:11: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2122:11: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2126:19: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2126:19: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2127:18: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value((x.val)))(ps.sto))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2127:18: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value((x.val)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2127:46: (forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_((x.val), Int) or is_((x.val), Real)) or is_((x.val), Structure)) or is_((x.val), Tr)) or is_((x.val), Union)) or is_((x.val), Vector)) or is_((x.val), Void))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2133:16: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 pre_(eval_NonLocals(nls)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2133:16: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 pre_(eval_NonLocals(nls)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2133:31: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 is_(nls, NonLocals))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2137:12: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, ns):EnvState \u0026 (mk_(ne, ns) \u003d env_st))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2137:25: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(env_st, (Env * PState))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2138:18: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in pre_(eval_Formals(formals)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2141:33: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 pre_(instantiate_formals(fls)(a)ne))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2141:33: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 pre_(instantiate_formals(fls)a))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2145:37: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Expression(expr)(nn_e)nps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2145:37: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Expression(expr)nn_e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2145:59: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e is_(nn_e, (map (Id) to (Denotable_value) * Location)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2152:12: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in let pr:Proc \u003d mk_Proc((lambda [a:(unresolved DEFAULT`Param)] \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (lambda [nps:(unresolved DEFAULT`PState)] \u0026 (if (nn_e \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(nn_e)(nps) in (if (((x.val) \u003c\u003e \u003cerr\u003e) and ((is_((x.val), Void) and (((x.val).type) \u003d mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) \u003d {Phi}))))\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse x))))) in pre_(update_env(id)(pr)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2152:12: (forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in let pr:Proc \u003d mk_Proc((lambda [a:(unresolved DEFAULT`Param)] \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (lambda [nps:(unresolved DEFAULT`PState)] \u0026 (if (nn_e \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(nn_e)(nps) in (if (((x.val) \u003c\u003e \u003cerr\u003e) and ((is_((x.val), Void) and (((x.val).type) \u003d mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) \u003d {Phi}))))\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse x))))) in pre_(update_env(id)pr)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2159:8: (forall mk_NonLocals(ids, decls):NonLocals, mk_(m, l):Env, ps:PState \u0026 let ids_map:(map (?) to (?) | map (Id) to (Denotable_value)) \u003d (if (ids \u003d nil)\nthen {|-\u003e}\nelse ((elems ids) \u003c: m)) in ((not (decls \u003d nil)) \u003d\u003e pre_(eval_Decls(decls)mk_(mk_(ids_map, l), ps))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2159:19: (forall mk_NonLocals(ids, decls):NonLocals, mk_(m, l):Env, ps:PState \u0026 let ids_map:(map (?) to (?) | map (Id) to (Denotable_value)) \u003d (if (ids \u003d nil)\nthen {|-\u003e}\nelse ((elems ids) \u003c: m)) in ((not (decls \u003d nil)) \u003d\u003e is_(decls, seq of (Declaration))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2163:4: (forall fls:seq of (Formal), e:Env \u0026 (forall i in set (inds fls) \u0026 pre_(eval_Formal(fls(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2163:16: (forall fls:seq of (Formal), e:Env \u0026 (forall i in set (inds fls) \u0026 (i in set (inds fls))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2167:15: (forall mk_Formal(id, rep, fl):Formal, e:Env \u0026 pre_(eval_Representation(rep)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2169:20: (forall mk_Formal(id, rep, fl):Formal, e:Env \u0026 let n_rep:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), n_fl:Flavdom \u003d eval_Flavouring(fl) in ((((((is_(n_rep, Float) or is_(n_rep, IntType)) or is_(n_rep, StructureType)) or is_(n_rep, TrType)) or is_(n_rep, UnionType)) or is_(n_rep, VectorType)) or is_(n_rep, VoidType)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2174:27: (forall rep:Representation, e:Env \u0026 (exists mk_PrimitiveRep(p):Representation \u0026 ((mk_PrimitiveRep(p) \u003d rep) \u003d\u003e let mk_PrimitiveRep(p) \u003d rep in pre_(eval_PrimitiveRep(rep)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2174:45: (forall rep:Representation, e:Env \u0026 (exists mk_PrimitiveRep(p):Representation \u0026 ((mk_PrimitiveRep(p) \u003d rep) \u003d\u003e let mk_PrimitiveRep(p) \u003d rep in is_(rep, PrimitiveRep))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2175:24: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e (exists mk_StrucRep(rs):Representation \u0026 ((mk_StrucRep(rs) \u003d rep) \u003d\u003e let mk_StrucRep(rs) \u003d rep in pre_(eval_StrucRep(rep)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2175:38: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e (exists mk_StrucRep(rs):Representation \u0026 ((mk_StrucRep(rs) \u003d rep) \u003d\u003e let mk_StrucRep(rs) \u003d rep in is_(rep, StrucRep)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2176:27: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e (exists mk_VecRep(range, r):Representation \u0026 ((mk_VecRep(range, r) \u003d rep) \u003d\u003e let mk_VecRep(range, r) \u003d rep in pre_(eval_VecRep(rep)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2176:39: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e (exists mk_VecRep(range, r):Representation \u0026 ((mk_VecRep(range, r) \u003d rep) \u003d\u003e let mk_VecRep(range, r) \u003d rep in is_(rep, VecRep))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2177:24: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e (exists mk_UnionRep(rs):Representation \u0026 ((mk_UnionRep(rs) \u003d rep) \u003d\u003e let mk_UnionRep(rs) \u003d rep in pre_(eval_UnionRep(rep)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2177:38: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e (exists mk_UnionRep(rs):Representation \u0026 ((mk_UnionRep(rs) \u003d rep) \u003d\u003e let mk_UnionRep(rs) \u003d rep in is_(rep, UnionRep)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2178:29: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e (exists mk_FlavouredRep(f, r):Representation \u0026 ((mk_FlavouredRep(f, r) \u003d rep) \u003d\u003e let mk_FlavouredRep(f, r) \u003d rep in pre_(eval_FlavouredRep(rep)e))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2178:47: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e (exists mk_FlavouredRep(f, r):Representation \u0026 ((mk_FlavouredRep(f, r) \u003d rep) \u003d\u003e let mk_FlavouredRep(f, r) \u003d rep in is_(rep, FlavouredRep))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2179:19: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_FlavouredRep(f, r):Representation \u0026 (mk_FlavouredRep(f, r) \u003d rep))) \u003d\u003e (exists mk_Type(t):Representation \u0026 ((mk_Type(t) \u003d rep) \u003d\u003e let mk_Type(t) \u003d rep in pre_(eval_Type(rep)e)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2179:29: (forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_FlavouredRep(f, r):Representation \u0026 (mk_FlavouredRep(f, r) \u003d rep))) \u003d\u003e (exists mk_Type(t):Representation \u0026 ((mk_Type(t) \u003d rep) \u003d\u003e let mk_Type(t) \u003d rep in is_(rep, Type)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2173:3: (forall rep:Representation, e:Env \u0026 ((((((exists mk_PrimitiveRep(p):Representation \u0026 (rep \u003d mk_PrimitiveRep(p))) or (exists mk_StrucRep(rs):Representation \u0026 (rep \u003d mk_StrucRep(rs)))) or (exists mk_VecRep(range, r):Representation \u0026 (rep \u003d mk_VecRep(range, r)))) or (exists mk_UnionRep(rs):Representation \u0026 (rep \u003d mk_UnionRep(rs)))) or (exists mk_FlavouredRep(f, r):Representation \u0026 (rep \u003d mk_FlavouredRep(f, r)))) or (exists mk_Type(t):Representation \u0026 (rep \u003d mk_Type(t)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2185:8: (forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 (is_(rep, NumRep) \u003d\u003e pre_(eval_NumRep(rep)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2186:8: (forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 ((not is_(rep, NumRep)) \u003d\u003e pre_(eval_FloatRep(rep)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2186:22: (forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 ((not is_(rep, NumRep)) \u003d\u003e is_(rep, FloatRep)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2191:22: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 ((not (range \u003d nil)) \u003d\u003e (forall r in set (elems range) \u0026 pre_(eval_Range(r)e))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2198:30: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 (r in set (dom {0 |-\u003e false, 1 |-\u003e true}))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2198:56: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 is_(r, nat)))))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2198:30: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2202:44: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e (forall v in set (dunion ranges) \u0026 is_((abs v), real))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2206:25: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-bytemax, ... ,bytemax}\nelse (dunion ranges)) in (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2206:29: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-bytemax, ... ,bytemax}\nelse (dunion ranges)) in is_(rngs, set of (int)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2211:20: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-maxint, ... ,maxint}\nelse (dunion ranges)) in (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2211:24: (forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-maxint, ... ,maxint}\nelse (dunion ranges)) in is_(rngs, set of (int)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2216:22: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (range \u003d nil)) \u003d\u003e (forall r in set (elems range) \u0026 pre_(eval_Range(r)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2220:21: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (abserr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(abserr)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2220:43: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (abserr \u003d nil)) \u003d\u003e is_(abserr, CompileTimeValue)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2224:21: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (relerr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(relerr)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2224:43: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (relerr \u003d nil)) \u003d\u003e is_(relerr, CompileTimeValue)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:37: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 pre_min(r)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:41: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(r, set of (real))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:44: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 pre_max(r)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:48: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(r, set of (real))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:37: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(min(r), int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2229:44: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(max(r), int)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2230:23: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e let rngs:set of (Floatrng) \u003d (if (range \u003d nil)\nthen {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}\nelse {mk_Floatrng(min(r), max(r)) | r in set ranges}) in is_(((abse.val).val), real)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2230:36: (forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e let rngs:set of (Floatrng) \u003d (if (range \u003d nil)\nthen {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}\nelse {mk_Floatrng(min(r), max(r)) | r in set ranges}) in is_(((rele.val).val), real)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2234:15: (forall mk_StrucRep(reps):StrucRep, e:Env \u0026 (forall i in set (inds reps) \u0026 pre_(eval_Representation(reps(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2234:35: (forall mk_StrucRep(reps):StrucRep, e:Env \u0026 (forall i in set (inds reps) \u0026 (i in set (inds reps))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2240:25: (forall mk_StrucRep(reps):StrucRep, e:Env \u0026 let tps:seq of ((Errvalue | Expressible_type)) \u003d [eval_Representation(reps(i))(e) | i in set (inds reps)] in ((not (exists tp in set (elems tps) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))) \u003d\u003e ((not (exists tp1, tp2 in set (elems tps) \u0026 fleq(tp1, tp2))) \u003d\u003e is_(tps, seq1 of (CompType)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2244:16: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 pre_(eval_Range(range)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2245:14: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 pre_(eval_Representation(rep)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:22: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_min(nrange)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:26: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:34: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_max(nrange)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:38: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:22: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(min(nrange), int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:34: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(max(nrange), int)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2248:46: (forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2252:14: (forall mk_UnionRep(reps):UnionRep, e:Env \u0026 (forall rep in set (elems reps) \u0026 pre_(eval_Representation(rep)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2258:21: (forall mk_UnionRep(reps):UnionRep, e:Env \u0026 let tps:set of ((Errvalue | Expressible_type)) \u003d {eval_Representation(rep)(e) | rep in set (elems reps)} in ((not (exists tp in set tps \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))) \u003d\u003e ((not (exists tp1, tp2 in set tps \u0026 fleq(tp1, tp2))) \u003d\u003e is_(tps, set of ((Float | IntType | TrType | VoidType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2262:14: (forall mk_FlavouredRep(fl, rep):FlavouredRep, e:Env \u0026 pre_(eval_Representation(rep)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2266:24: (forall mk_FlavouredRep(fl, rep):FlavouredRep, e:Env \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), flav:Flavdom \u003d eval_Flavouring(fl) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2270:14: (forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 pre_(eval_Type(tp)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2273:12: (forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)(type)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2273:12: (forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)type)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2278:20: (forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in pre_(eval_Decls(decls)env_st))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2281:12: (forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(mk_(nm, nl), nps):EnvState \u0026 (mk_(mk_(nm, nl), nps) \u003d new_env_st))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2281:34: (forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(new_env_st, (Env * PState))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2285:13: (forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(mk_(nm, nl), nps):EnvState \u003d new_env_st in ((not (not ((elems ids) subset ((dom nm) \\ (dom m))))) \u003d\u003e let ne:(map (Id) to (Denotable_value) * Location) \u003d mk_((((elems ids) union (dom m)) \u003c: nm), nl) in pre_(eval_Expression(expr)(ne)nps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2285:13: (forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(mk_(nm, nl), nps):EnvState \u003d new_env_st in ((not (not ((elems ids) subset ((dom nm) \\ (dom m))))) \u003d\u003e let ne:(map (Id) to (Denotable_value) * Location) \u003d mk_((((elems ids) union (dom m)) \u003c: nm), nl) in pre_(eval_Expression(expr)ne))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2289:16: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)(true)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2289:16: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)(true)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2289:16: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)true))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2292:12: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u0026 (mk_(ne, nps, val) \u003d g_decl))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2292:30: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e is_(g_decl, (Env * PState * bool))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2293:21: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(incl)(ne)nps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2293:21: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(incl)ne)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2294:22: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(outcl)(ne)nps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2294:22: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(outcl)ne)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2301:58: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in let in_val:EST_value \u003d eval_Sequence(incl)(ne)(nps), out_val:EST_value \u003d eval_Sequence(outcl)(ne)(nps) in ((not (((in_val.val) \u003d \u003cerr\u003e) or ((out_val.val) \u003d \u003cerr\u003e))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((in_val.val).type), ((out_val.val).type)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e (val \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2303:59: (forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in let in_val:EST_value \u003d eval_Sequence(incl)(ne)(nps), out_val:EST_value \u003d eval_Sequence(outcl)(ne)(nps) in ((not (((in_val.val) \u003d \u003cerr\u003e) or ((out_val.val) \u003d \u003cerr\u003e))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((in_val.val).type), ((out_val.val).type)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not val) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2309:14: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 pre_(eval_GuardedDecl((hd decls))(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2309:14: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 pre_(eval_GuardedDecl((hd decls))e))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2314:12: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u0026 (mk_(ne, nps, tr) \u003d gdcl)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2314:29: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e is_(gdcl, (Env * PState * bool)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2315:8: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))((b and tr))(ne)nps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2315:8: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))((b and tr))ne))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2315:8: (forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))(b and tr)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2321:8: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 (is_(decl, WhereDecl) \u003d\u003e pre_(eval_WhereDecl(decl)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2321:8: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 (is_(decl, WhereDecl) \u003d\u003e pre_(eval_WhereDecl(decl)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2322:16: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e pre_(eval_Declaration(decl)mk_(e, ps))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2322:33: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e (((((is_(decl, ExportDecl) or is_(decl, ImportDecl)) or is_(decl, LetDecl)) or is_(decl, ProcDec)) or is_(decl, TypeDec)) or is_(decl, VarDecl))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2325:17: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e let d:EnvState \u003d eval_Declaration(decl)(mk_(e, ps)) in ((not (d \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps):EnvState \u0026 (mk_(ne, nps) \u003d d)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2325:31: (forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e let d:EnvState \u003d eval_Declaration(decl)(mk_(e, ps)) in ((not (d \u003d \u003cerr\u003e)) \u003d\u003e is_(d, (Env * PState)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2330:11: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2330:11: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2333:16: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(type)(((x.val).type))e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2333:16: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(type)((x.val).type))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2338:34: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)((x.val))e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2338:34: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)(x.val))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2338:49: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e is_((x.val), Errvalue)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2338:45: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e is_(id, token)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2342:45: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e let env:Env \u003d (if (id \u003d nil)\nthen e\nelse update_env(id)((x.val))(e)) in let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2342:47: (forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e let env:Env \u003d (if (id \u003d nil)\nthen e\nelse update_env(id)((x.val))(e)) in let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(xt, Float) or is_(xt, IntType)) or is_(xt, StructureType)) or is_(xt, TrType)) or is_(xt, UnionType)) or is_(xt, VectorType)) or is_(xt, VoidType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2349:11: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2349:11: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2352:19: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(tp)(((x.val).type))e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2352:19: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(tp)((x.val).type))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2359:30: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2359:56: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e (tleq(type, ((x.val).type)) \u003d\u003e ((((((is_(xt, Float) or is_(xt, IntType)) or is_(xt, StructureType)) or is_(xt, TrType)) or is_(xt, UnionType)) or is_(xt, VectorType)) or is_(xt, VoidType)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2359:59: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e (tleq(type, ((x.val).type)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2361:61: (forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((not (not (tleq(type, ((x.val).type)) and tleq(xt, type)))) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2369:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 (is_(cond, IfThenOnly) \u003d\u003e pre_(eval_IfThenOnly(cond)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2369:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 (is_(cond, IfThenOnly) \u003d\u003e pre_(eval_IfThenOnly(cond)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2371:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e (is_(cond, IfThenElse) \u003d\u003e pre_(eval_IfThenElse(cond)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2371:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e (is_(cond, IfThenElse) \u003d\u003e pre_(eval_IfThenElse(cond)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2372:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e pre_(eval_CaseExpr(cond)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2372:8: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e pre_(eval_CaseExpr(cond)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2372:22: (forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e is_(cond, CaseExpr))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2376:14: (forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2376:14: (forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2377:14: (forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Sequence(action)(e)mu(ps, time |-\u003e tplus((cond.time), t_if))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2377:14: (forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Sequence(action)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2388:14: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2388:14: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2391:21: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(thenaction)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2391:21: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(thenaction)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2392:21: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(elseaction)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2392:21: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(elseaction)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2397:54: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e let then_x:EST_value \u003d eval_Sequence(thenaction)(e)(ps), else_x:EST_value \u003d eval_Sequence(elseaction)(e)(ps) in let type:(Errvalue | Expressible_type) \u003d lub(((then_x.val).type), ((else_x.val).type)) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e (((cond.val).val) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2399:54: (forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e let then_x:EST_value \u003d eval_Sequence(thenaction)(e)(ps), else_x:EST_value \u003d eval_Sequence(elseaction)(e)(ps) in let type:(Errvalue | Expressible_type) \u003d lub(((then_x.val).type), ((else_x.val).type)) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not ((cond.val).val)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2404:11: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2404:11: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2408:17: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)((x.val))(e)mu(ps, time |-\u003e (x.time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2408:17: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)((x.val))e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2408:17: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)(x.val))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2411:37: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e ((len ls) in set (inds ls)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2412:34: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in pre_(eval_Sequence(outlimb)(e)mu(ps, time |-\u003e (v.time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2412:34: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in pre_(eval_Sequence(outlimb)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2412:48: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in is_(outlimb, Sequence))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2422:36: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e is_({((v.val).type) | mk_(t, v) in set (elems pats)}, set of (Expressible_type)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2427:38: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 (let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t) \u003d\u003e (i in set (inds pats))))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2428:54: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 (i in set (inds pats)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2429:43: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in ((((((is_(x_type, Float) or is_(x_type, IntType)) or is_(x_type, StructureType)) or is_(x_type, TrType)) or is_(x_type, UnionType)) or is_(x_type, VectorType)) or is_(x_type, VoidType)))))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2430:43: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in (matches \u003c\u003e [])))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2432:35: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in is_((mv.time), (nat * nat))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2433:47: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in (((((((is_((mv.val), Errvalue) or is_((mv.val), Int)) or is_((mv.val), Real)) or is_((mv.val), Structure)) or is_((mv.val), Tr)) or is_((mv.val), Union)) or is_((mv.val), Vector)) or is_((mv.val), Void))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2433:54: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2433:60: (forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in is_((mv.sto), map (Location) to (Storable_value))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2438:18: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))(x)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2438:18: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))(x)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2438:18: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))x))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2441:20: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))(x)(e)mu(ps, time |-\u003e (v.time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2441:20: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))(x)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2441:20: (forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))x)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2446:11: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)(x)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2446:11: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)(x)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2446:11: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)x))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2449:12: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u0026 (mk_(type, env, tm) \u003d t))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2449:31: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e is_(t, (Expressible_type * Env * Time))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2450:18: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Sequence(sequ)(env)mu(ps, time |-\u003e tm))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2450:18: (forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Sequence(sequ)env)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2463:20: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in pre_(eval_SkeletonType(tester)((x.type))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2463:20: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in pre_(eval_SkeletonType(tester)(x.type)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2463:38: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in is_(tester, SkeletonType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2467:24: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)(x)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2467:24: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)(x)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2467:24: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)x)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2467:39: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in is_(tester, StrucTest)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2468:34: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)(x)(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2468:34: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)(x)e))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2468:34: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)x))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2468:52: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in is_(tester, NonStrucTest))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2461:3: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (((exists mk_SkeletonType(t):Tester \u0026 (tester \u003d mk_SkeletonType(t))) or (exists mk_StrucTest(s):Tester \u0026 (tester \u003d mk_StrucTest(s)))) or (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 (tester \u003d mk_NonStrucTest(id, tp, fl)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2458:1: (forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (is_((cases tester :\nmk_SkeletonType(t) -\u003e let nt:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tester)((x.type))(e) in (if (nt \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(nt, e, (ps.time))),\nmk_StrucTest(s) -\u003e eval_StrucTest(tester)(x)(e)(ps),\nmk_NonStrucTest(id, tp, fl) -\u003e eval_NonStrucTest(tester)(x)(e)(ps)\n end), (Expressible_type * Env * Time)) or is_((cases tester :\nmk_SkeletonType(t) -\u003e let nt:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tester)((x.type))(e) in (if (nt \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(nt, e, (ps.time))),\nmk_StrucTest(s) -\u003e eval_StrucTest(tester)(x)(e)(ps),\nmk_NonStrucTest(id, tp, fl) -\u003e eval_NonStrucTest(tester)(x)(e)(ps)\n end), Errvalue)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2476:19: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_Type(t) \u003d skel) \u003d\u003e let mk_Type(t) \u003d skel in pre_(eval_Type(skel)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2476:29: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_Type(t) \u003d skel) \u003d\u003e let mk_Type(t) \u003d skel in is_(skel, Type))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2477:25: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in pre_(eval_NumSkel(skel)(t)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2477:25: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in pre_(eval_NumSkel(skel)t)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2477:38: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in is_(skel, NumSkel)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2478:24: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in pre_(eval_StrucSkel(skel)(t)e))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2478:24: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in pre_(eval_StrucSkel(skel)t))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2478:39: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in is_(skel, StrucSkel))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2479:26: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in pre_(eval_FlavSkel(skel)(t)e)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2479:26: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in pre_(eval_FlavSkel(skel)t)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2479:40: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in is_(skel, FlavSkel)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2480:22: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in pre_(eval_VecSkel(skel)(t)e))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2480:22: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in pre_(eval_VecSkel(skel)t))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2480:35: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in is_(skel, VecSkel))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2481:24: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in pre_(eval_UnionSkel(skel)(t)e)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2481:24: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in pre_(eval_UnionSkel(skel)t)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2481:39: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in is_(skel, UnionSkel)))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2475:3: (forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((((((exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_Type(t))) or (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_NumSkel(r, er)))) or (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_StrucSkel(s)))) or (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_FlavSkel(s, fl)))) or (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_VecSkel(s)))) or (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_UnionSkel(s)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2493:25: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e ((not (ranges \u003d nil)) \u003d\u003e (forall r in set (elems ranges) \u0026 pre_(eval_Range(r)e)))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2500:38: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 (v in set (dom {0 |-\u003e false, 1 |-\u003e true})))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2501:33: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_(v, nat))))))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2500:38: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2504:42: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((rep \u003d \u003cbyte\u003e) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2505:56: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((not ((rep \u003d \u003cbyte\u003e) and (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d bytemax)))) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2507:42: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((not (((rep \u003d \u003cbyte\u003e) and (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d bytemax))) or (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint)))) \u003d\u003e is_((dunion rngs), set of (int)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2509:55: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2517:32: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.abserr) \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue((errors.abserr))e))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2517:54: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.abserr) \u003d nil)) \u003d\u003e is_((errors.abserr), CompileTimeValue))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2526:32: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.relerr) \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue((errors.relerr))e))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2526:54: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.relerr) \u003d nil)) \u003d\u003e is_((errors.relerr), CompileTimeValue))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:52: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 pre_min(r)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:56: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(r, set of (real))))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:59: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 pre_max(r)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:63: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(r, set of (real))))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:52: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(min(r), int)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2532:59: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(max(r), int)))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2533:48: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e is_(abserr, real))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2533:55: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e is_(relerr, real))))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2496:13: (forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (((exists mk_TrType(range, fl):Expressible_type \u0026 (x_type \u003d mk_TrType(range, fl))) or (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (x_type \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 (x_type \u003d mk_Float(rs, abse, rele, fl)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2543:20: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 (i in set (inds comps))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2544:22: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((comps(i) \u003d \u003cnil\u003e) \u003d\u003e (i in set (inds (x_type.tps))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2545:22: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_SkeletonType(comps(i))((x_type.tps)(i))e))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2545:22: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_SkeletonType(comps(i))(x_type.tps)(i)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2545:40: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e is_(comps(i), SkeletonType))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2545:40: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e (i in set (inds comps)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2545:50: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e (i in set (inds (x_type.tps))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2550:30: (forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e let t:seq of ((CompType | Errvalue | Expressible_type)) \u003d [(if (comps(i) \u003d \u003cnil\u003e)\nthen (x_type.tps)(i)\nelse eval_SkeletonType(comps(i))((x_type.tps)(i))(e)) | i in set (inds comps)] in ((not (exists tp in set (elems t) \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or is_(tp, Float)))))) \u003d\u003e is_(t, seq1 of (CompType))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2555:11: (forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)(x_type)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2555:11: (forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)x_type))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2559:24: (forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e), f:Flavdom \u003d eval_Flavouring(fl) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2564:11: (forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)(x_type)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2564:11: (forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)x_type))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2568:56: (forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_VectorType(l, u, tp, fl):Expressible_type \u0026 ((mk_VectorType(l, u, tp, fl) \u003d x_type) \u003d\u003e let mk_VectorType(l, u, tp, fl) \u003d x_type in ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2575:13: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (forall m1, m2 in set {{skel |-\u003e fl} | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","finite map obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2575:13: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (exists finmap1:map (nat) to (map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom)) \u0026 (forall skel in set (elems skels), fl:Flavdom \u0026 ((fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d {skel |-\u003e fl}))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2579:53: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (forall skel in set (elems skels), fl:Flavdom \u0026 ((not (exists mk_FlavSkel(skel, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(skel, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2584:25: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e (forall m1, m2 in set {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2597:45: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)(tp)e)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2597:45: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)tp)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2597:59: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in is_(skel, FlavSkel)))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2598:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in pre_(eval_FlavouredType(skel)e))))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2598:63: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in is_(skel, FlavouredType))))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2599:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e pre_(eval_VoidValType(skel)e)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2599:61: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2601:27: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 (skel in set (dom fls)))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2601:39: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 (tp in set (dom x_fls)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2605:31: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e let tps:set of ((Errvalue | Expressible_type)) \u003d {(cases skel :\nmk_FlavSkel(s, f) -\u003e eval_FlavSkel(skel)(tp)(e),\nmk_FlavouredType(f, t) -\u003e eval_FlavouredType(skel)(e)\nothers eval_VoidValType(skel)(e)\n end) | skel in set (elems skels), tp in set (x_type.tps) \u0026 (fls(skel) \u003d x_fls(tp))} in ((not (exists tp in set tps \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or (is_(tp, Float) or is_(tp, VoidType))))))) \u003d\u003e is_(tps, set of ((Float | IntType | TrType | VoidType))))))))","unique existence binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2611:24: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e (exists1 s in set (elems skels) \u0026 (fls(s) \u003d fl))))))","legal map application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2611:52: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e (forall s in set (elems skels) \u0026 (s in set (dom fls)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2613:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)(x_type)e)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2613:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)x_type)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2613:58: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in is_(skel, FlavSkel)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2614:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in pre_(eval_FlavouredType(skel)e))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2614:63: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in is_(skel, FlavouredType))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2615:44: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e pre_(eval_VoidValType(skel)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2615:61: (forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2621:11: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_SkeletonType(skel)((x.type))e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2621:11: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_SkeletonType(skel)(x.type)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2626:38: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((not (fl \u003d nil)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2626:56: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((not (fl \u003d nil)) \u003d\u003e is_(fl, Flavouring))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2629:20: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)(x)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2629:20: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)x))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2629:35: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e is_(x, Errvalue))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2629:31: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e is_(id, token))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2618:1: (forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 (is_(let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in (if (id \u003d nil)\nthen mk_(t\u0027, e, (ps.time))\nelse mk_(t\u0027, update_env(id)(x)(e), (ps.time)))), (Expressible_type * Env * Time)) or is_(let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in (if (id \u003d nil)\nthen mk_(t\u0027, e, (ps.time))\nelse mk_(t\u0027, update_env(id)(x)(e), (ps.time)))), Errvalue)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2638:32: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (is_((x.val)(i), bool) or is_((x.val)(i), real))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2638:32: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (i in set (inds (x.val)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2638:41: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (i in set (inds ((x.type).tps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2640:17: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)(xs)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2640:17: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)(xs)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2640:17: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)xs))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2643:17: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tps, env, time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u0026 (mk_(tps, env, time) \u003d ts))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2643:37: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e is_(ts, (seq of (Expressible_type) * Env * Time))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2644:34: (forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tps, env, time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d ts in is_(tps, seq1 of (CompType))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2652:22: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e (tests \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2653:29: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e (((hd tests) \u003d \u003cnil\u003e) \u003d\u003e (xs \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:21: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))((hd xs))(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:21: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))((hd xs))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:21: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))(hd xs)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:39: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e is_((hd tests), NonStrucTest))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:42: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e (tests \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2654:52: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e (xs \u003c\u003e []))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2657:17: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u0026 (mk_(tp, env, time) \u003d t)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2657:36: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (is_(t, ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time)) or is_(t, (Expressible_type * Env * Time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2658:22: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))((tl xs))(env)mu(ps, time |-\u003e time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2658:22: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))((tl xs))env))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2658:22: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))(tl xs)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2658:38: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in (tests \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2658:48: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in (xs \u003c\u003e []))))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2662:22: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-\u003e time)) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tps, n_env, n_time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u0026 (mk_(tps, n_env, n_time) \u003d ts))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2662:46: (forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-\u003e time)) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e is_(ts, (seq of (Expressible_type) * Env * Time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2668:8: (forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 (is_(oul, OuterIntLoop) \u003d\u003e pre_(eval_OuterIntLoop(oul)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2668:8: (forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 (is_(oul, OuterIntLoop) \u003d\u003e pre_(eval_OuterIntLoop(oul)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2669:8: (forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e pre_(eval_OuterVecLoop(oul)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2669:8: (forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e pre_(eval_OuterVecLoop(oul)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2669:26: (forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e is_(oul, OuterVecLoop)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2673:16: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 pre_(eval_Range(range)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2676:25: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))mu(ps, time |-\u003e zerot)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2676:25: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(eval_Sequence(actns)update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2676:46: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2676:46: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(update_env(id)mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {})))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2681:30: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e is_([((vec_elems(i).val).type) | i in set (inds vec_elems)], seq1 of (Expressible_type)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2681:31: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2682:31: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2687:39: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((is_(type, StructureType) or is_(type, VectorType)) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2689:39: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not (is_(type, StructureType) or is_(type, VectorType))) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2692:29: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2691:44: (forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(vec_val, seq1 of (Errvalue)) or is_(vec_val, seq1 of (Int))) or is_(vec_val, seq1 of (Real))) or is_(vec_val, seq1 of (StructValue))) or is_(vec_val, seq1 of (Tr))) or is_(vec_val, seq1 of (VectorValue))) or is_(vec_val, seq1 of (Void)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2696:14: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2696:14: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)e))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2699:47: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set (inds idvs) \u0026 (i in set (inds idvs)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2702:24: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 pre_(multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2704:65: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 is_(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])), seq of ((Id * Denotable_value))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2702:61: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 (forall j in set (inds idvs) \u0026 (j in set (inds idvs))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2707:25: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(eval_Sequence(actions)(new_env(i))mu(ps, time |-\u003e zerot)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2707:25: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(eval_Sequence(actions)new_env(i)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2707:48: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(new_envi))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2709:34: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (1 in set (inds idvs))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2712:31: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e is_([((vec_elems(i).val).type) | i in set (inds vec_elems)], seq1 of (Expressible_type)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2712:32: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2714:32: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2718:61: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2721:39: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in ((is_(type, StructureType) or is_(type, VectorType)) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2723:39: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in ((not (is_(type, StructureType) or is_(type, VectorType))) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2725:42: (forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(vec_val, seq1 of (Errvalue)) or is_(vec_val, seq1 of (Int))) or is_(vec_val, seq1 of (Real))) or is_(vec_val, seq1 of (StructValue))) or is_(vec_val, seq1 of (Tr))) or is_(vec_val, seq1 of (VectorValue))) or is_(vec_val, seq1 of (Void)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2731:47: (forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 (i in set (inds (ovs.ovv)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2732:27: (forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in pre_(eval_Operation(val)(e)mu(ps, time |-\u003e zerot))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2732:27: (forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in pre_(eval_Operation(val)e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2734:55: (forall ovs:OverVectors, e:Env, ps:PState \u0026 let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (forall i in set (inds indices) \u0026 (i in set (inds indices))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2728:1: (forall ovs:OverVectors, e:Env, ps:PState \u0026 (is_(let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists i in set (inds indices) \u0026 let mk_(id, v, t):(Id * Expressible_value * Time) \u003d indices(i) in (not is_(v, Vector)))\nthen \u003cerr\u003e\nelse indices), Errvalue) or is_(let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists i in set (inds indices) \u0026 let mk_(id, v, t):(Id * Expressible_value * Time) \u003d indices(i) in (not is_(v, Vector)))\nthen \u003cerr\u003e\nelse indices), seq1 of ((Id * Vector * Time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2742:32: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in pre_(eval_IntLoop(innerl)(e)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2742:32: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in pre_(eval_IntLoop(innerl)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2742:45: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in is_(innerl, IntLoop))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2743:32: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in pre_(eval_VecLoop(innerl)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2743:32: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in pre_(eval_VecLoop(innerl)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2743:45: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in is_(innerl, VecLoop)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2744:34: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in pre_(eval_TimeLoop(innerl)(e)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2744:34: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in pre_(eval_TimeLoop(innerl)e))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2744:48: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in is_(innerl, TimeLoop))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2741:3: (forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (((exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_IntLoop(inc, actions))) or (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_VecLoop(ovs, actions)))) or (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_TimeLoop(time, actions)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2749:15: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 pre_(eval_InnerControl(inc)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2749:15: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 pre_(eval_InnerControl(inc)e))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2752:12: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(id, range):((Id * seq of (int)) | Errvalue) \u0026 (mk_(id, range) \u003d idrng))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2752:28: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e is_(idrng, (Id * seq of (int)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2755:29: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2755:29: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(update_env(id)mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {})))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2756:56: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 ((x.i) in set (inds range)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2758:15: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in pre_(eval_SeqIterate(actions)(new_env)x))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2758:15: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in pre_(eval_SeqIterate(actions)new_env))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2759:19: (forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in eval_SeqIterate(actions)(new_env)(x)) in pre_(NIterate(f, (len range))mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time)), 1))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2768:17: (forall inc:InnerControl, e:Env, ps:PState \u0026 (exists mk_OverRange(cnt, range):InnerControl \u0026 ((mk_OverRange(cnt, range) \u003d inc) \u003d\u003e let mk_OverRange(cnt, range) \u003d inc in pre_(eval_Range(range)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2771:18: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(from_b)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2771:18: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(from_b)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2772:18: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(to_b)(e)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2772:18: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(to_b)e)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2776:31: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((inc \u003d nil) \u003d\u003e is_(((b1.val).val), real)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2776:45: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((inc \u003d nil) \u003d\u003e is_(((b2.val).val), real)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2779:29: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e pre_(eval_Operation(inc)(e)ps)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2779:29: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e pre_(eval_Operation(inc)e)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2779:44: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e is_(inc, Operation)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2784:65: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v3, real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2784:58: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v2, real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2784:61: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v1, real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2786:29: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 (((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val)))) \u003d\u003e is_(((b1.val).val), real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2786:50: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 (((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val)))) \u003d\u003e is_((b3.val), real)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2787:65: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_((b3.val), real)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2787:42: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_(((b2.val).val), real)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2787:53: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_(((b1.val).val), real)))))))","non-zero obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2787:64: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e ((b3.val) \u003c\u003e 0)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2788:36: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_((b3.val), real))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2788:52: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_(((b2.val).val), real))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2788:65: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_(((b1.val).val), real))))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2766:3: (forall inc:InnerControl, e:Env, ps:PState \u0026 ((exists mk_OverRange(cnt, range):InnerControl \u0026 (inc \u003d mk_OverRange(cnt, range))) or (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 (inc \u003d mk_PartialRange(cnt, from_b, to_b, inc)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2763:1: (forall inc:InnerControl, e:Env, ps:PState \u0026 (is_((cases inc :\nmk_OverRange(cnt, range) -\u003e let r:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (r \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(cnt, [x | x in set r])),\nmk_PartialRange(cnt, from_b, to_b, inc) -\u003e let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen \u003cerr\u003e\nelse let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))\nthen \u003cerr\u003e\nelse let r:seq of (real) \u003d [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 ((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))\n end), (Id * seq of (int))) or is_((cases inc :\nmk_OverRange(cnt, range) -\u003e let r:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (r \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(cnt, [x | x in set r])),\nmk_PartialRange(cnt, from_b, to_b, inc) -\u003e let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen \u003cerr\u003e\nelse let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))\nthen \u003cerr\u003e\nelse let r:seq of (real) \u003d [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 ((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))\n end), Errvalue)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2796:24: (forall sequ:Sequence, e:Env, exi:EST_Iterate \u0026 ((not (((exi.expst).val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Sequence(sequ)(e)mk_PState(((exi.expst).sto), ((exi.expst).time)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2796:24: (forall sequ:Sequence, e:Env, exi:EST_Iterate \u0026 ((not (((exi.expst).val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Sequence(sequ)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2801:17: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)(e)ps))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2801:17: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)e))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2804:45: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set (inds indices) \u0026 (i in set (inds indices)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2808:24: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2809:20: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 is_([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)], seq of ((Id * Denotable_value))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2809:39: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 (forall i in set (inds indices) \u0026 (i in set (inds indices))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2814:27: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e pre_(update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))env)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2814:27: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e pre_(update_env((ovs.cnt))mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2814:38: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e is_((ovs.cnt), token)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2816:14: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in pre_(eval_SeqIterate(actions)(new_env)mu(x, expst |-\u003e new_expst)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2816:14: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in pre_(eval_SeqIterate(actions)new_env))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2817:25: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-\u003e new_expst))) in (1 in set (inds indices))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2818:19: (forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-\u003e new_expst))) in let mk_(-, v, -):(Id * Vector * Time) \u003d indices(1) in pre_(NIterate(f, (len (v.val)))mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), tplus((ps.time), time)), 1))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2826:11: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2827:11: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_Sequence(actions)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2827:11: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_Sequence(actions)e))","unique existence binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2831:18: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (exists1 n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2832:65: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall n:nat \u0026 is_(t, (nat * nat))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2833:72: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) \u003d\u003e is_(t, (nat * nat)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2835:14: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall exs:(unresolved DEFAULT`EST_value) \u0026 pre_(eval_Sequence(actions)(e)mk_PState((exs.sto), (exs.time)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2835:14: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall exs:(unresolved DEFAULT`EST_value) \u0026 pre_(eval_Sequence(actions)e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2836:13: (forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e let its:nat \u003d (iota n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))), f:(EST_value -\u003e EST_value) \u003d (lambda [exs:(unresolved DEFAULT`EST_value)] \u0026 eval_Sequence(actions)(e)(mk_PState((exs.sto), (exs.time)))) in pre_(Iterate(f, its)mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2843:29: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in pre_(eval_NvAssignment(ass)(env)ps))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2843:29: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in pre_(eval_NvAssignment(ass)env))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2843:47: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in is_(ass, NvAssignment))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2844:33: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in pre_(eval_MultAssignment(ass)(env)ps)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2844:33: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in pre_(eval_MultAssignment(ass)env)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2844:53: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in is_(ass, MultAssignment)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2845:30: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in pre_(eval_StrAssignment(ass)(env)ps))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2845:30: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in pre_(eval_StrAssignment(ass)env))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2845:49: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in is_(ass, StrAssignment))))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2842:3: (forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (((exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_NvAssignment(d, e))) or (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_MultAssignment(d, m, e)))) or (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_StrAssignment(d, e)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2850:11: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 pre_(access_env(dest)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2853:16: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(eval_Expression(expr)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2853:16: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(eval_Expression(expr)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2861:47: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e pre_(access(l)(ps.sto))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2861:54: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e is_(l, Location)))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2864:8: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e pre_(update(l)(mk_Storable_value(widen_type((x.val), (dest_val.type))))(ps.sto)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2864:8: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e pre_(update(l)mk_Storable_value(widen_type((x.val), (dest_val.type)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2864:15: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e is_(l, Location))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2864:36: (forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e ((((((is_(widen_type((x.val), (dest_val.type)), Int) or is_(widen_type((x.val), (dest_val.type)), Real)) or is_(widen_type((x.val), (dest_val.type)), Structure)) or is_(widen_type((x.val), (dest_val.type)), Tr)) or is_(widen_type((x.val), (dest_val.type)), Union)) or is_(widen_type((x.val), (dest_val.type)), Vector)) or is_(widen_type((x.val), (dest_val.type)), Void)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2871:11: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 pre_(access_env(dest)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2874:35: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(access(l)(ps.sto))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2874:42: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e is_(l, Location)))","value binding obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2877:17: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e (exists mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u0026 (mk_Vector(val, type) \u003d v)))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2877:39: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e is_(v, Vector))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2879:16: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in pre_(eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)e))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2879:16: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in pre_(eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))mult))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2880:21: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in pre_(eval_Expression(expr)(e)mk_PState((v\u0027.sto), (v\u0027.time))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2880:21: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in pre_(eval_Expression(expr)e))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2898:65: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in is_(vmid, Vector))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2899:39: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in (((is_(t_vector_concat, (nat * nat)) and is_(t_vector_concat, (nat * nat))) and is_(vector_subv, (nat * nat))) and is_(vector_subv, (nat * nat))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2902:33: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in pre_(update(l)(mk_Storable_value(new_vec))(ps.sto)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2902:33: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in pre_(update(l)mk_Storable_value(new_vec)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2902:40: (forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in is_(l, Location))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2907:13: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 (forall i in set (inds dest) \u0026 pre_(access_env(dest(i))e)))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2907:24: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 (forall i in set (inds dest) \u0026 (i in set (inds dest))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2910:16: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e pre_(eval_Expression(expr)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2910:16: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e pre_(eval_Expression(expr)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2915:27: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 pre_(access(ls(i))(ps.sto)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2915:34: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 is_(ls(i), Location))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2915:34: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 (i in set (inds ls)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2917:53: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in (forall i in set (inds nvals) \u0026 (i in set (inds nvals)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2919:30: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in (forall i in set (inds vals) \u0026 (i in set (inds vals)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2920:26: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in (forall i in set (inds (((x.val).type).tps)) \u0026 (i in set (inds (((x.val).type).tps))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2921:55: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (forall i in set (inds dest_tps) \u0026 (i in set (inds dest_tps)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2921:67: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (forall i in set (inds dest_tps) \u0026 (i in set (inds x_tps)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2923:59: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (is_(((x.val).val)(i), bool) or is_(((x.val).val)(i), real))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2923:59: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (i in set (inds ((x.val).val)))))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2924:33: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (i in set (inds (((x.val).type).tps)))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2923:46: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 ((((((is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Int) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Real)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Structure)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Tr)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Union)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Vector)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Void))))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2928:21: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_(multi_update(ls)(ys)(ps.sto)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2928:21: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_(multi_update(ls)ys))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2928:21: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_multi_update(ls))))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2928:34: (forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in is_(ls, seq of (Location)))))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2934:8: (forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 (is_(texpr, TimeTakes) \u003d\u003e pre_(eval_TimeTakes(texpr)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2934:8: (forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 (is_(texpr, TimeTakes) \u003d\u003e pre_(eval_TimeTakes(texpr)e)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2935:8: (forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e pre_(eval_TimeAssertion(texpr)(e)ps)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2935:8: (forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e pre_(eval_TimeAssertion(texpr)e)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2935:27: (forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e is_(texpr, TimeAssertion)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2939:11: (forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2939:11: (forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2940:11: (forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2949:15: (forall time:TimeInterval, e:Env \u0026 pre_(eval_Range(time)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2950:23: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not (range \u003d \u003cerr\u003e)) \u003d\u003e pre_min(range)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2950:27: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not (range \u003d \u003cerr\u003e)) \u003d\u003e is_(range, set of (real))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2952:12: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e pre_min(range)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2952:16: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e is_(range, set of (real))))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2952:23: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e pre_max(range)))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2952:27: (forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e is_(range, set of (real))))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2947:1: (forall time:TimeInterval, e:Env \u0026 (is_(let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in (if ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))\nthen \u003cerr\u003e\nelse mk_(min(range), max(range))), Errvalue) or is_(let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in (if ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))\nthen \u003cerr\u003e\nelse mk_(min(range), max(range))), Time)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2956:11: (forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2956:11: (forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2957:11: (forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","type compatibility obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2961:36: (forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(mu(ps, time |-\u003e zerot)), t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e) in ((not (((x.val) \u003d \u003cerr\u003e) or (t \u003d \u003cerr\u003e))) \u003d\u003e (timeleq(t, (x.time)) \u003d\u003e is_(t, (nat * nat)))))","function compose obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2971:10: (forall f:(EST_value -\u003e EST_value), n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003d 1)) \u003d\u003e (forall arg1:EST_value \u0026 (pre_(Iterate(f, (n - 1))arg1) \u003d\u003e pre_(fIterate(f, (n - 1))(arg1)))))))","function compose obligation in \u0027DEFAULT\u0027 (newspeak.vdmsl) at line 2980:10: (forall f:(EST_Iterate -\u003e EST_Iterate), n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003d 1)) \u003d\u003e (forall arg1:EST_Iterate \u0026 (pre_(NIterate(f, (n - 1))arg1) \u003d\u003e pre_(fNIterate(f, (n - 1))(arg1)))))))"]