["map compatible obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 32:14: (forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 ((forall id in set ((dom b) inter (dom bind)) \u0026 (b(id) \u003d bind(id))) \u003d\u003e (forall ldom1 in set (dom b), rdom2 in set (dom bind) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (b(ldom1) \u003d bind(rdom2)))))))","legal map application obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 35:14: (forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 (forall id in set ((dom b) inter (dom bind)) \u0026 (id in set (dom b)))))","legal map application obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 35:22: (forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 (forall id in set ((dom b) inter (dom bind)) \u0026 (id in set (dom bind)))))","function establishes postcondition obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 48:3: (forall s:set of (VAL) \u0026 post_SetToSeq(s, (if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ SetToSeq((s \\ {e}))))))","let be st existence obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 52:14: (forall s:set of (VAL) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","legal sequence application obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 67:30: (forall l:seq of (VAL) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (VAL) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (forall j in set Permute(RestSeq(l, i)) \u0026 (i in set (inds l)))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 73:7: (forall l:seq of (VAL), i:nat1 \u0026 (forall j in set ((inds l) \\ {i}) \u0026 (j in set (inds l))))","cases exhaustive obligation in \u0027DEFAULT\u0027 (auxil.vdmsl) at line 81:5: (forall pat:Pattern \u0026 ((((exists mk_PatternName(mk_(nm, pos)):Pattern \u0026 (pat \u003d mk_PatternName(mk_(nm, pos)))) or (exists mk_MatchVal(-):Pattern \u0026 (pat \u003d mk_MatchVal(any1)))) or (exists mk_SetEnumPattern(els):Pattern \u0026 (pat \u003d mk_SetEnumPattern(els)))) or (exists mk_SetUnionPattern(lp, rp):Pattern \u0026 (pat \u003d mk_SetUnionPattern(lp, rp)))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 85:39: (forall mk_LetBeSTExpr(lhs, st_e, in_e):LetBeSTExpr, oldstate:Sigma \u0026 (true \u003d\u003e (forall ldom1 in set (dom m2), rdom2 in set (dom m) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m2(ldom1) \u003d m(rdom2))))))","while loop termination obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 142:9: ...","non-empty sequence obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 143:41: (forall mk_CasesExpr(sel, altns, Others):CasesExpr, oldstate:Sigma \u0026 (alt_l \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 153:18: (forall mk_CasesExpr(sel, altns, Others):CasesExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (alt_l \u003c\u003e []))))","operation call obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 177:12: (forall mk_BinaryExpr(left_e, opr, right_e):BinaryExpr, oldstate:Sigma \u0026 (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, SET)))","operation call obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 180:12: (forall mk_BinaryExpr(left_e, opr, right_e):BinaryExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 196:49: (forall l_lv:LVAL, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, SET)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 205:50: (forall l_lv:LVAL, r_lv:LVAL, oldstate:Sigma \u0026 (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2)))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 214:65: (forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 215:65: (forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 216:65: (forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","legal sequence application obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 231:70: (forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (1 in set (inds els)))","legal sequence application obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 234:41: (forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (index in set (inds els)))","map compatible obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 235:40: (forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 ((forall id in set ((dom m) inter (dom m2)) \u0026 (m(id) \u003d m2(id))) \u003d\u003e (forall ldom1 in set (dom m), rdom2 in set (dom m2) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m(ldom1) \u003d m2(rdom2)))))))","legal map application obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 238:13: (forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 (forall id in set ((dom m) inter (dom m2)) \u0026 (id in set (dom m)))))","legal map application obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 238:21: (forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 (forall id in set ((dom m) inter (dom m2)) \u0026 (id in set (dom m2)))))","operation call obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 269:12: (forall mk_ApplyExpr(fct_e, arg_e):ApplyExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (curfn \u003c\u003e []))))))","type compatibility obligation in \u0027DEFAULT\u0027 (expr.vdmsl) at line 296:26: (forall lit:Literal, oldstate:Sigma \u0026 ((not is_(lit, NumLit)) \u003d\u003e is_((lit.val), bool)))","value binding obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 15:41: (forall pat_p:Pattern, val_v:VAL, oldstate:Sigma \u0026 (exists mk_PatternName(id):Pattern \u0026 (mk_PatternName(id) \u003d pat_p)))","type compatibility obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 15:62: (forall pat_p:Pattern, val_v:VAL, oldstate:Sigma \u0026 is_(pat_p, PatternName))","legal sequence application obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 105:30: (forall els_lp:seq of (Pattern), val_lv:seq of (VAL), oldstate:Sigma \u0026 (forall i in set (inds els_lp) \u0026 (i in set (inds els_lp))))","legal sequence application obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 105:41: (forall els_lp:seq of (Pattern), val_lv:seq of (VAL), oldstate:Sigma \u0026 (forall i in set (inds els_lp) \u0026 (i in set (inds val_lv))))","while loop termination obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 136:3: ...","non-empty sequence obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 137:28: (forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 138:49: (forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 140:22: (forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (pat.vdmsl) at line 158:1: (forall mk_SetBind(pat_p, set_e):SetBind, oldstate:Sigma \u0026 is_(RESULT, set of ((BlkEnv * Model))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 159:18: (forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 (forall m1, m2 in set {{id |-\u003e {mk_(Look(env, id), model) | env in set env_s}} | id in set (dinter {SelDom(env) | env in set env_s})} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal function application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 159:31: (forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 (forall id in set (dinter {SelDom(env) | env in set env_s}) \u0026 (forall env in set env_s \u0026 pre_Look(env, id))))","non-empty set obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 160:33: (forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 ({SelDom(env) | env in set env_s} \u003c\u003e {}))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 172:13: (forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall m1, m2 in set {{nm |-\u003e mk_((fn_marg(nm).pat), (fn_marg(nm).body))} | nm in set (dom fn_marg)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 172:25: (forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall nm in set (dom fn_marg) \u0026 (nm in set (dom fn_marg))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 172:41: (forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall nm in set (dom fn_marg) \u0026 (nm in set (dom fn_marg))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 182:17: ((curfn \u003c\u003e []) \u003d\u003e (curfn \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 199:17: (env_l \u003c\u003e [])","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 203:15: (env_l \u003c\u003e [])","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 211:22: (env_l \u003c\u003e [])","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 211:19: ((hd env_l) \u003c\u003e [])","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 211:35: (env_l \u003c\u003e [])","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 215:30: (forall benv:BlkEnv, oldstate:Sigma \u0026 (env_l \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 215:43: (forall benv:BlkEnv, oldstate:Sigma \u0026 (env_l \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 235:20: (curfn \u003c\u003e [])","map compatible obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 254:26: (forall nm:Name, oldstate:Sigma \u0026 (forall mk_(v, m) in set val_m(id) \u0026 (forall ldom1 in set (dom m), rdom2 in set (dom {id |-\u003e v}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m(ldom1) \u003d {id |-\u003e v}(rdom2))))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 254:65: (forall nm:Name, oldstate:Sigma \u0026 (id in set (dom val_m)))","type compatibility obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 250:3: (forall nm:Name, oldstate:Sigma \u0026 is_(RESULT, set of ((VAL * Model))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 259:12: (forall nm:Name, oldstate:Sigma \u0026 ((nm in set (dom fn_m)) \u003d\u003e (nm in set (dom fn_m))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 280:31: (forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e (env \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 284:13: (forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e let mk_(nm, val):NameVal \u003d (hd env) in ((not (nm \u003d id)) \u003d\u003e pre_Look((tl env), id)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 284:21: (forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e let mk_(nm, val):NameVal \u003d (hd env) in ((not (nm \u003d id)) \u003d\u003e (env \u003c\u003e [])))))","comprehension map injectivity obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 290:14: (forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall m1, m2 in set {{id |-\u003e (if (id in set (dom val_m))\nthen (val_m(id) union upd_m(id))\nelse upd_m(id))} | id in set (dom upd_m)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 291:27: (forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((id in set (dom val_m)) \u003d\u003e (id in set (dom val_m)))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 291:43: (forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((id in set (dom val_m)) \u003d\u003e (id in set (dom upd_m)))))","legal map application obligation in \u0027DEFAULT\u0027 (env.vdmsl) at line 292:19: (forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((not (id in set (dom val_m))) \u003d\u003e (id in set (dom upd_m)))))"]