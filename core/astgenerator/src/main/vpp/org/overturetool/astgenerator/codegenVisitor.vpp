

\begin{vdm_al}
class codegenVisitor is subclass of AstVisitor

values
  nl : seq of char = "\n";
  digits : seq of char = "0123456789"

instance variables
  files : map nat to FileWriter := {|->};

  IntegerStr : seq of char := "Integer"

operations
  public nat2str: nat ==> seq of char
  nat2str (pval) ==
    if pval <= 9
    then return [digits(pval+1)]
    else return nat2str(pval div 10) ^ nat2str(pval mod 10);

  public setLong: () ==> ()
  setLong () == IntegerStr := "Long";

  -- createFile will be hand coded in Java
  createFile: seq of seq of char ==> nat
  createFile (-) == return 0;

  -- printFile will be hand coded in Java
  printFile: nat * seq of char ==> ()
  printFile (-,-) == skip;

  -- closeFiles will be hand coded in Java
  closeFiles: () ==> ()
  closeFiles () == skip;

  -- createDirectory will be hand coded in Java
  createDirectory: seq of char * seq of seq of char ==> bool
  createDirectory (-,-) == return true;

  createInterfaces: AstDefinitions  ==> ()
  createInterfaces (ad) ==
    ( print ("Creating interfaces...");
      def base = ad.getDirectory() in
      def root = ["src"] ^ ad.getRawPackage() ^ ["itf"] in
      if createDirectory(base, root)
      then createInterface(ad,[base]^root) );

  createInterface: AstDefinitions * seq of seq of char ==> ()
  createInterface (ad, path) ==
    def docnm = "I" ^ad.getPrefix()^"Document" in
    def lexnm = "I" ^ad.getPrefix()^"Lexem" in
    def basenm = "I" ^ad.getPrefix()^ "Node" in
    def basevisit = "I" ^ad.getPrefix()^ "Visitor" in
    def baseinfo = "I" ^ad.getPrefix()^ "ContextInfo" in
      ( -- the document interface
        dcl fid : nat := createFile(path ^ [docnm^".java"]);
        print ("Creating document, lexem, base class and visitor interfaces...");
        if fid >= 0 then createDocumentInterface(ad,fid,docnm);
        -- the base node interface
        fid := createFile(path ^ [basenm^".java"]);
        if fid >= 0 then createBaseNode(ad,fid,basenm);
        -- the base visitor interface
        fid := createFile(path ^ [basevisit^".java"]);
        if fid >= 0 then createBaseVisit(ad,fid,basevisit);
        -- the context info interface
        fid := createFile(path ^ [baseinfo^".java"]);
        if fid >= 0 then createContextInfo(ad,fid,baseinfo);
        -- the lexem interface
        fid := createFile(path ^ [lexnm^".java"]);
        if fid >= 0 then createLexemInterface(ad,fid,lexnm);
        print ("Creating composites...");
        for all composite in set ad.getComposites() do
          def clnm = "I" ^ad.getPrefix()^ composite in
           ( fid := createFile(path ^ [clnm ^ ".java"]);
             if fid >= 0 then createDefInt(ad, ad.getComposite(composite), fid) );
        print ("Creating shorthands...");
        for all shorthand in set ad.getShorthands() do
          if ad.getShorthand(shorthand).getType().isUnionType() then
            def clnm = "I" ^ad.getPrefix()^ shorthand in
              ( fid := createFile(path ^ [clnm ^ ".java"]);
                if fid >= 0 then createShInt(ad, ad.getShorthand(shorthand), path, fid) ) );

  createLexemInterface: AstDefinitions * nat * seq of char ==> ()
  createLexemInterface (ad, fid, lexnm) ==
    ( printFile (fid, createPackage(ad,"itf") ^nl);
      printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
      printFile (fid, "public abstract interface " ^ lexnm ^ nl);
      printFile (fid, "{" ^ nl);
      printFile (fid, "\tLong ILEXEMUNKNOWN      = new Long(0);"^nl);
      printFile (fid, "\tLong ILEXEMKEYWORD      = new Long(1);"^nl);
      printFile (fid, "\tLong ILEXEMIDENTIFIER   = new Long(2);"^nl);
      printFile (fid, "\tLong ILEXEMLINECOMMENT  = new Long(3);"^nl);
      printFile (fid, "\tLong ILEXEMBLOCKCOMMENT = new Long(4);"^nl);
      printFile (fid, "\tabstract void accept(I"^ad.getPrefix()^"Visitor theVisitor) throws CGException;"^nl);
	  printFile (fid, "\tabstract Long getLine() throws CGException;"^nl);
	  printFile (fid, "\tabstract Long getColumn() throws CGException;"^nl);
	  printFile (fid, "\tabstract Long getLexval() throws CGException;"^nl);
	  printFile (fid, "\tabstract String getText() throws CGException;"^nl);
	  printFile (fid, "\tabstract Long getType() throws CGException;"^nl);
	  printFile (fid, "\tabstract Boolean isKeyword() throws CGException;"^nl);
	  printFile (fid, "\tabstract Boolean isIdentifier() throws CGException;"^nl);
	  printFile (fid, "\tabstract Boolean isComment() throws CGException;"^nl);
	  printFile (fid, "\tabstract Boolean isLineComment() throws CGException;"^nl);
	  printFile (fid, "\tabstract Boolean isBlockComment() throws CGException;"^nl);
      printFile (fid, "}" ^ nl ^ nl) );
    
  createDocumentInterface: AstDefinitions * nat * seq of char ==> ()
  createDocumentInterface (ad, fid, docnm) ==
    ( printFile (fid, createPackage(ad,"itf") ^ nl);
      printFile (fid, "import java.util.*;" ^ nl);
      printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
      printFile (fid, "public abstract interface " ^ docnm ^ nl);
      printFile (fid, "{" ^ nl);
      printFile (fid, "\tabstract String getFilename() throws CGException;" ^nl);
      for name in ad.getTop() do
        def pname = ad.getPrefix() ^ name in
          ( printFile (fid, "\tabstract Boolean has" ^name^ "() throws CGException;" ^nl);
            printFile (fid, "\tabstract I" ^pname^ " get" ^name^ "() throws CGException;" ^nl) );
      printFile (fid, "\tabstract Vector getLexems() throws CGException;" ^nl);
      -- printFile (fid, "\tabstract I" ^ad.getPrefix()^ "Lexem getLexem(Long) throws CGException;" ^nl);
      printFile (fid, "\tabstract String toVdmSlValue() throws CGException;" ^nl);
      printFile (fid, "\tabstract String toVdmPpValue() throws CGException;" ^nl);
      printFile (fid, "\tabstract void accept(I" ^ad.getPrefix()^ "Visitor theVisitor) throws CGException;" ^nl);
      printFile (fid, "}" ^ nl ^ nl) );
  
  createPackage: AstDefinitions * seq of char ==> seq of char
  createPackage (ad, str) ==
    def pack = ad.getPackage() in
    def name = if pack = [] then str else pack^"."^str in
    def rule = "package " ^name^ ";" ^nl in
      return rule;

  createBaseNode: AstDefinitions * nat * seq of char ==> ()
  createBaseNode (ad, fid, basenm) ==
    ( printFile (fid, createPackage(ad,"itf") ^ nl);
      printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
      printFile (fid, "public abstract interface " ^ basenm ^ nl);
      printFile (fid, "{" ^ nl);
      printFile (fid, "\tabstract String identity() throws CGException;" ^nl);
      printFile (fid, "\tabstract void accept(I" ^ad.getPrefix()^ "Visitor theVisitor) throws CGException;" ^nl);
      printFile (fid, "\tabstract "^IntegerStr^" getLine () throws CGException;"^nl);
      printFile (fid, "\tabstract "^IntegerStr^" getColumn () throws CGException;"^nl);
      printFile (fid, "\tabstract void setPosition("^IntegerStr^" iLine, "^IntegerStr^" iColumn) throws CGException;"^nl);
      printFile (fid, "\tabstract void setPosLexem(I"^ad.getPrefix()^"Lexem iLexem) throws CGException;"^nl);
      printFile (fid, "\tabstract void setPosNode(I"^ad.getPrefix()^"Node iNode) throws CGException;"^nl);
      printFile (fid, "}" ^ nl ^ nl) );

  createContextInfo: AstDefinitions * nat * seq of char ==> ()
  createContextInfo (ad, fid, basenm) ==
    ( printFile (fid, createPackage(ad,"itf") ^ nl);
      printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
      printFile (fid, "public abstract interface " ^ basenm ^ nl);
      printFile (fid, "{" ^ nl);
      printFile (fid, "\tabstract void accept(I" ^ad.getPrefix()^ "Visitor theVisitor) throws CGException;" ^nl);
      printFile (fid, "}" ^ nl ^ nl) );

  createBaseVisit: AstDefinitions * nat * seq of char ==> ()
  createBaseVisit (ad, fid, basenm) ==
    ( printFile (fid, createPackage(ad,"itf") ^ nl);
      printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
      printFile (fid, "public abstract interface " ^ basenm ^ nl);
      printFile (fid, "{" ^ nl);
      printFile (fid, "\tabstract void visitContextInfo(I" ^ad.getPrefix()^"ContextInfo theInfo) throws CGException;" ^nl);
      printFile (fid, "\tabstract void visitLexem(I" ^ad.getPrefix()^"Lexem theLexem) throws CGException;" ^nl);
      printFile (fid, "\tabstract void visitNode(I" ^ad.getPrefix()^"Node theNode) throws CGException;" ^nl);
      printFile (fid, "\tabstract void visitDocument(I" ^ad.getPrefix()^"Document theDocument) throws CGException;" ^nl);
      for all id in set ad.getComposites() do
        printFile (fid, "\tabstract void visit" ^id^ "(I" ^ad.getPrefix()^id^ " theNode) throws CGException;" ^nl);
      for all id in set ad.getShorthands() do
        if ad.getShorthand(id).getType().isUnionType()
        then printFile (fid, "\tabstract void visit" ^id^ "(I" ^ad.getPrefix()^id^ " theNode) throws CGException;" ^nl);
      printFile (fid, "}" ^ nl ^ nl) );

  createDefInt: AstDefinitions * AstComposite * nat ==> ()
  createDefInt (ad, composite, fid) ==
    def clnm = "I" ^ad.getPrefix()^ composite.getName() in
      ( printFile(fid, createPackage(ad,"itf") ^ nl);
        if composite.hasAdts()
        then printFile (fid, "import java.util.*;" ^ nl);
        if len composite.getFields() > 0
        then printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
        printFile(fid, "public abstract interface " ^ clnm);
        def base = "I" ^ad.getPrefix()^
           if ad.hasInherit(composite.getName())
           then ad.getInherit(composite.getName())
           else "Node" in
          printFile(fid, " extends " ^ base ^ nl);
        printFile(fid, "{" ^ nl);
        for field in composite.getFields() do
          ( dcl tp : seq of char := getJavaType(ad.getPrefix(), field.getType());
            printFile(fid,"\tabstract " ^ tp ^ " get" ^ field.getName() ^ "() throws CGException;" ^ nl);
            if field.getType().isOptionalType()
            then printFile(fid,"\tabstract Boolean has" ^ field.getName() ^ "() throws CGException;" ^ nl) );
        printFile(fid, "}" ^ nl ^ nl) );

  createShInt: AstDefinitions * AstShorthand * seq of seq of char * nat ==> ()
  createShInt (ad, shorthand, path, fid) ==
    def clnm = "I" ^ad.getPrefix()^ shorthand.getName() in
    def mk_(rb,rs) = shorthand.getType().isQuotedTypeUnion() in
      ( printFile(fid, createPackage(ad,"itf") ^ nl);
        if rb
        then printFile (fid, "import jp.co.csk.vdm.toolbox.VDM.*;" ^ nl ^ nl);
        printFile(fid, "public abstract interface " ^ clnm);
        def base = "I" ^ad.getPrefix()^
           if ad.hasInherit(shorthand.getName())
           then ad.getInherit(shorthand.getName())
           else "Node" in
        printFile(fid, " extends " ^ base ^ nl);
        printFile(fid, "{" ^ nl);
        if rb
        then ( createShQuotedTypeInt (ad, clnm, path, rs);
               printFile(fid,"\tabstract void setValue(" ^IntegerStr^" val) throws CGException;" ^nl);
               printFile(fid,"\tabstract " ^IntegerStr^ " getValue() throws CGException;" ^nl);
               printFile(fid,"\tabstract String getStringValue() throws CGException;" ^nl) );
        printFile(fid, "}" ^ nl ^ nl) );

  createShQuotedTypeInt: AstDefinitions * seq of char * seq of seq of char * set of seq of char ==> ()
  createShQuotedTypeInt (ad, shnm, path, qtnms) ==
    def clnm = shnm ^ "Quotes" in
      ( dcl fid : nat := createFile(path ^[clnm ^".java"]);
        if fid >= 0
        then ( dcl cnt : nat := 0;
               printFile(fid, createPackage(ad,"itf") ^nl^nl);
               printFile(fid, "public interface " ^clnm ^"{" ^nl);
               for all id in set qtnms do
                 ( printFile(fid, "  public final "^IntegerStr^" IQ" ^id ^" = new "^IntegerStr^"(" ^nat2str(cnt) ^");"^nl);
                   cnt := cnt + 1 );
               printFile(fid, "}"^nl) ) );

  getJavaType: seq of char * AstType ==> seq of char
  getJavaType (prefix, atp) ==
    if atp.isCharType() then return "Character"
    elseif atp.isBoolType() then return "Boolean"
    elseif atp.isNatType() then return IntegerStr
    elseif atp.isRealType() then return "Double"
    elseif atp.isStringType() then return "String"
    elseif atp.isTypeName() then
      ( dcl atpnm : AstTypeName := atp;
        return "I" ^prefix^ atpnm.getName() )
    elseif atp.isSeqType() then return "Vector"
    elseif atp.isSetType() then return "HashSet"
    elseif atp.isOptionalType() then
      ( dcl aotp : AstOptionalType := atp;
        return getJavaType(prefix,aotp.getType()) )
    elseif atp.isMapType() then return "HashMap"
    else error;

  getVdmType: seq of char * AstType ==> seq of char
  getVdmType (prefix, atp) ==
    if atp.isCharType() then return "char"
    elseif atp.isBoolType() then return "bool"
    elseif atp.isNatType() then return "nat"
    elseif atp.isRealType() then return "real"
    elseif atp.isStringType() then return "seq of char"
    elseif atp.isTypeName() then
      ( dcl atpnm : AstTypeName := atp;
        return "I"^prefix^atpnm.getName() )
    elseif atp.isSeqType() then
      ( dcl astp : AstSeqOfType := atp;
        return "seq of " ^ getVdmType(prefix,astp.getType()) )
    elseif atp.isSetType() then
      ( dcl astp : AstSetOfType := atp;
        return "set of " ^ getVdmType(prefix,astp.getType()) )
    elseif atp.isOptionalType() then
      ( dcl aotp : AstOptionalType := atp;
        return getVdmType(prefix,aotp.getType()) )
    elseif atp.isMapType() then
      ( dcl amtp : AstMapType := atp;
        return "map " ^getVdmType(prefix,amtp.getDomType())^
               " to " ^getVdmType(prefix,amtp.getRngType()) )
    else error;

  createSpecifications: AstDefinitions ==> ()
  createSpecifications (ad) ==
    def base = ad.getDirectory() in
    def root = ["src"] in
    if createDirectory(base,root)
    then createSpecification (ad, [base]^root);

  createSpecification: AstDefinitions * seq of seq of char ==> ()
  createSpecification (ad, path) ==
    def docnm = ad.getPrefix()^"Document" in
    def basenm = ad.getPrefix()^"Node" in
    def basevisit = ad.getPrefix()^"Visitor" in
    def lexnm = ad.getPrefix()^"Lexem" in
      ( dcl fid : nat := createFile(path ^ ["I"^docnm^".tex"]);
        print ("Creating document, lexem, base class and visitor interfaces...");
        -- create the document class
        if fid >= 0 then createVppIDocument(ad,fid,docnm);
        fid := createFile(path ^ [docnm^".tex"]);
        if fid >= 0 then createVppDocument(ad,fid,docnm);
        -- create the lexem class
        fid := createFile(path ^ ["I"^lexnm^".tex"]);
        if fid >= 0 then createVppILexem(ad,fid,lexnm);
        fid := createFile(path ^ [lexnm^".tex"]);
        if fid >= 0 then createVppLexem(ad,fid,lexnm);
        -- create the base class
        fid := createFile(path ^ [basenm^".tex"]);
        if fid >= 0 then createVppBaseNode(ad,fid,basenm);
        -- create the visitor interface
        fid := createFile(path ^ ["I" ^basevisit^".tex"]);
        if fid >= 0
        then createVppIBaseVisit(ad,fid,basevisit);
        -- create the visitor implementation
        fid := createFile(path ^ [basevisit^".tex"]);
        if fid >= 0
        then createVppBaseVisit(ad,fid,basevisit);
        -- now iterate over all the composites and shorthands
        print ("Creating specifications...");
        for all composite in set ad.getComposites() do
          def clnm = ad.getPrefix() ^ composite in
            ( -- create the interface
              fid := createFile(path ^ ["I" ^ clnm ^ ".tex"]);
              if fid >= 0
              then createDefISpec(ad, ad.getComposite(composite), clnm, fid);
              -- create the implementation
              fid := createFile(path ^ [clnm ^ ".tex"]);
              if fid >= 0
              then createDefSpec(ad, ad.getComposite(composite), clnm, fid) );
        print ("Creating shorthands...");
        for all shorthand in set ad.getShorthands() do
          if ad.getShorthand(shorthand).getType().isUnionType()
          then def clnm = ad.getPrefix() ^ shorthand in
            ( fid := createFile(path ^ ["I" ^ clnm ^ ".tex"]);
              if fid >= 0
              then createShISpec(ad, ad.getShorthand(shorthand), clnm, path, fid);
              fid := createFile(path ^ [clnm ^ ".tex"]);
              if fid >= 0
              then createShSpec(ad, ad.getShorthand(shorthand), clnm, path, fid) );
        print ("Creating visitors...");
        -- first the top-down VDM-SL visitor
        fid := createFile(path ^ ["VdmSlVisitor.tex"]);
        if fid >= 0 then createVdmVisitor(ad,fid,false);
        -- then the bottom-up VDM++ visitor
        fid := createFile(path ^ ["VdmPpVisitor.tex"]);
        if fid >= 0 then createVdmVisitor(ad,fid,true) );

  createVppIDocument: AstDefinitions * int * seq of char ==> ()
  createVppIDocument (ad, fid, docnm) ==
    ( printFile(fid,"\\begin{vdm_al}" ^nl);
      printFile(fid,"class I"^docnm^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getFilename: () ==> seq of char"^nl);
      printFile(fid,"  getFilename () == is subclass responsibility;"^nl^nl);
      for name in ad.getTop() do
        ( printFile(fid,"  public has"^name^": () ==> bool"^nl);
          printFile(fid,"  has"^name^" () == is subclass responsibility;"^nl^nl);
          printFile(fid,"  public get"^name^": () ==> I"^ad.getPrefix()^name^nl);
          printFile(fid,"  get"^name^" () == is subclass responsibility;"^nl^nl) );
      printFile(fid,"  public getLexems: () ==> seq of I"^ad.getPrefix()^"Lexem"^nl);
      printFile(fid,"  getLexems () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public toVdmSlValue: () ==> seq of char"^nl);
      printFile(fid,"  toVdmSlValue () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public toVdmPpValue: () ==> seq of char"^nl);
      printFile(fid,"  toVdmPpValue () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public accept: I"^ad.getPrefix()^"Visitor ==> ()"^nl);
      printFile(fid,"  accept (-) == is subclass responsibility"^nl^nl);
      printFile(fid,"end I"^docnm^nl);
      printFile(fid,"\\end{vdm_al}" ^nl) );
  
  createVppDocument: AstDefinitions * int * seq of char ==> ()
  createVppDocument (ad, fid, docnm) ==
    ( dcl pexpr : seq of char := [];
      printFile(fid,"\\begin{vdm_al}" ^nl);
      printFile(fid,"class "^docnm^" is subclass of I"^docnm^nl^nl);
      -- handle the file name
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivFilename : seq of char := []"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getFilename: () ==> seq of char"^nl);
      printFile(fid,"  getFilename () == return ivFilename;"^nl^nl);
      printFile(fid,"  public setFilename: seq of char ==> ()"^nl);
      printFile(fid,"  setFilename (pfilename) == ivFilename := pfilename;"^nl^nl);
      -- handle the top-level abstract syntax element
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivTopNode : [ I"^ad.getPrefix()^"Node ] := nil"^nl^nl);
      printFile(fid,"operations"^nl);
      for name in ad.getTop() do
        ( printFile(fid,"  public has"^name^": () ==> bool"^nl);
          printFile(fid,"  has"^name^" () == return isofclass(I"^ad.getPrefix()^name^",ivTopNode);"^nl^nl);
          printFile(fid,"  public get"^name^": () ==> I"^ad.getPrefix()^name^nl);
          printFile(fid,"  get"^name^" () == return ivTopNode"^nl);
          printFile(fid,"    pre has"^name^"();"^nl^nl);
          printFile(fid,"  public set"^name^": I"^ad.getPrefix()^name^" ==> ()"^nl);
          printFile(fid,"  set"^name^" (pNode) == ivTopNode := pNode"^nl);
          printFile(fid,"    pre ivTopNode = nil;"^nl^nl);
          -- compose the pre-condition for the constructor
          def str = "isofclass(I"^ad.getPrefix()^name^",pnode)" in
            if pexpr = []
            then pexpr := str
            else pexpr := pexpr ^ " or "^str );
      -- handle the lexems
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivLexems : seq of I"^ad.getPrefix()^"Lexem := []"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getLexems : () ==> seq of I"^ad.getPrefix()^"Lexem"^nl);
      printFile(fid,"  getLexems () == return ivLexems;"^nl^nl);
      printFile(fid,"  public setLexems : seq of I"^ad.getPrefix()^"Lexem ==> ()"^nl);
      printFile(fid,"  setLexems (plexems) == ivLexems := plexems;"^nl^nl);
      -- the visitor
      printFile(fid,"  public accept: I"^ad.getPrefix()^"Visitor ==> ()"^nl);
      printFile(fid,"  accept (pVisitor) == pVisitor.visitDocument(self);"^nl^nl);
      -- the pretty-print support routines
      printFile(fid,"  public toVdmSlValue: () ==> seq of char"^nl);
      printFile(fid,"  toVdmSlValue () =="^nl);
      printFile(fid,"    ( dcl visitor : VdmSlVisitor := new VdmSlVisitor();"^nl);
      printFile(fid,"      accept(visitor);"^nl);
      printFile(fid,"      return visitor.result );"^nl^nl);
      printFile(fid,"  public toVdmPpValue: () ==> seq of char"^nl);
      printFile(fid,"  toVdmPpValue () =="^nl);
      printFile(fid,"    ( dcl visitor : VdmPpVisitor := new VdmPpVisitor();"^nl);
      printFile(fid,"      accept(visitor);"^nl);
      printFile(fid,"      return visitor.result );"^nl^nl);
      -- the constructor
      def pfx = ad.getPrefix() in
        ( printFile(fid,"  public "^docnm^": seq of char * I"^pfx^"Node * seq of I"^ad.getPrefix()^"Lexem ==> "^docnm^nl);
          printFile(fid,"  "^docnm^" (pfilename, pnode, plexems) =="^nl);
          printFile(fid,"    ( setFilename(pfilename);"^nl);
          printFile(fid,"      ivTopNode := pnode;"^nl);
          printFile(fid,"      setLexems(plexems) )"^nl);
          printFile(fid,"    pre "^pexpr^nl^nl) );
      printFile(fid,"end "^docnm^nl);
      printFile(fid,"\\end{vdm_al}" ^nl) );
  
  createVppILexem: AstDefinitions * int * seq of char ==> ()
  createVppILexem (ad, fid, lexnm) ==
    ( printFile(fid,"\\begin{vdm_al}" ^nl);
      printFile(fid,"class I"^lexnm^nl^nl);
      printFile(fid,"values"^nl);
      printFile(fid,"  static public ILEXEMUNKNOWN      : nat = 0;"^nl);
      printFile(fid,"  static public ILEXEMKEYWORD      : nat = 1;"^nl);
      printFile(fid,"  static public ILEXEMIDENTIFIER   : nat = 2;"^nl);
      printFile(fid,"  static public ILEXEMLINECOMMENT  : nat = 3;"^nl);
      printFile(fid,"  static public ILEXEMBLOCKCOMMENT : nat = 4"^nl^nl);
      printFile(fid,"operations"^nl);
	  printFile(fid,"  public accept: I"^ad.getPrefix()^"Visitor ==> ()"^nl);
	  printFile(fid,"  accept (-) == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public getLine: () ==> nat"^nl);
      printFile(fid,"  getLine () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public getColumn: () ==> nat"^nl);
      printFile(fid,"  getColumn () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public getLexval: () ==> nat"^nl);
      printFile(fid,"  getLexval () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public getText: () ==> seq of char"^nl);
      printFile(fid,"  getText () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public getType: () ==> nat"^nl);
      printFile(fid,"  getType () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public isKeyword: () ==> bool"^nl);
      printFile(fid,"  isKeyword () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public isIdentifier: () ==> bool"^nl);
      printFile(fid,"  isIdentifier () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public isComment: () ==> bool"^nl);
      printFile(fid,"  isComment () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public isLineComment: () ==> bool"^nl);
      printFile(fid,"  isLineComment () == is subclass responsibility;"^nl^nl);
      printFile(fid,"  public isBlockComment: () ==> bool"^nl);
      printFile(fid,"  isBlockComment () == is subclass responsibility;"^nl^nl);
      printFile(fid,"end I"^lexnm^nl);
      printFile(fid,"\\end{vdm_al}" ^nl) );
  
  createVppLexem: AstDefinitions * int * seq of char ==> ()
  createVppLexem (ad, fid, lexnm) ==
    ( printFile(fid,"\\begin{vdm_al}" ^nl);
      printFile(fid,"class "^lexnm^" is subclass of I"^lexnm^nl^nl);
      -- line number
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivLine : nat := 0"^nl^nl);
      printFile(fid,"operations"^nl);
	  printFile(fid,"  public accept: I"^ad.getPrefix()^"Visitor ==> ()"^nl);
	  printFile(fid,"  accept (pVisitor) == pVisitor.visitLexem(self);"^nl^nl);
      printFile(fid,"  public getLine: () ==> nat"^nl);
      printFile(fid,"  getLine () == return ivLine;"^nl^nl);
      printFile(fid,"  public setLine: nat ==> ()"^nl);
      printFile(fid,"  setLine (pline) == ivLine := pline"^nl^nl);
      -- column number
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivColumn : nat := 0"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getColumn: () ==> nat"^nl);
      printFile(fid,"  getColumn () == return ivColumn;"^nl^nl);
      printFile(fid,"  public setColumn: nat ==> ()"^nl);
      printFile(fid,"  setColumn (pcolumn) == ivColumn := pcolumn"^nl^nl);
      -- lexical value
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivLexval : nat := 0"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getLexval: () ==> nat"^nl);
      printFile(fid,"  getLexval () == return ivLexval;"^nl^nl);
      printFile(fid,"  public setLexval: nat ==> ()"^nl);
      printFile(fid,"  setLexval (plexval) == ivLexval := plexval"^nl^nl);
      -- text value
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivText : seq of char := []"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getText: () ==> seq of char"^nl);
      printFile(fid,"  getText () == return ivText;"^nl^nl);
      printFile(fid,"  public setText: seq of char ==> ()"^nl);
      printFile(fid,"  setText (ptext) == ivText := ptext"^nl^nl);
      -- the type of lexem
      printFile(fid,"instance variables"^nl);
      printFile(fid,"  private ivType : nat := ILEXEMUNKNOWN"^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  public getType: () ==> nat"^nl);
      printFile(fid,"  getType () == return ivType;"^nl^nl);
      printFile(fid,"  public isKeyword: () ==> bool"^nl);
      printFile(fid,"  isKeyword () == return ivType = ILEXEMKEYWORD;"^nl^nl);
      printFile(fid,"  public isIdentifier: () ==> bool"^nl);
      printFile(fid,"  isIdentifier () == return ivType = ILEXEMIDENTIFIER;"^nl^nl);
      printFile(fid,"  public isComment: () ==> bool"^nl);
      printFile(fid,"  isComment () == return (ivType = ILEXEMLINECOMMENT) or (ivType = ILEXEMBLOCKCOMMENT);"^nl^nl);
      printFile(fid,"  public isLineComment: () ==> bool"^nl);
      printFile(fid,"  isLineComment () == return ivType = ILEXEMLINECOMMENT;"^nl^nl);
      printFile(fid,"  public isBlockComment: () ==> bool"^nl);
      printFile(fid,"  isBlockComment () == return ivType = ILEXEMBLOCKCOMMENT;"^nl^nl);
      -- the lexem constructor
      printFile(fid,"  public "^lexnm^": nat * nat * nat * seq of char * nat ==> "^lexnm^nl);
      printFile(fid,"  "^lexnm^" (pline, pcolumn, plexval, ptext, ptype) =="^nl);
      printFile(fid,"    ( ivLine := pline;"^nl);
      printFile(fid,"      ivColumn := pcolumn;"^nl);
      printFile(fid,"      ivLexval := plexval;"^nl);
      printFile(fid,"      ivText := ptext;"^nl);
      printFile(fid,"      ivType := ptype )"^nl^nl);
      printFile(fid,"end "^lexnm^nl);
      printFile(fid,"\\end{vdm_al}" ^nl) );
  
  createVdmVisitor: AstDefinitions * int * bool ==> ()
  createVdmVisitor (ad, fid, vpp) ==
    ( printFile(fid,"\\begin{vdm_al}" ^nl);
      if not vpp
      then printFile(fid,"class VdmSlVisitor is subclass of " ^ad.getPrefix() ^"Visitor" ^nl^nl)
      else printFile(fid,"class VdmPpVisitor is subclass of " ^ad.getPrefix() ^"Visitor" ^nl^nl);
      printFile(fid,"values" ^nl);
      printFile(fid,"  private nl : seq of char = \"\\r\\n\";"^nl);
      if not vpp
      then printFile(fid,"  private prefix : seq of char = \"mk_ \""^nl^nl)
      else printFile(fid,"  private prefix : seq of char = \"new "^ad.getPrefix()^"\""^nl^nl);
      printFile(fid,"instance variables" ^nl);
      printFile(fid,"  public result : seq of char := [];" ^nl);
      printFile(fid,"  private lvl : nat := 0" ^nl^nl);
      printFile(fid,"operations"^nl);
      printFile(fid,"  private pushNL: () ==> ()" ^nl);
      printFile(fid,"  pushNL () == lvl := lvl + 2;" ^nl^nl);
      printFile(fid,"  private popNL: () ==> ()" ^nl);
      printFile(fid,"  popNL () == lvl := lvl - 2;" ^nl^nl);
      printFile(fid,"  private getNL: () ==> seq of char" ^nl);
      printFile(fid,"  getNL () ==" ^nl);
      printFile(fid,"    ( dcl res : seq of char := nl, cnt : nat := lvl;" ^nl);
      printFile(fid,"      while cnt > 0 do ( res := res ^\" \"; cnt := cnt - 1 );" ^nl);
      printFile(fid,"      return res );" ^nl^nl);
      createVdmSlFieldVisitors(ad,fid,vpp);
      printFile(fid,"  public visitNode: I" ^ad.getPrefix()^ "Node ==> ()" ^nl);
      printFile(fid,"  visitNode (pNode) == pNode.accept(self);" ^nl^nl);
      createVdmDocLexemVisitors(ad,fid,vpp);
      for all composite in set ad.getComposites() do
        def clnm = ad.getPrefix() ^ composite in
          ( dcl cmp : AstComposite := ad.getComposite(composite), cnt : nat := 1;
            printFile(fid,"  public visit" ^composite^ ": I" ^clnm^ " ==> ()" ^nl);
            printFile(fid,"  visit" ^composite^ "(pcmp) ==" ^nl);
            printFile(fid,"    ( dcl str : seq of char := prefix ^pcmp.identity() ^\"(\";" ^nl);
            if len cmp.getFields() > 1
            then ( printFile(fid,"      pushNL();" ^nl);
                   printFile(fid,"      str := str ^getNL();" ^nl) );
            while cnt <= len cmp.getFields() do
              ( dcl fld : AstField := cmp.getFields()(cnt),
                    ostr : seq of char := getVdmSlFieldOper(fld.getType());
                if fld.getType().isOptionalType()
                then ( dcl aotp : AstOptionalType := fld.getType();
                       printFile(fid,"      if pcmp.has" ^fld.getName() ^"()" ^nl);
                       printFile(fid,"      then " ^ostr^"(pcmp.get" ^fld.getName() ^"())" ^nl);
                       printFile(fid,"      else result := \"nil\";"^nl) )
                else printFile(fid,"      "^ostr^"(pcmp.get" ^fld.getName() ^"());"^nl);
                printFile(fid,"      str := str ^result");
                if cnt < len cmp.getFields() or vpp
                then ( if len cmp.getFields() = 1
                       then printFile(fid," ^\",\";"^nl)
                       else printFile(fid," ^\",\" ^getNL();"^nl) )
                else printFile(fid,";"^nl);
                cnt := cnt + 1 );
            -- position info
            if vpp
            then ( printFile(fid,"      printNatField(pcmp.getLine());"^nl);
                   printFile(fid,"      str := str ^result ^\",\"");
                   if len cmp.getFields() > 1
                   then printFile(fid," ^getNL();"^nl)
                   else printFile(fid,";"^nl);
                   printFile(fid,"      printNatField(pcmp.getColumn());"^nl);
                   printFile(fid,"      str := str ^result;"^nl)
                    );
            if len cmp.getFields() > 1
            then ( printFile(fid,"      popNL();" ^nl);
                   printFile(fid,"      str := str ^getNL() ^\")\";" ^nl) )
            else ( printFile(fid,"      str := str ^\")\";" ^nl) );
            printFile(fid,"      result := str );" ^nl^nl) );
      for all shorthand in set ad.getUnionShorthands() do
        def mk_(sb,-) = ad.getShorthand(shorthand).getType().isTypeNameUnion() in
        def shnm = ad.getPrefix()^shorthand in
          if sb
          then ( printFile(fid,"  public visit"^shorthand^": I"^shnm^" ==> ()"^nl);
                 printFile(fid,"  visit"^shorthand^"(pNode) == pNode.accept(self);"^nl^nl) )
          else ( printFile(fid,"  public visit"^shorthand^": I"^shnm^" ==> ()"^nl);
                 printFile(fid,"  visit"^shorthand^"(pNode) == ");
                 if not vpp
                 then printFile(fid, "result := pNode.getStringValue();"^nl^nl)
                 else ( printFile(fid, nl ^"    ( dcl str : seq of char := prefix ^pNode.identity() ^\"(\";" ^nl);
                        printFile(fid,     "      printNatField(pNode.getValue());" ^nl);
                        printFile(fid,     "      str := str ^ result ^ \",\";" ^nl);
                        printFile(fid,     "      printNatField(pNode.getLine());" ^nl);
                        printFile(fid,     "      str := str ^ result ^ \",\";" ^nl);
                        printFile(fid,     "      printNatField(pNode.getColumn());" ^nl);
                        printFile(fid,     "      str := str ^ result ^ \")\";" ^nl);
                        printFile(fid,     "      result := str );" ^nl^nl) ) );
      if not vpp
      then printFile(fid,"end VdmSlVisitor" ^nl)
      else printFile(fid,"end VdmPpVisitor" ^nl);
      printFile(fid,"\\end{vdm_al}" ^nl) );

  createVdmSlFieldVisitors: AstDefinitions * int * bool ==> ()
  createVdmSlFieldVisitors (ad,fid,vpp) ==
    def node = "I"^ad.getPrefix()^"Node" in
    def fval = node^"`FieldValue" in
      ( printFile (fid,"  private printBoolField: bool ==> ()" ^nl);
        printFile (fid,"  printBoolField (pval) ==" ^nl);
        printFile (fid,"    result := if pval then \"true\" else \"false\";" ^nl^nl);

        printFile (fid,"  private printCharField: char ==> ()" ^nl);
        printFile (fid,"  printCharField (pval) ==" ^nl);
        printFile (fid,"    result := [''',pval,'''];" ^nl^nl);

        printFile (fid,"  private printNatField: nat ==> ()" ^nl);
        printFile (fid,"  -- implement this operation by hand!" ^nl);
        printFile (fid,"  printNatField (-) == error;" ^nl^nl);

        printFile (fid,"  private printRealField: real ==> ()" ^nl);
        printFile (fid,"  -- implement this operation by hand!" ^nl);
        printFile (fid,"  printRealField (-) == error;" ^nl^nl);

        printFile (fid,"  private printNodeField: " ^node^ " ==> ()" ^nl);
        printFile (fid,"  printNodeField (pNode) == pNode.accept(self);" ^nl^nl);

        printFile (fid,"  private patchString: seq of char ==> seq of char" ^nl);
        printFile (fid,"  patchString (str) =="^nl);
        printFile (fid,"   ( dcl res : seq of char := [];"^nl);
        printFile (fid,"     for ch in str do"^nl);
        printFile (fid,"       if ch = '\\\\' then res := res ^ \"\\\\\\\\\""^nl);
        printFile (fid,"       else if ch = '\\\"' then res := res ^ \"\\\\\\\"\""^nl);
        printFile (fid,"       else res := res ^ [ch];"^nl);
        printFile (fid,"     return res );"^nl^nl);
        
        printFile (fid,"  private printStringField: seq of char ==> ()" ^nl);
        printFile (fid,"  printStringField (str) == result := \"\\\"\" ^ patchString(str) ^ \"\\\"\";" ^nl^nl);

        printFile (fid,"  private printSeqofField: seq of " ^fval^ " ==> ()" ^nl);
        printFile (fid,"  printSeqofField (pval) ==" ^nl);
        printFile (fid,"    ( dcl str : seq of char := \"[\", cnt : nat := len pval;" ^nl);
        printFile (fid,"      pushNL();" ^nl);
        printFile (fid,"      str := str ^ getNL();" ^nl);
        printFile (fid,"      while cnt > 0 do" ^nl);
        printFile (fid,"        ( printField(pval(len pval - cnt + 1));" ^nl);
        printFile (fid,"          str := str ^ result;" ^nl);
        printFile (fid,"          if cnt > 1" ^nl);
        printFile (fid,"          then str := str ^ \",\" ^ getNL();" ^nl);
        printFile (fid,"          cnt := cnt - 1 ); "^nl);
        printFile (fid,"      popNL();" ^nl);
        printFile (fid,"      str := str ^ getNL() ^ \"]\";" ^nl);
        printFile (fid,"      result := str );" ^nl^nl);

        printFile (fid,"  private printSetofField: set of " ^fval^ " ==> ()" ^nl);
        printFile (fid,"  printSetofField (pval) ==" ^nl);
        printFile (fid,"    ( dcl str : seq of char := \"{\", cnt : nat := card pval,"^nl);
        printFile (fid,"          pvs : set of "^fval^" := pval;" ^nl);
        printFile (fid,"      pushNL();" ^nl);
        printFile (fid,"      str := str ^ getNL();" ^nl);
        printFile (fid,"      while cnt > 0 do" ^nl);
        printFile (fid,"        let pv in set pvs in"^nl);
        printFile (fid,"          ( printField(pv);" ^nl);
        printFile (fid,"            str := str ^ result;" ^nl);
        printFile (fid,"            pvs := pvs \\ {pv};" ^nl);
        printFile (fid,"            if cnt > 1" ^nl);
        printFile (fid,"            then str := str ^ \",\" ^ getNL();" ^nl);
        printFile (fid,"            cnt := cnt - 1 ); "^nl);
        printFile (fid,"      popNL();" ^nl);
        printFile (fid,"      str := str ^ getNL() ^ \"}\";" ^nl);
        printFile (fid,"      result := str );" ^nl^nl);


        printFile (fid,"  private printMapField: map " ^fval^ " to " ^fval^ " ==> ()" ^nl);
        printFile (fid,"  printMapField (pval) == " ^nl);
        printFile (fid,"    ( dcl str : seq of char := \"{\", cnt : nat := card dom pval,"^nl);
        printFile (fid,"          pvs : set of "^fval^" := dom pval;" ^nl);
        printFile (fid,"      pushNL();" ^nl);
        printFile (fid,"      str := str ^ getNL();" ^nl);
        printFile (fid,"      while cnt > 0 do" ^nl);
        printFile (fid,"        let pv in set pvs in"^nl);
        printFile (fid,"          ( printField(pv);" ^nl);
        printFile (fid,"            str := str ^ result ^ \" |-> \";" ^nl);
        printFile (fid,"            printField(pval(pv));" ^nl);
        printFile (fid,"            str := str ^ result;" ^nl);
        printFile (fid,"            pvs := pvs \\ {pv};" ^nl);
        printFile (fid,"            if cnt > 1" ^nl);
        printFile (fid,"            then str := str ^ \",\" ^ getNL();" ^nl);
        printFile (fid,"            cnt := cnt - 1 ); "^nl);
        printFile (fid,"      popNL();" ^nl);
        printFile (fid,"      str := str ^ getNL() ^ \"}\";" ^nl);
        printFile (fid,"      result := str );" ^nl^nl);

        printFile (fid,"  private printField: " ^fval^ " ==> ()"^nl);
        printFile (fid,"  printField (fld) ==" ^nl);
        printFile (fid,"    if is_bool(fld) then printBoolField(fld)"^nl);
        printFile (fid,"    elseif is_char(fld) then printCharField(fld)"^nl);
        printFile (fid,"    elseif is_nat(fld) then printNatField(fld)"^nl);
        printFile (fid,"    elseif is_real(fld) then printRealField(fld)"^nl);
        printFile (fid,"    elseif isofclass("^node^",fld) then printNodeField(fld)"^nl);
        printFile (fid,"    else printStringField(fld);" ^nl^nl) );
        
  getVdmSlFieldOper: AstType ==> seq of char
  getVdmSlFieldOper (ast) ==
    if ast.isBoolType() then return "printBoolField"
    elseif ast.isCharType() then return "printCharField"
    elseif ast.isNatType() then return "printNatField"
    elseif ast.isRealType() then return "printRealField"
    elseif ast.isTypeName() then return "printNodeField"
    elseif ast.isStringType() then return "printStringField"
    elseif ast.isOptionalType() then
      ( dcl aotp : AstOptionalType := ast;
        return getVdmSlFieldOper(aotp.getType()) )
    elseif ast.isSeqType() then return "printSeqofField"
    elseif ast.isSetType() then return "printSetofField"
    elseif ast.isMapType() then return "printMapField"
    else error;

  createVdmDocLexemVisitors: AstDefinitions * int * bool ==> ()
  createVdmDocLexemVisitors (ad, fid, vpp) ==
    def pfx = ad.getPrefix() in
      ( -- handle the document
        printFile (fid,"  public visitDocument: I"^pfx^"Document ==> ()"^nl);
        printFile (fid,"  visitDocument(pcmp) =="^nl);
        if vpp
        then ( printFile (fid, "    ( dcl str : seq of char := \"new "^pfx^"Document(\","^nl);
               printFile (fid, "          lxms : seq of I"^pfx^"Lexem := pcmp.getLexems();"^nl);
               printFile (fid, "      pushNL();"^nl);
               printFile (fid, "      printStringField(pcmp.getFilename());"^nl);
               printFile (fid, "      str := str ^ result ^ \",\" ^ getNL();"^nl) )
        else ( printFile (fid, "    ( "^nl) );
        -- visit the embedded top-level abstract syntax
        for name in ad.getTop() do
          printFile (fid,"      if pcmp.has"^name^"() then visit"^name^"(pcmp.get"^name^"());"^nl);
        -- save the intermediate result
        if vpp
        then printFile (fid, "      str := str ^ result ^ \",\" ^ getNL();"^nl);
        -- output the lexems if we are in vpp mode
        if vpp
        then ( printFile (fid, "      str := str ^ \"[\";"^nl);
               printFile (fid, "      if len lxms > 0"^nl);
               printFile (fid, "      then ( pushNL();"^nl);
               printFile (fid, "             while len lxms > 0 do"^nl);
               printFile (fid, "               ( visitLexem(hd lxms);"^nl);
               printFile (fid, "                 str := str ^ getNL() ^ result;"^nl);
               printFile (fid, "                 lxms := tl lxms;"^nl);
               printFile (fid, "                 if len lxms > 0"^nl);
               printFile (fid, "                 then str := str ^ \",\" );"^nl);
               printFile (fid, "             popNL() );"^nl);
               printFile (fid, "      str := str ^ getNL() ^ \"]\";"^nl) );
        -- we're done, save the compiled result
        if vpp
        then ( printFile (fid, "      popNL();"^nl);
               printFile (fid, "      str := str ^ getNL() ^ \")\";"^nl);
               printFile (fid, "      result := str );"^nl^nl) )
        else printFile (fid, "    );"^nl^nl);
        -- handle the lexem
        printFile (fid,"  public visitLexem: I"^pfx^"Lexem ==> ()"^nl);
        printFile (fid,"  visitLexem(pcmp) =="^nl);
        if vpp
        then printFile (fid, "    ( dcl str : seq of char := \"new "^pfx^"Lexem(\";"^nl)
        else printFile (fid, "    ( dcl str : seq of char := \"mk_ "^pfx^"Lexem(\";"^nl);
        printFile (fid, "      printNatField(pcmp.getLine());"^nl);
        printFile (fid, "      str := str ^ result ^ \",\";"^nl);
        printFile (fid, "      printNatField(pcmp.getColumn());"^nl);
        printFile (fid, "      str := str ^ result ^ \",\";"^nl);
        printFile (fid, "      printNatField(pcmp.getLexval());"^nl);
        printFile (fid, "      str := str ^ result ^ \",\";"^nl);
        printFile (fid, "      printStringField(pcmp.getText());"^nl);
        printFile (fid, "      str := str ^ result ^ \",\";"^nl);
        printFile (fid, "      printNatField(pcmp.getType());"^nl);
        printFile (fid, "      str := str ^ result ^ \")\";"^nl);
        printFile (fid, "      result := str );"^nl^nl) );

  --
  -- CREATE ICONTEXTINFO AND INODE CLASSES
  --
  createVppBaseNode: AstDefinitions * int * seq of char  ==> ()
  createVppBaseNode (ad, fid, basenm) ==
    ( -- create the ICONTEXTINFO class
      printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class I" ^ ad.getPrefix() ^"ContextInfo"^nl^nl);
      printFile (fid,"operations" ^nl);
      printFile (fid,"  public accept: I" ^ad.getPrefix()^ "Visitor ==> ()" ^nl);
      printFile (fid,"  accept (-) == is subclass responsibility"^nl^nl);
      printFile (fid,"end I" ^ ad.getPrefix() ^"ContextInfo"^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl);
      -- create the INODE class
      printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"-- important note: this class is renamed to "^ad.getPrefix()^"Node by the patch script!"^nl);
      printFile (fid,"class I" ^ basenm ^nl^nl);
      printFile (fid,"values" ^nl);
      printFile (fid,"  public static prefix : seq of char = \"" ^ad.getPrefix() ^"\"" ^nl^nl);
      printFile (fid,"types" ^nl);
      printFile (fid,"  public FieldValue = " ^nl);
      printFile (fid,"    bool | char | nat | real | I"^ad.getPrefix()^"Node | " ^nl);
      printFile (fid,"    seq of FieldValue |" ^nl);
      printFile (fid,"    set of FieldValue |" ^nl);
      printFile (fid,"    map FieldValue to FieldValue" ^nl^nl);
      printFile (fid,"instance variables" ^nl);
      printFile (fid,"  private ivInfo : map nat to I" ^ad.getPrefix()^ "ContextInfo := {|->}" ^nl^nl);
      printFile (fid,"operations" ^nl);
      printFile (fid,"  public identity: () ==> seq of char" ^nl);
      printFile (fid,"  identity () == return \"Node\";" ^nl^nl);
      printFile (fid,"  public accept: I" ^ad.getPrefix()^ "Visitor ==> ()" ^nl);
      printFile (fid,"  accept (pVisitor) == pVisitor.visitNode(self);"^nl^nl);
      printFile (fid,"  public getContextInfo: nat ==> I" ^ad.getPrefix()^ "ContextInfo"^nl);
      printFile (fid,"  getContextInfo (pci) == return ivInfo(pci)"^nl);
      printFile (fid,"    pre pci in set dom ivInfo;" ^nl^nl);
      printFile (fid,"  public getContextInfoCount: () ==> nat"^nl);
      printFile (fid,"  getContextInfoCount () == return card dom ivInfo;"^nl^nl);
      printFile (fid,"  public addContextInfo: I" ^ad.getPrefix()^ "ContextInfo ==> nat"^nl);
      printFile (fid,"  addContextInfo (pci) =="^nl);
      printFile (fid,"    ( dcl res : nat := card dom ivInfo + 1;" ^nl);
      printFile (fid,"      ivInfo := ivInfo munion {res |-> pci};" ^nl);
      printFile (fid,"      return res )" ^nl^nl);
      -- add the line number info stuff
      printFile (fid,"instance variables" ^nl);
      printFile (fid,"  private ivLine : nat := 0;"^nl);
      printFile (fid,"  private ivColumn : nat := 0;"^nl^nl);
      printFile (fid,"operations"^nl);
      printFile (fid,"  public getLine : () ==> nat"^nl);
      printFile (fid,"  getLine () == return ivLine;"^nl^nl);
      printFile (fid,"  public setLine : nat ==> ()"^nl);
      printFile (fid,"  setLine (pl) == ivLine := pl;"^nl^nl);
      printFile (fid,"  public getColumn : () ==> nat"^nl);
      printFile (fid,"  getColumn () == return ivColumn;"^nl^nl);
      printFile (fid,"  public setColumn : nat ==> ()"^nl);
      printFile (fid,"  setColumn (pc) == ivColumn := pc;"^nl^nl);
      printFile (fid,"  public setPosition : nat * nat ==> ()"^nl);
      printFile (fid,"  setPosition (pl, pc) =="^nl);
      printFile (fid,"    ( setLine(pl); setColumn(pc) );"^nl^nl);
      printFile (fid,"  public setPosLexem : I"^ad.getPrefix()^"Lexem ==> ()"^nl);
      printFile (fid,"  setPosLexem (pol) =="^nl);
      printFile (fid,"    ( setLine(pol.getLine());"^nl);
      printFile (fid,"      setColumn(pol.getColumn()) );"^nl^nl);
      printFile (fid,"  public setPosNode : I"^ad.getPrefix()^"Node ==> ()"^nl);
      printFile (fid,"  setPosNode (pnd) =="^nl);
      printFile (fid,"    ( setLine(pnd.getLine());"^nl);
      printFile (fid,"      setColumn(pnd.getColumn()) )"^nl^nl);
      printFile (fid,"end I" ^ basenm ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl) );

  createNormalVisitor : AstDefinitions * nat * seq of char ==> ()
  createNormalVisitor (ad, fid, id) ==
    ( printFile (fid,"  public visit" ^id^ ": I" ^ ad.getPrefix() ^id^ " ==> ()"^nl);
      printFile (fid,"  visit" ^id^ " (-) == skip;" ^nl^nl) );

  createNormalIVisitor : AstDefinitions * nat * seq of char ==> ()
  createNormalIVisitor (ad, fid, id) ==
    ( printFile (fid,"  public visit" ^id^ ": I" ^ ad.getPrefix() ^id^ " ==> ()"^nl);
      printFile (fid,"  visit" ^id^ " (-) == is subclass responsibility;" ^nl^nl) );

  createNodeIVisitor : AstDefinitions * nat ==> ()
  createNodeIVisitor (ad, fid) ==
    ( printFile (fid,"  public visitNode: I" ^ ad.getPrefix() ^ "Node ==> ()"^nl);
      printFile (fid,"  visitNode (-) == is subclass responsibility;" ^nl ^nl) );

  createNodeVisitor : AstDefinitions * nat ==> ()
  createNodeVisitor (ad, fid) ==
    ( dcl subcl : set of seq of char := ad.getComposites() union ad.getUnionShorthands();
      printFile (fid,"  public visitNode: I" ^ ad.getPrefix() ^ "Node ==> ()"^nl);
      if subcl = {}
      then printFile (fid,"  visitNode (-) == skip;" ^nl ^nl)
      else ( printFile(fid, "  visitNode (pNode) ==" ^nl ^"    ( ");
             while card subcl > 0 do
               let tp in set subcl in
               def ptp = ad.getPrefix()^tp in
                 ( printFile (fid,"if isofclass(I"^ptp^",pNode) then visit"^tp^"(pNode)");
                   subcl := subcl \ {tp};
                   if card subcl > 0
                   then printFile (fid, nl ^"      else")
                   else printFile (fid, nl ^"      else error );" ^nl^nl) ) ) );

  createTypeNameUnionVisitor : AstDefinitions * nat * seq of char * set of seq of char ==> ()
  createTypeNameUnionVisitor (ad, fid, id, tnus) ==
    ( dcl subcl : set of seq of char := tnus;
      printFile (fid,"  public visit" ^id^ ": I" ^ ad.getPrefix() ^id^ " ==> ()"^nl);
      if subcl = {}
      then printFile (fid, "  visit" ^id^ " (-) == skip;" ^nl ^nl)
      else ( printFile(fid, "  visit" ^id^ " (pNode) ==" ^nl ^"    ( ");
             while card subcl > 0 do
               let tp in set subcl in
               def ptp = ad.getPrefix()^tp in
                 ( printFile (fid,"if isofclass(I"^ptp^",pNode) then visit"^tp^"(pNode)");
                   subcl := subcl \ {tp};
                   if card subcl > 0
                   then printFile (fid, nl ^"      else")
                   else printFile (fid, nl ^"      else error );" ^nl^nl) ) ) );

  createVppBaseVisit: AstDefinitions * int * seq of char  ==> ()
  createVppBaseVisit (ad, fid, basevisit) ==
    ( printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class " ^ basevisit ^" is subclass of I" ^basevisit ^nl);
      printFile (fid,"operations" ^nl);
      -- create the document and lexem interfaces
      printFile (fid,"  public visitDocument: I"^ad.getPrefix()^"Document ==> ()"^nl);
      printFile (fid,"  visitDocument (-) == skip;"^nl^nl);
      printFile (fid,"  public visitLexem: I"^ad.getPrefix()^"Lexem ==> ()"^nl);
      printFile (fid,"  visitLexem (-) == skip;"^nl^nl);
      -- normal visitors
      for all id in set ad.getComposites() do
        createNormalVisitor(ad,fid, id);
      -- visitor for the context information
      createNormalVisitor(ad,fid,"ContextInfo");
      -- visitors to walk the inheritance tree
      createNodeVisitor(ad,fid);
      for all id in set ad.getShorthands() do
        def shtp = ad.getShorthand(id).getType() in
          if shtp.isUnionType()
          then def mk_(sb,tnus) = shtp.isTypeNameUnion() in
                 if sb
                 then createTypeNameUnionVisitor(ad,fid,id,tnus)
                 else createNormalVisitor(ad,fid,id);
      printFile (fid,"end " ^ basevisit ^nl);
      printFile (fid,"\\end{vdm_al}" ^ nl) );

  createVppIBaseVisit: AstDefinitions * int * seq of char  ==> ()
  createVppIBaseVisit (ad, fid, basevisit) ==
    ( printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class I" ^basevisit ^nl);
      printFile (fid,"operations" ^nl);
      -- create the document and lexem interfaces
      printFile (fid,"  public visitDocument: I"^ad.getPrefix()^"Document ==> ()"^nl);
      printFile (fid,"  visitDocument (-) == is subclass responsibility;"^nl^nl);
      printFile (fid,"  public visitLexem: I"^ad.getPrefix()^"Lexem ==> ()"^nl);
      printFile (fid,"  visitLexem (-) == is subclass responsibility;"^nl^nl);
      -- normal visitors
      for all id in set ad.getComposites() do
        createNormalIVisitor(ad,fid, id);
      -- visitor for the context information
      createNormalIVisitor(ad,fid,"ContextInfo");
      -- visitors to walk the inheritance tree
      createNodeIVisitor(ad,fid);
      for all id in set ad.getShorthands() do
        def shtp = ad.getShorthand(id).getType() in
          if shtp.isUnionType()
          then createNormalIVisitor(ad,fid,id);
      printFile (fid,"end I" ^ basevisit ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl) );

  createDefSpec: AstDefinitions * AstComposite * seq of char * nat ==> ()
  createDefSpec (ad, acmp, clnm, fid) ==
    ( dcl tps : set of seq of char := {};
      printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class " ^ clnm ^" is subclass of I" ^clnm^nl);
      printFile (fid,"operations" ^nl);
      printFile (fid,"  public identity: () ==> seq of char" ^nl);
      printFile (fid,"  identity () == return \"" ^acmp.getName()^ "\";" ^nl^nl);
      printFile (fid,"  public accept: I" ^ad.getPrefix()^ "Visitor ==> ()" ^nl);
      printFile (fid,"  accept (pVisitor) == pVisitor.visit" ^acmp.getName()^ "(self);"^nl^nl);
      createDefSpecConstructor(ad, acmp, fid, false);
      createDefSpecConstructor(ad, acmp, fid, true);
      createDefSpecCompInit(acmp, fid);
      for field in acmp.getFields() do
        def fldnm = "iv" ^ field.getName() in
        def fldtp = field.getType() in
          ( dcl tp : seq of char := getVdmType(ad.getPrefix(), fldtp);
            -- write out the instance variable
            printFile(fid,"instance variables"^nl);
            -- if field.getOptional()
            if fldtp.isSeqType() or fldtp.isStringType()
            then printFile(fid,"  private " ^fldnm^ " : " ^tp ^" := []" ^nl^nl)
            else if fldtp.isSetType()
                 then printFile(fid,"  private " ^fldnm^ " : " ^tp ^" := {}" ^nl^nl)
                 else if fldtp.isMapType()
                      then printFile(fid,"  private " ^fldnm^ " : " ^tp ^" := {|->}" ^nl^nl)
                      else printFile(fid,"  private " ^fldnm^ " : [" ^tp^ "] := nil" ^nl^nl);
            -- now generate the access operations
            printFile(fid,"operations"^nl);
            -- the get operation
            printFile(fid,"  public get" ^field.getName()^ ": () ==> " ^tp^ nl);
            printFile(fid,"  get" ^field.getName()^ "() == return " ^fldnm);
            if fldtp.isOptionalType()
            then printFile(fid, nl^"    pre has" ^field.getName()^ "();"^nl^nl)
            else printFile(fid, ";"^nl^nl);
            -- the has operation
            if fldtp.isOptionalType()
            then ( printFile(fid,"  public has" ^field.getName()^ ": () ==> bool" ^nl);
                   printFile(fid,"  has" ^field.getName()^ " () == return " ^fldnm^ " <> nil;"^nl^nl) );
            -- the set operation
            if fldtp.isOptionalType()
            then printFile(fid,"  public set" ^field.getName()^ ": [ " ^tp^ " ] ==> ()"^nl)
            else printFile(fid,"  public set" ^field.getName()^ ": " ^tp^ " ==> ()"^nl);
            printFile(fid,"  set" ^field.getName()^ "(parg) == " ^fldnm^ " := parg;"^nl^nl);
            -- the operations to modify abstract data types
            if field.getType().isSeqType()
            then def stp : AstSeqOfType = field.getType() in
                   ( dcl ntp : seq of char := getVdmType(ad.getPrefix(), stp.getType());
                     if stp.getType().isTypeName()
                     then printFile(fid,"  public add" ^ field.getName() ^ ": I" ^ad.getPrefix() ^"Node ==> ()" ^nl)
                     else printFile(fid,"  public add" ^ field.getName() ^ ": " ^ntp^ " ==> ()" ^nl);
                     printFile(fid,"  add" ^field.getName()^ " (parg) == iv"^field.getName()^
                                   " := iv"^field.getName()^" ^ [parg];" ^nl^nl) );
            if field.getType().isSetType()
            then def stp : AstSetOfType = field.getType() in
                   ( dcl ntp : seq of char := getVdmType(ad.getPrefix(), stp.getType());
                     if stp.getType().isTypeName()
                     then printFile(fid,"  public add" ^ field.getName() ^ ": I" ^ad.getPrefix() ^"Node ==> ()" ^nl)
                     else printFile(fid,"  public add" ^ field.getName() ^ ": " ^ntp^ " ==> ()" ^nl);
                     printFile(fid,"  add" ^field.getName()^ " (parg) == iv"^field.getName()^
                                   " := iv"^field.getName()^" union {parg};" ^nl^nl) );
            if field.getType().isMapType()
            then def mtp : AstMapType = field.getType() in
                   ( dcl ndtp : seq of char := getVdmType(ad.getPrefix(), mtp.getDomType()),
                         nrtp : seq of char := getVdmType(ad.getPrefix(), mtp.getRngType());
                     def dtnm = if mtp.getDomType().isTypeName() then "I"^ad.getPrefix()^"Node" else ndtp in
                     def rtnm = if mtp.getRngType().isTypeName() then "I"^ad.getPrefix()^"Node" else nrtp in
                       ( printFile(fid,"  public add" ^field.getName()^ ": " ^dtnm^ " * " ^rtnm^ " ==> ()" ^nl);
                         printFile(fid,"  add" ^field.getName()^ "(pd, pr) ==" ^nl);
                         printFile(fid,"    "^fldnm^" := "^fldnm^" munion {pd |-> pr}" ^nl);
                         printFile(fid,"    pre pd not in set dom "^fldnm^";" ^nl^nl) ) ) );
      printFile (fid,"end " ^ clnm ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl) );

  createDefISpec: AstDefinitions * AstComposite * seq of char * nat ==> ()
  createDefISpec (ad, acmp, clnm, fid) ==
    ( dcl tps : set of seq of char := {};
      printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class I" ^ clnm ^ nl);
      def base = ad.getPrefix() ^
        if ad.hasInherit(acmp.getName())
        then ad.getInherit(acmp.getName())
        else "Node" in
        printFile(fid, " is subclass of I" ^ base ^ nl ^nl);
      for field in acmp.getFields() do
        def fldnm = "iv" ^ field.getName() in
        def fldtp = field.getType() in
          ( dcl tp : seq of char := getVdmType(ad.getPrefix(), fldtp);
            printFile(fid,"operations"^nl);
            -- the get operation
            printFile(fid,"  public get" ^field.getName()^ ": () ==> " ^tp^ nl);
            printFile(fid,"  get" ^field.getName()^ "() == is subclass responsibility;" ^nl^nl);
            if fldtp.isOptionalType()
            then ( printFile(fid,"  public has" ^field.getName()^ ": () ==> bool" ^nl);
                   printFile(fid,"  has" ^field.getName()^ " () == is subclass responsibility;"^nl^nl) ) );
                   -- printFile(fid,"  has" ^field.getName()^ " () == return " ^fldnm^ " <> nil;"^nl^nl) );
      printFile (fid,"end I" ^ clnm ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl) );

  createDefSpecConstructor: AstDefinitions * AstComposite * nat * bool ==> ()
  createDefSpecConstructor (ad, acmp, fid, posinfo) ==
    def clnm = ad.getPrefix() ^ acmp.getName() in
    def fields = acmp.getFields() in
      ( dcl siglist : seq of char := [],
            parmlist : seq of char := [],
            body : seq of char := [],
            cnt : nat := 1;
        -- process the field names
        while cnt <= len fields do
          ( -- add a parameter for each field and set the field in the body
            let pname = "p" ^ nat2str(cnt) in
            let nbody = "set" ^fields(cnt).getName()^ "(" ^pname^ ")" in
            let btype = getVdmType(ad.getPrefix(),fields(cnt).getType()) in
            let ftype = if fields(cnt).getType().isOptionalType()
                        then "    [" ^ btype ^ "]"
                        else "    (" ^ btype ^ ")" in
              ( parmlist := parmlist ^pname;
                siglist := siglist ^ftype;
                if body = []
                then body := "    ( " ^nbody
                else body := body ^ ";" ^nl ^"      " ^nbody );
            if cnt < len fields
            then ( parmlist := parmlist ^","; siglist := siglist ^" *" ^nl );
            cnt := cnt + 1 );
        -- create the final parmlist and body
        if posinfo
        then ( if fields = []
               then ( parmlist := "(line,column)";
                      siglist := "    nat *" ^nl ^"    nat";
                      body := "    setPosition(line, column);" )
               else ( parmlist := "(" ^parmlist ^",line,column)";
                      siglist := siglist ^" *" ^nl ^"    nat *" ^nl ^"    nat";
                      body := body ^ ";" ^nl ^"      setPosition(line, column) );" ) )
        else ( if fields = []
               then ( parmlist := "()";
                      siglist := "    ()";
                      body := "    skip;" )   
               else ( parmlist := "(" ^parmlist^ ")"; 
                      body := body ^ " );" ) );
        printFile (fid,"  public " ^clnm^ ":" ^nl ^siglist^ " ==> " ^clnm ^nl);
        printFile (fid,"  " ^clnm^ " " ^parmlist^ " == " ^nl ^body ^nl^nl) );
    
  createDefSpecCompInit: AstComposite * nat ==> ()
  createDefSpecCompInit (acmp, fid) ==
    def fields = acmp.getFields() in
      ( dcl cnt : nat := 1;
        printFile (fid, "  public init: map seq of char to [FieldValue] ==> ()"^nl);
        if fields = []
        then printFile (fid, "  init (-) == skip;" ^nl^nl)
        else ( printFile (fid, "  init (data) ==" ^nl ^"    ( ");
               while (cnt <= len fields) do
                 def fldnm = fields(cnt).getName();
                     rfldnm = fields(cnt).getRawName() in
                   ( printFile (fid, "let fname = \""^rfldnm^"\" in"^nl);
                     printFile (fid, "        if fname in set dom data"^nl);
                     printFile (fid, "        then set"^fldnm^"(data(fname))");
                     if cnt < len fields
                     then printFile (fid,";"^nl^"      ")
                     else printFile (fid," );"^nl^nl);
                     cnt := cnt + 1 ) ) );

  createShSpec: AstDefinitions * AstShorthand * seq of char * seq of seq of char * nat ==> ()
  createShSpec (ad, shorthand, clnm, path, fid) ==
    ( printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class " ^ clnm ^ " is subclass of I" ^clnm ^nl);
      printFile (fid,"operations" ^nl);
      printFile (fid,"  public identity: () ==> seq of char" ^nl);
      printFile (fid,"  identity () == return \"" ^shorthand.getName()^ "\";" ^nl^nl);
      printFile (fid,"  public accept: I" ^ad.getPrefix()^ "Visitor ==> ()" ^nl);
      printFile (fid,"  accept (pVisitor) == pVisitor.visit" ^shorthand.getName()^ "(self);"^nl^nl);
      -- createDefSpecShInit(shorthand, fid);
      def mk_(rb,rs) = shorthand.getType().isQuotedTypeUnion() in
        if rb
        then ( -- create the constructors
               printFile(fid,"  public " ^clnm^ ": nat ==> " ^clnm^nl);
               printFile(fid,"  " ^clnm^ " (pv) == setValue(pv);" ^nl^nl);
               printFile(fid,"  public " ^clnm^ ": nat * nat * nat ==> " ^clnm^nl);
               printFile(fid,"  " ^clnm^ " (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );" ^nl^nl);
               -- create the quoted type definition 
               createShQuotedTypeDef (clnm,path,rs);
               printFile(fid,"instance variables" ^nl);
               printFile(fid,"  private val : [nat] := nil" ^nl^nl);
               printFile(fid,"operations"^nl);
               printFile(fid,"  public setValue: nat ==> ()" ^nl);
               printFile(fid,"  setValue (pval) == val := pval" ^nl);
               printFile(fid,"    pre val = nil and " ^clnm^ "Quotes`validQuote(pval);" ^nl^nl);
               printFile(fid,"  public getValue: () ==> nat" ^nl);
               printFile(fid,"  getValue () == return val"^nl);
               printFile(fid,"    pre val <> nil;" ^nl^nl);
               printFile(fid,"  public getStringValue: () ==> seq of char" ^nl);
               printFile(fid,"  getStringValue() == return "^clnm^"Quotes`getQuoteName(val)" ^nl);
               printFile(fid,"    pre val <> nil;" ^nl^nl) );
      printFile (fid,"end " ^ clnm ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl) );

  createShISpec: AstDefinitions * AstShorthand * seq of char * seq of seq of char * nat ==> ()
  createShISpec (ad, shorthand, clnm, path, fid) ==
    ( printFile (fid,"\\begin{vdm_al}" ^ nl);
      printFile (fid,"class I" ^ clnm ^ nl);
      def base = ad.getPrefix() ^
        if ad.hasInherit(shorthand.getName())
        then ad.getInherit(shorthand.getName())
        else "Node" in
        printFile(fid, " is subclass of I" ^ base ^ nl ^nl);
      def mk_(rb,rs) = shorthand.getType().isQuotedTypeUnion() in
        if rb
        then ( printFile(fid,"operations"^nl);
               printFile(fid,"  public getValue: () ==> nat" ^nl);
               printFile(fid,"  getValue () == is subclass responsibility;"^nl^nl);
               printFile(fid,"  public getStringValue: () ==> seq of char" ^nl);
               printFile(fid,"  getStringValue() == is subclass responsibility" ^nl^nl) );
      printFile (fid,"end I" ^ clnm ^nl);
      printFile (fid,"\\end{vdm_al}" ^nl^nl) );

  createDefSpecShInit: AstShorthand * nat ==> ()
  createDefSpecShInit (ash, fid) ==
    ( printFile (fid, "  public init: map seq of char to [FieldValue] ==> ()"^nl);
      printFile (fid, "  init (-) == skip;" ^nl^nl) );

  createShQuotedTypeDef: seq of char * seq of seq of char * set of seq of char ==> ()
  createShQuotedTypeDef (ashnm, path, qtnms) ==
    def clnm = ashnm ^ "Quotes" in
      ( dcl fid : nat := createFile(path ^[clnm ^".tex"]),
            cnt : nat := 0,
            qmp : seq of char := [];
        if fid >= 0
        then ( printFile (fid,"\\begin{vdm_al}" ^nl);
               printFile (fid,"class " ^clnm ^nl);
               printFile (fid,"instance variables" ^nl);
               for all id in set qtnms do
                 def nstr = nat2str(cnt) in
                   ( printFile(fid,"  static public IQ" ^id ^" : nat := " ^nstr ^";" ^nl);
                     qmp := qmp ^"IQ" ^id ^" |-> \"<" ^id ^">\"";
                     if cnt+1 < card qtnms
                     then qmp := qmp ^"," ^nl ^"      "
                     else qmp := qmp ^" }"^nl ;
                     cnt := cnt + 1 );
               printFile (fid,nl ^"  static private qmap : map nat to seq of char :=");
               printFile (fid,nl ^"    { " ^qmp ^nl ^"operations" ^nl);
               printFile (fid,"  static public getQuoteName: nat ==> seq of char" ^nl);
               printFile (fid,"  getQuoteName (pid) ==" ^nl);
               printFile (fid,"    return qmap(pid)" ^nl);
               printFile (fid,"    pre validQuote(pid);" ^nl^nl);
               -- printFile (fid,"    if pid in set dom qmap" ^nl);
               -- printFile (fid,"    then return qmap(pid)" ^nl);
               -- printFile (fid,"    else return \"nil\";" ^nl^nl);
               printFile (fid,"  static public validQuote: nat ==> bool" ^nl);
               printFile (fid,"  validQuote (pid) == return pid in set dom qmap" ^nl^nl);
               printFile (fid,"end " ^clnm ^nl);
               printFile (fid,"\\end{vdm_al}" ^nl) ) );


  createScript: AstDefinitions ==> ()
  createScript (ad) ==
    def base = ad.getDirectory() in
    def root = ["src"]^ ad.getRawPackage() ^ ["imp"] in
      if createDirectory(base,root)
      then makeScript(ad, [base]^root) ;

  makeScript: AstDefinitions * seq of seq of char ==> ()
  makeScript (ad, path) ==
    ( dcl fid1 : nat := createFile(path ^ ["vdmpatch"]),
          fid2 : nat := createFile(path ^ ["script"]);
      def pack = ad.getPackage() in
      def packspec = if len pack > 0 then pack ^ ".itf" else "itf" in
      def nname = ad.getPrefix() ^"Node" in
      def vname = ad.getPrefix() ^"Visitor" in
      def dname = ad.getPrefix() ^"Document" in
      def lname = ad.getPrefix() ^"Lexem" in
      if fid1 >= 0 and fid2 >= 0
      then ( -- create the BASH file indicator
             printFile(fid1, "#!/usr/bin/bash"^nl);
             printFile(fid1, "echo start patching files"^nl);
             printFile(fid1, "mv -f I" ^nname^ ".java " ^nname^ ".java"^nl);
             printFile(fid1, "rm -rf *.bak *.tmp I*.java"^nl);
             -- create the basic SED script rules
             printFile(fid2, "s/imports KEEP=NO/imports KEEP=YES/g"^nl);
             printFile(fid2, "s/jp.co.csk.vdm.toolbox.VDM.jdk/"^packspec^"/g"^nl);
             printFile(fid2, "/"^IntegerStr^" IQ/d"^nl);
             printFile(fid2, "/Name=IQ/d"^nl);
             -- create file specific rules
             printFile(fid2, "s/^public class I"^nname^" .*/public class "^nname^" implements I"^nname^" {/g"^nl);
             printFile(fid2, "s/^  public I"^nname^"/  public "^nname^"/g"^nl);
             printFile(fid2, "s/public OmlNode setLexem/public IOmlNode setLexem/g"^nl);
             patchFile(fid1,fid2,vname,"",false);
             patchFile(fid1,fid2,dname,"",false);
             patchFile(fid1,fid2,lname,"",false);
             printPatch(nname,fid1);
             printPatch("VdmSlVisitor",fid1);
             printPatch("VdmPpVisitor",fid1);
             for all id in set ad.getComposites() do
               def clnm = ad.getPrefix() ^ id in
               def base = ad.getPrefix() ^
                 if ad.hasInherit(id)
                 then ad.getInherit(id)
                 else "Node" in
                   patchFile(fid1,fid2,clnm,base,false);
             for all id in set ad.getShorthands() do
               def clnm = ad.getPrefix() ^ id in
               def base = ad.getPrefix() ^
                     if ad.hasInherit(id)
                     then ad.getInherit(id)
                     else "Node" in
                  ( if ad.getShorthand(id).getType().isUnionType()
                    then patchFile(fid1,fid2,clnm,base,false);
                    def mk_ (sb,-) = ad.getShorthand(id).getType().isQuotedTypeUnion() in
                    if sb
                    then patchFile(fid1,fid2,clnm^"Quotes","",false) );
             def nloc = "../../visitor" in
               ( printFile(fid1, "echo Relocating visitors"^nl);
                 printFile(fid1, "mkdir " ^nloc^nl);
                 printFile(fid1, "sed -e \"s/ast.imp/visitor/g\" < " ^ ad.getPrefix() ^ "Visitor.java > " ^nloc^ "/" ^ ad.getPrefix()^ "Visitor.java"^nl);
                 printFile(fid1, "rm -f Visitor.java" ^nl);
                 printFile(fid1, "sed -e \"s/ast.imp/visitor/g\" < VdmSlVisitor.java > " ^nloc^ "/VdmSlVisitor.java"^nl);
                 printFile(fid1, "rm -f VdmSlVisitor.java" ^nl);
                 printFile(fid1, "sed -e \"s/ast.imp/visitor/g\" < VdmPpVisitor.java > " ^nloc^ "/VdmPpVisitor.java"^nl);
                 printFile(fid1, "rm -f VdmPpVisitor.java" ^nl) );
             printFile(fid1, "Echo done patching files!")  ) );

  patchFile: nat * nat * seq of char * seq of char * bool ==> ()
  patchFile (fid1, fid2, clnm, base, abstr) ==
    def inh = if len base > 0 then " extends " ^ base else "" in
    def bgn = if not abstr then "public class " else "public abstract class " in
    def str = bgn ^clnm ^inh ^" implements I" ^clnm^ " {" in
     ( printPatch(clnm, fid1);
       printFile(fid2, "s/^" ^bgn ^clnm ^" .*/" ^str ^"/g"^nl) );

  printPatch: seq of char * nat ==> ()
  printPatch(fname, fid) ==
    def org = fname ^ ".java" in
    def tmp = fname ^ ".tmp" in
      ( printFile(fid, "echo -n Patching file "^org^" .."^nl);
        printFile(fid, "mv -f " ^ org ^ " " ^ tmp ^ nl );
        printFile(fid, "sed -f script < " ^ tmp ^ " > " ^ org ^ nl);
        printFile(fid, "rm -f " ^ tmp ^ nl);
        printFile(fid, "echo .. done!"^nl) );

  public print : seq of char ==> ()
  print (-) == skip;

  public visit : AstDefinitions ==> ()
  visit (ad) ==
    ( print ("Start code generation...");
      def - = createDirectory (ad.getDirectory(), ["src"] ^ ad.getRawPackage()) in
        ( createInterfaces(ad);
          createSpecifications(ad);
          createScript(ad) );
      closeFiles();
      print ("Code generation finished!") );

  public visit : AstShorthand ==> ()
  visit (-) == skip;

  public visit : AstComposite ==> ()
  visit (-) == skip;

  public visit : AstField ==> ()
  visit (-) == skip;

  public visit : AstTypeName ==> ()
  visit (-) == skip;

  public visit : AstQuotedType ==> ()
  visit (-) == skip;

  public visit : AstUnionType ==> ()
  visit (-) == skip;

  public visit : AstSeqOfType ==> ()
  visit (-) == skip;

  public visit : AstOptionalType ==> ()
  visit (-) == skip;

  public visit : AstMapType ==> ()
  visit (-) == skip

end codegenVisitor
\end{vdm_al}
