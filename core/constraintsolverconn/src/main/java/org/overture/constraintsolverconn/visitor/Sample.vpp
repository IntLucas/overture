-- a = 1 + 2 -- unable to type check
-- a := 1 -- unable to type check
-- ( 1 + ( 2  - 3 ) * 4 ) / 5
-- (1 ** (5 mod 3)) + 0 
-- ((-2) ** (5 mod 3)) + 0 
-- (-2 ** (5 mod 3)) + 0 
-- 1+2
-- 1-2
-- -3
-- +5
-- 7 mod 3
-- -7 mod 3
-- 7 mod -3
-- -7 mod -3
-- abs -3 
-- abs 5 
-- abs 0 
-- true
-- false
-- {1} union {2,3}
-- {1+2} union {2,3}
-- {1*2,3-4} union {2,3}
-- {1*2,3-4} \ {2,3}
-- {1} \ {2,3}
-- {1,2,3} \ {2,3}
-- dom {1|->2, 3|->3}
-- true and false
-- ( 1=1 and 1=2) or 1=3
-- ( 1=1 or 1=2) and 1=3
-- (1=1 and 1=2) => 1=3
-- 1=1 and 2=2
-- 1=1 and 2=1
-- 1=2-1 and 2=2
-- 1=2 and 2=3
-- 1=1 or 2=2
-- 1=1 or 2=1
-- 1=2 or 2=2
-- 1=2 or 2=3
-- rng {1|->2, 3|->3}
-- {1|->2, 3|->3} = {1|->2, 3|->3}
-- {1|->2, 3|->3} <> {1|->2, 3|->3}
-- { }
-- dunion({{1+1,2*5}union{2,3,4},{1,5}}) 
-- dunion({{1+1,2*5}inter{2,3,4},{1,5}}) 
-- dunion({{1+1,2*5},{2,3,4},{1,5}}) 
-- dinter({{1+1,2*5},{2,3,4},{1,5}}) 
-- {1, 2, 3}
-- 1 in set {1,2}
-- 2 in set {1,2,3}
-- 1 not in set {1,2}
-- len ([1,2,3] ^ [2,4])
-- elems [[10,20],[30],[10,20], [40,50,60]]
-- elems [[10,20],[30],[40,50,60]]
-- elems [10,20,30,40]
-- elems [3,1,4,1,5,9,2]
-- [10,20,30,40,50](2)
-- [10,20,30,40,50](len([1,2]^[3]))
-- inds [1,2,3]
-- elems [1,2,3]
-- reverse ([1,2,3])
-- -- unable to parse expression
-- {0,1,2,3} = set of nat
-- {0,1,2,3} = set of nat1
-- -- under construction
-- { x+y | x in set {1,2,3,4} , y in set {1,2} & x + y <= 3}
-- { x*y | x in set {1,2,3,4} , y in set {1,2} & x * y <= 3}
-- -- under construction
-- { x+y | x in set {1,2,3,4} , y in set {-1,0,1} & x + y <= 3}
-- -- should be translated to dom(dom({z,x,y | z:NATURAL & x:1..4 & y : {-1, 0, 1} & x + y = z & z <= 3 }))
-- --                      or ran(%(x,y).( x:1..4 & y : {-1, 0, 1} | x + y)) /\ {x|x<=3}
-- { x | x in set {-1,0,1,2,3} & x*x = 1 }
{ x | x in set {-1,0,1,2,3} & x*x = 1 }
{ -x | x in set {-1,0,1,2,3} & x*x = 1 }
{ 2*x | x in set {-1,0,1,2,3} & x*x = 1 }
{ x*y/z | x in set {1,2,3,4,5} , y in set {1,2,3,4,5} , z in set {1,2,3,4,5} &  x*y/z<15 }
{ x+y | x in set {1,2,3,4} , y in set {1,2} & x + y <= 3}
{ -(x+y) | x in set {1,2,3,4} , y in set {1,2} & x + y <= 3}
{ x+y-2*z+x | x in set {1,2,3,4} , y in set {1,2} , z in set {1,2} & x + y -z <= 3}
-- { abs(x+y-2*z+1) | x in set {1,2,3,4} , y in set {1,2} , z in set {1,2} & x + y -z <= 3}
-- { x | x in set {1,2,3} & x = 1 }
-- { x | x in set {1,2,3,4,5} & x*x <= 10 }
-- forall a,b in set {1,2,3} &  a+b > 2
-- forall a,b in set {1,2,3} &  a+b > 0
-- forall a in set {1,1+1,3}, b in set {3} & a + b = 2
-- -> ProB !(a,b).(a : {1, 2, 3} & b : {3, 4} => a + b > 2)
-- exists a in set {1,2,3}, b in set {3,4} & a + b = 5
-- -- target = {a,b}a:{1,2,3} & b : {3,4} & a+b=5} & card(target)>0
-- -- #(a,b).(a : {1,2,3} & b : {3,4} & a+b=5)
-- -- {a,b | a : {1,2,3} & b : {3,4} & a+b=5 }  {} -> FALSE
-- -- dom({a,b,z | a : {1,2,3} & b : {3,4} & z=a+b & z=5 })
-- -- exists1 a in set {1,2,3}, b in set {3,4} & a + b = 5 -- syntax error in vdm
-- -- card( {a,b | a : {1,2,3} & b : {3,4} & a+b=5 } ) = 1
-- -- card( {a,b,z | a : {1,2,3} & b : {3,4} & z=a+b & z=5 } ) = 1
-- exists1 a in set {1,2,3} &  b in set {3,4} & a + b = 5
-- exists1 a in set {1,2,3} & a = 1
-- -- card({x | a : {1, 2, 3} & a = 1 & x=a})=1
-- exists a,b,c in set {1,2,3} & a+b+c <= 2
-- exists a,b,c in set {1,2,3} & a+b+c >= 5 & a+b+c<=7
-- exists a in set {1,2,3} ,b in set {1,2,3} ,c in set {1,2,3} & a+b+c >= 5
-- exists a in set {1,2,3} ,b in set {1,2,3} ,c in set {1,2,3} & a+b+c >= 5 and a+b+c<=7
-- exists a in set {1,2,3}, b in set {3,4} & a + b = 5
-- (forall f:(@elem -> @elem), l:seq of (@elem) & (not (l = []) => m[@elem](f, l) > m[@elem](f, (tl l))))  -- not done
-- if true then true else false
-- if 1=1 then a=1 else a=0
-- if 1=0 then 1 else 0
-- if true and false then 1+2 else 0+4
-- if (1=1) and (2=1) then 1+2 else 0+4
-- if true then 1 else (3 * (3-1))
-- if (1=1) then 1=2 else 0=4
-- if true then 1=1 elseif 2=3 then 3=4 else 4=5
-- if (1=1) then 1 else 2
-- if true then 1 elseif 2=3 then 2 else 3
-- if true then 1=2 elseif 2=2 then 3=4 else 4=5 
-- if true then 1=2 elseif 2=3 then 3=4 else 4=5 
-- if true then 1=2 elseif 2=3 then 3=4 else 4=4 
-- -- unable to type check expression below
-- if false then a=1+1 elseif 2=3 then a=3+4 else a=4+5
-- if false then 1=2 elseif 2=2 then 3=4 else 4=5 
-- if false then 1=2 elseif 2=3 then 3=4 else 4=5 
-- if false then 1=2 elseif 2=3 then 3=4 else 4=4 
-- if true then 1=2 elseif false then 2=3 elseif 4=5 then 6=7 else 3=4
-- -- Europe = { "France", "England", "Denmark", "Spain" }
-- -- m1 = { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 }
-- -- m2 = { 1|-> 2, 2|->3, 3|->4, 4|->1 }
-- -- m3 = { "England" |-> 3 }
-- -- m4 = { "France"|-> 8, "England" |-> 4 }
-- dom( { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 })
-- rng( { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 })
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 } munion { "England" |-> 3 }
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 } ++ { "France"|-> 8, "England" |-> 4 }
-- merge {{ "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 },{ "England" |-> 3 },{ "France"|-> 8, "England" |-> 4 }}
-- { "France", "England", "Denmark", "Spain" } <: { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 }
-- { "France", "England", "Denmark", "Spain" } <-: { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 }
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 } :> { 1, 2 }
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 } :-> { 1, 2 }
-- merge( {{ "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 },{ "England" |-> 3 },{ "France"|-> 8, "England" |-> 4 }})
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 }("Denmark")
-- { 9 |-> "France", 4 |-> "Denmark" , 2 |-> "SouthAfrica" , 1 |-> "SaudiArabia" }(2)
-- len([2]^[3])
-- [1,2,3](len ([3]^[2]))
-- ["France", "England", "Denmark", "Spain" ] ++ { 2|->"Italy", 4|->"Ireland" }
-- { "France" |-> 9, "Denmark" |-> 4, "SouthAfrica" |-> 2, "SaudiArabia" |-> 1 } comp ( { "FRANCE"|-> "France" } )
-- { 1|-> 2, 2|->3, 3|->4, 4|->1 } ** 3 
-- map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
-- { 1|-> 2, 2|->3, 3|->4, 4|->1 } comp (inverse { 1|-> 2, 2|->3, 3|->4, 4|->1 })
-- (lambda n : nat & n + 1)(3)
-- -- evaluation value is a map
-- (lambda n : nat & n + 1)
-- --> should be translated to %n.(n : NAT | n + 1) in ProB
-- lambda a : nat , b : nat & a + b
-- lambda a : nat & lambda b : nat & a + b
-- -- unable to parse expression in cscvisitor.java
-- lambda n : {1,2,3} & n + 1
--  -- unable to parse expression in cscvisitor.java
-- lambda n in set {1,2,3} & n + 1
-- lambda a : {1,2,3} , b : {10,20,30} & a + b  -- unable to parse expression in cscvisitor.java
-- lambda a : {1,2,3} & lambda b : {10,20,30} & a + b  -- unable to parse expression in cscvisitor.java
-- f1 = lambda x : nat & lambda y : nat & x + y -- Unable to type check expression: f1 = lambda x : nat & lambda y : nat & x + y
-- -- Unable to type check expression: map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
-- map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
-- map_inter (m1, m2) ==
--   (dom m1 inter dom m2) <: m1
-- pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)  -- unable to parse expression 
-- ["a", "b", "c"](2)
-- [[1,2],[3,4],[1,2,3]](2)
-- under construction
-- let a = 1, b = 2 in a + b
-- let a in set dom {1,2,3} be st { -- under construction
-- exists1 a in set {1,2,3} & a > 2
-- cartesian product (1|->2) in ProB
-- mk_(1,2)
-- mk_(1,2,3)
-- mk_(1,2).# 1
-- mk_(1,2).# 2
-- mk_(1,2,3).# 1
-- mk_(1,2,3).# 2
-- mk_(1,2,3).# 3
-- mk_([], [1,2],[3])
-- mk_token({9, 3})
-- mk_token([true, {}])
-- mk_(1+2, 3, 4*5)
-- mk_("a", 1, "b", 2)
-- mk_token(1)  -- (temporary) as a string "mk_token(1)"
-- mk_token([[1,2],[],[3]]) -- (temporary) as a string "mk_token([[1,2],[],[3]])"
-- mk_token([true, {}])
-- mk_token({1,2})
-- 1+2
-- mk_("a", "b", 1 , 2).# 1
-- mk_("a", "b", 1 , 2).# 2
-- mk_("a", "b", 1 , 2).# 3
-- mk_("a", "b", 1 , 2).# 4
-- mk_Score(10, 3,0,0,9) -- unable to type check
-- let sc1 = mk_(1,2,3) in set {(1,2,3), (1,2,3), (1,2,3)}  -- unable to parse expression
-- cases {}: {}, {1}, {2} -> [], {3} -> [1] , others -> [1,2,3] end
-- cases {1}: {}, {1}, {2} -> [], {3} -> [1] , others -> [1,2,3] end
-- cases {2}: {}, {1}, {2} -> [], {3} -> [1] , others -> [1,2,3] end
-- cases {3}: {}, {1}, {2} -> [], {3} -> [1] , others -> [1,2,3] end
-- cases {4,5}: {}, {1}, {2} -> [], {3} -> [1] , others ->  [ len [1,2+3,3]] end
-- cases {}: {}, {1}, {2} -> [], {3} -> [1] end
-- cases {1}: {}, {1}, {2} -> [], {3} -> [1] end
-- cases {2}: {}, {1}, {2} -> [], {3} -> [1] end
-- cases {3}: {}, {1}, {2} -> [], {3} -> [1] end
-- cases {4}: {}, {1}, {2} -> [], {3} -> [1] end
-- -- not yet checked
-- let
-- set comprehension
-- -- under construction
-- record
-- mu
-- seq comprehension
-- unable to type check expression
-- elems [3,1,4,1,5,9,2]
-- conc [[1,2],[1,2,2+1],[1,1+1],[3]]
-- conc [[1,2],[1,2,2+1],[3]]