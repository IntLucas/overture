\section{Visitor for pretty-pinting ASTs}

\begin{vdm_al}
class Oml2VppVisitor is subclass of OmlVisitor
types
  String = seq of char;
values
  private nl : seq of char = "";
  


instance variables
  public result : seq of char := [];
  private lvl : nat := 0

operations
private printNodeField: IOmlNode ==> ()
printNodeField (pNode) == pNode.accept(self);

private printBoolField: bool ==> ()
printBoolField (pval) ==
  result := if pval then "true" else "false";
    
private printNatField: nat ==> ()
-- implement this operation by hand!
printNatField (pval) == result := StdLib`ToStringInt(pval);

private printRealField: real ==> ()
  -- implement this operation by hand!
printRealField (pval) == 
  result := VDMUtil`val2seq_of_char[real](pval);
  
private printCharField: char ==> ()
printCharField (pval) ==
  result := [pval];
  
private printField: IOmlNode`FieldValue ==> ()
printField (fld) ==
  if is_bool(fld) then printBoolField(fld)
  elseif is_char(fld) then printCharField(fld)
  elseif is_nat(fld) then printNatField(fld)
  elseif is_real(fld) then printRealField(fld)
  elseif isofclass(IOmlNode,fld) then printNodeField(fld)
  else printStringField(fld);
  
private printStringField: seq of char ==> ()
printStringField (str) == result := "\"" ^ str ^ "\"";
  
private printSeqofField: seq of IOmlNode`FieldValue ==> ()
printSeqofField (pval) ==
( dcl str : seq of char := "", cnt : nat := len pval;
   while cnt > 0 do
   ( 
     printField(pval(len pval - cnt + 1));
     str := str ^ result;
     if cnt > 1
     then str := str ^ ", ";
     cnt := cnt - 1 ); 
     result := str 
    );

public visitNode: IOmlNode ==> ()
visitNode (pNode) == pNode.accept(self);
  
public visitDocument: IOmlDocument ==> ()
visitDocument(pcmp) ==
( dcl str : seq of char := "--BEGIN FileName: " ^ pcmp.getFilename() ^ nl;
   
  if pcmp.hasSpecifications() then visitSpecifications(pcmp.getSpecifications());
  --if pcmp.hasExpression() then visitExpression(pcmp.getExpression());
  result := str ^ result ^ "--END FileName: " ^ pcmp.getFilename();
);
    
public visitSpecifications: IOmlSpecifications ==> ()
visitSpecifications(pcmp) ==
( dcl str : seq of char := nl;
  for node in pcmp.getClassList() do
  (
    printNodeField(node);
    str := str ^ nl ^ result ^nl;
  );
  result := str;
);
     
public visitClass: IOmlClass ==> ()
visitClass(pcmp) ==
( dcl str : seq of char := "class " ^ pcmp.getIdentifier();
     
  if pcmp.hasInheritanceClause()
  then printNodeField(pcmp.getInheritanceClause())
  else result :="";
  str := str ^ result ^nl;

  for db in pcmp.getClassBody() do
  (  
    printNodeField(db);
    str := str ^ nl ^ result;
  );
        
      --pushNL();
      --str := str ^getNL();
      --printStringField(pcmp.getIdentifier());
      --str := str ^result ^"," ^getNL();
      --printSeqofField(pcmp.getGenericTypes());
      --str := str ^result ^"," ^getNL();
      --if pcmp.hasInheritanceClause()
      --then printNodeField(pcmp.getInheritanceClause())
      --else result := "nil";
      --str := str ^result ^"," ^getNL();
      --printSeqofField(pcmp.getClassBody());
      --str := str ^result ^"," ^getNL();
      --printBoolField(pcmp.getSystemSpec());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getLine());
      --str := str ^result ^"," ^getNL();
      --printNatField(pcmp.getColumn());
      --str := str ^result;
      --popNL();
      --str := str ^getNL() ^")";
      
  result := str ^ nl ^ "end " ^ pcmp.getIdentifier() 
);
    
public visitInheritanceClause: IOmlInheritanceClause ==> ()
visitInheritanceClause(pcmp) ==
( dcl str : seq of char := " is subclass of ",
  list : seq of String := pcmp.getIdentifierList(),
  length : nat := len list, 
  i : nat := 1;
  while i <= length do
  ( str := str ^ list(i);
    i := i+1;
    if i <= length then
    str := str ^ " ,";
  );
  result := str ^ nl;
);
    
public visitValueDefinitions: IOmlValueDefinitions ==> ()
visitValueDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "values" ^ nl;
   
  for db in pcmp.getValueList() do
  (  printNodeField(db);
    str := str ^ result ^nl;
  );
  if len pcmp.getValueList() =0 then 
    result := ""
  else 
    result := str; );
      
public visitValueDefinition: IOmlValueDefinition ==> ()
visitValueDefinition(pcmp) ==
( dcl str : seq of char;
  printNodeField(pcmp.getAccess());
  str := result;
  printNodeField(pcmp.getShape());
  str := str ^ result ^ ";" ^ nl;
  result := str 
);
      
public visitAccessDefinition: IOmlAccessDefinition ==> ()
visitAccessDefinition(pcmp) ==
( dcl str : seq of char := "";-- prefix ^pcmp.identity() ^"(";
      --pushNL();
      --str := str ^getNL();
      --printBoolField(pcmp.getAsyncAccess());
      --str := str ^result ^"," ^getNL();
  if pcmp.getStaticAccess() 
  then str := " static ";
      
  printNodeField(pcmp.getScope());
  str := str ^ result ^ " ";
  result := str 
);
      
public visitScope: IOmlScope ==> ()
visitScope(pNode) == 
( --dcl str : seq of char;-- := prefix ^pNode.identity() ^"(";
  cases pNode.getValue():
   (OmlScopeQuotes`IQPUBLIC) 	    	-> result := "public",
   (OmlScopeQuotes`IQPRIVATE),
   (OmlScopeQuotes`IQDEFAULT)  		-> result := "private",
   (OmlScopeQuotes`IQPROTECTED) 		-> result := "protected",
   others 	                            -> error
  end;
      --result := str 
);

public visitValueShape: IOmlValueShape ==> ()
visitValueShape(pcmp) ==
( dcl str : seq of char; -- := prefix ^pcmp.identity() ^"(";
  printNodeField(pcmp.getPattern());
  str := result ^ " ";
  if pcmp.hasType()
  then
  ( printNodeField(pcmp.getType());
    str := str ^ ":" ^ result ^ " ";
  )
  else result := "";
      
  printNodeField(pcmp.getExpression());
  str := str ^ "=" ^ result ^ " ";
  result := str );  
      
      

          

public visitPattern: IOmlPattern ==> ()
visitPattern(pNode) == pNode.accept(self);
  
public visitExpression: IOmlExpression ==> ()
visitExpression(pNode) == pNode.accept(self);
  
public visitBinaryExpression: IOmlBinaryExpression ==> ()
visitBinaryExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getLhsExpression());
    str := str ^result;
    printNodeField(pcmp.getOperator());
    str := str ^result;
    printNodeField(pcmp.getRhsExpression());
    str := str ^result ^ nl;
    result := str );

public visitUnaryExpression: IOmlUnaryExpression ==> ()
visitUnaryExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getOperator());
    str := str ^result;
    printNodeField(pcmp.getExpression());
    str := str ^result ^ nl;
    result := str );

public visitBinaryOperator: IOmlBinaryOperator ==> ()
visitBinaryOperator(pNode) == 
 result :=
 cases pNode.getValue():
  (OmlBinaryOperatorQuotes`IQMODIFY     )-> "++",
  (OmlBinaryOperatorQuotes`IQGE         )-> ">=",
  (OmlBinaryOperatorQuotes`IQLT         )-> "<",
  (OmlBinaryOperatorQuotes`IQPSUBSET    )-> " psubset ",
  (OmlBinaryOperatorQuotes`IQMOD        )-> " mod ",
  (OmlBinaryOperatorQuotes`IQMAPDOMRESBY)-> "<-:",
  (OmlBinaryOperatorQuotes`IQINTER      )-> " inter ",
  (OmlBinaryOperatorQuotes`IQCOMP       )-> " comp ",
  (OmlBinaryOperatorQuotes`IQMINUS      )-> "-",
  (OmlBinaryOperatorQuotes`IQREM        )-> " rem ",
  (OmlBinaryOperatorQuotes`IQAND        )-> " and ",
  (OmlBinaryOperatorQuotes`IQUNION      )-> " union ",
  (OmlBinaryOperatorQuotes`IQINSET      )-> " in set ",
  (OmlBinaryOperatorQuotes`IQEQUIV      )-> "<=>",
  (OmlBinaryOperatorQuotes`IQMAPRNGRESTO)-> ":>",
  (OmlBinaryOperatorQuotes`IQITERATE    )-> "**",
  (OmlBinaryOperatorQuotes`IQSUBSET     )-> " subset ",
  (OmlBinaryOperatorQuotes`IQMAPRNGRESBY)-> ":->",
  (OmlBinaryOperatorQuotes`IQTUPSEL     )-> "#.",
  (OmlBinaryOperatorQuotes`IQNOTINSET   )-> " not in set ",
  (OmlBinaryOperatorQuotes`IQMULTIPLY   )-> "*",
  (OmlBinaryOperatorQuotes`IQIMPLY      )-> "=>",
  (OmlBinaryOperatorQuotes`IQOR         )-> " or ",
  (OmlBinaryOperatorQuotes`IQGT         )-> ">",
  (OmlBinaryOperatorQuotes`IQPLUS       )-> "+",
  (OmlBinaryOperatorQuotes`IQMUNION     )-> " munion ",
  (OmlBinaryOperatorQuotes`IQMAPDOMRESTO)-> "<:",
  (OmlBinaryOperatorQuotes`IQEQ         )-> "=",
  (OmlBinaryOperatorQuotes`IQDIV        )-> " div ",
  (OmlBinaryOperatorQuotes`IQDIFFERENCE )-> "-",
  (OmlBinaryOperatorQuotes`IQCONC       )-> "^",
  (OmlBinaryOperatorQuotes`IQLE         )-> "<=",
  (OmlBinaryOperatorQuotes`IQDIVIDE     )-> "/",
  (OmlBinaryOperatorQuotes`IQNE         )-> "<>"
end;

public visitUnaryOperator: IOmlUnaryOperator ==> ()
visitUnaryOperator(pNode) == 
 result :=
 cases pNode.getValue():
    (OmlUnaryOperatorQuotes`IQABS    ) -> "abs ",
    (OmlUnaryOperatorQuotes`IQINVERSE) -> "inverse ",
    (OmlUnaryOperatorQuotes`IQHD     ) -> "hd ",
    (OmlUnaryOperatorQuotes`IQELEMS  ) -> "elems ",
    (OmlUnaryOperatorQuotes`IQINDS   ) -> "inds ",
    (OmlUnaryOperatorQuotes`IQTL     ) -> "tl ",
    (OmlUnaryOperatorQuotes`IQCARD   ) -> "card ",
    (OmlUnaryOperatorQuotes`IQDUNION ) -> "dunion ",
    (OmlUnaryOperatorQuotes`IQPOWER  ) -> "power ",
    (OmlUnaryOperatorQuotes`IQLEN    ) -> "len ",
    (OmlUnaryOperatorQuotes`IQPLUS   ) -> "+",
    (OmlUnaryOperatorQuotes`IQDOM    ) -> "dom ",
    (OmlUnaryOperatorQuotes`IQDMERGE ) -> "merge ",
    (OmlUnaryOperatorQuotes`IQDINTER ) -> "dinter ",
    (OmlUnaryOperatorQuotes`IQNOT    ) -> "not ",
    (OmlUnaryOperatorQuotes`IQMINUS  ) -> "-",
    (OmlUnaryOperatorQuotes`IQRNG    ) -> "rng ",
    (OmlUnaryOperatorQuotes`IQFLOOR  ) -> "floor ",
    (OmlUnaryOperatorQuotes`IQDCONC  ) -> "conc "
  end;


public visitSetEnumeration: IOmlSetEnumeration ==> ()
visitSetEnumeration(pcmp) ==
  ( dcl str : seq of char := "{";
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^"}";
    result := str );

public visitLetExpression: IOmlLetExpression ==> ()
visitLetExpression(pcmp) ==
  ( dcl str : seq of char := "let ";
    printSeqofField(pcmp.getDefinitionList());
    str := str ^result ^ nl ^ " in ";
    printNodeField(pcmp.getExpression());
    str := str ^result ^ nl;
    result := str );

public visitFieldSelect: IOmlFieldSelect ==> ()
visitFieldSelect(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getExpression());
    str := str ^result ^"."; 
    printNodeField(pcmp.getName());
    str := str ^result;
    result := str );

public visitApplyExpression: IOmlApplyExpression ==> ()
visitApplyExpression(pcmp) ==
  ( dcl str : seq of char := "";
    printNodeField(pcmp.getExpression());
    str := str ^result ^"("; 
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitTupleConstructor: IOmlTupleConstructor ==> ()
visitTupleConstructor(pcmp) ==
  ( dcl str : seq of char := "mk_(";
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitRecordConstructor: IOmlRecordConstructor ==> ()
visitRecordConstructor(pcmp) ==
  ( dcl str : seq of char := "mk_";
    printNodeField(pcmp.getName());
    str := str ^result ^"("; 
    printSeqofField(pcmp.getExpressionList());
    str := str ^result ^")";
    result := str );

public visitTokenExpression: IOmlTokenExpression ==> ()
visitTokenExpression(pcmp) ==
  ( dcl str : seq of char := "mk_token(";
    printNodeField(pcmp.getExpression());
    str := str ^result ^")";
    result := str );

public visitLiteral: IOmlLiteral ==> ()
visitLiteral(pNode) == pNode.accept(self);
  
public visitType: IOmlType ==> ()
visitType(pNode) == pNode.accept(self);
  
public visitPatternIdentifier: IOmlPatternIdentifier ==> ()
visitPatternIdentifier(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^" ";
  result := str );
      
public visitSymbolicLiteralExpression: IOmlSymbolicLiteralExpression ==> ()
visitSymbolicLiteralExpression(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getLiteral());
  -- := str ^result;
  --str := str ^")";
  --result := str 
);
      
public visitTextLiteral: IOmlTextLiteral ==> ()
visitTextLiteral(pcmp) ==
( dcl str : seq of char := pcmp.getVal();
  result := "\"" ^ str ^ "\"" );
      
public visitCharacterLiteral: IOmlCharacterLiteral ==> ()
visitCharacterLiteral(pcmp) ==
 ( dcl str : seq of char := "\'";
   printCharField(pcmp.getVal());
   str := str ^result ^"\'";
   result := str );

public visitSeq0Type: IOmlSeq0Type ==> ()
visitSeq0Type(pcmp) ==
( dcl str : seq of char := "seq of ";
  printNodeField(pcmp.getType());
  str := str ^ result;
  result := str );
      
public visitCharType: IOmlCharType ==> ()
visitCharType(-) ==
( dcl str : seq of char := "char";
  result := str );
      
public visitInstanceVariableDefinitions: IOmlInstanceVariableDefinitions ==> ()
visitInstanceVariableDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "instance variables" ^ nl ^ nl;
    
  for db in pcmp.getVariablesList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;
  );
  if len pcmp.getVariablesList() =0 then 
    result := ""
  else 
    result := str  );

public visitInstanceVariable: IOmlInstanceVariable ==> ()
visitInstanceVariable(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^ result; 
  printNodeField(pcmp.getAssignmentDefinition());
  str := str ^ result ;
  result := str );
      
public visitAssignmentDefinition: IOmlAssignmentDefinition ==> ()
visitAssignmentDefinition(pcmp) ==
( dcl str : seq of char := "";
  str := str ^ pcmp.getIdentifier();
  printNodeField(pcmp.getType());
  str := str ^ " : " ^ result;
  if pcmp.hasExpression()
  then 
  (printNodeField(pcmp.getExpression());
   str := str ^" := ";
  )
  else result := "";
  str := str ^ result ^";";
  result := str );
      
public visitTypeName: IOmlTypeName ==> ()
visitTypeName(pcmp) ==
( --dcl str : seq of char := prefix ^pcmp.identity() ^"(";
  printNodeField(pcmp.getName());
);

public visitName: IOmlName ==> ()
visitName(pcmp) ==
( dcl str : seq of char := "";
  if pcmp.hasClassIdentifier()
  then str := str ^ pcmp.getClassIdentifier() ^ "`";
  str := str ^ pcmp.getIdentifier();
  result := str );
      
public visitIntType: IOmlIntType ==> ()
visitIntType(-) ==
( dcl str : seq of char := "int";
  result := str );
      
public visitNatType: IOmlNatType ==> ()
visitNatType(-) ==
( dcl str : seq of char := "nat";
  result := str );
      
public visitNat1Type: IOmlNat1Type ==> ()
visitNat1Type(-) ==
( dcl str : seq of char := "nat1";
  result := str );
  
public visitBoolType: IOmlBoolType ==> ()
visitBoolType(-) ==
( dcl str : seq of char := "bool";
  result := str );
      
public visitSeq1Type: IOmlSeq1Type ==> ()
visitSeq1Type(pcmp) ==
( dcl str : seq of char := "seq1 of ";
  printNodeField(pcmp.getType());
  str := str ^result;
  result := str );
      
public visitRealType: IOmlRealType ==> ()
visitRealType(-) ==
( dcl str : seq of char := "real";
  result := str );
      
public visitSetType: IOmlSetType ==> ()
visitSetType(pcmp) ==
( dcl str : seq of char := "set of ";
  printNodeField(pcmp.getType());
  str := str ^result;
  result := str );
      
public visitTypeDefinitions: IOmlTypeDefinitions ==> ()
visitTypeDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "types" ^ nl ^ nl;
    
  for db in pcmp.getTypeList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    result := str;
);
    
public visitTypeDefinition: IOmlTypeDefinition ==> ()
visitTypeDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result ^";";
  result := str );
      
public visitSimpleType: IOmlSimpleType ==> ()
visitSimpleType(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier();
  printNodeField(pcmp.getType());
  result := str ^ " = " ^ result);
  
 public visitEmptyType: IOmlEmptyType ==> ()
  visitEmptyType(-) ==
    ( dcl str : seq of char := "()";
      result := str );

public visitNewExpression: IOmlNewExpression ==> ()
visitNewExpression(pcmp) ==
( dcl str : seq of char := "new ";
  printNodeField(pcmp.getName());
  str := str ^result ^ "(";
      --printSeqofField(pcmp.getGenericTypes());
      --str := str ^result ^"," ^getNL();
  printSeqofField(pcmp.getExpressionList());
  str := str ^result ^")" ^ nl;
      --printNatField(pcmp.getLine());
      --str := str ^result ^"," nl;
      --printNatField(pcmp.getColumn());
      --str := str ^result;
      --popNL();
  result := str );
      
public visitIfExpression: IOmlIfExpression ==> ()
visitIfExpression(pcmp) ==
 ( dcl str : seq of char := "if ";
   printNodeField(pcmp.getIfExpression());
   str := str ^result ^" then " ^ nl;
   printNodeField(pcmp.getThenExpression());
   str := str ^result ^ nl;
   printSeqofField(pcmp.getElseifExpressionList());
   str := str ^result ^" else ";
   printNodeField(pcmp.getElseExpression());
   str := str ^ result;
   result := str );

public visitElseIfExpression: IOmlElseIfExpression ==> ()
visitElseIfExpression(pcmp) ==
 ( dcl str : seq of char := " elseif ";
   printNodeField(pcmp.getElseifExpression());
   str := str ^result ^" then ";
   printNodeField(pcmp.getThenExpression());
   str := str ^result ^ nl;
   result := str );

public visitBracketedExpression: IOmlBracketedExpression ==> ()
visitBracketedExpression(pcmp) ==
 ( dcl str : seq of char := "(";
   printNodeField(pcmp.getExpression());
   str := str ^result;
   str := str ^")";
   result := str );

public visitNumericLiteral: IOmlNumericLiteral==> ()--IOmlRealLiteral printField
visitNumericLiteral(pcmp) ==
(dcl str : seq of char := "";
  printNatField(pcmp.getVal());
  str := result;
  result := str );
  


public visitRealLiteral: IOmlRealLiteral ==> () 
visitRealLiteral(pcmp) ==
( dcl str : seq of char := "";
  printRealField(pcmp.getVal());
  str := result;
  result := str );
      
public visitQuoteLiteral: IOmlQuoteLiteral ==> ()
visitQuoteLiteral(pcmp) ==
 ( dcl str : seq of char := "<";
   printStringField(pcmp.getVal());
   str := str ^result(2,...,len result - 1) ^">";
   result := str );

public visitBooleanLiteral: IOmlBooleanLiteral ==> ()
visitBooleanLiteral(pcmp) ==
 ( dcl str : seq of char := "";
   printBoolField(pcmp.getVal());
   result := " " ^ result ^ " " );

public visitNilLiteral: IOmlNilLiteral ==> ()
visitNilLiteral(pcmp) ==
  result := " nil ";

public visitOperationDefinitions: IOmlOperationDefinitions ==> ()
visitOperationDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "operations" ^ nl ^ nl;
    
  for db in pcmp.getOperationList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    
    if len pcmp.getOperationList()>0 then
    result := str
    else
    result :="";
);
    
public visitOperationDefinition: IOmlOperationDefinition ==> ()
visitOperationDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result;
  result := str );
      
public visitExplicitOperation: IOmlExplicitOperation ==> ()
visitExplicitOperation(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^ " : ";
  --printNodeField(pcmp.getType());
  printNodeField(pcmp.getType());
  str := str ^result;
  str := str ^ nl ^ pcmp.getIdentifier() ^ "(";
  if len pcmp.getParameterList() > 0
  then 
  (
    for db in pcmp.getParameterList() do
    ( printNodeField(db);
      str := str ^ result ^", ";);
      str := str(1,...,len str -2); 
  )  ;  
  str := str ^ ") == ";
    --  printSeqofField(pcmp.getParameterList());
    --  str := str ^result ^"," ^getNL();
      printNodeField(pcmp.getBody());
     str := str ^result ^";"^nl;
   
  result := str );
      
public visitOperationType: IOmlOperationType ==> ()
visitOperationType(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getDomType());
  str := str ^result ^ " ==> ";
  printNodeField(pcmp.getRngType());
  str := str ^result;
  result := str );
  
  public visitOperationBody: IOmlOperationBody ==> ()
  visitOperationBody(pcmp) ==
    ( dcl str : seq of char := "(";
      
      
      if pcmp.getNotYetSpecified()then
      ( result := "is not yet specified";
        return;
      )
      else
      (  if pcmp.hasStatement()
        then printNodeField(pcmp.getStatement())
        else result := "";
        str := str ^result;
      );
      if pcmp.getSubclassResponsibility() then
      (
         result := "sub class responsibility";
         return;
      );
     
      str := str ^")";
      result := str );
      
  public visitSkipStatement: IOmlSkipStatement ==> ()
  visitSkipStatement(-) ==
    ( dcl str : seq of char := "skip";
      result := str );
      
public visitParameter: IOmlParameter ==> ()
visitParameter(pcmp) ==
( dcl str : seq of char := "";
  for db in pcmp.getPatternList() do
  ( printNodeField(db);
    str := str ^ result ^", ";);
    str := str(1,...,len str -2);-- ", ";
  result := str );
      
public visitFunctionDefinitions: IOmlFunctionDefinitions ==> ()
visitFunctionDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "functions" ^ nl ^ nl;
    
  for db in pcmp.getFunctionList() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
    result := str;
);

public visitFunctionDefinition: IOmlFunctionDefinition ==> ()
visitFunctionDefinition(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getAccess());
  str := str ^result;
  printNodeField(pcmp.getShape());
  str := str ^result;
  result := str );
      
public visitExplicitFunction: IOmlExplicitFunction ==> ()
visitExplicitFunction(pcmp) ==
( dcl str : seq of char := pcmp.getIdentifier() ^ " : ";
  if len pcmp.getTypeVariableList() > 0
  then
  (
    for db in pcmp.getTypeVariableList() do
    ( printNodeField(db);
      str := str ^ result ^"* ";);  
    str := str(1,...,len str -2);
    
  );
 -- str := str ^" -> ";    
  printNodeField(pcmp.getType());
  str := str ^result;
  str := str ^ nl ^ pcmp.getIdentifier() ^ "(";
  for db in pcmp.getParameterList() do
  ( printNodeField(db);
    str := str ^ result ^", ";);
  str := str(1,...,len str -2);
  str := str ^ ") == is not yet specified;";
    --  printSeqofField(pcmp.getParameterList());
    --  str := str ^result ^"," ^getNL();
    --  printNodeField(pcmp.getBody());
   --   str := str ^result ^"," ^getNL();
   
  result := str );
      
public visitPartialFunctionType: IOmlPartialFunctionType ==> ()
visitPartialFunctionType(pcmp) ==
( dcl str : seq of char := "";
  printNodeField(pcmp.getDomType());
  str := str ^result ^ " -> ";
  printNodeField(pcmp.getRngType());
  str := str ^result;
  result := str );
      
public visitUnionType: IOmlUnionType ==> ()
visitUnionType(pcmp) ==
(
  dcl str : seq of char := "";
  pcmp.getLhsType().accept(self);
  str := str ^ result;
  pcmp.getRhsType().accept(self);
  str := str ^ " | " ^ result;
  
  result := str;
  
);
  
public visitProductType: IOmlProductType ==> ()
visitProductType(pcmp) ==
(
  dcl str : seq of char := "";
  pcmp.getLhsType().accept(self);
  str := str ^ result;
  pcmp.getRhsType().accept(self);
  str := str ^ " * " ^ result;
  
  result := str;
  
);
  
  
  
  
  
  
public visitTraceDefinitions: IOmlTraceDefinitions ==> ()
visitTraceDefinitions(pcmp) ==
( dcl str : seq of char := nl ^ "traces" ^ nl ^nl;
  for db in pcmp.getTraces() do
  ( printNodeField(db);
    str := str ^ result ^ nl;);
  result := str;
   
);
       
       
public visitNamedTrace: IOmlNamedTrace ==> ()
visitNamedTrace(pcmp) ==
( dcl str : seq of char := "  ";
  str := str ^pcmp.getName() ^" : ";
     
  printNodeField(pcmp.getDefs());
  str := str ^result ;
     
  result := str;
);
     
public visitTraceDefinition: IOmlTraceDefinition ==> ()
visitTraceDefinition(pNode) == pNode.accept(self);
  
public visitTraceDefinitionItem: IOmlTraceDefinitionItem ==> ()
visitTraceDefinitionItem(pcmp) ==
( dcl str : seq of char := "";
     
  printSeqofField(pcmp.getBind());
  str := str ^result;
  printNodeField(pcmp.getTest());
  str := str ^result;
  if pcmp.hasRegexpr()
  then printNodeField(pcmp.getRegexpr())
  else result := "";
  str := str ^result;
  result := str );
      
public visitTraceBinding: IOmlTraceBinding ==> ()
visitTraceBinding(pNode) == pNode.accept(self);
  
public visitTraceLetBinding: IOmlTraceLetBinding ==> ()
visitTraceLetBinding(pcmp) ==
( dcl str : seq of char := "let ";
  printSeqofField(pcmp.getDefinitionList());
  str := str ^result ^ " in ";
     
  result := str );
         
public visitTraceBracketedDefinition: IOmlTraceBracketedDefinition ==> ()
visitTraceBracketedDefinition(pcmp) ==
( dcl str : seq of char := "(";
  printNodeField(pcmp.getDefinition());
  str := str ^result^")";
  result := str );
      
public visitTraceMethodApply: IOmlTraceMethodApply ==> ()
visitTraceMethodApply(pcmp) ==
( dcl str : seq of char := "";     
  str := str ^pcmp.getVariableName() ^".";
  str := str ^pcmp.getMethodName()^"(";
  printSeqofField(pcmp.getArgs());
  str := str ^result ^")";
  result := str );
      
public visitTraceCoreDefinition: IOmlTraceCoreDefinition ==> ()
visitTraceCoreDefinition(pNode) == pNode.accept(self);

public visitTraceRepeatPattern: IOmlTraceRepeatPattern ==> ()
visitTraceRepeatPattern(pNode) == pNode.accept(self);
  
public visitTraceZeroOrMore: IOmlTraceZeroOrMore ==> ()
visitTraceZeroOrMore(-) ==
( dcl str : seq of char := "*";
  result := str );
      
      
public visitTraceOneOrMore: IOmlTraceOneOrMore ==> ()
visitTraceOneOrMore(-) ==
( dcl str : seq of char := "+";
  result := str );
      
public visitTraceZeroOrOne: IOmlTraceZeroOrOne ==> ()
visitTraceZeroOrOne(-) ==
( dcl str : seq of char := "?";
  result := str );
      
public visitTraceRange: IOmlTraceRange ==> ()
visitTraceRange(pcmp) ==
( dcl str : seq of char := "{";
  printNodeField(pcmp.getLower());
  str := str ^result  ;
  if pcmp.hasUpper()
  then 
  (
    printNodeField(pcmp.getUpper());
    str := str ^"," ^result;
  );
  str := str ^"}";
  result := str );
  
  
public visitTraceChoiceDefinition: IOmlTraceChoiceDefinition ==> ()
visitTraceChoiceDefinition(pcmp) ==
( dcl str : seq of char := "", count : nat := 1;
  for db in pcmp.getDefs() do
  ( printNodeField(db);
    if len pcmp.getDefs() = count then str := str ^result
    else str := str^ result ^" | ";
    count := count + 1;
   );
    result := str;
);
       
       
public visitTraceSequenceDefinition: IOmlTraceSequenceDefinition ==> ()
visitTraceSequenceDefinition(pcmp) ==
( dcl str : seq of char := "", count : nat := 1;
  for db in pcmp.getDefs() do
  ( printNodeField(db);
    if len pcmp.getDefs() = count then str := str ^result
    else str := str^ result ^" ; ";
    count := count + 1;
   );
    result := str;
);



---------------------------------------------------------------------
--   Operations below this comment is not implemented and
--    thus not supported. They are included in such a way
--    that they return a "NOT YES SUPPORTED" result
---------------------------------------------------------------------
  public visitLexem: IOmlLexem ==> ()
  visitLexem (-) == result := "NOT YET SUPPORTED";


  public visitOldName: IOmlOldName ==> ()
  visitOldName (-) == result := "NOT YET SUPPORTED";


  public visitSeqConcPattern: IOmlSeqConcPattern ==> ()
  visitSeqConcPattern (-) == result := "NOT YET SUPPORTED";


  public visitPeriodicThread: IOmlPeriodicThread ==> ()
  visitPeriodicThread (-) == result := "NOT YET SUPPORTED";


  public visitCallStatement: IOmlCallStatement ==> ()
  visitCallStatement (-) == result := "NOT YET SUPPORTED";


  public visitIsofclassExpression: IOmlIsofclassExpression ==> ()
  visitIsofclassExpression (pcmp) == 
    ( dcl str : seq of char := "isofclass(";
      printNodeField(pcmp.getName());
      str := str ^result ^",";
      printNodeField(pcmp.getExpression());
      str := str ^result ^")";
      result := str );

  public visitIndexForLoop: IOmlIndexForLoop ==> ()
  visitIndexForLoop (-) == result := "NOT YET SUPPORTED";


  public visitReqExpression: IOmlReqExpression ==> ()
  visitReqExpression (-) == result := "NOT YET SUPPORTED";


  public visitPermissionPredicate: IOmlPermissionPredicate ==> ()
  visitPermissionPredicate (-) == result := "NOT YET SUPPORTED";


  public visitProcedureThread: IOmlProcedureThread ==> ()
  visitProcedureThread (-) == result := "NOT YET SUPPORTED";


  public visitMapEnumeration: IOmlMapEnumeration ==> ()
  visitMapEnumeration (pcmp) == 
    ( dcl str : seq of char := "{";
      printSeqofField(pcmp.getMapletList());
      str := str ^result ^"}";
      result := str );

  public visitAtomicStatement: IOmlAtomicStatement ==> ()
  visitAtomicStatement (-) == result := "NOT YET SUPPORTED";


  public visitFieldReference: IOmlFieldReference ==> ()
  visitFieldReference (-) == result := "NOT YET SUPPORTED";


  public visitBlockStatement: IOmlBlockStatement ==> ()
  visitBlockStatement (-) == result := "NOT YET SUPPORTED";


  public visitInjectiveMapType: IOmlInjectiveMapType ==> ()
  visitInjectiveMapType (-) == result := "NOT YET SUPPORTED";


  public visitMatchValue: IOmlMatchValue ==> ()
  visitMatchValue (-) == result := "NOT YET SUPPORTED";


  public visitOperationTrailer: IOmlOperationTrailer ==> ()
  visitOperationTrailer (-) == result := "NOT YET SUPPORTED";


  public visitTypeBind: IOmlTypeBind ==> ()
  visitTypeBind (-) == result := "NOT YET SUPPORTED";


  public visitRecordModifier: IOmlRecordModifier ==> ()
  visitRecordModifier (-) == result := "NOT YET SUPPORTED";


  public visitObjectDesignatorExpression: IOmlObjectDesignatorExpression ==> ()
  visitObjectDesignatorExpression (-) == result := "NOT YET SUPPORTED";


  public visitIdentifierTypePair: IOmlIdentifierTypePair ==> ()
  visitIdentifierTypePair (-) == result := "NOT YET SUPPORTED";


  public visitPatternBindExpression: IOmlPatternBindExpression ==> ()
  visitPatternBindExpression (-) == result := "NOT YET SUPPORTED";


  public visitTrapDefinition: IOmlTrapDefinition ==> ()
  visitTrapDefinition (-) == result := "NOT YET SUPPORTED";


  public visitSelfExpression: IOmlSelfExpression ==> ()
  visitSelfExpression (-) == result := " self ";


  public visitRecursiveTrapStatement: IOmlRecursiveTrapStatement ==> ()
  visitRecursiveTrapStatement (-) == result := "NOT YET SUPPORTED";


  public visitWhileLoop: IOmlWhileLoop ==> ()
  visitWhileLoop (-) == result := "NOT YET SUPPORTED";


  public visitDefStatement: IOmlDefStatement ==> ()
  visitDefStatement (-) == result := "NOT YET SUPPORTED";


  public visitSetForLoop: IOmlSetForLoop ==> ()
  visitSetForLoop (-) == result := "NOT YET SUPPORTED";


  public visitDefExpression: IOmlDefExpression ==> ()
  visitDefExpression (pcmp) == 
    ( dcl str : seq of char := "def ";
      printSeqofField(pcmp.getPatternBindList());
      str := str ^result ^" in ";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitDurationStatement: IOmlDurationStatement ==> ()
  visitDurationStatement (-) == result := "NOT YET SUPPORTED";


  public visitImplicitOperation: IOmlImplicitOperation ==> ()
  visitImplicitOperation (-) == result := "NOT YET SUPPORTED";


  public visitTypeVariable: IOmlTypeVariable ==> ()
  visitTypeVariable (-) == result := "NOT YET SUPPORTED";


  public visitCompositeType: IOmlCompositeType ==> ()
  visitCompositeType (-) == result := "NOT YET SUPPORTED";


  public visitCasesStatementAlternative: IOmlCasesStatementAlternative ==> ()
  visitCasesStatementAlternative (-) == result := "NOT YET SUPPORTED";


  public visitActiveExpression: IOmlActiveExpression ==> ()
  visitActiveExpression (-) == result := "NOT YET SUPPORTED";


  public visitForAllExpression: IOmlForAllExpression ==> ()
  visitForAllExpression (pcmp) == 
    ( dcl str : seq of char := "forall ";
      printSeqofField(pcmp.getBindList());
      str := str ^result ^" in ";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitCasesExpression: IOmlCasesExpression ==> ()
  visitCasesExpression (-) == result := "NOT YET SUPPORTED";


  public visitCasesStatement: IOmlCasesStatement ==> ()
  visitCasesStatement (-) == result := "NOT YET SUPPORTED";


  public visitErrorStatement: IOmlErrorStatement ==> ()
  visitErrorStatement (-) == result := "NOT YET SUPPORTED";


  public visitImplicitFunction: IOmlImplicitFunction ==> ()
  visitImplicitFunction (-) == result := "NOT YET SUPPORTED";


  public visitSamebaseclassExpression: IOmlSamebaseclassExpression ==> ()
  visitSamebaseclassExpression (-) == result := "NOT YET SUPPORTED";


  public visitComplexType: IOmlComplexType ==> ()
  visitComplexType (-) == result := "NOT YET SUPPORTED";


  public visitExternals: IOmlExternals ==> ()
  visitExternals (-) == result := "NOT YET SUPPORTED";


  public visitSubsequenceExpression: IOmlSubsequenceExpression ==> ()
  visitSubsequenceExpression (pcmp) == 
    ( dcl str : seq of char := "";
      printNodeField(pcmp.getExpression());
      str := str ^result ^"(";
      printNodeField(pcmp.getLower());
      str := str ^result ^",...,";
      printNodeField(pcmp.getUpper());
      str := str ^result ^")";
      result := str );

  public visitElseIfStatement: IOmlElseIfStatement ==> ()
  visitElseIfStatement (-) == result := "NOT YET SUPPORTED";


  public visitGeneralMapType: IOmlGeneralMapType ==> ()
  visitGeneralMapType (-) == result := "NOT YET SUPPORTED";


  public visitSpecificationStatement: IOmlSpecificationStatement ==> ()
  visitSpecificationStatement (-) == result := "NOT YET SUPPORTED";


  public visitTuplePattern: IOmlTuplePattern ==> ()
  visitTuplePattern (-) == result := "NOT YET SUPPORTED";


  public visitField: IOmlField ==> ()
  visitField (-) == result := "NOT YET SUPPORTED";


  public visitTokenType: IOmlTokenType ==> ()
  visitTokenType (-) == result := "NOT YET SUPPORTED";


  public visitSameclassExpression: IOmlSameclassExpression ==> ()
  visitSameclassExpression (-) == result := "NOT YET SUPPORTED";


  public visitExitStatement: IOmlExitStatement ==> ()
  visitExitStatement (-) == result := "NOT YET SUPPORTED";


  public visitExistsExpression: IOmlExistsExpression ==> ()
  visitExistsExpression (pcmp) == 
    ( dcl str : seq of char := "exists ";
      printSeqofField(pcmp.getBindList());
      str := str ^result ^"&";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitFunctionTypeInstantiation: IOmlFunctionTypeInstantiation ==> ()
  visitFunctionTypeInstantiation (-) == result := "NOT YET SUPPORTED";


  public visitSequenceEnumeration: IOmlSequenceEnumeration ==> ()
  visitSequenceEnumeration (pcmp) == 
    ( dcl str : seq of char := "[";
      printSeqofField(pcmp.getExpressionList());
      str := str ^result ^"]";
      result := str );

  public visitObjectApply: IOmlObjectApply ==> ()
  visitObjectApply (-) == result := "NOT YET SUPPORTED";


  public visitSetUnionPattern: IOmlSetUnionPattern ==> ()
  visitSetUnionPattern (-) == result := "NOT YET SUPPORTED";


  public visitStartStatement: IOmlStartStatement ==> ()
  visitStartStatement (-) == result := "NOT YET SUPPORTED";


  public visitError: IOmlError ==> ()
  visitError (-) == result := "NOT YET SUPPORTED";


  public visitIfStatement: IOmlIfStatement ==> ()
  visitIfStatement (-) == result := "NOT YET SUPPORTED";


  public visitLetBeExpression: IOmlLetBeExpression ==> ()
  visitLetBeExpression (pcmp) == 
    ( dcl str : seq of char := "let ";
      printNodeField(pcmp.getBind());
      str := str ^result;
      if pcmp.hasBest()
      then (printNodeField(pcmp.getBest());
            str := " be st " ^ result ^ " in ");
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitTotalFunctionType: IOmlTotalFunctionType ==> ()
  visitTotalFunctionType (-) == result := "NOT YET SUPPORTED";


  public visitSporadicThread: IOmlSporadicThread ==> ()
  visitSporadicThread (-) == result := "NOT YET SUPPORTED";


  public visitMapComprehension: IOmlMapComprehension ==> ()
  visitMapComprehension (pcmp) == 
    ( dcl str : seq of char := "{";
      printNodeField(pcmp.getExpression());
      str := str ^result ^"|";
      printSeqofField(pcmp.getBindList());
      str := str ^result;
      if pcmp.hasGuard()
      then (printNodeField(pcmp.getGuard());
            str := "&" ^ result);
      str := str ^ "}";
      result := str );

  public visitSetBind: IOmlSetBind ==> ()
  visitSetBind (pBind) == 
  ( dcl str : seq of char := "";
    let pat_l = pBind.getPattern(),
        set_e = pBind.getExpression()
    in
      (printSeqofField(pat_l);
       str := result ^ " in set ";
       printNodeField(set_e);
       result := str ^ result)
  );


  public visitNondeterministicStatement: IOmlNondeterministicStatement ==> ()
  visitNondeterministicStatement (-) == result := "NOT YET SUPPORTED";


  public visitSymbolicLiteralPattern: IOmlSymbolicLiteralPattern ==> ()
  visitSymbolicLiteralPattern (-) == result := "NOT YET SUPPORTED";


  public visitOptionalType: IOmlOptionalType ==> ()
  visitOptionalType (-) == result := "NOT YET SUPPORTED";


  public visitMutexAllPredicate: IOmlMutexAllPredicate ==> ()
  visitMutexAllPredicate (-) == result := "NOT YET SUPPORTED";


  public visitSequenceComprehension: IOmlSequenceComprehension ==> ()
  visitSequenceComprehension (-) == result := "NOT YET SUPPORTED";


  public visitEqualsDefinition: IOmlEqualsDefinition ==> ()
  visitEqualsDefinition (-) == result := "NOT YET SUPPORTED";


  public visitMaplet: IOmlMaplet ==> ()
  visitMaplet (pcmp) == 
    ( dcl str : seq of char := "";
      printNodeField(pcmp.getDomExpression());
      str := str ^result ^"|->";
      printNodeField(pcmp.getRngExpression());
      str := str ^result;
      result := str );

  public visitExistsUniqueExpression: IOmlExistsUniqueExpression ==> ()
  visitExistsUniqueExpression (pcmp) == 
    ( dcl str : seq of char := "exists1 ";
      printNodeField(pcmp.getBind());
      str := str ^result ^"&";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );


  public visitThreadIdExpression: IOmlThreadIdExpression ==> ()
  visitThreadIdExpression (-) == result := "NOT YET SUPPORTED";


  public visitExtendedExplicitOperation: IOmlExtendedExplicitOperation ==> ()
  visitExtendedExplicitOperation (-) == result := "NOT YET SUPPORTED";


public visitSetComprehension: IOmlSetComprehension ==> ()
visitSetComprehension (pcmp) == 
   ( dcl str : seq of char := "{";
     printNodeField(pcmp.getExpression());
     str := str ^result ^"|";
     printSeqofField(pcmp.getBindList());
     str := str ^result;
     if pcmp.hasGuard()
     then (printNodeField(pcmp.getGuard());
           str := str ^ " & " ^ result);
     str := str ^ "}";
     result := str );

  public visitIotaExpression: IOmlIotaExpression ==> ()
  visitIotaExpression (pcmp) == 
    ( dcl str : seq of char := "iota ";
      printNodeField(pcmp.getBind());
      str := str ^result ^"&";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitReturnStatement: IOmlReturnStatement ==> ()
  visitReturnStatement (-) == result := "NOT YET SUPPORTED";


  public visitSetEnumPattern: IOmlSetEnumPattern ==> ()
  visitSetEnumPattern (-) == result := "NOT YET SUPPORTED";


  public visitTrapStatement: IOmlTrapStatement ==> ()
  visitTrapStatement (-) == result := "NOT YET SUPPORTED";


  public visitFunctionTypeSelect: IOmlFunctionTypeSelect ==> ()
  visitFunctionTypeSelect (-) == result := "NOT YET SUPPORTED";


  public visitClassTypeInstantiation: IOmlClassTypeInstantiation ==> ()
  visitClassTypeInstantiation (-) == result := "NOT YET SUPPORTED";


  public visitCyclesStatement: IOmlCyclesStatement ==> ()
  visitCyclesStatement (-) == result := "NOT YET SUPPORTED";


  public visitPreconditionExpression: IOmlPreconditionExpression ==> ()
  visitPreconditionExpression (pcmp) == 
    ( dcl str : seq of char := "pre_(";
      printSeqofField(pcmp.getExpressionList());
      str := str ^result ^")";
      result := str );

  public visitTraceLetBeBinding: IOmlTraceLetBeBinding ==> ()
  visitTraceLetBeBinding (pcmp) == 
( dcl str : seq of char := "let ";
  printNodeField(pcmp.getBind());
  str := str ^ result ^ " in ";
  if pcmp.hasBest()
  then (printNodeField(pcmp.getBest());
        str := str ^ " be st " ^result);
     
  result := str );

  public visitVarInformation: IOmlVarInformation ==> ()
  visitVarInformation (-) == result := "NOT YET SUPPORTED";


  public visitIsofbaseclassExpression: IOmlIsofbaseclassExpression ==> ()
  visitIsofbaseclassExpression (-) == result := "NOT YET SUPPORTED";


  public visitLetStatement: IOmlLetStatement ==> ()
  visitLetStatement (-) == result := "NOT YET SUPPORTED";


  public visitActExpression: IOmlActExpression ==> ()
  visitActExpression (-) == result := "NOT YET SUPPORTED";


  public visitExceptions: IOmlExceptions ==> ()
  visitExceptions (-) == result := "NOT YET SUPPORTED";


  public visitIsExpression: IOmlIsExpression ==> ()
  visitIsExpression (pcmp) == 
    ( dcl str : seq of char := "is_";
      printNodeField(pcmp.getType());
      str := str ^result;
      printNodeField(pcmp.getExpression());
      str := str ^result ^")";
      result := str );

  public visitCasesExpressionAlternative: IOmlCasesExpressionAlternative ==> ()
  visitCasesExpressionAlternative (-) == result := "NOT YET SUPPORTED";


  public visitLetBeStatement: IOmlLetBeStatement ==> ()
  visitLetBeStatement (-) == result := "NOT YET SUPPORTED";


  public visitMutexPredicate: IOmlMutexPredicate ==> ()
  visitMutexPredicate (-) == result := "NOT YET SUPPORTED";


  public visitUndefinedExpression: IOmlUndefinedExpression ==> ()
  visitUndefinedExpression (-) == 
    result := "undefined";


  public visitAssignStatement: IOmlAssignStatement ==> ()
  visitAssignStatement (-) == result := "NOT YET SUPPORTED";


  public visitSequenceForLoop: IOmlSequenceForLoop ==> ()
  visitSequenceForLoop (-) == result := "NOT YET SUPPORTED";


  public visitWaitingExpression: IOmlWaitingExpression ==> ()
  visitWaitingExpression (-) == result := "NOT YET SUPPORTED";


  public visitInvariant: IOmlInvariant ==> ()
  visitInvariant (-) == result := "NOT YET SUPPORTED";


  public visitObjectFieldReference: IOmlObjectFieldReference ==> ()
  visitObjectFieldReference (-) == result := "NOT YET SUPPORTED";


  public visitBracketedType: IOmlBracketedType ==> ()
  visitBracketedType (-) == result := "NOT YET SUPPORTED";


  public visitFinExpression: IOmlFinExpression ==> ()
  visitFinExpression (-) == result := "NOT YET SUPPORTED";


  public visitSetRangeExpression: IOmlSetRangeExpression ==> ()
  visitSetRangeExpression (pcmp) == 
  ( dcl str : seq of char := "{";
    printField(pcmp.getLower());
    str := str ^result ^",...,";
    printField(pcmp.getUpper());
    str := str ^result ^"}";
    result := str );


  public visitFunctionBody: IOmlFunctionBody ==> ()
  visitFunctionBody (-) == result := "NOT YET SUPPORTED";


  public visitLambdaExpression: IOmlLambdaExpression ==> ()
  visitLambdaExpression (pcmp) == 
    ( dcl str : seq of char := "lambda ";
      printSeqofField(pcmp.getTypeBindList());
      str := str ^result ^"&";
      printNodeField(pcmp.getExpression());
      str := str ^result;
      result := str );

  public visitInstanceVariableInvariant: IOmlInstanceVariableInvariant ==> ()
  visitInstanceVariableInvariant (-) == result := "NOT YET SUPPORTED";


  public visitDontCarePattern: IOmlDontCarePattern ==> ()
  visitDontCarePattern (-) == result := "NOT YET SUPPORTED";


  public visitSeqEnumPattern: IOmlSeqEnumPattern ==> ()
  visitSeqEnumPattern (-) == result := "NOT YET SUPPORTED";


  public visitTypelessExplicitFunction: IOmlTypelessExplicitFunction ==> ()
  visitTypelessExplicitFunction (-) == result := "NOT YET SUPPORTED";


  public visitThreadDefinition: IOmlThreadDefinition ==> ()
  visitThreadDefinition (-) == result := "NOT YET SUPPORTED";


  public visitAlwaysStatement: IOmlAlwaysStatement ==> ()
  visitAlwaysStatement (-) == result := "NOT YET SUPPORTED";


  public visitRecordPattern: IOmlRecordPattern ==> ()
  visitRecordPattern (-) == result := "NOT YET SUPPORTED";


  public visitQuoteType: IOmlQuoteType ==> ()
  visitQuoteType (-) == result := "NOT YET SUPPORTED";


  public visitDclStatement: IOmlDclStatement ==> ()
  visitDclStatement (-) == result := "NOT YET SUPPORTED";


  public visitPatternTypePair: IOmlPatternTypePair ==> ()
  visitPatternTypePair (-) == result := "NOT YET SUPPORTED";


  public visitMapOrSequenceReference: IOmlMapOrSequenceReference ==> ()
  visitMapOrSequenceReference (-) == result := "NOT YET SUPPORTED";


  public visitSynchronizationDefinitions: IOmlSynchronizationDefinitions ==> ()
  visitSynchronizationDefinitions (-) == result := "NOT YET SUPPORTED";


  public visitMuExpression: IOmlMuExpression ==> ()
  visitMuExpression (pcmp) == 
    ( dcl str : seq of char := "mu(";
      printNodeField(pcmp.getExpression());
      str := str ^result ^",";
      printSeqofField(pcmp.getModifierList());
      str := str ^result ^")";
      result := str );

  public visitFunctionTrailer: IOmlFunctionTrailer ==> ()
  visitFunctionTrailer (-) == result := "NOT YET SUPPORTED";


  public visitTimeExpression: IOmlTimeExpression ==> ()
  visitTimeExpression (-) == result := " time ";


  public visitRatType: IOmlRatType ==> ()
  visitRatType (-) == result := "NOT YET SUPPORTED";


  public visitStateDesignatorName: IOmlStateDesignatorName ==> ()
  visitStateDesignatorName (-) == result := "NOT YET SUPPORTED";


  public visitExtendedExplicitFunction: IOmlExtendedExplicitFunction ==> ()
  visitExtendedExplicitFunction (-) == result := "NOT YET SUPPORTED";


  public visitContextInfo: IOmlContextInfo ==> ()
  visitContextInfo (-) == result := "NOT YET SUPPORTED";


  public visitMode: IOmlMode ==> ()
  visitMode (-) == result := "NOT YET SUPPORTED";
       
end Oml2VppVisitor
\end{vdm_al}

\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[Oml2VppVisitor]

\end{rtinfo}
