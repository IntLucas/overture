//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2009-02-15 by the VDM++ to JAVA Code Generator
// (v8.2b - Tue 03-Feb-2009 11:50:55)
//
// Supported compilers: jdk 1.4/1.5/1.6
//

// ***** VDMTOOLS START Name=HeaderComment KEEP=NO
// ***** VDMTOOLS END Name=HeaderComment

// ***** VDMTOOLS START Name=package KEEP=NO
package org.overturetool.traces;

// ***** VDMTOOLS END Name=package

// ***** VDMTOOLS START Name=imports KEEP=YES

import jp.co.csk.vdm.toolbox.VDM.*;
import jp.co.csk.vdm.toolbox.api.corba.ToolboxAPI.ToolType;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;
import org.overturetool.vdmtools.VDMToolsProject;
import org.overturetool.vdmtools.interpreter.Interpreter;
// ***** VDMTOOLS END Name=imports



public class external_VDMToolsToolBox {

// ***** VDMTOOLS START Name=parent KEEP=YES
	VDMToolsToolBox parent = null;
	VDMToolsProject p = null;
	Interpreter interpreter = null;
	static String vdmPath="";
// ***** VDMTOOLS END Name=parent


// ***** VDMTOOLS START Name=external_VDMToolsToolBox#1|VDMToolsToolBox KEEP=NO
  public external_VDMToolsToolBox (VDMToolsToolBox parentVDMToolsToolBox) {
    parent = parentVDMToolsToolBox;
  }
// ***** VDMTOOLS END Name=external_VDMToolsToolBox#1|VDMToolsToolBox


// ***** VDMTOOLS START Name=external_VDMToolsToolBox KEEP=NO
  public external_VDMToolsToolBox () {}
// ***** VDMTOOLS END Name=external_VDMToolsToolBox


// ***** VDMTOOLS START Name=impl_InitToolbox KEEP=YES
  
  public static void SetVDMToolPath(String path) throws FileNotFoundException
  {
	  if(new File(path).exists())
	  vdmPath=path;
	  else
		  throw new FileNotFoundException(path);
  }
  
  public void impl_InitToolbox () throws CGException {
	  VDMToolsProject p = VDMToolsProject.getInstance();
		try {
		
			p.init(vdmPath, ToolType.PP_TOOLBOX);
		//	p.init("c:\\Program Files\\The VDM++ Toolbox v8.2b\\bin\\vppde.exe", ToolType.PP_TOOLBOX);
			File[] files = new File[parent.specsFiles.toArray().length];
			for (int i = 0; i < parent.specsFiles.size(); i++) {
				files[i] = new File(parent.specsFiles.toArray()[i].toString());
			}
			
			p.addFilesToProject(files);
			
			interpreter = p.GetInterpreter();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		}
  }
// ***** VDMTOOLS END Name=impl_InitToolbox


// ***** VDMTOOLS START Name=impl_IsPreError#1 KEEP=NO
  public Boolean impl_IsPreError (final ToolBox.InterpreterResult res) throws CGException {

    return !res.successfull && res.output.trim().endsWith("Run-Time Error 58: The pre-condition evaluated to false");
  }
// ***** VDMTOOLS END Name=impl_IsPreError#1


// ***** VDMTOOLS START Name=impl_runTestCase#2|String|Vector KEEP=YES
  public Vector impl_runTestCase (final String className, final Vector expressions) throws CGException {

	  String [] exps = new String[expressions.size()];
		for (int i = 0; i < expressions.size(); i++) {
			exps[i] = expressions.toArray()[i].toString();
		}
		
		String results[]= null;
		try {
			results = interpreter.EvalTraceCase(className,exps);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			results = new String[exps.length];
			results[0]= e.getMessage();
		}
		
		Vector iResult = new Vector();
		
		for (int j = 0; j < results.length; j++) {
			boolean isError = false;
			try {
				if (results.length > 0 && (results[j]==null || results[j].startsWith("Error")))
					isError= true;
			} catch (Exception e) {
				// TODO: handle exception
				int i = 0;
				
			}
			
			iResult.add(new ToolBox.InterpreterResult(!isError,results[j]));	
		}
		return iResult;
  }
// ***** VDMTOOLS END Name=impl_runTestCase#2|String|Vector

}
;
