//TODO1: maybe generate classes with the Comparable interface 
Packages
base org.overture.codegen.cgast;
analysis org.overture.codegen.cgast.analysis;
  
Tokens
/* This section declared tokens as internal types or external classes
 * internal definitions:
 *  plus='+';
 *  
 * external
 *  location = 'java:org.overture.ast.lex.LexLocation';
 */

  
  //Java
  java_Boolean = 'java:java.lang.Boolean';
  java_Integer = 'java:java.lang.Integer';
  java_String = 'java:java.lang.String';
  java_Long = 'java:java.lang.Long';
     
Abstract Syntax Tree
/* This section declares the AST by giving root nodes and their possible sub classes
 *
 * exp {-> package='org.overture.ast.expressions'}
 *      = {subclass1} [field_name]:field_type_must_either_be_root_or_token ...
 *      ;
 *
 */

/*
    Expressions
*/    
    
declCG {-> package='org.overture.codegen.cgast.declarations'}
	=	{method}
		[access]:java_String
		[static]:java_Boolean
		[abstract]:java_Boolean
		[return_type]:typeCG
		[name]:java_String
		[formalParams]:localDeclCG.formalParam*
		[isConstructor]:java_Boolean //Is it appropriate to call it method then?
		//[throws]:type*
		[body]:stmCG
	|	{field} 
    	[access]:java_String
    	[static]:java_Boolean
    	[final]:java_Boolean
    	[type]:typeCG
    	[name]:java_String
    	[initial]:expCG
    |	{localVar}
    	[type]:typeCG
    	[name]:java_String
    	[exp]:expCG
   	|	{class}
      	[access]:java_String
      	[abstract]:java_Boolean
      	[static]:java_Boolean 
    	[name]:java_String
    	[fields]:field*
    	[methods]:declCG.method*
    	[superName]:java_String
    	[innerClasses]:declCG.class*
//    |	{typDecl} //Consider removing this
//    	[name]:java_String
//    	[type]:typeCG
//   	|	{recField}
//   		[name]:java_String
//   		[type]:typeCG
//    |	{record}
//    	[name]:java_String
//    	[fields]:declCG.recField* 
    	
//    |	{constructor}
//    	[access]:java_String
//		[name]:java_String
//		[formals]:localDeclCG*
		//[throws]:type*
//		[body]:stmCG
	;
	
stateDesignatorCG {-> package='org.overture.codegen.cgast.statements'}
	= {identifier} [name]:java_String //TODO: not supported
	| {field} [object]:stateDesignatorCG [field]:java_String
	;
//    =   {field} [object]:stateDesignator [field]:LexIdentifierToken (objectfield):LexNameToken
//   |   {identifier} [name]:LexNameToken
//    |   {mapSeq} [mapseq]:stateDesignator [exp]:exp (mapType):type.#Map (seqType):type.#seq
    
localDeclCG {-> package='org.overture.codegen.cgast.declarations'}
           = {formalParam} [type]:typeCG [name]:java_String// [init]:exp
           ;

stmCG {-> package='org.overture.codegen.cgast.statements'}
           =	{if} [ifExp]:expCG [thenStm]:stmCG [elseIf]:stmCG.elseIf* [elseStm]:stmCG
           | 	{elseIf} [elseIf]:expCG [thenStm]:stmCG
           | 	{skip}
           |	{return} [exp]:expCG
           |	{letDef} [localDefs]:declCG.localVar* [stm]:stmCG
           |	{abstractBody}
           |	{assignment} [target]:stateDesignatorCG [exp]:expCG
           |	{block}	[statements]:stmCG*
           ;

expCG {-> package='org.overture.codegen.cgast.expressions'}
    =	#Unary
    |	#Binary
    |	{field} [object]:expCG [memberName]: java_String//[memberName]:LexNameToken [field]:LexIdentifierToken
    |	{apply} [root]:expCG [args]:expCG*// (argtypes):type* (recursive):definition
	|	{new} [className]:java_String [args]:expCG*
	|   {variable} [original]:java_String 
    |	{intLiteral} [value]:java_String
    |	{realLiteral} [value]:java_String
    |	{charLiteral} [value]:java_String
    |	{self}
    |	#Seq
    ;
    
#Binary {-> package='org.overture.codegen.cgast.expressions'}
    =   #Numeric 
    |	{equals}
    |	{seqConcat}
    ;
 
#Numeric {-> package='org.overture.codegen.cgast.expressions'}
    =	{div}
    |	{divide}
    |	{greaterEqual}
    |	{greater}
    |	{lessEqual}
    |	{less}
    |	{mod}   
    |	{plus} 
    |   {subtract}
    |	{rem}
    |	{times}       
    ;   
 
#Unary {-> package='org.overture.codegen.cgast.expressions'}
    =   {plus} 
    |   {minus}
    |	{cast}
    |	{isolation}
    |	{len}
    |	{head}
    |	{tail}      
    ;
    
#Seq {-> package='org.overture.codegen.cgast.expressions'}
	= {enum} [members]:expCG*// (types):typeCG*
	//=   {seqComp} [first]:exp [setBind]:bind.set [predicate]:exp
	//|   {seqEnum} [members]:exp* (types):type*
	;

typeCG {-> package='org.overture.codegen.cgast.types'}
    =   #basic
    |	{void}
    |	{class} [name]:java_String
    |	#seq
    ;
    
#seq {-> package='org.overture.codegen.cgast.types'}
    =   {seq} 
    |   {seq1} 
    ;
    
#basic {-> package='org.overture.codegen.cgast.types'}
    =   #numeric
    |	{char}
    |	{bool}
    ;

#numeric {-> package='org.overture.codegen.cgast.types'}
    =   {int}
    |   {real} 
    ;
     
Aspect Declaration
/* This section allows fields of root types to be declared e.g. exp*/

//1) No check for clash wrt nameing of fields
//2) Only graphs
%expCG = (type):typeCG [vdmLocation]:java_String
    ;

%expCG->#Unary =  [exp]:expCG
    ;
    
%expCG->#Binary = [left]:expCG [right]:expCG
	;
	
%typeCG->#seq
    = [seqOf]:typeCG//(seqof):type [empty]:java_Boolean
    ;

