module Entry

exports all
definitions

values

v = 1;
vOpt = nil;

state St of
 s: nat
 sOpt : [nat]
 init s == s = mk_St(2,nil)
end 

types

Rec ::
  r : nat | char
  rOpt :nat | [char];
  
operations

opA : () ==> ()
opA () ==
let aOpt = nil,
    a = 1
in
  skip;
  
opB : () ==> ()
opB () ==
(
  dcl bOpt : char | nat | [bool] := nil;
  dcl b : nat := 4;
  skip;
);

opC : () ==> ()
opC () ==
(
  dcl c : nat;
  skip;
);

opD : () ==> ()
opD () ==
let mk_(d1Opt,d2Opt) = mk_(1,2)
in
  skip; 

end Entry
