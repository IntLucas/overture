/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overturetool.vdmj.modules;


import org.overturetool.vdmj.modules.PImports;
import org.overture.ast.node.Node;
import java.lang.String;
import java.util.Map;
import org.overturetool.vdmj.modules.ASignaturesImports;
import org.overturetool.vdmj.modules.EImports;
import org.overture.ast.node.NodeList;
import org.overture.ast.analysis.IAnalysis;
import org.overture.ast.analysis.IAnswer;
import org.overture.ast.analysis.IQuestion;
import org.overture.ast.analysis.IQuestionAnswer;
import java.util.List;
import org.overturetool.vdmj.modules.AImportImports;


public class ASignaturesImports extends PImports
{
	private NodeList<AImportImports> _importList = new NodeList<AImportImports>(this);

	/**
	* Creates a new {@code ASignaturesImports} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param importList the {@link NodeList<AImportImports>} node for the {@code importList} child of this {@link ASignaturesImports} node
	*/
	public ASignaturesImports(List<? extends AImportImports> importList_)
	{
		super();
		this.setImportList(importList_);

	}


	/**
	 * Creates a new {@link ASignaturesImports} node with no children.
	 */
	public ASignaturesImports()
	{

	}


	/**
	 * Removes the {@link Node} {@code child} as a child of this {@link ASignaturesImports} node.
	 * @param child the child node to be removed from this {@link ASignaturesImports} node
	 * @throws RuntimeException if {@code child} is not a child of this {@link ASignaturesImports} node
	 */
	public void removeChild(Node child)
	{
		if (this._importList.remove(child)) {
				return;
		}
		throw new RuntimeException("Not a child.");
	}


	public String toString()
	{
		return (_importList!=null?_importList.toString():this.getClass().getSimpleName());
	}


	/**
	 * Returns a deep clone of this {@link ASignaturesImports} node.
	 * @return a deep clone of this {@link ASignaturesImports} node
	 */
	public ASignaturesImports clone()
	{
		return new ASignaturesImports(
			cloneList(_importList)
		);
	}


	/**
	 * Creates a deep clone of this {@link ASignaturesImports} node while putting all
	 * old node-new node relations in the map {@code oldToNewMap}.
	 * @param oldToNewMap the map filled with the old node-new node relation
	 * @return a deep clone of this {@link ASignaturesImports} node
	 */
	public ASignaturesImports clone(Map<Node,Node> oldToNewMap)
	{
		ASignaturesImports node = new ASignaturesImports(
			cloneList(_importList, oldToNewMap)
		);
		oldToNewMap.put(this, node);
		return node;
	}


	/**
	 * Returns the {@link EImports} corresponding to the
	 * type of this {@link EImports} node.
	 * @return the {@link EImports} for this node
	 */
	@Override
	public EImports kindPImports()
	{
		return EImports.SIGNATURES;
	}


	/**
	 * Sets the {@code _importList} child of this {@link ASignaturesImports} node.
	 * @param value the new {@code _importList} child of this {@link ASignaturesImports} node
	*/
	public void setImportList(List<? extends AImportImports> value)
	{
		if (value == this._importList) {
			return;
		}
		this._importList.clear();
		if (value != null) {
			this._importList.addAll(value);
		}

	}


	/**
	 * Returns the {@link NodeList<AImportImports>} node which is the {@code _importList} child of this {@link ASignaturesImports} node.
	 * @return the {@link NodeList<AImportImports>} node which is the {@code _importList} child of this {@link ASignaturesImports} node
	*/
	public NodeList<AImportImports> getImportList()
	{
		return this._importList;
	}


	/**
	* Calls the {@link IAnalysis#caseASignaturesImports(ASignaturesImports)} of the {@link IAnalysis} {@code analysis}.
	* @param analysis the {@link IAnalysis} to which this {@link ASignaturesImports} node is applied
	*/
	@Override
	public void apply(IAnalysis analysis)
	{
		analysis.caseASignaturesImports(this);
	}


	/**
	* Calls the {@link IAnswer#caseASignaturesImports(ASignaturesImports)} of the {@link IAnswer} {@code caller}.
	* @param caller the {@link IAnswer} to which this {@link ASignaturesImports} node is applied
	*/
	@Override
	public <A> A apply(IAnswer<A> caller)
	{
		return caller.caseASignaturesImports(this);
	}


	/**
	* Calls the {@link IQuestion#caseASignaturesImports(ASignaturesImports)} of the {@link IQuestion} {@code caller}.
	* @param caller the {@link IQuestion} to which this {@link ASignaturesImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q> void apply(IQuestion<Q> caller, Q question)
	{
		caller.caseASignaturesImports(this, question);
	}


	/**
	* Calls the {@link IQuestionAnswer#caseASignaturesImports(ASignaturesImports)} of the {@link IQuestionAnswer} {@code caller}.
	* @param caller the {@link IQuestionAnswer} to which this {@link ASignaturesImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q, A> A apply(IQuestionAnswer<Q, A> caller, Q question)
	{
		return caller.caseASignaturesImports(this, question);
	}



}

