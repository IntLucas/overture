/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overturetool.vdmj.modules;


import org.overturetool.vdmj.modules.PImports;
import org.overturetool.vdmj.lex.LexLocation;
import org.overturetool.vdmj.lex.LexNameToken;
import org.overture.ast.modules.AModuleModules;
import org.overture.ast.node.Node;
import java.lang.String;
import java.util.Map;
import org.overturetool.vdmj.modules.AImportImports;
import org.overturetool.vdmj.modules.EImports;
import org.overture.ast.analysis.IAnalysis;
import org.overture.ast.analysis.IAnswer;
import org.overture.ast.analysis.IQuestion;
import org.overture.ast.analysis.IQuestionAnswer;


public class AImportImports extends PImports
{
	private LexLocation _location;
	private LexNameToken _name;
	private LexNameToken _renamed;
	private AModuleModules _from;

	/**
	* Creates a new {@code AImportImports} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param location the {@link LexLocation} node for the {@code location} child of this {@link AImportImports} node
	* @param name the {@link LexNameToken} node for the {@code name} child of this {@link AImportImports} node
	* @param renamed the {@link LexNameToken} node for the {@code renamed} child of this {@link AImportImports} node
	* @param from the {@link AModuleModules} node for the {@code from} child of this {@link AImportImports} node
	*/
	public AImportImports(LexLocation location_, LexNameToken name_, LexNameToken renamed_, AModuleModules from_)
	{
		super();
		this.setLocation(location_);
		this.setName(name_);
		this.setRenamed(renamed_);
		this.setFrom(from_);

	}


	/**
	 * Creates a new {@link AImportImports} node with no children.
	 */
	public AImportImports()
	{

	}


	/**
	 * Removes the {@link Node} {@code child} as a child of this {@link AImportImports} node.
	 * @param child the child node to be removed from this {@link AImportImports} node
	 * @throws RuntimeException if {@code child} is not a child of this {@link AImportImports} node
	 */
	public void removeChild(Node child)
	{
		if (this._name == child) {
			this._name = null;
			return;
		}

		if (this._renamed == child) {
			this._renamed = null;
			return;
		}

		if (this._from == child) {
			this._from = null;
			return;
		}

		throw new RuntimeException("Not a child.");
	}


	public String toString()
	{
		return (_location!=null?_location.toString():this.getClass().getSimpleName())+ (_name!=null?_name.toString():this.getClass().getSimpleName())+ (_renamed!=null?_renamed.toString():this.getClass().getSimpleName())+ (_from!=null?_from.toString():this.getClass().getSimpleName());
	}


	/**
	 * Returns a deep clone of this {@link AImportImports} node.
	 * @return a deep clone of this {@link AImportImports} node
	 */
	public AImportImports clone()
	{
		return new AImportImports(
			cloneNode(_location),
			cloneNode(_name),
			cloneNode(_renamed),
			cloneNode(_from)
		);
	}


	/**
	 * Creates a deep clone of this {@link AImportImports} node while putting all
	 * old node-new node relations in the map {@code oldToNewMap}.
	 * @param oldToNewMap the map filled with the old node-new node relation
	 * @return a deep clone of this {@link AImportImports} node
	 */
	public AImportImports clone(Map<Node,Node> oldToNewMap)
	{
		AImportImports node = new AImportImports(
			cloneNode(_location, oldToNewMap),
			cloneNode(_name, oldToNewMap),
			cloneNode(_renamed, oldToNewMap),
			cloneNode(_from, oldToNewMap)
		);
		oldToNewMap.put(this, node);
		return node;
	}


	/**
	 * Returns the {@link EImports} corresponding to the
	 * type of this {@link EImports} node.
	 * @return the {@link EImports} for this node
	 */
	@Override
	public EImports kindPImports()
	{
		return EImports.IMPORT;
	}


	/**
	 * Sets the {@code _location} child of this {@link AImportImports} node.
	 * @param value the new {@code _location} child of this {@link AImportImports} node
	*/
	public void setLocation(LexLocation value)
	{
		this._location = value;
	}


	/**
	 * Returns the {@link LexLocation} node which is the {@code _location} child of this {@link AImportImports} node.
	 * @return the {@link LexLocation} node which is the {@code _location} child of this {@link AImportImports} node
	*/
	public LexLocation getLocation()
	{
		return this._location;
	}


	/**
	 * Sets the {@code _name} child of this {@link AImportImports} node.
	 * @param value the new {@code _name} child of this {@link AImportImports} node
	*/
	public void setName(LexNameToken value)
	{
		if (this._name != null) {
			this._name.parent(null);
		}
		if (value != null) {
			if (value.parent() != null) {
				value.parent().removeChild(value);
		}
			value.parent(this);
		}
		this._name = value;

	}


	/**
	 * Returns the {@link LexNameToken} node which is the {@code _name} child of this {@link AImportImports} node.
	 * @return the {@link LexNameToken} node which is the {@code _name} child of this {@link AImportImports} node
	*/
	public LexNameToken getName()
	{
		return this._name;
	}


	/**
	 * Sets the {@code _renamed} child of this {@link AImportImports} node.
	 * @param value the new {@code _renamed} child of this {@link AImportImports} node
	*/
	public void setRenamed(LexNameToken value)
	{
		if (this._renamed != null) {
			this._renamed.parent(null);
		}
		if (value != null) {
			if (value.parent() != null) {
				value.parent().removeChild(value);
		}
			value.parent(this);
		}
		this._renamed = value;

	}


	/**
	 * Returns the {@link LexNameToken} node which is the {@code _renamed} child of this {@link AImportImports} node.
	 * @return the {@link LexNameToken} node which is the {@code _renamed} child of this {@link AImportImports} node
	*/
	public LexNameToken getRenamed()
	{
		return this._renamed;
	}


	/**
	 * Sets the {@code _from} child of this {@link AImportImports} node.
	 * @param value the new {@code _from} child of this {@link AImportImports} node
	*/
	public void setFrom(AModuleModules value)
	{
		if (this._from != null) {
			this._from.parent(null);
		}
		if (value != null) {
			if (value.parent() != null) {
				value.parent().removeChild(value);
		}
			value.parent(this);
		}
		this._from = value;

	}


	/**
	 * Returns the {@link AModuleModules} node which is the {@code _from} child of this {@link AImportImports} node.
	 * @return the {@link AModuleModules} node which is the {@code _from} child of this {@link AImportImports} node
	*/
	public AModuleModules getFrom()
	{
		return this._from;
	}


	/**
	* Calls the {@link IAnalysis#caseAImportImports(AImportImports)} of the {@link IAnalysis} {@code analysis}.
	* @param analysis the {@link IAnalysis} to which this {@link AImportImports} node is applied
	*/
	@Override
	public void apply(IAnalysis analysis)
	{
		analysis.caseAImportImports(this);
	}


	/**
	* Calls the {@link IAnswer#caseAImportImports(AImportImports)} of the {@link IAnswer} {@code caller}.
	* @param caller the {@link IAnswer} to which this {@link AImportImports} node is applied
	*/
	@Override
	public <A> A apply(IAnswer<A> caller)
	{
		return caller.caseAImportImports(this);
	}


	/**
	* Calls the {@link IQuestion#caseAImportImports(AImportImports)} of the {@link IQuestion} {@code caller}.
	* @param caller the {@link IQuestion} to which this {@link AImportImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q> void apply(IQuestion<Q> caller, Q question)
	{
		caller.caseAImportImports(this, question);
	}


	/**
	* Calls the {@link IQuestionAnswer#caseAImportImports(AImportImports)} of the {@link IQuestionAnswer} {@code caller}.
	* @param caller the {@link IQuestionAnswer} to which this {@link AImportImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q, A> A apply(IQuestionAnswer<Q, A> caller, Q question)
	{
		return caller.caseAImportImports(this, question);
	}



}

