/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overturetool.vdmj.modules;


import org.overturetool.vdmj.modules.PImports;
import org.overturetool.vdmj.lex.LexIdentifierToken;
import org.overture.ast.node.Node;
import java.lang.String;
import java.util.Map;
import org.overturetool.vdmj.modules.AModuleImports;
import org.overturetool.vdmj.modules.EImports;
import org.overture.ast.node.NodeList;
import org.overture.ast.analysis.IAnalysis;
import org.overture.ast.analysis.IAnswer;
import org.overture.ast.analysis.IQuestion;
import org.overture.ast.analysis.IQuestionAnswer;
import java.util.List;
import org.overturetool.vdmj.modules.AFromModuleImports;


public class AModuleImports extends PImports
{
	private LexIdentifierToken _name;
	private NodeList<AFromModuleImports> _imports = new NodeList<AFromModuleImports>(this);

	/**
	* Creates a new {@code AModuleImports} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param name the {@link LexIdentifierToken} node for the {@code name} child of this {@link AModuleImports} node
	* @param imports the {@link NodeList<AFromModuleImports>} node for the {@code imports} child of this {@link AModuleImports} node
	*/
	public AModuleImports(LexIdentifierToken name_, List<? extends AFromModuleImports> imports_)
	{
		super();
		this.setName(name_);
		this.setImports(imports_);

	}


	/**
	 * Creates a new {@link AModuleImports} node with no children.
	 */
	public AModuleImports()
	{

	}


	/**
	 * Removes the {@link Node} {@code child} as a child of this {@link AModuleImports} node.
	 * @param child the child node to be removed from this {@link AModuleImports} node
	 * @throws RuntimeException if {@code child} is not a child of this {@link AModuleImports} node
	 */
	public void removeChild(Node child)
	{
		if (this._name == child) {
			this._name = null;
			return;
		}

		if (this._imports.remove(child)) {
				return;
		}
		throw new RuntimeException("Not a child.");
	}


	public String toString()
	{
		return (_name!=null?_name.toString():this.getClass().getSimpleName())+ (_imports!=null?_imports.toString():this.getClass().getSimpleName());
	}


	/**
	 * Returns a deep clone of this {@link AModuleImports} node.
	 * @return a deep clone of this {@link AModuleImports} node
	 */
	public AModuleImports clone()
	{
		return new AModuleImports(
			cloneNode(_name),
			cloneList(_imports)
		);
	}


	/**
	 * Creates a deep clone of this {@link AModuleImports} node while putting all
	 * old node-new node relations in the map {@code oldToNewMap}.
	 * @param oldToNewMap the map filled with the old node-new node relation
	 * @return a deep clone of this {@link AModuleImports} node
	 */
	public AModuleImports clone(Map<Node,Node> oldToNewMap)
	{
		AModuleImports node = new AModuleImports(
			cloneNode(_name, oldToNewMap),
			cloneList(_imports, oldToNewMap)
		);
		oldToNewMap.put(this, node);
		return node;
	}


	/**
	 * Returns the {@link EImports} corresponding to the
	 * type of this {@link EImports} node.
	 * @return the {@link EImports} for this node
	 */
	@Override
	public EImports kindPImports()
	{
		return EImports.MODULE;
	}


	/**
	 * Sets the {@code _name} child of this {@link AModuleImports} node.
	 * @param value the new {@code _name} child of this {@link AModuleImports} node
	*/
	public void setName(LexIdentifierToken value)
	{
		if (this._name != null) {
			this._name.parent(null);
		}
		if (value != null) {
			if (value.parent() != null) {
				value.parent().removeChild(value);
		}
			value.parent(this);
		}
		this._name = value;

	}


	/**
	 * Returns the {@link LexIdentifierToken} node which is the {@code _name} child of this {@link AModuleImports} node.
	 * @return the {@link LexIdentifierToken} node which is the {@code _name} child of this {@link AModuleImports} node
	*/
	public LexIdentifierToken getName()
	{
		return this._name;
	}


	/**
	 * Sets the {@code _imports} child of this {@link AModuleImports} node.
	 * @param value the new {@code _imports} child of this {@link AModuleImports} node
	*/
	public void setImports(List<? extends AFromModuleImports> value)
	{
		if (value == this._imports) {
			return;
		}
		this._imports.clear();
		if (value != null) {
			this._imports.addAll(value);
		}

	}


	/**
	 * Returns the {@link NodeList<AFromModuleImports>} node which is the {@code _imports} child of this {@link AModuleImports} node.
	 * @return the {@link NodeList<AFromModuleImports>} node which is the {@code _imports} child of this {@link AModuleImports} node
	*/
	public NodeList<AFromModuleImports> getImports()
	{
		return this._imports;
	}


	/**
	* Calls the {@link IAnalysis#caseAModuleImports(AModuleImports)} of the {@link IAnalysis} {@code analysis}.
	* @param analysis the {@link IAnalysis} to which this {@link AModuleImports} node is applied
	*/
	@Override
	public void apply(IAnalysis analysis)
	{
		analysis.caseAModuleImports(this);
	}


	/**
	* Calls the {@link IAnswer#caseAModuleImports(AModuleImports)} of the {@link IAnswer} {@code caller}.
	* @param caller the {@link IAnswer} to which this {@link AModuleImports} node is applied
	*/
	@Override
	public <A> A apply(IAnswer<A> caller)
	{
		return caller.caseAModuleImports(this);
	}


	/**
	* Calls the {@link IQuestion#caseAModuleImports(AModuleImports)} of the {@link IQuestion} {@code caller}.
	* @param caller the {@link IQuestion} to which this {@link AModuleImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q> void apply(IQuestion<Q> caller, Q question)
	{
		caller.caseAModuleImports(this, question);
	}


	/**
	* Calls the {@link IQuestionAnswer#caseAModuleImports(AModuleImports)} of the {@link IQuestionAnswer} {@code caller}.
	* @param caller the {@link IQuestionAnswer} to which this {@link AModuleImports} node is applied
	* @param question the question provided to {@code caller}
	*/
	@Override
	public <Q, A> A apply(IQuestionAnswer<Q, A> caller, Q question)
	{
		return caller.caseAModuleImports(this, question);
	}



}

