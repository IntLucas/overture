Tokens
/* This section declared tokens as internal types or external classes
 * internal definitions:
 *  plus='+';
 * 
 * external
 *  location = 'java:org.overturetool.vdmj.lex.LexLocation';
 */
  LexToken = 'java:node:org.overturetool.vdmj.lex.LexToken';
  LexNameToken = 'java:node:org.overturetool.vdmj.lex.LexNameToken';
  LexIdentifierToken = 'java:node:org.overturetool.vdmj.lex.LexIdentifierToken';
  LexBooleanToken = 'java:node:org.overturetool.vdmj.lex.LexBooleanToken';
  LexCharacterToken = 'java:node:org.overturetool.vdmj.lex.LexCharacterToken';
  LexIntegerToken = 'java:node:org.overturetool.vdmj.lex.LexIntegerToken';
  LexQuoteToken = 'java:node:org.overturetool.vdmj.lex.LexQuoteToken';
  LexRealToken = 'java:node:org.overturetool.vdmj.lex.LexRealToken';
  LexStringToken = 'java:node:org.overturetool.vdmj.lex.LexStringToken';
  
  location = 'java:org.overturetool.vdmj.lex.LexLocation';
  plus = '+';
  java_Boolean = 'java:java.lang.Boolean';
  java_Integer = 'java:java.lang.Integer';
  java_String = 'java:java.lang.String';
  nameScope = 'java:enum:org.overturetool.vdmj.typechecker.NameScope';
  
  bool = 'bool';
  char = 'char';
  int = 'int';
  natOne = 'nat1';
  nat = 'nat';
  rat = 'rat';
  real = 'real';
  true = 'true';
  false = 'false';
  and_and = '&&';
  or_or = '||';  
  numbers_literal = 'some regex for numbers';
  char_literal = 'some regex for chars';
  quote_literal = 'some regex for quote types';
  real_literal = 'some regex for reals';
  string_literal = 'some regex for string';
  token_literal = 'some regex for token type';
  bool_literal = 'some regex for bool type';
  static = 'static';
  async = 'async';
  


Abstract Syntax Tree
/* This section declares the AST by giving root nodes and their possible sub classes
 *
 * exp {-> package='org.overture.ast.expressions'}
 *      = {subclass1} [field_name]:field_type_must_either_be_root_or_token ...
 *      ;
 *
 */

/*
    Expressions
*/    
exp {-> package='org.overture.ast.expressions'}
    =   {apply} [root]:exp [args]:exp* [argtypes]:type* [recursive]:definition
    |   #Unary
    |   #Binary
    |   {boolean_const} [value]:LexBooleanToken
    |   {cases} [expression]:exp [cases]:alternative.case* [others]:exp
    |   {char_const} [value]:LexCharacterToken
    |   {elseIf} [elseIf]:exp [then]:exp  
    |   {exists1}  [bind]:bind [predicate]:exp
    |   {exists} [bindList]:multipleBind* [predicate]:exp
    |   {field} [object]:exp [memberName]:LexNameToken [field]:LexIdentifierToken
    |   {fieldNumber} [tuple]:exp [field]:LexIntegerToken
    |   {forAll} [bindList]:multipleBind* [predicate]:exp
    |   {funcInstatiation} [function]:exp [actualTypes]:type* [expdef]:definition.explicitFunction [impdef]:definition.implicitFunction
    |   {history} [hop]:LexToken [opnames]:LexNameToken*
    |   {if} [test]:exp [then]:exp [elseList]:elseIf* [else]:exp
    |   {int_const} [value]:LexIntegerToken
    |   {iota} [bind]:bind [predicate]:exp
    |   {is} [typeName]:LexNameToken [test]:exp
    |   {isOfBaseClass} [baseClass]:LexNameToken [exp]:exp
    |   {isOfClass} [className]:LexNameToken [exp]:exp
    |   {lambda} [bindList]:bind.type* [expression]:exp    
    |   {letBeSt} [bind]:multipleBind [suchThat]:exp [value]:exp
    |   {letDef} [localDefs]:definition* [expression]:exp
    |   {def} [localDefs]:definition* [expression]:exp
    |   #Map
    |   {maplet}  [left]:exp [right]:exp
    |   {mkBasic} [arg]:exp
    |   {mkType} [typeName]:LexNameToken [args]:exp*
    |   {mu} [recordType]:exp [modifiers]:modifier.record*
    |   {new} [className]:LexIdentifierToken [args]:exp*
    |   {nil} 
    |   {notYetSpecified} 
    |   {postOp} [opname]:LexNameToken [preexpression]:exp [postexpression]:exp [errors]:case.error* [state]:definition.state [errorLocation]:location
    |   {pre} [function]:exp [args]:exp*
    |   {preOp} [opname]:LexNameToken [expression]:exp  [errors]:case.error* [state]:definition.state
    |   {quote_const} [value]:LexQuoteToken
    |   {real_const} [value]:LexRealToken
    |   {sameBaseClass} [left]:exp [right]:exp
    |   {sameClass} [left]:exp [right]:exp
    |   {self} [name]:LexNameToken
    |   #Seq
    |   #Set
    |   {stateInit} [state]:state
    |   {string_const} [value]:LexStringToken
    |   {subclassResponsibility} 
    |   {subseq} [seq]:exp [from]:exp [to]:exp
    |   {threadId} 
    |   {time} 
    |   {tuple} [args]:exp*    
  //  |   {unary} unop [exp]:exp     
    |   {undefined}
    |   {variable} [name]:LexNameToken           
    ;
    
#Unary {-> package='org.overture.ast.expressions'}
    =   {absolute} 
    |   {cardinality}  
    |   {distConcat} 
    |   {distIntersect}  
    |   {distMerge} 
    |   {distUnion} 
    |   {elements}
    |   {floor}  
    |   {head} 
    |   {indices}  
    |   {len} 
    |   {mapDomain} 
    |   {mapInverse} 
    |   {mapRange} 
    |   {not}  
    |   {powerSet} 
    |   {reverse}  
    |   {tail} 
    |   {unaryMinus}
    |   {unaryPlus}       
    ;


#Binary {-> package='org.overture.ast.expressions'}
    =   #Boolean
    |   {comp} 
    |   {domainResBy}
    |   {domainResTo}
    |   {equals}
    |   {inSet}
    |   {mapUnion}
    |   {notEqual}
    |   {notInSet}
    |   #Numeric
    |   {plusPlus}
    |   {properSubset}
    |   {rangeResBy}
    |   {rangeResTo}
    |   {seqConcat}
    |   {setDifference}
    |   {setIntersect}
    |   {setUnion}
    |   {starStar}
    |   {subset}
    ;
    

    
#Boolean {-> package='org.overture.ast.expressions'}
    =   {and}
    |   {equivalent}
    |   {implies}
    |   {or}
    ;
    
#Numeric {-> package='org.overture.ast.expressions'}
    =   {div}
    |   {divide}
    |   {greaterEqual}
    |   {greater}
    |   {lessEqual}
    |   {less}
    |   {mod}
    |   {plus}
    |   {rem}
    |   {substract}
    |   {times}
    ;
    
#Map {-> package='org.overture.ast.expressions'}
    =   {mapComp} [first]:maplet [bindings]:multipleBind* [predicate]:exp
    |   {mapEnum} [members]:maplet* 
    ;
    
#Seq {-> package='org.overture.ast.expressions'}
    =   {seqComp} [first]:exp [setBind]:bind.set [predicate]:exp
    |   {seqEnum} [members]:exp*
    ;
    
#Set {-> package='org.overture.ast.expressions'}
    =   {setComp} [first]:exp [bindings]:multipleBind* [predicate]:exp
    |   {setEnum} [members]:exp*
    |   {setRange} [first]:exp [last]:exp
    ;
    
modifier {-> package='org.overture.ast.expressions'}
    = {record} [tag]:LexIdentifierToken [value]:exp
    ;
    
alternative {-> package='org.overture.ast.expressions'}
    = {case} [location]:location [cexp]:exp [pattern]:pattern [result]:exp
    ;
    
boolean_const
    =   {true}
    |   {false}
    ;
    
type {-> package='org.overture.ast.types'}
    =   #basic
    |   {bracket} [type]:type
    |   {class} [name]:LexNameToken [classdef]:definition.class 
    |   {function} [partial]:java_Boolean [parameters]:type* [result]:type 
    |   #invariant
    |   {map}   [from]:type [to]:type [empty]:java_Boolean
    |   {inMap} [from]:type [to]:type 
    |   {operation} [parameters]:type* [result]:type
    |   {optional} [type]:type
    |   {parameter} [name]:LexNameToken
    |   {product} [types]:type*
    |   {quote} [value]:string_literal //TODO whats the value type
    |   {seq} [seqof]:type [empty]:java_Boolean
    |   {seq1} [seqof]:type [empty]:java_Boolean
    |   {set} [setof]:type [empty]:java_Boolean
    |   {undefined}
    |   {union} [types]:type* //should be a type set
    |   {unknown}
    |   {unresolved} [typename]:LexNameToken
    |   {voidReturn}
    |   {void} 
    ;

#invariant {-> package='org.overture.ast.types'}
    =   {named} [typename]:LexNameToken [type]:type [invdef]:explicitFunction //super = invariant type
    |   {record} [typename]:LexNameToken [fields]:field* [invdef]:explicitFunction //super = invariant type
    ;

#basic {-> package='org.overture.ast.types'}
    =   {boolean}
    |   {char}
    |   #numeric     
    |   {token}
    ;

#numeric {-> package='org.overture.ast.types'}
    =   {int} 
    |   {natOne} 
    |   {nat} 
    |   {rational} 
    |   {real} 
    ;

field {-> package='org.overture.ast.types'}
    =   {field} [access]:accessSpecifier [tagname]:LexNameToken [tag]:java_String [type]:type [equalityAbstraction]:java_Boolean
    ;
accessSpecifier  {-> package='org.overture.ast.types'}
  = {accessSpecifier} [access]:access [static]:static [async]:async 
  ;
access  {-> package='org.overture.ast.definitions'}
    =   {public}
    |   {protected}
    |   {private}
    ;

pattern {-> package='org.overture.ast.patterns'}
    =   {boolean} [value]:LexBooleanToken
    |   {character} [value]:LexCharacterToken
    |   {concatenation} [left]:pattern [right]:pattern
    |   {expression} [exp]:exp
    |   {identifier} [name]:LexNameToken
    |   {ignore} 
    |   {integer} [value]:LexIntegerToken
    |   {nil}
    |   {quote} [value]:LexQuoteToken
    |   {real} [value]:LexRealToken
    |   {record} [typename]:LexNameToken [plist]:pattern* [type]:type
    |   {seq} [plist]:pattern*
    |   {set} [plist]:pattern*
    |   {string} [value]:LexStringToken
    |   {tuple} [plist]:pattern*
    |   {union} [left]:pattern [right]:pattern
    ;
    
pair {-> package='org.overture.ast.patterns'}
    = {patternType} [pattern]:pattern [type]:type
    | {patternListType} [pattern]:pattern* [type]:type
    ; 
    
bind {-> package='org.overture.ast.patterns'}
    =   {set} [pattern]:pattern [set]:exp //binds
    |   {type} [pattern]:pattern [type]:type //binds
    ;

multipleBind {-> package='org.overture.ast.patterns'}
    =   {multipleSet} [plist]:pattern* [set]:exp //binds
    |   {multipleType}  [plist]:pattern* [type]:type //binds
    ;

patternBind {-> package='org.overture.ast.patterns'}
    = {def} [location]:location [pattern]:pattern [bind]:bind
    ;
    
definition {-> package='org.overture.ast.definitions'}
    =   {assignment} [expression]:exp [expType]:type
    |   {instanceVariable} [expression]:exp [expType]:type [initialized]:boolean_const [oldname]:LexNameToken
    |   #class 
    |   {classInvariant}  [expression]:exp
    |   {equals} [pattern]:pattern [typebind]:bind.type [setbind]:bind.set [test]:exp [expType]:type [defType]:type [defs]:definition*
    |   {explicitFunction} [typeParams]:LexNameToken* [functionType]:function [paramPatternList]:pattern_inner_list* 
                           [precondition]:exp [predef]:explicitFunction 
                           [postcondition]:exp [postdef]:explicitFunction 
                           [body]:exp [actualResult]:type
                           [isTypeInvariant]:java_Boolean 
                           [measure]:LexNameToken [measureDef]:definition [recursive]:java_Boolean [measureLexical]:java_Integer
                           [isCurried]:java_Boolean 
    |   {external} [state]:definition [readOnly]:boolean_const [oldname]:LexNameToken
    |   {implicitFunction}  [typeParams]:LexNameToken* 
                            [typeFunction]:function 
                            [paramPatternList]:pair.patternListType* 
                            [precondition]:exp 
                            [predef]:explicitFunction 
                            [postcondition]:exp 
                            [postdef]:explicitFunction 
                            [result]:pair.patternType
                            [body]:exp 
                            [isTypeInvariant]:java_Boolean 
                            [measure]:LexNameToken 
                            [isCurried]:java_Boolean 
    |   {explicitOperation} [parameterPatterns]:pattern* 
                            [result]:pair.patternType 
                            [externals]:clause.external*
                            [body]:stm 
                            [precondition]:exp 
                            [postcondition]:exp 
                            [errors]:case.error*
                            [opType]:type.operation
                            [predef]:definition.explicitFunction
                            [postdef]:definition.explicitFunction
                            [state]:definition.state
                            [actualResult]:type
                            [stateDefinition]:definition
                            [isConstructor]:java_Boolean
    |   {implicitOperation} [opType]:type.operation
                            [parameterPatternList]:pair.patternListType*
                            [precondition]:exp 
                            [postcondition]:exp
                            [result]:pair.patternType 
                            [body]:stm 
                            [predef]:definition.explicitFunction
                            [postdef]:definition.explicitFunction
                            [paramDefinitions]:definition*
                            [state]:definition.state
                            [actualResult]:type
                            [isConstructor]:java_Boolean
                            
    |   {imported} [def]:definition
    |   {inherited} [superdef]:definition [oldname]:LexNameToken
    |   {local} 
    |   {multiBindList} [bindings]:multipleBind* [defs]:definition*
    |   {mutexSync} [operations]:LexNameToken*
    // |    {namedTrace_def} [pathname]:string* [terms]:traceDefinitionTerm*
    |   {perSync} [opname]:LexNameToken [guard]:exp
    |   {renamed} [def]:definition
    |   {state} [fields]:field* [invPattern]:pattern [invExpression]:exp [initPattern]:pattern [initExpression]:exp [stateDefs]:definition*
    |   {thread} [statement]:stm [operationName]:LexNameToken [operationDef]:definition.explicitOperation
    |   {type} [invType]:invariant [invPattern]:pattern [invExpression]:exp
    |   {untyped}
    |   {value} [pattern]:pattern [expression]:exp [defs]:definition* [expType]:type 
    ;

#class {-> package='org.overture.ast.definitions'}
    = {bus}
    | {cpu}
    | {system}
    ;

modules {-> package='org.overture.ast.modules'}
    = {module} [name]:LexNameToken [imports]:imports.module
        //[exports]:moduleExports
        [importdefs]:definition*
        //[exportdefs]:definition*
        [defs]:definition*
        ;

imports {-> package='org.overture.ast.modules'} 
    = {module} [name]:LexIdentifierToken [imports]:fromModule*
    | {fromModule} [name]:LexIdentifierToken [signatures]:signatures
    | {signatures} [importList]:import*
    | {import} [location]:location [name]:LexNameToken [renamed]:LexNameToken [from]:module
    ;
 

patternList {-> package='org.overture.ast.patterns'}
    = {pattern_inner_list} [list]:pattern*
    ;
    
/*
    Statements
*/

stm {-> package='org.overture.ast.statements'}
    =   {always} [always]:stm [body]:stm
    |   {assignment} [target]:stateDesignator [exp]:exp
    |   {atomic} [assignments]:stm.assignment*
    |   {callObject} [designator]:objectDesignator [classname]:LexNameToken [args]:exp*
    |   {call} [name]:LexNameToken [args]:exp*
    |   {cases} [exp]:exp [cases]:alternativeStm.case [others]:stm*//? is this correct
    |   {classInvariant} [name]:LexNameToken [invDefs]:definition*
    |   {cycles} [cycles]:exp [statement]:stm
    |   {duration} [duration]:exp [statement]:stm
    |   {elseIf} [elseIf]:exp [thenStm]:stm
    |   {error}
    |   {exit}
    |   {forAll} [pattern]:pattern [set]:exp [statement]:stm
    |   {forIndex} [var]:LexNameToken [from]:exp [to]:exp [by]:exp [statement]:stm
    |   {forPatternBind} [patternBind]:patternBind [reverse]:java_Boolean [exp]:exp [statement]:stm
    |   {if} [ifExp]:exp [thenStm]:stm [elseIf]:stm.elseIf* [elseStm]:stm
    |   {letBe} [bind]:multipleBind [suchThat]:exp [statement]:stm
    |   #LetDef
    |   {notYetSpecified} [opname]:LexNameToken [args]:exp*
    |   {return} [expression]:exp
    |   #SimpleBlock
    |   {skip}
    |   {specification} [externals]:clause.external* [precondition]:exp [postcondition]:exp [errors]:case.error*
    |   {start} [obj]:exp
    |   {subclassResponsibility}
    |   {tixe} [traps]:stmtAlternative.tixe [body]:stm
    //|   {traceVariable} //TODO why does this have a value inside?
    |   {trap} [patternBind]:patternBind [with]:stm [body]:stm
    |   {while} [exp]:exp [statement]:stm
    |   {periodic} [opname]:LexNameToken [args]:exp*
    ; 
    
#LetDef {-> package='org.overture.ast.statements'}
    =   {def}
    ;
    
#SimpleBlock {-> package='org.overture.ast.statements'}
    =   {block} [assignmentDefs]:definition*
    |   {nonDeterministic}
    ;
    
stateDesignator {-> package='org.overture.ast.statements'}
    =   {field} [object]:stateDesignator [field]:LexIdentifierToken
    |   {identifier} [name]:LexNameToken
    |   {mapSeq} [mapseq]:stateDesignator [exp]:exp
    ;
    
objectDesignator {-> package='org.overture.ast.statements'}
    =   {apply} [object]:objectDesignator [args]:exp*
    |   {field} [object]:objectDesignator [className]:LexNameToken [fieldName]:LexIdentifierToken
    |   {identifier} [name]:LexNameToken [expression]:exp.variable
    |   {new} [expression]:exp.new
    |   {self} [self]:LexNameToken
    ;

alternativeStm {-> package='org.overture.ast.statements'}
    = {case} [location]:location [cexp]:exp [pattern]:pattern [result]:exp
    ;
    
stmtAlternative {-> package='org.overture.ast.statements'}
    = {tixe} [patternBind]:patternBind [statement]:stm
    ;
    
clause {-> package='org.overture.ast.statements'}
    = {external} [mode]:LexToken [identifiers]:LexNameToken* [type]:type
    ;
    
case {-> package='org.overture.ast.statements'}
    = {error} [name]:LexIdentifierToken [left]:exp [right]:exp
    ;

Aspect Declaration
/* This section allows fields of root types to be declared e.g. exp*/

%exp->#Unary =  [exp]:exp
    ;

%exp = [type]:type [location]:location
    ;

%exp->#Binary = [left]:exp [op]:LexToken [right]:exp 
    ; 

%type = [location]:location [resolved]:java_Boolean
     ; 

%pattern = [location]:location [definitions]:definition*
    ;

%bind = [location]:location
    ;

%multipleBind = [location]:location
    ;
    
%definition = [location]:location [name]:LexNameToken [nameScope]:nameScope [used]:java_Boolean [classDefinition]:definition.class [access]:accessSpecifier [type]:type // [pass]:pass
    ;

%definition->#class
    = [className]:LexNameToken [supertypes]:type* [supernames]:LexNameToken* [definitions]:definition*
    ;
    
%stm
    = [location]:location
    ;
    
%stm->#LetDef
    = [localDefs]:definition* [statement]:stm
    ;
    
%stm->#SimpleBlock 
    =   [statements]:stm*
    ;
    
    
