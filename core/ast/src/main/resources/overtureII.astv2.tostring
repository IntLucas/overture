To String Extensions
// import packages used by external $$ java code
import org.overturetool.util.Utils;


//  Expressions

%exp->apply = [root] "("+ $Utils.listToString($ [args] $)$+  ")"
%exp->boolean_const =  [value] 
%exp->cases = "(cases "  [expression] " :\n" + $Utils.listToString("",$ [cases] $, ",\n", "\n") + ($ [others] $ == null ? "\n" : "others " + $ [others] + $"\n")$ + "end)" 
//
%alternative->case ="case "  [pattern] + " -> "  [result] 

%exp->#Unary->absolute ="(abs "  [exp]+")"
%exp->#Unary->cardinality ="(card "  [exp]+")"
%exp->#Unary->distConcat ="(conc "  [exp]+")"
%exp->#Unary->distIntersect ="(dinter "  [exp]+")"
%exp->#Unary->distMerge ="(merge "  [exp]+")"
%exp->#Unary->distUnion ="(dunion "  [exp]+")"
%exp->#Unary->elements ="(elems "  [exp]+")"
%exp->#Unary->floor ="(floor "  [exp]+")"
%exp->#Unary->head ="(hd "  [exp]+")"
%exp->#Unary->indices ="(inds "  [exp]+")"
%exp->#Unary->len ="(len "  [exp]+")"
%exp->#Unary->mapDomain ="(dom "  [exp]+")"
%exp->#Unary->mapInverse ="(inverse "  [exp]+")"
%exp->#Unary->mapRange ="(rng "  [exp]+")"
%exp->#Unary->not ="(not "  [exp]+")"
%exp->#Unary->powerSet ="(power "  [exp]+")"
%exp->#Unary->reverse ="(reverse "  [exp]+")"
%exp->#Unary->tail ="(tl "  [exp]+")"
%exp->#Unary->unaryMinus ="(- "  [exp]+")"
%exp->#Unary->unaryPlus ="(+ "  [exp]+")"

%exp->#binary->#Boolean->and = [left] "and" [right]
%exp->#binary->#Boolean->equivalent = [left] "<=>" [right]
%exp->#binary->#Boolean->implies = [left] "=>" [right]
%exp->#binary->#Boolean->or = [left] "or" [right]

%exp->#binary->#Numeric->div = [left] "div" [right]
%exp->#binary->#Numeric->divide = [left] "/" [right]
%exp->#binary->#Numeric->greaterEqual = [left] ">=" [right]
%exp->#binary->#Numeric->greater = [left] ">" [right]
%exp->#binary->#Numeric->lessEqual = [left] "<=" [right]
%exp->#binary->#Numeric->less = [left] "<" [right]
%exp->#binary->#Numeric->mod = [left] "mod" [right]
%exp->#binary->#Numeric->plus = [left] "+" [right]
%exp->#binary->#Numeric->rem = [left] "rem" [right]
%exp->#binary->#Numeric->substract = [left] "-" [right]
%exp->#binary->#Numeric->times = [left] "*" [right]



%exp->letBeSt = "let " [bind] + $($ [suchThat] $== null ? "" : " be st ")$+ [suchThat]  " in " [value]

 

%exp->letDef = "let " [localDefs] " in " [expression]


//  Types
%type->#basic->boolean = "bool"
%type->#basic->char="char"
%type->#basic->token="token"

%type->#basic->#numeric->int ="int"
%type->#basic->#numeric->natOne="nat1"
%type->#basic->#numeric->nat="nat"
%type->#basic->#numeric->rational="rat"
%type->#basic->#numeric->real="real"

%type->bracket ="(" [type] ")"
%type->class =[classdef]$.getName().name$
%type->function = "(" + $($ [parameters]$.isEmpty() ? "()" : Utils.listToString($[parameters]$, " * ")) + ($[partial]$ ? " -> " : " +> ")$ + [result] + ")"
%type->#invariant->named = [name]
%type->#invariant->record = [name]
//map
%type->operation = "(" + $($[parameters]$.isEmpty() ? "()" : Utils.listToString($[parameters]$, " * ")) + " ==> "$ + [result] + ")"
%type->optional = "[" [type] "]"
%type->parameter = "@" [name]
%type->product = "" +$Utils.listToString("(",$ [types] $, " * ", ")")$
%type->quote = "<" [value] ">"
%type->seq = ""+ $($[empty]$ ? "[]" : "seq of (" + $  [seqof] $+ ")" )$ 
%type->seq1 = "seq1 of (" + [seqof] + ")"
%type->set = ""+ $($[empty]$ ? "{}" : "set of (" +$ [setof]$ + ")")$
%type->undefined = "(undefined)"
%type->union = ""+$($[types]$.size() == 1?$ [types]$.iterator().next().toString() : Utils.setToString($[types]$, " | "))$
%type->unknown = "?"
%type->unresolved = "(unresolved " + [typename] + ")"
%type->voidReturn = "(return)"
%type->void = "()"       

//  Patterns
%pattern->boolean = [value]
%pattern->character = [value]
%pattern->concatenation = [left] " ^ " [right]
%pattern->expression = "(" [exp] ")"
%pattern->identifier = [name]
%pattern->ignore = "-"
%pattern->integer = [value]
%pattern->nil = "nil"
%pattern->quote = [value]
%pattern->real = [value]
%pattern->record = "mk_" [typename]  "(" + $Utils.listToString($[plist]$)$ + ")"
%pattern->seq = "[" [plist] "]"
%pattern->set = "{" [plist] "}"
%pattern->string = [value]
%pattern->tuple = "mk_"  "(" + $Utils.listToString($[plist]$)$ + ")"
%pattern->union = [left] " union " [right]

  

//  Definitions
%definition->value = [pattern] " : " [expType] " = " [expression]

//  Statements




