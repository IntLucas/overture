//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2008-11-08 by the VDM++ to JAVA Code Generator
// (v8.1.1b - Fri 24-Oct-2008 08:59:25)
//
// Supported compilers: jdk 1.4/1.5/1.6
//

// ***** VDMTOOLS START Name=HeaderComment KEEP=NO
// ***** VDMTOOLS END Name=HeaderComment

// ***** VDMTOOLS START Name=package KEEP=NO
package org.overturetool.potrans;

// ***** VDMTOOLS END Name=package

// ***** VDMTOOLS START Name=imports KEEP=YES

import jp.co.csk.vdm.toolbox.VDM.*;
import java.util.*;
// ***** VDMTOOLS END Name=imports



public class HolApplication extends HolExpression {

// ***** VDMTOOLS START Name=vdmComp KEEP=NO
  static UTIL.VDMCompare vdmComp = new UTIL.VDMCompare();
// ***** VDMTOOLS END Name=vdmComp

// ***** VDMTOOLS START Name=op KEEP=NO
  private HolExpression op = null;
// ***** VDMTOOLS END Name=op

// ***** VDMTOOLS START Name=parameters KEEP=NO
  private Vector parameters = null;
// ***** VDMTOOLS END Name=parameters

// ***** VDMTOOLS START Name=parameterTypes KEEP=NO
  private Vector parameterTypes = null;
// ***** VDMTOOLS END Name=parameterTypes


// ***** VDMTOOLS START Name=vdm_init_HolApplication KEEP=NO
  private void vdm_init_HolApplication () throws CGException {}
// ***** VDMTOOLS END Name=vdm_init_HolApplication


// ***** VDMTOOLS START Name=HolApplication KEEP=NO
  public HolApplication () throws CGException {
    vdm_init_HolApplication();
  }
// ***** VDMTOOLS END Name=HolApplication


// ***** VDMTOOLS START Name=HolApplication#2|HolExpression|Vector KEEP=NO
  public HolApplication (final HolExpression newOp, final Vector newParameters) throws CGException {

    vdm_init_HolApplication();
    {

      op = (HolExpression) UTIL.clone(newOp);
      parameters = (Vector) UTIL.ConvertToList(UTIL.clone(newParameters));
      parameterTypes = null;
    }
  }
// ***** VDMTOOLS END Name=HolApplication#2|HolExpression|Vector


// ***** VDMTOOLS START Name=HolApplication#3|HolExpression|Vector|Vector KEEP=NO
  public HolApplication (final HolExpression newOp, final Vector newParameters, final Vector newTypes) throws CGException {

    vdm_init_HolApplication();
    {

      op = (HolExpression) UTIL.clone(newOp);
      parameters = (Vector) UTIL.ConvertToList(UTIL.clone(newParameters));
      parameterTypes = (Vector) UTIL.ConvertToList(UTIL.clone(newTypes));
    }
  }
// ***** VDMTOOLS END Name=HolApplication#3|HolExpression|Vector|Vector


// ***** VDMTOOLS START Name=setTypeInformation#1|HolTypeDescription KEEP=NO
  public void setTypeInformation (final HolTypeDescription typeInfo) throws CGException {

    op.setTypeInformation((HolTypeDescription) typeInfo);
    for (int ilb_7 = 1; ilb_7 <= new Integer(parameters.size()).intValue(); ilb_7++) {

      Integer i = new Integer(ilb_7);
      HolExpression obj_9 = null;
      if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
        obj_9 = (HolExpression) parameters.get(i.intValue() - 1);
      else 
        UTIL.RunTime("Run-Time Error:Illegal index");
      obj_9.setTypeInformation((HolTypeDescription) typeInfo);
    }
    if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) 
      for (int ilb_19 = 1; ilb_19 <= new Integer(parameterTypes.size()).intValue(); ilb_19++) {

        Integer i = new Integer(ilb_19);
        HolType obj_21 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
          obj_21 = (HolType) parameterTypes.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        obj_21.setTypeInformation((HolTypeDescription) typeInfo);
      }
  }
// ***** VDMTOOLS END Name=setTypeInformation#1|HolTypeDescription


// ***** VDMTOOLS START Name=requires KEEP=NO
  public HashSet requires () throws CGException {

    HashSet result = new HashSet();
    result = op.requires();
    for (int ilb_4 = 1; ilb_4 <= new Integer(parameters.size()).intValue(); ilb_4++) {

      Integer i = new Integer(ilb_4);
      HashSet rhs_5 = new HashSet();
      HashSet var2_7 = new HashSet();
      HolExpression obj_8 = null;
      if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
        obj_8 = (HolExpression) parameters.get(i.intValue() - 1);
      else 
        UTIL.RunTime("Run-Time Error:Illegal index");
      var2_7 = obj_8.requires();
      rhs_5 = (HashSet) result.clone();
      rhs_5.addAll(var2_7);
      result = (HashSet) UTIL.clone(rhs_5);
    }
    if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) 
      for (int ilb_17 = 1; ilb_17 <= new Integer(parameterTypes.size()).intValue(); ilb_17++) {

        Integer i = new Integer(ilb_17);
        HashSet rhs_18 = new HashSet();
        HashSet var2_20 = new HashSet();
        HolType obj_21 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
          obj_21 = (HolType) parameterTypes.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        var2_20 = obj_21.requires();
        rhs_18 = (HashSet) result.clone();
        rhs_18.addAll(var2_20);
        result = (HashSet) UTIL.clone(rhs_18);
      }
    return result;
  }
// ***** VDMTOOLS END Name=requires


// ***** VDMTOOLS START Name=print KEEP=NO
  public String print () throws CGException {

    Boolean cond_1 = null;
    {
      if ((cond_1 = isInfix((HolExpression) op)).booleanValue()) 
        cond_1 = new Boolean(new Integer(parameters.size()).intValue() == new Integer(2).intValue());
    }
    if (cond_1.booleanValue()) 
      return printAsInfix();
    else 
      return printAsSuffix();
  }
// ***** VDMTOOLS END Name=print


// ***** VDMTOOLS START Name=printAsSuffix KEEP=NO
  private String printAsSuffix () throws CGException {

    String result = null;
    String rhs_1 = null;
    rhs_1 = op.print();
    result = UTIL.ConvertToString(UTIL.clone(rhs_1));
    for (int ilb_5 = 1; ilb_5 <= new Integer(parameters.size()).intValue(); ilb_5++) {

      Integer i = new Integer(ilb_5);
      {

        String rhs_6 = null;
        Vector unArg_7 = null;
        unArg_7 = new Vector();
        unArg_7.add(result);
        unArg_7.add(new String(" "));
        String e_seq_10 = null;
        HolExpression obj_11 = null;
        if ((1 <= i.intValue()) && (i.intValue() <= parameters.size())) 
          obj_11 = (HolExpression) parameters.get(i.intValue() - 1);
        else 
          UTIL.RunTime("Run-Time Error:Illegal index");
        e_seq_10 = obj_11.print();
        unArg_7.add(e_seq_10);
        String rdcseq_14 = new String();
        for (Iterator enm_17 = unArg_7.iterator(); enm_17.hasNext(); ) {

          String e_15 = UTIL.ConvertToString(enm_17.next());
          rdcseq_14 = rdcseq_14.concat(e_15);
        }
        rhs_6 = rdcseq_14;
        result = UTIL.ConvertToString(UTIL.clone(rhs_6));
        if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) {

          String rhs_21 = null;
          Vector unArg_22 = null;
          unArg_22 = new Vector();
          unArg_22.add(result);
          unArg_22.add(new String(":"));
          String e_seq_25 = null;
          HolType obj_26 = null;
          if ((1 <= i.intValue()) && (i.intValue() <= parameterTypes.size())) 
            obj_26 = (HolType) parameterTypes.get(i.intValue() - 1);
          else 
            UTIL.RunTime("Run-Time Error:Illegal index");
          e_seq_25 = obj_26.print(new org.overturetool.potrans.quotes.plain());
          unArg_22.add(e_seq_25);
          String rdcseq_30 = new String();
          for (Iterator enm_33 = unArg_22.iterator(); enm_33.hasNext(); ) {

            String e_31 = UTIL.ConvertToString(enm_33.next());
            rdcseq_30 = rdcseq_30.concat(e_31);
          }
          rhs_21 = rdcseq_30;
          result = UTIL.ConvertToString(UTIL.clone(rhs_21));
        }
      }
    }
    String rexpr_34 = null;
    Vector unArg_35 = null;
    unArg_35 = new Vector();
    unArg_35.add(new String("("));
    unArg_35.add(result);
    unArg_35.add(new String(")"));
    String rdcseq_39 = new String();
    for (Iterator enm_42 = unArg_35.iterator(); enm_42.hasNext(); ) {

      String e_40 = UTIL.ConvertToString(enm_42.next());
      rdcseq_39 = rdcseq_39.concat(e_40);
    }
    rexpr_34 = rdcseq_39;
    return rexpr_34;
  }
// ***** VDMTOOLS END Name=printAsSuffix


// ***** VDMTOOLS START Name=printAsInfix KEEP=NO
  private String printAsInfix () throws CGException {

    String result = null;
    result = UTIL.ConvertToString(UTIL.clone(new String("")));
    result = UTIL.ConvertToString(UTIL.clone(addParameter(new Integer(1), result)));
    String rhs_5 = null;
    Vector unArg_6 = null;
    unArg_6 = new Vector();
    unArg_6.add(result);
    unArg_6.add(new String(" "));
    unArg_6.add(getInfixOperator((HolExpression) op));
    unArg_6.add(new String(" "));
    String rdcseq_12 = new String();
    for (Iterator enm_15 = unArg_6.iterator(); enm_15.hasNext(); ) {

      String e_13 = UTIL.ConvertToString(enm_15.next());
      rdcseq_12 = rdcseq_12.concat(e_13);
    }
    rhs_5 = rdcseq_12;
    result = UTIL.ConvertToString(UTIL.clone(rhs_5));
    result = UTIL.ConvertToString(UTIL.clone(addParameter(new Integer(2), result)));
    String rexpr_19 = null;
    Vector unArg_20 = null;
    unArg_20 = new Vector();
    unArg_20.add(new String("("));
    unArg_20.add(result);
    unArg_20.add(new String(")"));
    String rdcseq_24 = new String();
    for (Iterator enm_27 = unArg_20.iterator(); enm_27.hasNext(); ) {

      String e_25 = UTIL.ConvertToString(enm_27.next());
      rdcseq_24 = rdcseq_24.concat(e_25);
    }
    rexpr_19 = rdcseq_24;
    return rexpr_19;
  }
// ***** VDMTOOLS END Name=printAsInfix


// ***** VDMTOOLS START Name=addParameter#2|Integer|String KEEP=NO
  private String addParameter (final Integer index, final String existingPars) throws CGException {

    String result = null;
    String rhs_3 = null;
    Vector unArg_4 = null;
    unArg_4 = new Vector();
    unArg_4.add(existingPars);
    String e_seq_6 = null;
    HolExpression obj_7 = null;
    if ((1 <= index.intValue()) && (index.intValue() <= parameters.size())) 
      obj_7 = (HolExpression) parameters.get(index.intValue() - 1);
    else 
      UTIL.RunTime("Run-Time Error:Illegal index");
    e_seq_6 = obj_7.print();
    unArg_4.add(e_seq_6);
    String rdcseq_10 = new String();
    for (Iterator enm_13 = unArg_4.iterator(); enm_13.hasNext(); ) {

      String e_11 = UTIL.ConvertToString(enm_13.next());
      rdcseq_10 = rdcseq_10.concat(e_11);
    }
    rhs_3 = rdcseq_10;
    result = UTIL.ConvertToString(UTIL.clone(rhs_3));
    if (new Boolean(!UTIL.equals(parameterTypes, null)).booleanValue()) {

      String rhs_17 = null;
      Vector unArg_18 = null;
      unArg_18 = new Vector();
      unArg_18.add(result);
      unArg_18.add(new String(":"));
      String e_seq_21 = null;
      HolType obj_22 = null;
      if ((1 <= index.intValue()) && (index.intValue() <= parameterTypes.size())) 
        obj_22 = (HolType) parameterTypes.get(index.intValue() - 1);
      else 
        UTIL.RunTime("Run-Time Error:Illegal index");
      e_seq_21 = obj_22.print(new org.overturetool.potrans.quotes.plain());
      unArg_18.add(e_seq_21);
      String rdcseq_26 = new String();
      for (Iterator enm_29 = unArg_18.iterator(); enm_29.hasNext(); ) {

        String e_27 = UTIL.ConvertToString(enm_29.next());
        rdcseq_26 = rdcseq_26.concat(e_27);
      }
      rhs_17 = rdcseq_26;
      result = UTIL.ConvertToString(UTIL.clone(rhs_17));
    }
    String rexpr_30 = null;
    Vector unArg_31 = null;
    unArg_31 = new Vector();
    unArg_31.add(result);
    unArg_31.add(new String(" "));
    String rdcseq_34 = new String();
    for (Iterator enm_37 = unArg_31.iterator(); enm_37.hasNext(); ) {

      String e_35 = UTIL.ConvertToString(enm_37.next());
      rdcseq_34 = rdcseq_34.concat(e_35);
    }
    rexpr_30 = rdcseq_34;
    return rexpr_30;
  }
// ***** VDMTOOLS END Name=addParameter#2|Integer|String


// ***** VDMTOOLS START Name=isInfix#1|HolExpression KEEP=NO
  private Boolean isInfix (final HolExpression oper) throws CGException {

    Boolean varRes_2 = null;
    Character var1_3 = null;
    String tmp_l_4 = null;
    tmp_l_4 = oper.print();
    if ((1 <= new Integer(1).intValue()) && (new Integer(1).intValue() <= tmp_l_4.length())) 
      var1_3 = new Character(tmp_l_4.charAt(new Integer(1).intValue() - 1));
    else 
      UTIL.RunTime("Run-Time Error:Illegal index");
    varRes_2 = new Boolean(UTIL.equals(var1_3, new Character('$')));
    return varRes_2;
  }
// ***** VDMTOOLS END Name=isInfix#1|HolExpression


// ***** VDMTOOLS START Name=getInfixOperator#1|HolExpression KEEP=NO
  private String getInfixOperator (final HolExpression oper) throws CGException {

    String varRes_2 = null;
    String unArg_3 = null;
    unArg_3 = oper.print();
    varRes_2 = unArg_3.substring(1);
    return varRes_2;
  }
// ***** VDMTOOLS END Name=getInfixOperator#1|HolExpression

}
;
