\documentclass[]{article}
\usepackage[draft]{fixme}
\usepackage{url}

\title{Implementing the Overture Automatic Proof System for VDM}

\author{Miguel Alexandre Ferreira\\
        Software Improvement Group\\
		The Netherlands\\ 
		\texttt{m.ferreira@sig.nl}}

\date{\today}

\begin{document}

\maketitle
\begin{abstract}
Sander Vermolen has produced a VDM to HOL translator prototype together with HOL tactics that allow VDM proof obligations to be discharged in the theorem prover HOL.
Vermolen's VDM++ prototype is complete enough to discharge proof obligations arising from functional VDM++ models.
However the prototype's performance is very limited as it can only be executed within a VDM++ interpreter.
Through the VDM++ to Java code generator tool, provided by the VDMTools, the prototype was implemented in Java allowing for its integration in the Overture Automatic Proof System.

The Automatic Proof System is a Java program that promotes the interoperation between a VDM proof obligation generation tool, the VDM to HOL translator, and the theorem prover HOL.
The current paper reports on the challenges and achievements of the Automatic Proof System's implementation, as part of the Overture Tool framework.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

The Overture initiative is a platform that enables researchers, students and practitioners to experiment with software modelling languages and tools~\cite{OverturePaper}.
Although the initiative has mainly focused in VDM and its three dialects, due to its open source nature everyone is welcome to contribute with tools and extensions to other languages.
Through Overture, extensions to the different VDM dialects and supporting tools have been proposed, analysed, tested and finally transferred to industrial settings, namely to the VDMTools~\cite{VDMTools}.
However, Overture's contribution has gone further than that, as new tools have been developed that supersede the functionality provided by the VDMTools.

One of the tools that adds to the capabilities of the VDMTools is the Automatic Proof Support (APS), which is capable of discharging proof obligations (POs) arising from functional VDM models, using the theorem prover HOL~\cite{HOL}.
Due to VDM's formal semantics it is possible to analyse a VDM model and pinpoint the locations where inconsistencies might occur.
Such inconsistencies can arise from invariants violations, miss usage of partial functions and mappings, etc.
Furthermore, besides pinpointing possible inconsistencies, it is also possible to generate verification conditions that if proven to be true assure the model's consistency.
In a VDM context, these verification conditions are deemed POs.

The APS was designed by Sander Verm\"olen during his MSc project~\cite{Sander}.
As deliverables from the project, Verm\"olen produced a VDM++ model of a tool that translates VDM to HOL syntax (the Overture VDM-to-HOL Translator); plus a set of lemmas, which he identified as useful in a VDM context, together with a set of tactics to automate the proofs.

The implementation described in this paper follows Verm\"olen's design as truly as possible, but also adds to it whenever found necessary.

In the next section Verm\"olen's architecture for APS is described together with the discussion of the difficulties to implement it, and possible solutions.
Section~\ref{sec:implementation} covers the actual implementation issues both at architectural and code level.
Future work is presented in Section~\ref{sec:future_work}, and the paper terminates with some conclusions in Section~\ref{sec:conclusion}.




\section{Architecture}
\label{sec:intended_architecure}

%Sander's architecture \ldots
%Description of components \ldots
%
%Automated proof achieved in three steps: preparation, translation, proof.
%
%Preparation:
%- convert model's concrete syntax in abstract syntax
%- generate POs from model's AST. POs are already in AST format
%Translation:
%- VDM AST to HOL AST (model + POs)
%- combine HOL AST model with HOL AST POs
%Proof:
%- HOL code generation
%- HOL tactics selection

The APS workflow as originally designed by Verm\"olen divides the system's operation in three sequential steps: preparation, translation, and proof.

\begin{description}
  \item[Preparation.] Preparation is the step that converts a VDM model concrete syntax into the abstract syntax tree (AST) format, as expected by the translator tool.
It's also in the preparation step that the POs, arising from the model, get generated by a PO generation (POG) tool.
The POG performs an analyses of the model's abstract representation and produces the PO expressions in the same abstract format.

  \item[Translation.] Given both model and POs in abstract representation, in the translation step an abstract representation of an equivalent HOL model is created. 
	The translated HOL model consists of a theory (obtained from the VDM model) and a set of proof commands (obtained from the VDM model's POs).

  \item[Proof.] In last step ofÂ§ the workflow, the proof, the concrete HOL syntax is generated from its abstract representation and a proof tactic is selected for each PO, according with its type~\footnote{There are several types of PO. For more detailed information see~\ref{VDMToolsManual}}. The last activity in the workflow is the actual proof carried out in the theorem prover.
\end{description}

Following from the described workflow, the architecture of the system is composed of three high level components, one per each step as depicted in Figure~\ref{fig:sander_arch}.
Each of these high level components can be decomposed in sub components, which may be part of the APS itself, or external tools that need to be integrated.

\fixme[inline]{Add breakdown pictures for each component.}

\subsection{Adjustments}
\label{sub:adjustments}

The architecture, as described up until now, can be regarded as the ideal architecture for a scenario where all external tools provide the necessary features.
However, this is not yet the case and two adjustments have to be made.

% There is no POG that generates AST \ldots
The first thing to notice is that, although Verm\"olen's design makes perfect sense, there is no available combination of POG tool and public VDM AST format to be used in preparation.
There are two POG tools that can be used both belonging to tool sets that are implemented in monolithic packages, namely the commercial VDMTools and the open source VDMJ.
Moreover, the translation tool, in the translation step, expects both the model and POs to be in the Overture Modelling Language (OML) AST representation, and neither of the POG tools available expects the model to be in this format, let alone generating POs in OML AST.
Both POG tools expect the models to be in VDM concrete syntax and produce textual, human readable, representations of the POs.
This mismatch between the available tools and the intended architecture makes it necessary to adjust the architecture by introducing the Overture Parser as part of the preparation step, as depicted in Figure~\ref{fig:archi_with_ovt_parser}.
In this arrangement the system uses the Overture Parser to generate OML AST representations for the model and each POs individually.

% The HOL code generation and tactics selection is done by the translator tool
The second adjustment needed is related with the proof step, more specifically with the HOL concrete syntax generation and tactics selection.
Both of these activities are performed by the translation tool, and therefore they are performed in the translation step instead of the proof step.
However, from the experience gathered by the use of the APS in some case studies~\cite{MiguelMSc,SBMF09paper}, the tactics selection as done by the translation tool is suboptimal as the same tactic gets chosen for each and every type of PO.
This issue was not yet addressed in the APS and is left as future work (see Section~\ref{sec:future_work}).

\section{Implementation}
\label{sec:implementation}

The APS is a component of the Overture Tool, and therefore must abide by the development standards of the Overture initiative~\cite{OverturePaper}.
The Overture Tool is a formal modelling and verification tool suite that is modular, and integrates in the Eclipse platform through several plugins.
The main implementation language is Java and the APS is no exception to that.

Figure~\ref{fig:??} clearly shows that the APS is nothing more than a tool-chain of components that contribute to the system's goal.
All the computations that are in fact implemented in the APS are either to promote interoperation of the components, or to increase usability.

%Integration of components \ldots
As far as the integration of components goes the implementation uses two ways to achieve it:
\begin{itemize}
  \item direct calls from Java code using external component's public APIs;
  \item or through the command line interface (CLI) of external processes.
\end{itemize}

Both Overture Parser and the Overture VDM-to-HOL Translator have a publicly available Java API and therefore can be seemingly integrated with the APS.
As for the generation of POs, the VDMTools was chosen to perform the underlying tasks and because its CORBA interface doesn't provided the necessary API, the interoperation was done though the CLI.
The choice here could have been VDMJ as it offers a Java API that could be called directly from the APS code.
However, the VDMJ was still under development at the time of the implementation, and the VDMTools is a much more mature and heavily tested POG.
This doesn't mean that the APS relies exclusively on the VDMTools, because the PO generation and parsing of their textual representations are abstracted by Java interfaces, which provide the necessary decoupling from implementations.
Although the VDMJ is not yet supported as a POG tool for the APS, the system is prepared to allow its integration in the tool-chain (see Section~\ref{sec:future_work} for more information on this subject).
The CLI is also used to interoperate with the theorem prover HOL.

% Interoperation
The interoperation of the different tools though CLI raises some difficulties in terms of parsing the output of a tool to supply the needed data to the next.
This difficulties are due to the nature of the CLI the components, as these are meant to be operated by humans.
The most notorious example is the parsing of the list of POs generated by the POG component.
If the tool (in this case the VDMTools) would provide a machine readable format, like XML for instance, it would make the implementation a lot easier and cleaner.
Also the output from HOL must be parsed to check whether a statement is valid or it contains errors, as well as to check the result from a  proof.

Interoperation with the CLI of the different components was implemented through a \emph{console} abstraction layer.
The \emph{console} mimics the behaviour a human expects from the CLI of a tool, as well as the behaviour the tool expects from its user.
This implementation decision helped clear the clutter involved in the interaction with the CLIs, as well as to better structure and re-utilize code.
On top of the \emph{console} abstraction layer wrapper objects were implemented for each component, taking advantage of methods the layer provides and adding more, component specific, features.
Furthermore all external components implement an interface to decouple the actual implementation from the APS core.

%Usability \ldots
Usability issues also arise from the experience obtained using the system as it was still a prototype.
Many times it paid off to try a different tactic to tackle some PO, and the reason behind this was not always straight forward.
So if the APS was able to detect a failing, or non terminating, proof and tried a different tactic it would increase the success rate of the overall system (see Section~\ref{sec:future_work} for more information).

\subsection{Difficulties}
\label{sub:implementation_difficulties}

% Lack of proper documentation
Documentation, or the lack of it, was one of the major drawbacks during implementation, even regarding components that are part of the Overture Initiative.
For instance the Overture Parser has had the capability to parse a single VDM expression separated from the context of a model for a long time now.
This feature is what enables the APS system to generate OML AST representations for each PO individually.
However, during the implementation of the APS the development was stopped for some weeks because there was no knowledge of this feature.
This lack of knowledge was due to a momentary lack of availability from the implementer of the Overture Parser.
If better documentation was available some time could have been saved. 
The same goes for the APS, as no documentation whatsoever was created apart from Verm\"olen's MSc thesis, and this paper.

It is not only on the open source side that documentation lacked. 
The APS uses the VDMTools to generate the POs through the CLI.
However the flag that is used to trigger the PO generation in the VDMTools is also not documented.
Neither in the usage information provided through the CLI, nor the actual manual of the tool.
It was only though the close connection and cooperation with CSK, the current suppliers of the VDMTools, that this information was obtained.

%Java child process bug \ldots
Other major drawback for the implementation of the APS was the way Java handles external processes, and especially child processes\footnote{A child process is a process that is created within another process.} of the processes one instantiates within a Java application.

The theorem prover HOL, in its version 4, is built on top of the Moscow ML~\footnote{\url{http://www.itu.dk/~sestoft/mosml.html}} interpreter which an implementation of the Standard ML language interpreter.
This means that HOL runs inside the Moscow ML interpreter.
HOL's executable is in fact a script that pipes its input to a first command, named \emph{unquote}, which basically replaces the quotes in HOL concrete syntax by machine readable markers.
The output of \emph{unquote} is then re-piped to the \emph{ML interpreter}.
So whenever the HOL executable is invoked from the command line two child processes are also invoked, one for \emph{unquote} and another for the \emph{ML interpreter}.
This is the case both in Windows and Unix alike platforms.

The problem with creating this processes within a Java application was not in the creation itself, but rather in the destruction of the child processes.
In Java, like in most other programming languages, it is a good programming practice to wait for the processes to finish.
However, in this case after issuing the termination command in the HOL process, the method that waits for it to finish would enter a deadlock state.
On the other hand, if a forced destruction of the HOL process would be issued, the result would be even worse.
One of HOL's child processes would start to allocate all the memory it could get, until the machine would become unusable.

This strange behaviour has to do with the way Java handles external processes.
If a process, say $A$, creates a child process, say $B$, then if $A$ is terminated, and a waiting for termination method is issued on $A$ but $B$ does not terminate, then the method issued on $A$ will never return.
This means that the wait method does not return until all child processes are terminated.
However, if a destroy method is called on $A$ it's child processes will not be destroyed, as it is the responsibility of the parent process to terminate its child processes.
This behaviour is well documented in the Java bug/issue tracking system~\footnote{For more details see \url{http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4770092}.}.

To overcome this problem regarding HOL's child processes and the pipe in between them, the implementation never calls HOL's executable directly.
Instead, it creates two independent processes, one for \emph{unquote} and another for the \emph{ML interpreter}.
These two processes are encapsulated using the already mentioned \emph{console} abstraction, and a new thread is created to pipe the output of the first process to the input of the second.
This way both processes are directly managed by the APS, thus avoiding the unwanted behaviour of Java.

\subsection{Current Status}

The APS is currently in its version 1.0.0, and is only available as a command line application.
It uses the Args4j~\footnote{\url{https://args4j.dev.java.net}} library to parse command line parameters and arguments.

Testing was done through the jUnit test framework, and 69 unit tests were created to monitor the APS code.
These unit tests amounting to a code coverage of 78.2\%, covering all major components and their interactions.

There are two execution modes: \emph{translation} that simply translates the VDM model and its POs to HOL syntax; and \emph{proof} that not only translates the model but also attempts to discharge the POs directly in HOL.
The execution of the tool in either mode is done in a batch, meaning that inputs are supplied to the tool and it produces an output.

\section{Future Work}
\label{sec:future_work}

%Integration in Eclipse\ldots
Although the APS has its utility as a standalone application, the objective is to have it integrated in the Overture Tool as an Eclipse plugin.
This integration can be done in two steps. 
First through a minimalistic plugin that acts as a ``console'' for the APS, simply showing the user the results from each PO proof attempt.
If all goes right with the first, and minimalistic, plugin then a more sophisticated approach could be taken.
This approach would consist in having a graphical user interface (GUI) for the APS, where POs would be displayed in a table aggregating the information of automated proof attempts.
In the case that some POs are not automatically discharged, the GUI would give the user the opportunity to assist the theorem prover.

%Interactive execution \ldots


%Support for VDMJ as a POG tool \ldots
The generation of the POs is an open issue in the context of Overture since there are two available POG tools, but none works at the AST level.
This fact implicates unnecessary parsing and diminishes the interoperability between components.
The APS doesn't yet support VDMJ as a POG generator, although it is prepared for that, and this is also something to be done in the upcoming releases.

%Use timer to avoid non terminating proofs, and be able to try different tactics if a proof takes too long \ldots
Proofs in HOL might not terminate in feasible time.
Therefore the APS must be equipped with, configurable, timers to detect those situations, and abort the proof if necessary.

% Panellisation
Given the current multi-core trend in computer hardware, the APS could take advantage of multi-core architectures to launch proofs in parallel, and with this improve its performance.

% Improve on translation \ldots
Although the translation of VDM syntax in HOL syntax is the responsibility of other Overture component, this is crucial for the usability of the APS.
At the moment the APS, even if was already integrated in the Overture Tool through Eclipse, wouldn't bringso much value to VDM modellers because of the quite small subset of the language supported by the translator.
There are also problems in the translation that were already identifyed by Verm\"olen in his thesis~\cite[OpenIssues]{Sander} but remain unresolved.
Some of these issues result in syntax errors in the produced HOL code.

\section{Conclusion}
\label{sec:conclusion}

In conclusion, the APS is basically a tool-chain of components that when properly interoperated work together to discharge VDM POs.
Its implementation was not always straight forward but it was still successful.
The basic functionality as designed and prototyped by Sander Verm\"olen is now implemented but, there is still much room for improvements.

\end{document}